                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (BPEM488.s)                                                                *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BPEM488 Engine Controller for the Dodge 488CID (8.0L) V10 engine  *
                                      ;*    by Robert Hiebert.                                                                 *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teaching    *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*    Application code for the Basic Programmable Engine Management 488 project          *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project (This module)       *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project                          *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map                                       *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project               *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map                                         *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features                     *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler              *
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications                  *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)                                     *
                                      ;*   gpio_BPEM488.s       - Initialization all ports                                     *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros                         *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing                              *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths                       *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors                   *
                                      ;*****************************************************************************************
                                      ;* Version History:                                                                      *
                                      ;*    May 14 2020                                                                        *
                                      ;*    - BPEM488 Dedicated Hardware version begins(work in progress)                      *
                                      ;*    - Update December 10 2020                                                          *
                                      ;*    - Update January 6 2021 Corrected ADC0 init macro                                  *
                                      ;*    - Update February 7 2021 Change OFC logic                                          *
                                      ;*    March 22 2021                                                                      *
                                      ;*    - Add current gear code                                                            *
                                      ;*    April 11 2021                                                                      *
                                      ;*    - Modify ST table and WUE bins                                                     *
                                      ;*    April 20 2021                                                                      *
                                      ;*    - Change RPM period code                                                           *
                                      ;*    April 28 2021                                                                      *
                                      ;*    - Add baroADC averaging code code                                                  *
                                      ;*    May 4 2021                                                                         *
                                      ;*    - Move macro calls for ST_ LU, VE_LU, AFR_LU, DWELL_COR_LU, BARO_COR_LU, and       *
                                      ;*      MAT_COR_LU to work around corrupted returns                                      *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
??????        S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ;*****************************************************************************************
                                      ;* - Resource mapping -                                                                  *
                                      ;*****************************************************************************************
001000 0FD000                                         ORG   MMAP_RAM_START, MMAP_RAM_START_LIN   ; $1000, $0F_D000
                                      ;*****************************************************************************************
                                      ;* - Variables -                                                                         *
                                      ;*****************************************************************************************
001000 0FD000 -> $1000                BASE_VARS_START           EQU *   ; * Represents the current value of the paged
                                                                        ; program counter
001000 0FD000 -> $FD000               BASE_VARS_START_LIN       EQU @   ; @ Represents the current value of the linear
                                                                        ; program counter
001064 0FD064                                         ORG   BASE_VARS_END, BASE_VARS_END_LIN
                                      ; - Shared Variables -
001064 0FD064 -> $1064                BPEM488_SHARED_VARS_START       EQU *   ; * Represents the current value of the paged
                                                                              ; program counter
001064 0FD064 -> $FD064               BPEM488_SHARED_VARS_START_LIN   EQU @   ; @ Represents the current value of the linear
                                                                              ; program counter
004000 7F4000                                         ORG   MMAP_FLASH_FD_START, MMAP_FLASH_FD_START_LIN   ; $4000, $7F_4000
                                      ;*****************************************************************************************
                                      ;* - Macros -                                                                            *
                                      ;*****************************************************************************************
                                      ; ------------------------------- No macros for this module ------------------------------
                                      ;*****************************************************************************************
                                      ;* - Code -                                                                              *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; THIS IS THE AFTER RESET ENTRY POINT                                                    *
                                      ;*****************************************************************************************
004000 7F4000 -> $4000                BPEM488_CODE_START       EQU  *  ; * Represents the current value of the paged
                                                                       ; program counter
004000 7F4000 -> $7F4000              BPEM488_CODE_START_LIN   EQU  @  ; @ Represents the current value of the linear
                                                                       ; program counter
00533D 7F533D                                         ORG   BPEM488_CODE_END, BPEM488_CODE_END_LIN
00533D 7F533D -> $533D                BASE_CODE_START       EQU  *  ; * Represents the current value of the paged
                                                                    ; program counter
00533D 7F533D -> $7F533D              BASE_CODE_START_LIN   EQU  @  ; @ Represents the current value of the linear
                                                                    ; program counter
00719A 7F719A                                         ORG   BASE_CODE_END, BASE_CODE_END_LIN
                                      ; - Tables -
00719A 7F719A -> $719A                BPEM488_TABS_START       EQU  *  ; * Represents the current value of the paged
                                                                       ; program counter
00719A 7F719A -> $7F719A              BPEM488_TABS_START_LIN   EQU  @  ; @ Represents the current value of the linear
                                                                       ; program counter
007B53 7F7B53                                         ORG   BPEM488_TABS_END, BPEM488_TABS_END_LIN
007B53 7F7B53 -> $7B53                BASE_TABS_START       EQU BPEM488_TABS_END
007B53 7F7B53 -> $7F7B53              BASE_TABS_START_LIN   EQU BPEM488_TABS_END_LIN
                                      ;*****************************************************************************************
                                      ; - Complete last flash phrase - (Required for D-Bug12)
                                      ;*****************************************************************************************
00849D 7F849D                                         ORG   BASE_TABS_END, BASE_TABS_END_LIN
                                      ;*              FILL    $FF, 8-(*&7)
00849D 7F849D FF FF FF                       ALIGN 7,$FF          ; This is the better option
                                      ; - XGATE Code -
000800 780800                                         ORG   MMAP_XG_FLASH_START_XG, MMAP_XG_FLASH_START_LIN   ; $0800, $78_0800
000800 780800                                ALIGN 7,$FF
                                      ;*****************************************************************************************
                                      ;* - Variables -                                                                         *
                                      ;*****************************************************************************************
001064 0FD064                                         ORG   BPEM488_SHARED_VARS_START, BPEM488_SHARED_VARS_START_LIN
001064 0FD064                                 ALIGN 1
                                      ;*****************************************************************************************
                                      ;----------------------------- RS232 Real Time Variables ---------------------------------
                                      ;   Zero page ordered list continuously updated to Tuner Studio
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Seconds counter variables
                                      ;*****************************************************************************************
001064 0FD064                         SecH:         ds 1 ; RTI seconds count Hi byte (offset=0)
001065 0FD065                         SecL:         ds 1 ; RTI seconds count Lo byte (offset=1)
                                      ;*****************************************************************************************
                                      ; - ADC variables
                                      ;*****************************************************************************************
001066 0FD066                         batAdc:       ds 2 ; Battery Voltage 10 bit ADC AN00(offset=2)
001068 0FD068                         BatVx10:      ds 2 ; Battery Voltage (Volts x 10)(offset=4)
00106A 0FD06A                         cltAdc:       ds 2 ; 10 bit ADC AN01 Engine Coolant Temperature ADC(offset=6)
00106C 0FD06C                         Cltx10:       ds 2 ; Engine Coolant Temperature (Degrees F x 10)(offset=8)
00106E 0FD06E                         matAdc:       ds 2 ; 10 bit ADC AN02 Manifold Air Temperature ADC(offset=10)
001070 0FD070                         Matx10:       ds 2 ; Manifold Air Temperature (Degrees F x 10)(offset=12)
001072 0FD072                         PAD03inAdc:   ds 2 ; 10 bit ADC AN03 Spare Temperature ADC(offset=14)
001074 0FD074                         Place16:      ds 2 ; Place holder 16(offset=16)
001076 0FD076                         mapAdc:       ds 2 ; 10 bit ADC AN04 Manifold Absolute Pressure ADC(offset=18)
001078 0FD078                         Mapx10:       ds 2 ; Manifold Absolute Pressure (KPAx10)(offset=20)
00107A 0FD07A                         tpsADC:       ds 2 ; 10 bit ADC AN05 Throttle Position Sensor ADC (exact for TS)(offset=22)
00107C 0FD07C                         TpsPctx10:    ds 2 ; Throttle Position Sensor % of travel(%x10)(update every 100mSec)(offset=24)
00107E 0FD07E                         egoAdc1:      ds 2 ; 10 bit ADC AN06 Exhaust Gas Oxygen ADC Left bank odd cyls(offset=26)
001080 0FD080                         afr1x10:      ds 2 ; Air Fuel Ratio for gasoline Left bank odd cyls(AFR1x10)(offset=28)
001082 0FD082                         baroAdc:      ds 2 ; 10 bit ADC AN07 Barometric Pressure ADC(offset=30)
001084 0FD084                         Barox10:      ds 2 ; Barometric Pressure (KPAx10)(offset=32)
001086 0FD086                         eopAdc:       ds 2 ; 10 bit ADC AN08 Engine Oil Pressure ADC(offset=34)
001088 0FD088                         Eopx10:       ds 2 ; Engine Oil Pressure (PSI x 10)(offset=36)
00108A 0FD08A                         efpAdc:       ds 2 ; 10 bit ADC AN09 Engine Fuel Pressure ADC(offset=38)
00108C 0FD08C                         Efpx10:       ds 2 ; Engine Fuel Pressure (PSI x 10)(offset=40)
00108E 0FD08E                         itrmAdc:      ds 2 ; 10 bit ADC AN10 Ignition Trim ADC(offset=42)
001090 0FD090                         Itrmx10:      ds 2 ; Ignition Trim (degrees x 10)+-20 degrees) (offset=44)
001092 0FD092                         ftrmAdc:      ds 2 ; 10 bit ADC AN11 Fuel Trim ADC(offset=46)
001094 0FD094                         Ftrmx10:      ds 2 ; Fuel Trim (% x 10)(+-20%)(offset=48)
001096 0FD096                         egoAdc2:      ds 2 ; 10 bit ADC AN12  Exhaust Gas Oxygen ADC Right bank even cyls(offset=50)
001098 0FD098                         afr2x10:      ds 2 ; Air Fuel Ratio for gasoline Right bank even cyls(AFR2x10) (offset=52)
                                      ;*****************************************************************************************
                                      ; - Input capture variables
                                      ;*****************************************************************************************
00109A 0FD09A                         CASprd512:    ds 2 ; Crankshaft Angle Sensor period (5.12uS time base(offset=54)
00109C 0FD09C                         CASprd256:    ds 2 ; Crankshaft Angle Sensor period (2.56uS time base(offset=56)
00109E 0FD09E                         VSSprd:       ds 2 ; Vehicle Speed Sensor period(offset=58)
0010A0 0FD0A0                         RPM:          ds 2 ; Crankshaft Revolutions Per Minute(offset=60)
0010A2 0FD0A2                         KPH:          ds 2 ; Vehicle speed (KpH x 10)(offset=62)
                                      ;*****************************************************************************************
                                      ; - Fuel calculation variables
                                      ;*****************************************************************************************
0010A4 0FD0A4                         ASEcnt:       ds 2 ; Counter for "ASErev"(offset=64)
0010A6 0FD0A6                         AFRcurr:      ds 2 ; Current value in AFR table (AFR x 100)(offset=66)
0010A8 0FD0A8                         VEcurr:       ds 2 ; Current value in VE table (% x 10)(offset=68)
0010AA 0FD0AA                         barocor:      ds 2 ; Barometric Pressure Correction (% x 10)(offset=70)
0010AC 0FD0AC                         matcor:       ds 2 ; Manifold Air Temperature Correction (% x 10)(offset=72)
0010AE 0FD0AE                         WUEcor:       ds 2 ; Warmup Enrichment Correction (% x 10)(offset=74)
0010B0 0FD0B0                         ASEcor:       ds 2 ; Afterstart Enrichmnet Correction (% x 10)(offset=76)
0010B2 0FD0B2                         WUEandASEcor: ds 2 ; the sum of WUEcor and ASEcor (% x 10)(offset=78)
0010B4 0FD0B4                         Crankcor:     ds 2 ; Cranking pulsewidth temperature correction (% x 10)(offset=80)
0010B6 0FD0B6                         TpsPctDOT:    ds 2 ; TPS difference over time (%/Sec)(update every 100mSec)(offset=82)
0010B8 0FD0B8                         TpsDOTcor:    ds 1 ; Throttle Opening Enrichment table value(%)(offset=84)
0010B9 0FD0B9                         ColdAddpct:   ds 1 ; Throttle Opening Enrichment cold adder (%)(offset=85)
0010BA 0FD0BA                         ColdMulpct:   ds 1 ; Throttle Opening Enrichment cold multiplier (%)(offset=86)
0010BB 0FD0BB                         TOEpct:       ds 1 ; Throttle Opening Enrichment (%)(offset=87)
0010BC 0FD0BC                         TOEpw:        ds 2 ; Throttle Opening Enrichment adder (mS x 100)(offset=88)
0010BE 0FD0BE                         PWlessTOE:    ds 2 ; Injector pulse width before "TOEpw" and "Deadband" (mS x 10)(offset=90)
0010C0 0FD0C0                         Deadband:     ds 2 ; injector deadband at current battery voltage mS*100(offset=92)
0010C2 0FD0C2                         PrimePW:      ds 2 ; Primer injector pulswidth (mS x 10)(offset=94)
0010C4 0FD0C4                         CrankPW:      ds 2 ; Cranking injector pulswidth (mS x 10)(offset=96)
0010C6 0FD0C6                         FDpw:         ds 2 ; Fuel Delivery pulse width (PW - Deadband) (mS x 10)(offset=98)
0010C8 0FD0C8                         PW:           ds 2 ; Running engine injector pulsewidth (mS x 10)(offset=100)
0010CA 0FD0CA                         LpH:          ds 2 ; Fuel burn Litres per hour(offset=102)
0010CC 0FD0CC                         FDsec:        ds 2 ; Fuel delivery pulse width total over 1 second (mS x 10)(offset=104)
0010CE 0FD0CE                         GearCur:      ds 1 ; Current transmission gear(offset=106)
0010CF 0FD0CF                         TOEdurCnt:    ds 1 ; Throttle Opening Enrichment duration counter(offset=107)
0010D0 0FD0D0                         FDt:          ds 2 ; Fuel Delivery pulse width total(mS) (for FDsec calcs)(offset=108)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Ignition calculation variables
                                      ;*****************************************************************************************
0010D2 0FD0D2                         STcurr:         ds 2 ; Current value in ST table (Degrees x 10)(offset=110)
0010D4 0FD0D4                         KmpL:           ds 2 ; Fuel burn kilometers per litre(offset=112)
0010D6 0FD0D6                         DwellCor:       ds 2 ; Coil dwell voltage correction (%*10)(offset=114)
0010D8 0FD0D8                         DwellFin:       ds 2 ; ("Dwell" * "DwellCor") (mS*10)(offset=116)
0010DA 0FD0DA                         STandItrmx10:   ds 2 ; stCurr and Itmx10 (degrees*10)(offset=118)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Port status variables
                                      ;*****************************************************************************************
0010DC 0FD0DC                         PortAbits:    ds 1  ; Port A status bit field(offset=120)
0010DD 0FD0DD                         PortBbits:    ds 1  ; Port B status bit field(offset=121)
0010DE 0FD0DE                         PortKbits:    ds 1  ; Port K status bit field(offset=122)
0010DF 0FD0DF                         PortPbits:    ds 1  ; Port P status bit field(offset=123)
0010E0 0FD0E0                         PortTbits:    ds 1  ; Port T status bit field(offset=124)
                                      ;*****************************************************************************************
                                      ; - Misc variables
                                      ;*****************************************************************************************
0010E1 0FD0E1                         engine:       ds 1  ; Engine status bit field(offset=125)
0010E2 0FD0E2                         engine2:      ds 1  ; Engine2 status bit field(offset=126)
0010E3 0FD0E3                         alarmbits:    ds 1  ; Alarm status bit field(offset=127)
0010E4 0FD0E4                         AAoffbits:    ds 1  ; Audio Alarm Off status bit field(offset=128)
0010E5 0FD0E5                         StateStatus:  ds 1  ; State status bit field(offset=129)
0010E6 0FD0E6                         LoopTime:     ds 2  ; Program main loop time (loops/Sec)(offset=130)
0010E8 0FD0E8                         DutyCyclex10: ds 2  ; Injector duty cycle in run mode (% x 10)(offset=132)
0010EA 0FD0EA                         MpG:          ds 2  ; Fuel burn miles per gallon Imperial (offset=134)
0010EC 0FD0EC                         TestValw:     ds 2  ; Word test value (for program developement only)(offset=136)
0010EE 0FD0EE                         testValb:     ds 1  ; Byte test value (for program developement only)(offset=138)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - This marks the end of the real time variables (139 bytes in total)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; --------------------------------- RS232 equates ----------------------------------------
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - "engine" equates
                                      ;*****************************************************************************************
0010EF 0FD0EF -> $0001                OFCdelon     equ  $01 ; %00000001, bit 0, In Crank Delay Mode (NOT USED)
0010EF 0FD0EF -> $0002                crank        equ  $02 ; %00000010, bit 1, In Crank Mode
0010EF 0FD0EF -> $0004                run          equ  $04 ; %00000100, bit 2, In Run Mode
0010EF 0FD0EF -> $0008                ASEon        equ  $08 ; %00001000, bit 3, In ASE Mode
0010EF 0FD0EF -> $0010                WUEon        equ  $10 ; %00010000, bit 4, In WUE Mode
0010EF 0FD0EF -> $0020                TOEon        equ  $20 ; %00100000, bit 5, In Throttle Opening Enrichment Mode
0010EF 0FD0EF -> $0040                OFCon        equ  $40 ; %01000000, bit 6, In Overrun Fuel Cut Mode
0010EF 0FD0EF -> $0080                FldClr       equ  $80 ; %10000000, bit 7, In Flood Clear Mode
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; "engine2" equates
                                      ;*****************************************************************************************
0010EF 0FD0EF -> $0001                base512        equ $01 ; %00000001, bit 0, In Timer Base 512 mode
0010EF 0FD0EF -> $0002                base256        equ $02 ; %00000010, bit 1, In Timer Base 256 Mode
0010EF 0FD0EF -> $0004                AudAlrm        equ $04 ; %00000100, bit 2, In Audible Alarm Mode
0010EF 0FD0EF -> $0008                TOEduron       equ $08 ; %00001000, bit 3, In Throttle Opening Enrichment Duration Mode
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; "alarmbits" equates
                                      ;*****************************************************************************************
0010EF 0FD0EF -> $0001                LOP        equ $01 ; %00000001, bit 0, Low Oil Pressure
0010EF 0FD0EF -> $0002                HOT        equ $02 ; %00000010, bit 1, High Oil Temperature
0010EF 0FD0EF -> $0004                HET        equ $04 ; %00000100, bit 2, High Engine Temperature
0010EF 0FD0EF -> $0008                HEGT       equ $08 ; %00001000, bit 3, High Exhaust Gas Temperature
0010EF 0FD0EF -> $0010                HFT        equ $10 ; %00010000, bit 4, High Fuel Temperature
0010EF 0FD0EF -> $0020                LFP        equ $20 ; %00100000, bit 5, Low Fuel Pressure
0010EF 0FD0EF -> $0040                HFP        equ $40 ; %01000000, bit 6, High Fuel Pressure
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; "AAoffbits"equates
                                      ;*****************************************************************************************
0010EF 0FD0EF -> $0001                LOPoff        equ $01 ; %00000001, bit 0, Low Oil Pressure Alarm Silenced
0010EF 0FD0EF -> $0002                HOToff        equ $02 ; %00000010, bit 1, High Oil Temperature Alarm Silenced
0010EF 0FD0EF -> $0004                HEToff        equ $04 ; %00000100, bit 2, High Engine Temperature Alarm Silenced
0010EF 0FD0EF -> $0008                HEGToff       equ $08 ; %00001000, bit 3, High Exhaust Gas Temperature Alarm Silenced
0010EF 0FD0EF -> $0010                HFToff        equ $10 ; %00010000, bit 4, High Fuel Temperature Alarm Silenced
0010EF 0FD0EF -> $0020                LFPoff        equ $20 ; %00100000, bit 5, Low Fuel Pressure Alarm Silenced
0010EF 0FD0EF -> $0040                HFPoff        equ $40 ; %01000000, bit 6, High Fuel Pressure Alarm Silenced
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - "StateStatus" equates
                                      ;*****************************************************************************************
0010EF 0FD0EF -> $0001                Synch            equ    $01  ; %00000001, bit 0, Crank Position Synchronized
0010EF 0FD0EF -> $0002                SynchLost        equ    $02  ; %00000010, bit 1, Crank Position Synchronize Lost
0010EF 0FD0EF -> $0004                StateNew         equ    $04  ; %00000100, bit 2, New Crank Position
                                      ;*****************************************************************************************
                                      ; PortAbits: Port A status bit field (PORTA)
                                      ;*****************************************************************************************
0010EF 0FD0EF -> $0001                LoadEEEM        equ  $01 ;(PA0)%00000001, bit 0, Load EEEM Enable
0010EF 0FD0EF -> $0002                Itrimen         equ  $02 ;(PA1)%00000010, bit 1, Ignition Trim Enable
0010EF 0FD0EF -> $0004                Ftrimen         equ  $04 ;(PA2)%00000100, bit 2, Fuel Trim Enable
0010EF 0FD0EF -> $0008                AudAlrmSil      equ  $08 ;(PA3)%00001000, bit 3, Audible Alarm Silence
0010EF 0FD0EF -> $0010                OFCen           equ  $10 ;(PA4)%00010000, bit 4, Overrun Fuel Cut Enable
0010EF 0FD0EF -> $0020                OFCdis          equ  $20 ;(PA5)%00100000, bit 5, Overrun Fuel Cut Disable
0010EF 0FD0EF -> $0040                PA6in           equ  $40 ;(PA6)%01000000, bit 6, PA6in State
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; PortBbits: Port B status bit field (PORTB)
                                      ;*****************************************************************************************
0010EF 0FD0EF -> $0001                FuelPump    equ  $01 ;(PB0)%00000001, bit 0, Fuel Pump State
0010EF 0FD0EF -> $0002                ASDRelay    equ  $02 ;(PB1)%00000010, bit 1, Automatic Shutdown Relay State
0010EF 0FD0EF -> $0004                EngAlarm    equ  $04 ;(PB2)%00000100, bit 2, Engine Alarm State
0010EF 0FD0EF -> $0008                AIOT        equ  $08 ;(PB3)%00001000, bit 3, AIOT Signal State
0010EF 0FD0EF -> $0010                PB4out      equ  $10 ;(PB4)%00010000, bit 4, PB4out State
0010EF 0FD0EF -> $0020                PB5out      equ  $20 ;(PB5)%00100000, bit 5, PB5out State
0010EF 0FD0EF -> $0040                PB6out      equ  $40 ;(PB6)%01000000, bit 6, PB6out State
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; PortKbits: Port K status bit field (PORTK)
                                      ;*****************************************************************************************
0010EF 0FD0EF -> $0001                LOPalrm    equ  $01 ;(PK0)%00000001, bit 0, Low Oil Pressure Alarm Condition
0010EF 0FD0EF -> $0002                HOTalrm    equ  $02 ;(PK1)%00000010, bit 1, High Oil Temperature Alarm Condition
0010EF 0FD0EF -> $0004                HETalrm    equ  $04 ;(PK2)%00000100, bit 2, High Engine Temperature Alarm Condition
0010EF 0FD0EF -> $0008                HEGTalrm   equ  $08 ;(PK3)%00001000, bit 3, High Exhaust Gas Temperature Alarm Condition
0010EF 0FD0EF -> $0010                HFTalrm    equ  $10 ;(PK4)%00010000, bit 4, High Fuel Temperature Alarm Condition
0010EF 0FD0EF -> $0020                LFPalrm    equ  $20 ;(PK5)%00100000, bit 5, Low Fuel Pressure Alarm Condition
                                      ;N/A        equ  $40 ;(PK6)%01000000, bit 6
0010EF 0FD0EF -> $0080                HFPalrm    equ  $80 ;(PK7)%10000000, bit 7, High Fuel Pressure Alarm Condition
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; PortPbits: Port P status bit field (PTP)(Tim1 Output Compare Channels)
                                      ;*****************************************************************************************
0010EF 0FD0EF -> $0001                Inj1      equ $01 ;(PP0)%00000001, bit 0, Inj1(1&10)
0010EF 0FD0EF -> $0002                Inj2      equ $02 ;(PP1)%00000010, bit 1, Inj2(9&4)
0010EF 0FD0EF -> $0004                Inj3      equ $04 ;(PP2)%00000100, bit 2, Inj3(3&6)
0010EF 0FD0EF -> $0008                Inj4      equ $08 ;(PP3)%00001000, bit 3, Inj4(5&8)
0010EF 0FD0EF -> $0010                Inj5      equ $10 ;(PP4)%00010000, bit 4, Inj5(7&2)
0010EF 0FD0EF -> $0020                PP5out    equ $20 ;(PP5)%00100000, bit 5,
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; PortTbits: Port T status bit field (PTT)(Enhanced Capture Channels)
                                      ;*****************************************************************************************
0010EF 0FD0EF -> $0001                CMP        equ $01 ;(PT0)%00000001, bit 0, Camshaft Position
0010EF 0FD0EF -> $0002                CKP        equ $02 ;(PT1)%00000010, bit 1, Crankshaft Position
0010EF 0FD0EF -> $0004                VSpd       equ $04 ;(PT2)%00000100, bit 2, Vehicle Speed
0010EF 0FD0EF -> $0008                Ign1       equ $08 ;(PT3)%00001000, bit 3, Ign1 (1&6)
0010EF 0FD0EF -> $0010                Ign2       equ $10 ;(PT4)%00010000, bit 4, Ign2 (10&5)
0010EF 0FD0EF -> $0020                Ign3       equ $20 ;(PT5)%00100000, bit 5, Ign3 (9&8)
0010EF 0FD0EF -> $0040                Ign4       equ $40 ;(PT6)%01000000, bit 6, Ign4 (4&7)
0010EF 0FD0EF -> $0080                Ign5       equ $80 ;(PT7)%10000000, bit 7, Ign5 (3&2)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; ------------------------------- Non RS232 variables ------------------------------------
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Misc variables
                                      ;*****************************************************************************************
0010EF 0FD0EF                         LoopCntr    ds 2 ; Counter for "LoopTime" (incremented every Main Loop pass)
0010F1 0FD0F1                         tmp1w       ds 2 ; Temporary word variable #1
0010F3 0FD0F3                         tmp2w       ds 2 ; Temporary word variable #2
0010F5 0FD0F5                         tmp3w       ds 2 ; Temporary word variable #3
0010F7 0FD0F7                         tmp4w       ds 2 ; Temporary word variable #4
0010F9 0FD0F9                         tmp5b       ds 1 ; Temporary byte variable #5
0010FA 0FD0FA                         tmp6b       ds 1 ; Temporary byte variable #6
0010FB 0FD0FB                         tmp7b       ds 1 ; Temporary byte variable #7
0010FC 0FD0FC                         tmp8b       ds 1 ; Temporary byte variable #8
0010FD 0FD0FD                         GearKCur    ds 2 ; Variable for current gear K factor calculations
0010FF 0FD0FF                         baroADCsum  ds 2 ; Variable for "baroADC" averaging sum
001101 0FD101                         baroADCcnt  ds 1 ; Counter for "baroADC" averaging sum
                                      ;*****************************************************************************************
001102 0FD102 -> $1102                BPEM488_SHARED_VARS_END       EQU *   ; * Represents the current value of the paged
                                                                            ; program counter
001102 0FD102 -> $FD102               BPEM488_SHARED_VARS_END_LIN   EQU @   ; @ Represents the current value of the linear
                                                                            ; program counter
                                      ;*****************************************************************************************
                                      ;* - Macros -                                                                            *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Code -                                                                              *
                                      ;*****************************************************************************************
004000 7F4000                                         ORG   BPEM488_CODE_START, BPEM488_CODE_START_LIN
                                      ; - Initialization -
                                      ;*****************************************************************************************
                                      ; - Initialize stack pointer -
                                      ;*****************************************************************************************
004000 7F4000 CF 40 00                    lds   #$3FFF+1    ; Initialize stack pointer bottom + 1
                                      ;*****************************************************************************************
                                      ; - Make sure we are in Single Chip Mode
                                      ;*****************************************************************************************
004003 7F4003 86 80                       ldaa  #MODC     ; Load Acc A with the value in bit 7 of Mode Register
004005 7F4005 5A 0B                       staa  MODE      ; Copy to Mode Register (lock MODE register into NSC
                                                          ;(normal single chip mode)
004007 7F4007 79 00 1E                    clr  IRQCR      ; Disable IRQ (won't run without this)
00400A 7F400A MACRO                       BASE_INIT       ; Call "BASE_INIT" Macro
                                                                        ; program counter                              (BASE_INIT)
                                      ;***************************************************************************************** (BASE_INIT)
                                      ;* - Macros -                                                                            * (BASE_INIT)
                                      ;***************************************************************************************** (BASE_INIT)
                                      ; -  Initialization -                                                            (BASE_INIT)
00400A 7F400A MACRO                                           INIT_VECTAB     ; Initialize Interrupt vectors (vectabs_BEEM488.s) (BASE_INIT)
                                      ;***************************************************************************************** (BASE_INIT/INIT_VECTAB)
                                      ; ------------------------- Initialize interupt vectors ---------------------------------- (BASE_INIT/INIT_VECTAB)
                                      ;                                                                                (BASE_INIT/INIT_VECTAB)
                                      ;   Priority level 7 = highest, 1 = lowest. If no priority set then highest address has (BASE_INIT/INIT_VECTAB)
                                      ;   priority                                                                     (BASE_INIT/INIT_VECTAB)
                                      ;***************************************************************************************** (BASE_INIT/INIT_VECTAB)
                                      ; - Disable XGATE interrupts -                                                   (BASE_INIT/INIT_VECTAB)
                                      ;    clr   INT_XGPRIO       ; Clear XGATE Interrupt Priority Configuration Register (XGATE NOT USED!!!!!!!!!!!!!!!) (BASE_INIT/INIT_VECTAB)
                                      ; - Initialize RTI -> UI ISR vectors -                                           (BASE_INIT/INIT_VECTAB)
00400A 7F400A 18 0B F0 01 27              movb  #$F0,INT_CFADDR  ; Load "CFADDR" with %11110000 (Place RTI -> UI       (BASE_INIT/INIT_VECTAB)
                                                                 ; into window)                                        (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$00,INT_CFDATA0 ; Load "CFDATA0" with %00000000 (Set RTI disabled)  (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$81,INT_CFDATA0 ; Load "CFDATA0" with %10000001 (Set RTI XGATE      (BASE_INIT/INIT_VECTAB)
                                                                 ; level 1 priority)                                   (BASE_INIT/INIT_VECTAB)
00400F 7F400F 18 0B 01 01 28              movb  #$01,INT_CFDATA0 ; Load "CFDATA0" with %00000001 (Set RTI CPU                ; RTI ENABLED, CPU, level 1 (BASE_INIT/INIT_VECTAB)
                                                                 ; level 1 priority)                                   (BASE_INIT/INIT_VECTAB)
004014 7F4014 18 0B 00 01 29              movb  #$00,INT_CFDATA1 ; Load "CFDATA1" with %00000000 (Set IRQ disabled)    (BASE_INIT/INIT_VECTAB)
004019 7F4019 18 0B 00 01 2A              movb  #$00,INT_CFDATA2 ; Load "CFDATA2" with %00000000 (Set XIRQ disabled)   (BASE_INIT/INIT_VECTAB)
00401E 7F401E 18 0B 00 01 2B              movb  #$00,INT_CFDATA3 ; Load "CFDATA3" with %00000000 (Set SWI disabled)    (BASE_INIT/INIT_VECTAB)
                                      ; - Initialize Enhanced Capture Timer Ch7 -> Ch0 vectors -                       (BASE_INIT/INIT_VECTAB)
004023 7F4023 18 0B E0 01 27              movb  #$E0,INT_CFADDR  ; Load "CFADDR" with %11100000 (Place Enhanced Captuer Timer (BASE_INIT/INIT_VECTAB)
                                                                 ; Ch7 -> Ch0 into window)                             (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$00,INT_CFDATA0 ; Load "CFDATA0" with %00000000 (Set ECT ch7 disabled) (BASE_INIT/INIT_VECTAB)
004028 7F4028 18 0B 01 01 28              movb  #$01,INT_CFDATA0 ; Load "CFDATA0" with %00000001 (Set ECT ch7 CPU                  ; ECT ch7 PT7 Ign5 (3&2) ENABLED, CPU, level 1 (BASE_INIT/INIT_VECTAB)
                                                                 ; priority level 1)(PT7 Ign5 (3&2))                   (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$00,INT_CFDATA1 ; Load "CFDATA1" with %00000000 (Set ECT ch6 VSS disabled) (BASE_INIT/INIT_VECTAB)
00402D 7F402D 18 0B 01 01 29              movb  #$01,INT_CFDATA1 ; Load "CFDATA1" with %00000001 (Set ECT ch6 CPU,                 ; ECT ch6 PT6 Ign4 4&7) ENABLED, CPU, level 1 (BASE_INIT/INIT_VECTAB)
                                                                 ; priority level 1)(PT6 Ign4 (4&7))                   (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$00,INT_CFDATA2 ; Load "CFDATA2" with %00000000 (Set ECT ch5 disabled) (BASE_INIT/INIT_VECTAB)
004032 7F4032 18 0B 01 01 2A              movb  #$01,INT_CFDATA2 ; Load "CFDATA2" with %00000001 (Set ECT ch5 CPU)                 ; ECT ch5 PT5 Ign3 (9&8) ENABLED, CPU, level 1 (BASE_INIT/INIT_VECTAB)
                                                                 ; priority level 1)(PT5 Ign3 (9&8))                   (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$00,INT_CFDATA3 ; Load "CFDATA3" with %00000000 (Set ECT ch4 disabled) (BASE_INIT/INIT_VECTAB)
004037 7F4037 18 0B 01 01 2B              movb  #$01,INT_CFDATA3 ; Load "CFDATA3" with %00000001 (Set ECT ch4 CPU,                 ; ECT ch4 PT4 Ign2 (10&5) ENABLED, CPU, level 1 (BASE_INIT/INIT_VECTAB)
                                                                 ; priority level 1)(PT4 Ign2 (10&5))                  (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$00,INT_CFDATA4 ; Load "CFDATA4" with %00000000 (Set ECT ch3 disabled) (BASE_INIT/INIT_VECTAB)
00403C 7F403C 18 0B 01 01 2C              movb  #$01,INT_CFDATA4 ; Load "CFDATA4" with %00000001 (Set ECT ch3 CPU,                 ; ECT ch3 (PT3 Ign1 (1&6)) ENABLED, CPU, level 1 (BASE_INIT/INIT_VECTAB)
                                                                 ; priority level 1)(PT3 Ign1 (1&6))                   (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$00,INT_CFDATA5 ; Load "CFDATA5" with %00000000 (Set ECT ch2 disabled) (BASE_INIT/INIT_VECTAB)
004041 7F4041 18 0B 01 01 2D              movb  #$01,INT_CFDATA5 ; Load "CFDATA5" with %00000001 (Set ECT ch2 CPU                  ; ECT ch2 (PT2 Vspd), ENABLED, CPU level 1 (BASE_INIT/INIT_VECTAB)
                                                                 ; priority level 1) (PT2 Vspd)                        (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$00,INT_CFDATA6 ; Load "CFDATA0" with %00000000 (Set ECT ch1 disabled) (BASE_INIT/INIT_VECTAB)
004046 7F4046 18 0B 07 01 2E              movb  #$07,INT_CFDATA6 ; Load "CFDATA5" with %00000111 (Set ECT ch1 CPU                  ; ECT ch1 (PT1 CKP), ENABLED, CPU level 7 (BASE_INIT/INIT_VECTAB)
                                                                 ; priority level 7) (PT1 CKP)                         (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$00,INT_CFDATA7 ; Load "CFDATA0" with %00000000 (Set ECT ch0 disabled) (BASE_INIT/INIT_VECTAB)
00404B 7F404B 18 0B 07 01 2F              movb  #$07,INT_CFDATA7 ; Load "CFDATA7" with %00000111 (Set ECT ch0 CPU                  ; ECT ch0 (PT0 CMP), ENABLED, CPU level 7 (BASE_INIT/INIT_VECTAB)
                                                                 ; priority level 7) (PT0 CMP)                         (BASE_INIT/INIT_VECTAB)
                                      ; - Initialize ATD1 -> Enhanced Capture Timer Overflow Interrupt Vectors -       (BASE_INIT/INIT_VECTAB)
004050 7F4050 18 0B D0 01 27              movb  #$D0,INT_CFADDR  ; Load "CFADDR" with %11010000 (Place ATD1 -> Enhanced (BASE_INIT/INIT_VECTAB)
                                                                 ; Capture Timer Overflow into window)                 (BASE_INIT/INIT_VECTAB)
004055 7F4055 18 0B 00 01 28              movb  #$00,INT_CFDATA0 ; Load "CFDATA0" with %00000000 (Set ATD1 disabled)   (BASE_INIT/INIT_VECTAB)
00405A 7F405A 18 0B 00 01 29              movb  #$00,INT_CFDATA1 ; Load "CFDATA1" with %00000000 (Set ATD0 disabled)   (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$01,INT_CFDATA1 ; Load "CFDATA1" with %00000001 (Set ATD0 CPU to    (BASE_INIT/INIT_VECTAB)
                                                                 ; priority level 1)                                   (BASE_INIT/INIT_VECTAB)
00405F 7F405F 18 0B 00 01 2A              movb  #$00,INT_CFDATA2 ; Load "CFDATA2" with %00000000 (Set SCI1 disabled)   (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$00,INT_CFDATA3 ; Load "CFDATA3" with %00000000 (Set SCI0 disabled) (BASE_INIT/INIT_VECTAB)
004064 7F4064 18 0B 01 01 2B              movb  #$01,INT_CFDATA3 ; Load "CFDATA3" with %00000001 (Set SCI0 CPU to         ; SCI0 ENABLED, CPU, level 1 (BASE_INIT/INIT_VECTAB)
                                                                 ; priority level 1)                                   (BASE_INIT/INIT_VECTAB)
004069 7F4069 18 0B 00 01 2C              movb  #$00,INT_CFDATA4 ; Load "CFDATA4" with %00000000 (Set SPI0 disabled)   (BASE_INIT/INIT_VECTAB)
00406E 7F406E 18 0B 00 01 2D              movb  #$00,INT_CFDATA5 ; Load "CFDATA5" with %00000000 (Set Pulse accumulator input (BASE_INIT/INIT_VECTAB)
                                                                 ; edge disabled)                                      (BASE_INIT/INIT_VECTAB)
004073 7F4073 18 0B 00 01 2E              movb  #$00,INT_CFDATA6 ; Load "CFDATA0" with %00000000 (Set Pulse accumulator A (BASE_INIT/INIT_VECTAB)
                                                                 ; overflow disabled)                                  (BASE_INIT/INIT_VECTAB)
004078 7F4078 18 0B 00 01 2F              movb  #$00,INT_CFDATA7 ; Load "CFDATA0" with %00000000 (Set ECT overflow disabled) (BASE_INIT/INIT_VECTAB)
                                      ; - Initialize IIC0 bus -> Port J Interrupt Vectors -                            (BASE_INIT/INIT_VECTAB)
00407D 7F407D 18 0B C0 01 27              movb  #$C0,INT_CFADDR  ; Load "CFADDR" with %11000000 (IIC0 bus -> Port J    (BASE_INIT/INIT_VECTAB)
                                                                 ; into window)                                        (BASE_INIT/INIT_VECTAB)
004082 7F4082 18 0B 00 01 28              movb  #$00,INT_CFDATA0 ; Load "CFDATA0" with %00000000 (Set IIC0 bus disabled) (BASE_INIT/INIT_VECTAB)
004087 7F4087 18 0B 00 01 29              movb  #$00,INT_CFDATA1 ; Load "CFDATA1" with %00000000 (Set SCI6 disabled)   (BASE_INIT/INIT_VECTAB)
00408C 7F408C 18 0B 00 01 2A              movb  #$00,INT_CFDATA2 ; Load "CFDATA2" with %00000000 (Set CRG self clock mode (BASE_INIT/INIT_VECTAB)
                                                                 ; disabled)                                           (BASE_INIT/INIT_VECTAB)
004091 7F4091 18 0B 00 01 2B              movb  #$00,INT_CFDATA3 ; Load "CFDATA3" with %00000000 (Set CRG PLL lock disabled) (BASE_INIT/INIT_VECTAB)
004096 7F4096 18 0B 00 01 2C              movb  #$00,INT_CFDATA4 ; Load "CFDATA4" with %00000000 (Set Pulse accumulator B (BASE_INIT/INIT_VECTAB)
                                                                 ; overflow disabled)                                  (BASE_INIT/INIT_VECTAB)
00409B 7F409B 18 0B 00 01 2D              movb  #$00,INT_CFDATA5 ; Load "CFDATA5" with %00000000 (Set Modulus down counter (BASE_INIT/INIT_VECTAB)
                                                                 ; underflow disabled)                                 (BASE_INIT/INIT_VECTAB)
0040A0 7F40A0 18 0B 00 01 2E              movb  #$00,INT_CFDATA6 ; Load "CFDATA0" with %00000000 (Set Port H disabled) (BASE_INIT/INIT_VECTAB)
0040A5 7F40A5 18 0B 00 01 2F              movb  #$00,INT_CFDATA7 ; Load "CFDATA0" with %00000000 (Set Port J disabled) (BASE_INIT/INIT_VECTAB)
                                      ; - Initialize CAN0 transmit -> SPI1 Interrupt Vectors -                         (BASE_INIT/INIT_VECTAB)
0040AA 7F40AA 18 0B B0 01 27              movb  #$B0,INT_CFADDR  ; Load "CFADDR" with %10110000 (CAN0 transmit -> SPI1 (BASE_INIT/INIT_VECTAB)
                                                                 ; into window)                                        (BASE_INIT/INIT_VECTAB)
0040AF 7F40AF 18 0B 00 01 28              movb  #$00,INT_CFDATA0 ; Load "CFDATA0" with %00000000 (Set CAN0 transmit disabled) (BASE_INIT/INIT_VECTAB)
0040B4 7F40B4 18 0B 00 01 29              movb  #$00,INT_CFDATA1 ; Load "CFDATA1" with %00000000 (Set CAN0 receive disabled) (BASE_INIT/INIT_VECTAB)
0040B9 7F40B9 18 0B 00 01 2A              movb  #$00,INT_CFDATA2 ; Load "CFDATA2" with %00000000 (Set CAN0 errors disabled) (BASE_INIT/INIT_VECTAB)
0040BE 7F40BE 18 0B 00 01 2B              movb  #$00,INT_CFDATA3 ; Load "CFDATA3" with %00000000 (Set CAN0 wake-up disabled) (BASE_INIT/INIT_VECTAB)
0040C3 7F40C3 18 0B 00 01 2C              movb  #$00,INT_CFDATA4 ; Load "CFDATA4" with %00000000 (Set FLASH disabled)  (BASE_INIT/INIT_VECTAB)
0040C8 7F40C8 18 0B 00 01 2D              movb  #$00,INT_CFDATA5 ; Load "CFDATA5" with %00000000 (Set Flash fault detect (BASE_INIT/INIT_VECTAB)
                                                                 ; disabled)                                           (BASE_INIT/INIT_VECTAB)
0040CD 7F40CD 18 0B 00 01 2E              movb  #$00,INT_CFDATA6 ; Load "CFDATA0" with %00000000 (Set SPI2 disabled)   (BASE_INIT/INIT_VECTAB)
0040D2 7F40D2 18 0B 00 01 2F              movb  #$00,INT_CFDATA7 ; Load "CFDATA0" with %00000000 (Set SPI1 disabled)   (BASE_INIT/INIT_VECTAB)
                                      ; - Initialize CAN2 transmit -> CAN1 wake-up Interrupt Vectors -                 (BASE_INIT/INIT_VECTAB)
0040D7 7F40D7 18 0B A0 01 27              movb  #$A0,INT_CFADDR  ; Load "CFADDR" with %10100000 (CAN2 transmit -> CAN1 (BASE_INIT/INIT_VECTAB)
                                                                 ; wake-up into window)                                (BASE_INIT/INIT_VECTAB)
0040DC 7F40DC 18 0B 00 01 28              movb  #$00,INT_CFDATA0 ; Load "CFDATA0" with %00000000 (Set CAN2 transmit disabled) (BASE_INIT/INIT_VECTAB)
0040E1 7F40E1 18 0B 00 01 29              movb  #$00,INT_CFDATA1 ; Load "CFDATA1" with %00000000 (Set CAN2 receive disabled) (BASE_INIT/INIT_VECTAB)
0040E6 7F40E6 18 0B 00 01 2A              movb  #$00,INT_CFDATA2 ; Load "CFDATA2" with %00000000 (Set CAN2 errors disabled) (BASE_INIT/INIT_VECTAB)
0040EB 7F40EB 18 0B 00 01 2B              movb  #$00,INT_CFDATA3 ; Load "CFDATA3" with %00000000 (Set CAN2 wake-up disabled) (BASE_INIT/INIT_VECTAB)
0040F0 7F40F0 18 0B 00 01 2C              movb  #$00,INT_CFDATA4 ; Load "CFDATA4" with %00000000 (Set CAN1 transmit disabled) (BASE_INIT/INIT_VECTAB)
0040F5 7F40F5 18 0B 00 01 2D              movb  #$00,INT_CFDATA5 ; Load "CFDATA5" with %00000000 (Set CAN1 receive disabled) (BASE_INIT/INIT_VECTAB)
0040FA 7F40FA 18 0B 00 01 2E              movb  #$00,INT_CFDATA6 ; Load "CFDATA0" with %00000000 (Set CAN1 errors disabled) (BASE_INIT/INIT_VECTAB)
0040FF 7F40FF 18 0B 00 01 2F              movb  #$00,INT_CFDATA7 ; Load "CFDATA0" with %00000000 (Set CAN1 wake-up disabled) (BASE_INIT/INIT_VECTAB)
                                      ; - Initialize CAN4 transmit -> CAN3 wake-up Interrupt Vectors -                 (BASE_INIT/INIT_VECTAB)
004104 7F4104 18 0B 90 01 27              movb  #$90,INT_CFADDR  ; Load "CFADDR" with %10010000 (CAN2 transmit -> CAN1 (BASE_INIT/INIT_VECTAB)
                                                                 ; wake-up into window)                                (BASE_INIT/INIT_VECTAB)
004109 7F4109 18 0B 00 01 28              movb  #$00,INT_CFDATA0 ; Load "CFDATA0" with %00000000 (Set CAN4 transmit disabled) (BASE_INIT/INIT_VECTAB)
00410E 7F410E 18 0B 00 01 29              movb  #$00,INT_CFDATA1 ; Load "CFDATA1" with %00000000 (Set CAN4 receive disabled) (BASE_INIT/INIT_VECTAB)
004113 7F4113 18 0B 00 01 2A              movb  #$00,INT_CFDATA2 ; Load "CFDATA2" with %00000000 (Set CAN4 errors disabled) (BASE_INIT/INIT_VECTAB)
004118 7F4118 18 0B 00 01 2B              movb  #$00,INT_CFDATA3 ; Load "CFDATA3" with %00000000 (Set CAN4 wake-up disabled) (BASE_INIT/INIT_VECTAB)
00411D 7F411D 18 0B 00 01 2C              movb  #$00,INT_CFDATA4 ; Load "CFDATA4" with %00000000 (Set CAN3 transmit disabled) (BASE_INIT/INIT_VECTAB)
004122 7F4122 18 0B 00 01 2D              movb  #$00,INT_CFDATA5 ; Load "CFDATA5" with %00000000 (Set CAN3 receive disabled) (BASE_INIT/INIT_VECTAB)
004127 7F4127 18 0B 00 01 2E              movb  #$00,INT_CFDATA6 ; Load "CFDATA0" with %00000000 (Set CAN3 errors disabled) (BASE_INIT/INIT_VECTAB)
00412C 7F412C 18 0B 00 01 2F              movb  #$00,INT_CFDATA7 ; Load "CFDATA0" with %00000000 (Set CAN3 wake-up disabled) (BASE_INIT/INIT_VECTAB)
                                      ; - Initialize Low Voltage interrupt -> Port P Interrupt Vectors -               (BASE_INIT/INIT_VECTAB)
004131 7F4131 18 0B 80 01 27              movb  #$80,INT_CFADDR  ; Load "CFADDR" with %10000000 (Low Voltage interrupt -> (BASE_INIT/INIT_VECTAB)
                                                                 ; Port P into window)                                 (BASE_INIT/INIT_VECTAB)
004136 7F4136 18 0B 00 01 28              movb  #$00,INT_CFDATA0 ; Load "CFDATA0" with %00000000 (Set Low Voltage interrupt (BASE_INIT/INIT_VECTAB)
                                                                 ; disabled)                                           (BASE_INIT/INIT_VECTAB)
00413B 7F413B 18 0B 00 01 29              movb  #$00,INT_CFDATA1 ; Load "CFDATA1" with %00000000 (Set IIC1 bus disabled) (BASE_INIT/INIT_VECTAB)
004140 7F4140 18 0B 00 01 2A              movb  #$00,INT_CFDATA2 ; Load "CFDATA2" with %00000000 (Set SCI5 disabled)   (BASE_INIT/INIT_VECTAB)
004145 7F4145 18 0B 00 01 2B              movb  #$00,INT_CFDATA3 ; Load "CFDATA3" with %00000000 (Set SCI4 disabled)   (BASE_INIT/INIT_VECTAB)
00414A 7F414A 18 0B 00 01 2C              movb  #$00,INT_CFDATA4 ; Load "CFDATA4" with %00000000 (Set SCI3 transmit disabled) (BASE_INIT/INIT_VECTAB)
00414F 7F414F 18 0B 00 01 2D              movb  #$00,INT_CFDATA5 ; Load "CFDATA5" with %00000000 (Set SCI2 receive disabled) (BASE_INIT/INIT_VECTAB)
004154 7F4154 18 0B 00 01 2E              movb  #$00,INT_CFDATA6 ; Load "CFDATA0" with %00000000 (Set PWM emergency shutdown (BASE_INIT/INIT_VECTAB)
                                                                 ; disabled)                                           (BASE_INIT/INIT_VECTAB)
004159 7F4159 18 0B 00 01 2F              movb  #$00,INT_CFDATA7 ; Load "CFDATA0" with %00000000 (Set Port P interrupt disabled) (BASE_INIT/INIT_VECTAB)
                                      ; - Initialize XGATE SW trig 1 -> API Interrupt Vectors -                        (BASE_INIT/INIT_VECTAB)
00415E 7F415E 18 0B 70 01 27              movb  #$70,INT_CFADDR  ; Load "CFADDR" with %01110000 (XGATE SW trig 1 -> API (BASE_INIT/INIT_VECTAB)
                                                                 ; into window)                                        (BASE_INIT/INIT_VECTAB)
004163 7F4163 18 0B 00 01 28              movb  #$00,INT_CFDATA0 ; Load "CFDATA0" with %00000000 (Set XGATE SW trig 1 disabled) (BASE_INIT/INIT_VECTAB)
004168 7F4168 18 0B 00 01 29              movb  #$00,INT_CFDATA1 ; Load "CFDATA1" with %00000000 (Set XGATE SW trig 0 disabled) (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$81,INT_CFDATA1 ; Load "CFDATA1" with %10000001 (Set XGATE SW trig 0 XGATE,)      ; XGATE SW Trig 0 (RTI) Disabled, XGATE, level 1 (used to clear RTI variables) (BASE_INIT/INIT_VECTAB)
                                                                 ; level 1 priority)                                   (BASE_INIT/INIT_VECTAB)
00416D 7F416D 18 0B 00 01 2A              movb  #$00,INT_CFDATA2 ; Load "CFDATA2" with %00000000 (Set PIT ch3 disabled) (BASE_INIT/INIT_VECTAB)
004172 7F4172 18 0B 00 01 2B              movb  #$00,INT_CFDATA3 ; Load "CFDATA3" with %00000000 (Set PIT ch2 disabled) (BASE_INIT/INIT_VECTAB)
004177 7F4177 18 0B 00 01 2C              movb  #$00,INT_CFDATA4 ; Load "CFDATA4" with %00000000 (Set PIT ch1 transmit disabled) (BASE_INIT/INIT_VECTAB)
00417C 7F417C 18 0B 00 01 2D              movb  #$00,INT_CFDATA5 ; Load "CFDATA5" with %00000000 (Set PIT ch0 disabled) (BASE_INIT/INIT_VECTAB)
004181 7F4181 18 0B 00 01 2E              movb  #$00,INT_CFDATA6 ; Load "CFDATA0" with %00000000 (Set Hi Temp interrupt disabled) (BASE_INIT/INIT_VECTAB)
004186 7F4186 18 0B 00 01 2F              movb  #$00,INT_CFDATA7 ; Load "CFDATA0" with %00000000 (Set API interrupt disabled) (BASE_INIT/INIT_VECTAB)
                                      ; - Initialize XGATE SW trig 7 -> XGATE SW trig 2 Interrupt Vectors -            (BASE_INIT/INIT_VECTAB)
00418B 7F418B 18 0B 64 01 27              movb  #$64,INT_CFADDR  ; Load "CFADDR" with %01100100 (XGATE SW trig 7 -> XGATE SW (BASE_INIT/INIT_VECTAB)
                                                                 ; trig 2 into window)                                 (BASE_INIT/INIT_VECTAB)
004190 7F4190 18 0B 00 01 28              movb  #$00,INT_CFDATA0 ; Load "CFDATA0" with %00000000 (Set XGATE SW trig 7 disabled) (BASE_INIT/INIT_VECTAB)
004195 7F4195 18 0B 00 01 29              movb  #$00,INT_CFDATA1 ; Load "CFDATA1" with %00000000 (Set XGATE SW trig 6 disabled) (BASE_INIT/INIT_VECTAB)
00419A 7F419A 18 0B 00 01 2A              movb  #$00,INT_CFDATA2 ; Load "CFDATA2" with %00000000 (Set XGATE SW trig 5 disabled) (BASE_INIT/INIT_VECTAB)
00419F 7F419F 18 0B 00 01 2B              movb  #$00,INT_CFDATA3 ; Load "CFDATA3" with %00000000 (Set XGATE SW trig 4 disabled) (BASE_INIT/INIT_VECTAB)
0041A4 7F41A4 18 0B 00 01 2C              movb  #$00,INT_CFDATA4 ; Load "CFDATA4" with %00000000 (Set XGATE SW trig 3 disabled) (BASE_INIT/INIT_VECTAB)
0041A9 7F41A9 18 0B 00 01 2D              movb  #$00,INT_CFDATA5 ; Load "CFDATA5" with %00000000 (Set XGATE SW trig 2 disabled) (BASE_INIT/INIT_VECTAB)
0041AE 7F41AE 18 0B 00 01 2E              movb  #$00,INT_CFDATA6 ; Load "CFDATA0" with %00000000 (Reserved)            (BASE_INIT/INIT_VECTAB)
0041B3 7F41B3 18 0B 00 01 2F              movb  #$00,INT_CFDATA7 ; Load "CFDATA0" with %00000000 (Reserved)            (BASE_INIT/INIT_VECTAB)
                                      ; - Initialize TIM ch2 -> PIT ch4 Interrupt Vectors -                            (BASE_INIT/INIT_VECTAB)
0041B8 7F41B8 18 0B 50 01 27              movb  #$50,INT_CFADDR  ; Load "CFADDR" with %01010000 (TIM ch2 -> PIT ch4    (BASE_INIT/INIT_VECTAB)
                                                                 ; into window)                                        (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$00,INT_CFDATA0 ; Load "CFDATA0" with %00000000 (Set TIM ch2 disabled) (BASE_INIT/INIT_VECTAB)
0041BD 7F41BD 18 0B 01 01 28              movb  #$01,INT_CFDATA0 ; Load "CFDATA0" with %00000001 (Set TIM ch2 CPU              ; TIM ch2 (PP2 Inj3 (3&6)), ENABLED, CPU level 1 (BASE_INIT/INIT_VECTAB)
                                                                 ; priority level 1)(PP2 Inj3 (3&6))                   (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$00,INT_CFDATA1 ; Load "CFDATA1" with %00000000 (Set TIM ch1 disabled) (BASE_INIT/INIT_VECTAB)
0041C2 7F41C2 18 0B 01 01 29              movb  #$01,INT_CFDATA1 ; Load "CFDATA1" with %00000001 (Set TIM ch1 CPU              ; TIM ch1 (PP1 Inj2 (9&4)), ENABLED, CPU level 1 (BASE_INIT/INIT_VECTAB)
                                                                 ; priority level 1)(PP1 Inj2 (9&4))                   (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$00,INT_CFDATA2 ; Load "CFDATA2" with %00000000 (Set TIM ch0 disabled) (BASE_INIT/INIT_VECTAB)
0041C7 7F41C7 18 0B 01 01 2A              movb  #$01,INT_CFDATA2 ; Load "CFDATA2" with %00000001 (Set TIM ch0 CPU              ; TIM ch0 (PP0 Inj1 (1&10)), ENABLED, CPU level 1 (BASE_INIT/INIT_VECTAB)
                                                                 ; priority level 1)(PP0 Inj1 (1&10))                  (BASE_INIT/INIT_VECTAB)
0041CC 7F41CC 18 0B 00 01 2B              movb  #$00,INT_CFDATA3 ; Load "CFDATA3" with %00000000 (Set SCI7 disabled)   (BASE_INIT/INIT_VECTAB)
0041D1 7F41D1 18 0B 00 01 2C              movb  #$00,INT_CFDATA4 ; Load "CFDATA4" with %00000000 (Set PIT ch7 disabled) (BASE_INIT/INIT_VECTAB)
0041D6 7F41D6 18 0B 00 01 2D              movb  #$00,INT_CFDATA5 ; Load "CFDATA5" with %00000000 (Set PIT ch6 disabled) (BASE_INIT/INIT_VECTAB)
0041DB 7F41DB 18 0B 00 01 2E              movb  #$00,INT_CFDATA6 ; Load "CFDATA0" with %00000000 (Set PIT ch5 disabled) (BASE_INIT/INIT_VECTAB)
0041E0 7F41E0 18 0B 00 01 2F              movb  #$00,INT_CFDATA7 ; Load "CFDATA0" with %00000000 (Set PIT ch4 disabled) (BASE_INIT/INIT_VECTAB)
                                      ; - Initialize TIM Pulse accumulator input edge -> TIM ch3 Interrupt Vectors -   (BASE_INIT/INIT_VECTAB)
0041E5 7F41E5 18 0B 40 01 27              movb  #$40,INT_CFADDR  ; Load "CFADDR" with %01000000 (TIM Pulse accumulator (BASE_INIT/INIT_VECTAB)
                                                                 ; input edge -> TIM ch3 into window)                  (BASE_INIT/INIT_VECTAB)
0041EA 7F41EA 18 0B 00 01 28              movb  #$00,INT_CFDATA0 ; Load "CFDATA0" with %00000000 (Set TIM Pulse accumulator (BASE_INIT/INIT_VECTAB)
                                                                 ; input edge disabled)                                (BASE_INIT/INIT_VECTAB)
0041EF 7F41EF 18 0B 00 01 29              movb  #$00,INT_CFDATA1 ; Load "CFDATA1" with %00000000 (Set TIM Pulse accumulator (BASE_INIT/INIT_VECTAB)
                                                                 ; A overflow disabled)                                (BASE_INIT/INIT_VECTAB)
0041F4 7F41F4 18 0B 00 01 2A              movb  #$00,INT_CFDATA2 ; Load "CFDATA2" with %00000000 (Set TIM overflow disabled) (BASE_INIT/INIT_VECTAB)
0041F9 7F41F9 18 0B 00 01 2B              movb  #$00,INT_CFDATA3 ; Load "CFDATA3" with %00000000 (Set TIM ch7 disabled) (BASE_INIT/INIT_VECTAB)
0041FE 7F41FE 18 0B 00 01 2C              movb  #$00,INT_CFDATA4 ; Load "CFDATA4" with %00000000 (Set TIM ch6 disabled) (BASE_INIT/INIT_VECTAB)
004203 7F4203 18 0B 00 01 2D              movb  #$00,INT_CFDATA5 ; Load "CFDATA5" with %00000000 (Set TIM ch5 disabled) (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$01,INT_CFDATA5 ; Load "CFDATA5" with %00000001 (Set TIM ch5 CPU    (BASE_INIT/INIT_VECTAB)
                                                                 ; priority level 1)(PP5out)                           (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$00,INT_CFDATA6 ; Load "CFDATA6" with %00000000 (Set TIM ch4 disabled) (BASE_INIT/INIT_VECTAB)
004208 7F4208 18 0B 01 01 2E              movb  #$01,INT_CFDATA6 ; Load "CFDATA6" with %00000001 (Set TIM ch4                   ; TIM ch4 (PP4 Inj5 (7&2)), ENABLED, CPU level 1 (BASE_INIT/INIT_VECTAB)
                                                                 ; priority level 1)(PP4 Inj5 (7&2))                   (BASE_INIT/INIT_VECTAB)
                                      ;*    movb  #$00,INT_CFDATA7 ; Load "CFDATA7" with %00000000 (Set TIM ch3 disabled) (BASE_INIT/INIT_VECTAB)
00420D 7F420D 18 0B 01 01 2F              movb  #$01,INT_CFDATA7 ; Load "CFDATA7" with %00000001 (Set TIM ch3 CPU               ; TIM ch3 (PP3 Inj4 (5&8)), ENABLED, CPU level 1 (BASE_INIT/INIT_VECTAB)
                                                                 ; priority level 1)(PP3 Inj4 (5&8))                   (BASE_INIT/INIT_VECTAB)
                                      ; - Initialize ATD1 Compare interrupt -> ATD0 Compare interrupt Interrupt Vectors - (BASE_INIT/INIT_VECTAB)
004212 7F4212 18 0B 3C 01 27              movb  #$3C,INT_CFADDR  ; Load "CFADDR" with %00111100 (ATD1 Compare interrupt -> (BASE_INIT/INIT_VECTAB)
                                                                 ; ATD0 Compare interrupt into window)                 (BASE_INIT/INIT_VECTAB)
004217 7F4217 18 0B 00 01 28              movb  #$00,INT_CFDATA0 ; Load "CFDATA0" with %00000000 (Set ATD1 Compare interrupt disabled) (BASE_INIT/INIT_VECTAB)
00421C 7F421C 18 0B 00 01 29              movb  #$00,INT_CFDATA1 ; Load "CFDATA1" with %00000000 (Set ATD0 Compare interrupt disabled) (BASE_INIT/INIT_VECTAB)
004221 7F4221 18 0B 00 01 2A              movb  #$00,INT_CFDATA2 ; Load "CFDATA2" with %00000000 (Reserved)            (BASE_INIT/INIT_VECTAB)
004226 7F4226 18 0B 00 01 2B              movb  #$00,INT_CFDATA3 ; Load "CFDATA3" with %00000000 (Reserved)            (BASE_INIT/INIT_VECTAB)
00422B 7F422B 18 0B 00 01 2C              movb  #$00,INT_CFDATA4 ; Load "CFDATA4" with %00000000 (Reserved)            (BASE_INIT/INIT_VECTAB)
004230 7F4230 18 0B 00 01 2D              movb  #$00,INT_CFDATA5 ; Load "CFDATA5" with %00000000 (Reserved)            (BASE_INIT/INIT_VECTAB)
004235 7F4235 18 0B 00 01 2E              movb  #$00,INT_CFDATA6 ; Load "CFDATA0" with %00000000 (Reserved)            (BASE_INIT/INIT_VECTAB)
00423A 7F423A 18 0B 00 01 2F              movb  #$00,INT_CFDATA7 ; Load "CFDATA0" with %00000000 (Reserved)            (BASE_INIT/INIT_VECTAB)
                                      ; - Initialize Spurious interrupt -> XGATE software error Interrupt Vectors -    (BASE_INIT/INIT_VECTAB)
00423F 7F423F 18 0B 10 01 27              movb  #$10,INT_CFADDR  ; Load "CFADDR" with %00010000 (ATD1 Compare interrupt -> (BASE_INIT/INIT_VECTAB)
                                                                 ; ATD0 Compare interrupt into window)                 (BASE_INIT/INIT_VECTAB)
004244 7F4244 18 0B 00 01 28              movb  #$00,INT_CFDATA0 ; Load "CFDATA0" with %00000000 (Set Spurious interrupt (BASE_INIT/INIT_VECTAB)
                                                                 ; disabled)                                           (BASE_INIT/INIT_VECTAB)
004249 7F4249 18 0B 00 01 29              movb  #$00,INT_CFDATA1 ; Load "CFDATA1" with %00000000 (Set System Call disabled) (BASE_INIT/INIT_VECTAB)
00424E 7F424E 18 0B 00 01 2A              movb  #$00,INT_CFDATA2 ; Load "CFDATA2" with %00000000 (Set MPU access error disabled) (BASE_INIT/INIT_VECTAB)
004253 7F4253 18 0B 00 01 2B              movb  #$00,INT_CFDATA3 ; Load "CFDATA3" with %00000000 (Set XGATE software error (BASE_INIT/INIT_VECTAB)
                                                                 ; disabled)                                           (BASE_INIT/INIT_VECTAB)
004258 7F4258 18 0B 00 01 2C              movb  #$00,INT_CFDATA4 ; Load "CFDATA4" with %00000000 (Reserved)            (BASE_INIT/INIT_VECTAB)
00425D 7F425D 18 0B 00 01 2D              movb  #$00,INT_CFDATA5 ; Load "CFDATA5" with %00000000 (Reserved)            (BASE_INIT/INIT_VECTAB)
004262 7F4262 18 0B 00 01 2E              movb  #$00,INT_CFDATA6 ; Load "CFDATA0" with %00000000 (Reserved)            (BASE_INIT/INIT_VECTAB)
004267 7F4267 18 0B 00 01 2F              movb  #$00,INT_CFDATA7 ; Load "CFDATA0" with %00000000 (Reserved)            (BASE_INIT/INIT_VECTAB)
00426C 7F426C MACRO                                           CLR_VECTAB_VARS ; Clear Vectab variables (vectabs_BPEM488.s) (BASE_INIT)
                                                                    ; program counter                                  (BASE_INIT/CLR_VECTAB_VARS)
                                      ;***************************************************************************************** (BASE_INIT/CLR_VECTAB_VARS)
                                      ;* - Macros -                                                                            * (BASE_INIT/CLR_VECTAB_VARS)
                                      ;***************************************************************************************** (BASE_INIT/CLR_VECTAB_VARS)
00426C 7F426C 79 10 00                   clr  ResetFlgs  ; Reset Flags bit field variable                              (BASE_INIT/CLR_VECTAB_VARS)
00426F 7F426F 79 10 01                   clr  VecDebug   ; Vector Table de-bug address holder                          (BASE_INIT/CLR_VECTAB_VARS)
004272 7F4272 MACRO                                           INIT_EEEM       ; Initialize EEPROM Emulation (eeem_BEEM488.s) (BASE_INIT)
                                                                    ; program counter                                  (BASE_INIT/INIT_EEEM)
                                      ;***************************************************************************************** (BASE_INIT/INIT_EEEM)
                                      ;* - Macros -                                                                            * (BASE_INIT/INIT_EEEM)
                                      ;***************************************************************************************** (BASE_INIT/INIT_EEEM)
                                      ; - Initialization -                                                             (BASE_INIT/INIT_EEEM)
004272 7F4272 18 0B 0F 01 00              movb    #EEEM_FDIV_VAL, FCLKDIV ; Load Flash clock Divider Register          (BASE_INIT/INIT_EEEM)
004277 7F4277 MACRO                               INIT_CLOCK      ; Initialize Clocks and RTI(clock_BEEM488.s)         (BASE_INIT)
                                                                    ; program counter                                  (BASE_INIT/INIT_CLOCK)
                                      ;***************************************************************************************** (BASE_INIT/INIT_CLOCK)
                                      ;* - Macros -                                                                            * (BASE_INIT/INIT_CLOCK)
                                      ;***************************************************************************************** (BASE_INIT/INIT_CLOCK)
                                      ;***************************************************************************************** (BASE_INIT/INIT_CLOCK)
                                      ; - Initialize the the clock generator and Phase Lock Loop for 50 Mhz            (BASE_INIT/INIT_CLOCK)
                                      ;   Bus Clock frequency.(See pages 473, 474 and 486,487)                         (BASE_INIT/INIT_CLOCK)
                                      ;                                                                                (BASE_INIT/INIT_CLOCK)
                                      ;   SYSCLK (bus clock) is half of selected source clock, either OSCCLK           (BASE_INIT/INIT_CLOCK)
                                      ;   or PLLCLK.The PLLCLK frequency is:                                           (BASE_INIT/INIT_CLOCK)
                                      ;   PLLCLCK = 2 * OSCCLK * (SYDIV + 1) / REFDIV + 1)                             (BASE_INIT/INIT_CLOCK)
                                      ;   We are using a 16 Mhz crystal oscilator for OSCCLK, So if SYNDIV             (BASE_INIT/INIT_CLOCK)
                                      ;   = 24 and REFDIV = 7 then PLLCLCK will be (2 * 16000000 *25) / 8 =            (BASE_INIT/INIT_CLOCK)
                                      ;   100 Mhz. PLLCLK / 2 = 50 Mhz. Bus Clock.                                     (BASE_INIT/INIT_CLOCK)
                                      ;   From table 11-2 for 100MHz VCO clock VCOFRQ[1:0] = 11 so                     (BASE_INIT/INIT_CLOCK)
                                      ;   so SYNR = %11011000 = $D8                                                    (BASE_INIT/INIT_CLOCK)
                                      ;   From table 11-3 for 2MHz REFLCK frequency REFFRQ[1:0] = 00 so                (BASE_INIT/INIT_CLOCK)
                                      ;   so REFDV = %00000111 = $07                                                   (BASE_INIT/INIT_CLOCK)
                                      ;***************************************************************************************** (BASE_INIT/INIT_CLOCK)
004277 7F4277 18 0B FF 00 37              movb  #$FF,CRGFLG     ; Clear all flags                                      (BASE_INIT/INIT_CLOCK)
00427C 7F427C 18 0B D8 00 34              movb  #$D8,SYNR       ; Load "SYNR" with %11011000                           (BASE_INIT/INIT_CLOCK)
004281 7F4281 18 0B 07 00 35              movb  #$07,REFDV      ; Load "REFDV" with %00000111                          (BASE_INIT/INIT_CLOCK)
004286 7F4286 4F 37 08 FC                 brclr CRGFLG,LOCK,*+0 ; Loop until LOCK flag is cleared                      (BASE_INIT/INIT_CLOCK)
00428A 7F428A 4C 39 80                    bset  CLKSEL,PLLSEL   ; Set "PLL Select bit" to derive system clocks from "PLLCLK" (BASE_INIT/INIT_CLOCK)
00428D 7F428D MACRO                               INIT_RTI        ; Initialize Real Time Interrupt (rti_BEEM488.s)     (BASE_INIT)
                                      ;***************************************************************************************** (BASE_INIT/INIT_RTI)
                                      ; - Initialize Real Time Interrupt for 125uS period -                            (BASE_INIT/INIT_RTI)
                                      ;   OSCLOCK / 2 = Frequency divide rate                                          (BASE_INIT/INIT_RTI)
                                      ;   16,000,000/2=8,000,000                                                       (BASE_INIT/INIT_RTI)
                                      ;   1/8,000,000=0.000125 Sec period                                              (BASE_INIT/INIT_RTI)
                                      ;***************************************************************************************** (BASE_INIT/INIT_RTI)
00428D 7F428D 18 0B 81 00 3B              movb  #$81,RTICTL     ; Load "RTICTL with %10000001 (Decimal                 (BASE_INIT/INIT_RTI)
                                                                ; based divider,125uS period)                          (BASE_INIT/INIT_RTI)
004292 7F4292 4C 37 80                    bset  CRGFLG,RTIF     ; Clear Real Time Interrupt Flag                       (BASE_INIT/INIT_RTI)
004295 7F4295 4C 38 80                    bset  CRGINT,RTIE     ; Enable RTI                                           (BASE_INIT/INIT_RTI)
004298 7F4298 MACRO                                           CLR_RTI_VARS    ; Clear RTI variables  (rti_BEEM488.s)   (BASE_INIT)
                                                                    ; program counter                                  (BASE_INIT/CLR_RTI_VARS)
                                      ;***************************************************************************************** (BASE_INIT/CLR_RTI_VARS)
                                      ;* - Macros -                                                                            * (BASE_INIT/CLR_RTI_VARS)
                                      ;***************************************************************************************** (BASE_INIT/CLR_RTI_VARS)
004298 7F4298 79 10 02                   clr uSx125     ; 125 microsecond counter                                      (BASE_INIT/CLR_RTI_VARS)
00429B 7F429B 79 10 03                   clr mS         ; 1 millisecond counter                                        (BASE_INIT/CLR_RTI_VARS)
00429E 7F429E 79 10 04                   clr mSx250     ; 250 millisecond counter                                      (BASE_INIT/CLR_RTI_VARS)
0042A1 7F42A1 79 10 05                   clr clock      ; Time rate flag marker bit field                              (BASE_INIT/CLR_RTI_VARS)
0042A4 7F42A4 MACRO                               INIT_SCI0       ; Initialize SCI0 (sci0_BEEM488.s)                   (BASE_INIT)
                                      ;***************************************************************************************** (BASE_INIT/INIT_SCI0)
                                      ; - Initialize the SCI0 interface for 115,200 Baud Rate                          (BASE_INIT/INIT_SCI0)
                                      ;   When IREN = 0, SCI Baud Rate = SCI bus clock / 16 x SBR[12-0]                (BASE_INIT/INIT_SCI0)
                                      ;   or SCI0BDH:SCI0BDL = (Bus Freq/16)/115200 = 21.70                            (BASE_INIT/INIT_SCI0)
                                      ;   27.1 rounded = 27 = $1B                                                      (BASE_INIT/INIT_SCI0)
                                      ;***************************************************************************************** (BASE_INIT/INIT_SCI0)
0042A4 7F42A4 18 0B 00 00 C8              movb  #$00,SCI0BDH  ; Load SCI0BDH with %01010100, (IR disabled, 1/16 narrow pulse (BASE_INIT/INIT_SCI0)
                                                              ; width, no prescale Hi Byte)                            (BASE_INIT/INIT_SCI0)
0042A9 7F42A9 18 0B 1B 00 C9              movb  #$1B,SCI0BDL  ; Load SCI0BDL with decimal 27, prescale Lo byte         (BASE_INIT/INIT_SCI0)
                                                              ;(115,200 Baud Rate)                                     (BASE_INIT/INIT_SCI0)
0042AE 7F42AE 79 00 CA                    clr   SCI0CR1       ; Load SCI0CR1 with %00000000(Normal operation, SCI enabled (BASE_INIT/INIT_SCI0)
                                                              ; in wait mode. Internal receiver source. One start bit,8 data (BASE_INIT/INIT_SCI0)
                                                              ; bits, one stop bit. Idle line wakeup. No parity.)      (BASE_INIT/INIT_SCI0)
0042B1 7F42B1 18 0B 24 00 CB              movb  #$24,SCI0CR2  ; Load SCI0CR2 with %00100100(TDRE interrupts disabled. TCIE (BASE_INIT/INIT_SCI0)
0042B6 7F42B6 MACRO                                           CLR_SCI0_VARS   ; Clear SCI0 variables  (sci0_BEEM488.s) (BASE_INIT)
                                                                    ; program counter                                  (BASE_INIT/CLR_SCI0_VARS)
                                      ;***************************************************************************************** (BASE_INIT/CLR_SCI0_VARS)
                                      ;* - Macros -                                                                            * (BASE_INIT/CLR_SCI0_VARS)
                                      ;***************************************************************************************** (BASE_INIT/CLR_SCI0_VARS)
0042B6 7F42B6 79 10 06                   clr  txgoalMSB    ; SCI number of bytes to send/rcv Hi byte                   (BASE_INIT/CLR_SCI0_VARS)
0042B9 7F42B9 79 10 07                   clr  txgoalLSB    ; SCI number of bytes to send/rcv Lo byte                   (BASE_INIT/CLR_SCI0_VARS)
0042BC 7F42BC 18 79 10 08                clrw txcnt        ; SCI count of bytes sent/rcvd                              (BASE_INIT/CLR_SCI0_VARS)
0042C0 7F42C0 79 10 0A                   clr  rxoffsetMSB  ; SCI offset from start of page Hi byte                     (BASE_INIT/CLR_SCI0_VARS)
0042C3 7F42C3 79 10 0B                   clr  rxoffsetLSB  ; SCI offset from start of page lo byte                     (BASE_INIT/CLR_SCI0_VARS)
0042C6 7F42C6 79 10 0C                   clr  rxmode       ; SCI receive mode selector                                 (BASE_INIT/CLR_SCI0_VARS)
0042C9 7F42C9 79 10 0D                   clr  txmode       ; SCI transmit mode selector                                (BASE_INIT/CLR_SCI0_VARS)
0042CC 7F42CC 79 10 0E                   clr  pageID       ; SCI page identifier                                       (BASE_INIT/CLR_SCI0_VARS)
0042CF 7F42CF 79 10 0F                   clr  txcmnd       ; SCI command character identifier                          (BASE_INIT/CLR_SCI0_VARS)
0042D2 7F42D2 79 10 10                   clr  dataMSB      ; SCI data Most Significant Byte received                   (BASE_INIT/CLR_SCI0_VARS)
0042D5 7F42D5 79 10 11                   clr  dataLSB      ; SCI data Least Significant Byte received                  (BASE_INIT/CLR_SCI0_VARS)
0042D8 7F42D8 MACRO                               INIT_ADC0       ; Initialize ADC0 channels (adc0_BEEM488.s)          (BASE_INIT)
                                                                    ; program counter                                  (BASE_INIT/INIT_ADC0)
                                      ;***************************************************************************************** (BASE_INIT/INIT_ADC0)
                                      ;* - Macros -                                                                            * (BASE_INIT/INIT_ADC0)
                                      ;***************************************************************************************** (BASE_INIT/INIT_ADC0)
                                      ;***************************************************************************************** (BASE_INIT/INIT_ADC0)
                                      ; - Initialize Analog to Digital Converter (ATD0) for continuous conversions     (BASE_INIT/INIT_ADC0)
                                      ;   8.3MHz ATDCLK period = 0.00000012048 Sec.                                    (BASE_INIT/INIT_ADC0)
                                      ;   10 bit ATD Conversion period = 41 ATDCLK cycles(ref page 1219)               (BASE_INIT/INIT_ADC0)
                                      ;   Sample time per channel = 24+2 for discharge capacitor = 26 ATDCLK cycles    (BASE_INIT/INIT_ADC0)
                                      ;   Sample time for 13 channels = (41+26)x13=871 ATDCLK periods = 0.000114810 Sec. (~115uS) (BASE_INIT/INIT_ADC0)
                                      ;***************************************************************************************** (BASE_INIT/INIT_ADC0)
0042D8 7F42D8 18 03 1F FF 02 70           movw  #$1FFF,PT0AD0     ; Load Port AD0 Data Registers PT0AD0:PT1AD0         (BASE_INIT/INIT_ADC0)
                                                                  ; with %0001111111111111 (General Purpose I/Os on pins 15,14,13 (BASE_INIT/INIT_ADC0)
                                                                  ; ATD on pins 12,11,10,9,8,7,6,5,4,3,2,1,0)          (BASE_INIT/INIT_ADC0)
                                                                  ;(Registers are %00000000 out of reset)              (BASE_INIT/INIT_ADC0)
0042DE 7F42DE 18 03 00 00 02 72           movw  #$0000,DDR0AD0    ; Load Port AD0 Data Direction Registers DDR0AD0:DDR1AD0 (BASE_INIT/INIT_ADC0)
                                                                  ; with %0000000000000000 (All pins inputs)           (BASE_INIT/INIT_ADC0)
                                                                  ;(Registers are %00000000 out of reset)              (BASE_INIT/INIT_ADC0)
0042E4 7F42E4 18 03 E0 00 02 72           movw  #$E000,DDR0AD0    ; Load Port AD0 Data Direction Registers DDR0AD0:DDR1AD0 (BASE_INIT/INIT_ADC0)
                                                                  ; with %1110000000000000 (Outputs on pins 15,14,13   (BASE_INIT/INIT_ADC0)
                                                                  ; ATD on pins 12,11,10,9,8,7,6,5,4,3,2,1,0)          (BASE_INIT/INIT_ADC0)
                                                                  ;(Registers are %00000000 out of reset)              (BASE_INIT/INIT_ADC0)
0042EA 7F42EA 18 03 E0 00 02 76           movw  #$E000,PER0AD0    ; Load Port AD0 Pullup Enable Registers PER0AD0:PER1AD0 (BASE_INIT/INIT_ADC0)
                                                                  ; with %1110000000000000 (Pullups enabled on pins 15,14,13 (BASE_INIT/INIT_ADC0)
                                                                  ; Pullups disabled on pins 12,11,10,9,8,7,6,5,4,3,2,1,0) (BASE_INIT/INIT_ADC0)
                                                                  ;(Registers are %00000000 out of reset)              (BASE_INIT/INIT_ADC0)
0042F0 7F42F0 18 0B 0C 02 C0              movb  #$0C,ATD0CTL0     ; Load ATD0 Control Register 0 with %00001100        (BASE_INIT/INIT_ADC0)
                                                                  ; (wrap after converting AN12)                       (BASE_INIT/INIT_ADC0)
                                                                              ;             ^  ^                       (BASE_INIT/INIT_ADC0)
                                                                              ;    WRAP-----+--+                       (BASE_INIT/INIT_ADC0)
                                                                  ;(Register is %00001111 out of reset)                (BASE_INIT/INIT_ADC0)
0042F5 7F42F5 18 0B 30 02 C1              movb  #$30,ATD0CTL1     ; Load ATD Control Register 1 with %00110000         (BASE_INIT/INIT_ADC0)
                                                                  ; (no external trigger, 10 bit resolution,           (BASE_INIT/INIT_ADC0)
                                                                  ; discharge cap before conversion)                   (BASE_INIT/INIT_ADC0)
                                                                  ;         ^^^^^  ^                                   (BASE_INIT/INIT_ADC0)
                                                                  ;ETRIGSEL-+||||  |                                   (BASE_INIT/INIT_ADC0)
                                                                  ;    SRES--++||  |                                   (BASE_INIT/INIT_ADC0)
                                                                  ; SMP_DIS----+|  |                                   (BASE_INIT/INIT_ADC0)
                                                                  ; ETRIGCH-----+--+                                   (BASE_INIT/INIT_ADC0)
                                                                  ;(Register is %00001111 out of reset)                (BASE_INIT/INIT_ADC0)
0042FA 7F42FA 18 0B 20 02 C2              movb  #$20,ATD0CTL2    ; Load ATD Control Register 2 with %00100000          (BASE_INIT/INIT_ADC0)
                                                                 ;(no fast flag clear, continue in stop,               (BASE_INIT/INIT_ADC0)
                                                                 ; no external trigger, Sequence                       (BASE_INIT/INIT_ADC0)
                                                                 ; complete interrupt disabled,                        (BASE_INIT/INIT_ADC0)
                                                                 ; Compare interrupt disabled)                         (BASE_INIT/INIT_ADC0)
                                                                 ;          ^^^^^^^                                    (BASE_INIT/INIT_ADC0)
                                                                 ;    AFFC--+||||||                                    (BASE_INIT/INIT_ADC0)
                                                                 ; ICLKSTP---+|||||                                    (BASE_INIT/INIT_ADC0)
                                                                 ; ETRIGLE----+||||                                    (BASE_INIT/INIT_ADC0)
                                                                 ;  ETRIGP-----+|||                                    (BASE_INIT/INIT_ADC0)
                                                                 ;  ETRIGE------+||                                    (BASE_INIT/INIT_ADC0)
                                                                 ;   ASCIE-------+|                                    (BASE_INIT/INIT_ADC0)
                                                                 ;  ACMPIE--------+;                                   (BASE_INIT/INIT_ADC0)
                                                                 ;(Register is %00000000 out of reset)                 (BASE_INIT/INIT_ADC0)
0042FF 7F42FF 18 0B 82 02 C3              movb  #$82,ATD0CTL3 ; Load ATD Control Register 3 with %10000010             (BASE_INIT/INIT_ADC0)
                                                              ;(right justifed data, 16 conversions,                   (BASE_INIT/INIT_ADC0)
                                                              ; no Fifo, Finish conversion before stop in freeze)      (BASE_INIT/INIT_ADC0)
                                                              ;         ^^^^^^^^                                       (BASE_INIT/INIT_ADC0)
                                                              ;     DJM-+|||||||                                       (BASE_INIT/INIT_ADC0)
                                                              ;     S8C--+||||||                                       (BASE_INIT/INIT_ADC0)
                                                              ;     S4C---+|||||                                       (BASE_INIT/INIT_ADC0)
                                                              ;     S2C----+||||                                       (BASE_INIT/INIT_ADC0)
                                                              ;     S1C-----+|||                                       (BASE_INIT/INIT_ADC0)
                                                              ;    FIFO------+||                                       (BASE_INIT/INIT_ADC0)
                                                              ;     FRZ-------++                                       (BASE_INIT/INIT_ADC0)
                                                              ;(Register is %00100000 out of reset)                    (BASE_INIT/INIT_ADC0)
004304 7F4304 18 0B E2 02 C4              movb  #$E2,ATD0CTL4 ; Load ATD Control Register 4 with %11100010             (BASE_INIT/INIT_ADC0)
                                                              ;(24 cycle sample time, prescale = 2                     (BASE_INIT/INIT_ADC0)
                                                              ; for 8.3MHz ATDCLK)                                     (BASE_INIT/INIT_ADC0)
                                                              ;         ^ ^^   ^                                       (BASE_INIT/INIT_ADC0)
                                                              ;     SMP-+-+|   |                                       (BASE_INIT/INIT_ADC0)
                                                              ;     PRS----+---+                                       (BASE_INIT/INIT_ADC0)
                                                              ;(Register is %00000101 out of reset)                    (BASE_INIT/INIT_ADC0)
004309 7F4309 18 03 E0 00 02 CC           movw  #$E000,ATD0DIENH  ; Load ATD0 Input Enable Register Hi byte and Lo byte with (BASE_INIT/INIT_ADC0)
00430F 7F430F MACRO                               INIT_GPIO       ; Initialize GPIOs (gpio_BEEM488.s)                  (BASE_INIT)
                                                                    ; program counter                                  (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ;* - Macros -                                                                            * (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ;*    BPEM488 pin assignments                                                            * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;*    Port AD:                                                                           * (BASE_INIT/INIT_GPIO)
                                      ;*     PAD00 - (batAdc)     (analog, no pull) hard wired Bat volts ADC                   * (BASE_INIT/INIT_GPIO)
                                      ;*     PAD01 - (cltAdc)     (analog, no pull) temperature sensor ADC                     * (BASE_INIT/INIT_GPIO)
                                      ;*     PAD02 - (matAdc)     (analog, no pull) temperature sensor ADC                     * (BASE_INIT/INIT_GPIO)
                                      ;*     PAD03 - (PAD03inAdc) (analog, no pull) temperature sensor ADC  spare              * (BASE_INIT/INIT_GPIO)
                                      ;*     PAD04 - (mapAdc)     (analog, no pull) general purpose ADC                        * (BASE_INIT/INIT_GPIO)
                                      ;*     PAD05 - (tpsAdc)     (analog, no pull) general purpose ADC                        * (BASE_INIT/INIT_GPIO)
                                      ;*     PAD06 - (egoAdc1)(EGO)  (analog, no pull) general purpose ADC                     * (BASE_INIT/INIT_GPIO)
                                      ;*     PAD07 - (baroAdc)    (analog, no pull) general purpose ADC                        * (BASE_INIT/INIT_GPIO)
                                      ;*     PAD08 - (eopAdc)     (analog, no pull) general purpose ADC                        * (BASE_INIT/INIT_GPIO)
                                      ;*     PAD09 - (efpAdc)     (analog, no pull) general purpose ADC                        * (BASE_INIT/INIT_GPIO)
                                      ;*     PAD10 - (itrmAdc)    (analog, no pull) general purpose ADC                        * (BASE_INIT/INIT_GPIO)
                                      ;*     PAD11 - (ftrmAdc)    (analog, no pull) general purpose ADC                        * (BASE_INIT/INIT_GPIO)
                                      ;*     PAD12 - (egoAdc2)(PAD12) (analog, no pull) general purpose ADC                    * (BASE_INIT/INIT_GPIO)
                                      ;*     PAD13 - Not used     (GPIO input, pull-up)                                        * (BASE_INIT/INIT_GPIO)
                                      ;*     PAD14 - Not used     (GPIO input, pull-up)                                        * (BASE_INIT/INIT_GPIO)
                                      ;*     PAD15 - Not used     (GPIO input, pull-up)                                        * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;*    Port A:                                                                            * (BASE_INIT/INIT_GPIO)
                                      ;*     PA0 - LoadEEEM       (input, pull-up, active low) momentary contact               * (BASE_INIT/INIT_GPIO)
                                      ;*     PA1 - Itrmen         (input, pull-up, active low) maintained contact              * (BASE_INIT/INIT_GPIO)
                                      ;*     PA2 - Ftrmen         (input, pull-up, active low) maintained contact              * (BASE_INIT/INIT_GPIO)
                                      ;*     PA3 - AudAlrmSil     (input, pull-up, active low) maintained contact              * (BASE_INIT/INIT_GPIO)
                                      ;*     PA4 - OFCen(PA4)     (input, pull-up, active low) momentar contact                * (BASE_INIT/INIT_GPIO)
                                      ;*     PA5 - OFCdis(PA5)    (input, pull-up, active low) momentary contact               * (BASE_INIT/INIT_GPIO)
                                      ;*     PA6 - PA6in          (input, pull-up, active low) maintained contact spare        * (BASE_INIT/INIT_GPIO)
                                      ;*     PA7 - Not used       (input, pull-up)                                             * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;*    Port B:                                                                            * (BASE_INIT/INIT_GPIO)
                                      ;*     PB0 - FuelPump             (output, active high, initialize low)                  * (BASE_INIT/INIT_GPIO)
                                      ;*     PB1 - ASDRelay             (output, active high, initialize low)                  * (BASE_INIT/INIT_GPIO)
                                      ;*     PB2 - EngAlarm             (output, active high, initialize low)                  * (BASE_INIT/INIT_GPIO)
                                      ;*     PB3 - AIOT                 (output, active high, initialize low)                  * (BASE_INIT/INIT_GPIO)
                                      ;*     PB4 - Tach out             (output, active high, initialize low)                  * (BASE_INIT/INIT_GPIO)
                                      ;*     PB5 - PB5out               (output, active high, initialize low) spare            * (BASE_INIT/INIT_GPIO)
                                      ;*     PB6 - PB6out               (output, active high, initialize low) spare            * (BASE_INIT/INIT_GPIO)
                                      ;*     PB7 - Not used             (output, initialize low)                               * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;*    Port C: - Not Available in 112 LQFP                                                * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;*    Port D: - Not Available in 112 LQFP                                                * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;*    Port E:                                                                            * (BASE_INIT/INIT_GPIO)
                                      ;*     PE0 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PE1 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PE2 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PE3 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PE4 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PE5 -(MODA)      (input, pull-up) (hard wired to ground)                          * (BASE_INIT/INIT_GPIO)
                                      ;*     PE6 -(MODB)      (input, pull-up) (hard wired to ground)                          * (BASE_INIT/INIT_GPIO)
                                      ;*     PE7 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;*    Port F: - Not Available in 112 LQFP                                                * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;*    Port H:                                                                            * (BASE_INIT/INIT_GPIO)
                                      ;*     PH0 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PH1 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PH2 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PH3 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PH4 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PH5 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PH6 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PH7 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;*    Port J:                                                                            * (BASE_INIT/INIT_GPIO)
                                      ;*     PJ0 - Not used                    (input, pull-up)                                * (BASE_INIT/INIT_GPIO)
                                      ;*     PJ1 - Not used                    (input, pull-up)                                * (BASE_INIT/INIT_GPIO)
                                      ;*     PJ2 - Not Available in 112 LQFP                                                   * (BASE_INIT/INIT_GPIO)
                                      ;*     PJ3 - Not Available in 112 LQFP                                                   * (BASE_INIT/INIT_GPIO)
                                      ;*     PJ4 - Not Available in 112 LQFP                                                   * (BASE_INIT/INIT_GPIO)
                                      ;*     PJ5 - Not Available in 112 LQFP                                                   * (BASE_INIT/INIT_GPIO)
                                      ;*     PJ6 - Not used                    (input, pull-up)                                * (BASE_INIT/INIT_GPIO)
                                      ;*     PJ7 - Not used                    (input, pull-up)                                * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;*    Port K:                                                                            * (BASE_INIT/INIT_GPIO)
                                      ;*     PK0 - LOPalrm                   (output, active high, initialize low)             * (BASE_INIT/INIT_GPIO)
                                      ;*     PK1 - HOTalrm                   (output, active high, initialize low)  N/C        * (BASE_INIT/INIT_GPIO)
                                      ;*     PK2 - HETalrm                   (output, active high, initialize low)             * (BASE_INIT/INIT_GPIO)
                                      ;*     PK3 - HEGTalrm                  (output, active high, initialize low)  N/C        * (BASE_INIT/INIT_GPIO)
                                      ;*     PK4 - HFTalrm                   (output, active high, initialize low)  N/C        * (BASE_INIT/INIT_GPIO)
                                      ;*     PK5 - LFPalrm                   (output, active high, initialize low)             * (BASE_INIT/INIT_GPIO)
                                      ;*     PK6 - Not Available in 112 LQFP                                                   * (BASE_INIT/INIT_GPIO)
                                      ;*     PK7 - HFPalrm                   (output, active high, initialize low)             * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;*    Port M:                                                                            * (BASE_INIT/INIT_GPIO)
                                      ;*     PM0 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PM1 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PM2 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PM3 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PM4 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PM5 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PM6 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*     PM7 - Not used   (input, pull-up)                                                 * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;*    Port L: - Not Available in 112 LQFP                                                * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;*    Port P: - (Timer module)                                                           * (BASE_INIT/INIT_GPIO)
                                      ;*     PP0 - TIM1 OC0 Inj1 (1&10)   (output, active high, initialize low)                * (BASE_INIT/INIT_GPIO)
                                      ;*     PP1 - TIM1 OC1 Inj2 (9&4)    (output, active high, initialize low)                * (BASE_INIT/INIT_GPIO)
                                      ;*     PP2 - TIM1 OC2 Inj3 (3&6)    (output, active high, initialize low)                * (BASE_INIT/INIT_GPIO)
                                      ;*     PP3 - TIM1 OC3 Inj4 (5&8)    (output, active high, initialize low)                * (BASE_INIT/INIT_GPIO)
                                      ;*     PP4 - TIM1 OC4 Inj5 (7&2)    (output, active high, initialize low)                * (BASE_INIT/INIT_GPIO)
                                      ;*     PP5 - TIM1 OC5 PP5out        (output, initialize low, spare)                      * (BASE_INIT/INIT_GPIO)
                                      ;*     PP6 - Not used               (output, initialize low)                             * (BASE_INIT/INIT_GPIO)
                                      ;*     PP7 - Not used               (output, initialize low)                             * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;*    Port R: - Not Available in 112 LQFP                                                * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;*    Port S:                                                                            * (BASE_INIT/INIT_GPIO)
                                      ;*     PS0 - SCI0 RXD              (input, pull-up)                                      * (BASE_INIT/INIT_GPIO)
                                      ;*     PS1 - SCI0 TXD              (input, pull-up)(SCI0 init will change to output)     * (BASE_INIT/INIT_GPIO)
                                      ;*     PS2 - Not used              (input, pull-up)                                      * (BASE_INIT/INIT_GPIO)
                                      ;*     PS3 - Not used              (input, pull-up)                                      * (BASE_INIT/INIT_GPIO)
                                      ;*     PS4 - Not used              (input, pull-up)                                      * (BASE_INIT/INIT_GPIO)
                                      ;*     PS5 - Not used              (input, pull-up)                                      * (BASE_INIT/INIT_GPIO)
                                      ;*     PS6 - Not used              (input, pull-up)                                      * (BASE_INIT/INIT_GPIO)
                                      ;*     PS7 - Not used              (input, pull-up)                                      * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;*    Port T: (Enhanced Capture Timer module)                                            * (BASE_INIT/INIT_GPIO)
                                      ;*     PT0 - IOC0 - CMP                 (input, pull-down, active high) gear tooth sens  * (BASE_INIT/INIT_GPIO)
                                      ;*     PT1 - IOC1 - CKP                 (input, pull-down, active high) gear tooth sens  * (BASE_INIT/INIT_GPIO)
                                      ;*     PT2 - IOC2 - Vspd                (input, pull-down, active high) gear tooth sens  * (BASE_INIT/INIT_GPIO)
                                      ;*     PT3 - IOC3 - Ign1 (1&6)          (output, active high, initialize low)            * (BASE_INIT/INIT_GPIO)
                                      ;*     PT4 - IOC4 - Ign2 (10&5)         (output, active high, initialize low)            * (BASE_INIT/INIT_GPIO)
                                      ;*     PT5 - IOC5 - Ign3 (9&8)          (output, active high, initialize low)            * (BASE_INIT/INIT_GPIO)
                                      ;*     PT6 - IOC6 - Ign4 (4&7)          (output, active high, initialize low)            * (BASE_INIT/INIT_GPIO)
                                      ;*     PT7 - IOC7 - Ign5 (3&2)          (output, active high, initialize low)            * (BASE_INIT/INIT_GPIO)
                                      ;*                                                                                       * (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ;*    This Macro initializes all GPIO ports for the BPEM488 project                      * (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ;   Note! ADC0 is initialized in adc0_BPEM488.s                                  (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ; - Initialize Port A. General purpose I/Os. All pins inputs - Page 109          (BASE_INIT/INIT_GPIO)
                                      ;   (pull-ups enabled at the end of this macro)                                  (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
00430F 7F430F 79 00 02                    clr   DDRA        ; Load %00000000 into Port A Data Direction                (BASE_INIT/INIT_GPIO)
                                                            ; Register(all pins inputs)                                (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ; - Initialize Port B. General purpose I/Os. all pins outputs - Page 109, 108    (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
004312 7F4312 18 0B FF 00 03              movb  #$FF,DDRB   ; Load %11111111 into Port B Data                          (BASE_INIT/INIT_GPIO)
                                                            ; Direction Register (all pins outputs)                    (BASE_INIT/INIT_GPIO)
004317 7F4317 18 0B 00 00 01              movb  #$00,PORTB  ; Load %00000000 into Port B Data                          (BASE_INIT/INIT_GPIO)
                                                            ; Register (initialize all pin states low)                 (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ; - Initialize Port E. General purpose I/Os. Not used, all pins inputs - Page 114 (BASE_INIT/INIT_GPIO)
                                      ;   (pull-ups enabled at the end of this macro)                                  (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
00431C 7F431C 79 00 09                    clr   DDRE        ; Load %00000000 into Port E Data                          (BASE_INIT/INIT_GPIO)
                                                            ; Direction Register (all pins inputs)                     (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ; - Initialize Port H. General purpose I/Os. Not used, all pins inputs - Page 144, 147 (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
00431F 7F431F 79 02 62                    clr   DDRH        ; Load %00000000 into Port H Data Direction                (BASE_INIT/INIT_GPIO)
                                                            ; Register(all pins inputs)                                (BASE_INIT/INIT_GPIO)
004322 7F4322 18 03 FF 00 02 64           movw #$FF00,PERH  ; Load Port H Pull Device Enable                           (BASE_INIT/INIT_GPIO)
                                                            ; Register and Port H Polarity Select                      (BASE_INIT/INIT_GPIO)
                                                            ; Register with %1111111100000000                          (BASE_INIT/INIT_GPIO)
                                                            ; (pull-ups on all pins)                                   (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ; - Initialize Port J. General purpose I/Os.Not used, all pins inputs - Page 150, 153 (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
004328 7F4328 79 02 6A                    clr   DDRJ        ; Load %00000000 into Port J Data Direction                (BASE_INIT/INIT_GPIO)
                                                            ; Register(all pins inputs)                                (BASE_INIT/INIT_GPIO)
00432B 7F432B 18 03 FF 00 00 2C           movw #$FF00,PERJ  ; Load Port J Pull Device Enable                           (BASE_INIT/INIT_GPIO)
                                                            ; Register and Port J Polarity Select                      (BASE_INIT/INIT_GPIO)
                                                            ; Register with %1111111100000000                          (BASE_INIT/INIT_GPIO)
                                                            ; (pull-ups on all pins)                                   (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ; - Initialize Port K. General purpose I/Os. All pins outputs, initialize low - Page 120 (BASE_INIT/INIT_GPIO)
                                      ;   NOTE! - PK6 not available in 112 pin package.                                (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
004331 7F4331 18 0B FF 00 33              movb  #$FF,DDRK   ; Load %11111111 into Port K Data                          (BASE_INIT/INIT_GPIO)
                                                            ; Direction Register (all pins outputs)                    (BASE_INIT/INIT_GPIO)
004336 7F4336 18 0B 00 00 32              movb  #$00,PORTK  ; Load %00000000 into Port K Data                          (BASE_INIT/INIT_GPIO)
                                                            ; Register (initialize all pin states low)                 (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ; - Initialize Port M. General purpose I/Os. Not used, all pins inputs -         (BASE_INIT/INIT_GPIO)
                                      ;   Page 132, 134, 135                                                           (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
00433B 7F433B 79 02 52                    clr   DDRM        ; Load %00000000 into Port M Data Direction                (BASE_INIT/INIT_GPIO)
                                                            ; Register(all pins inputs)                                (BASE_INIT/INIT_GPIO)
00433E 7F433E 18 03 FF 00 02 54           movw #$FF00,PERM  ; Load Port M Pull Device Enable                           (BASE_INIT/INIT_GPIO)
                                                            ; Register and Port M Polarity Select                      (BASE_INIT/INIT_GPIO)
                                                            ; Register with %1111111100000000                          (BASE_INIT/INIT_GPIO)
                                                            ; (pull-ups on all pins)                                   (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ; - Initialize Port P. General purpose I/Os. Fuel Injector Control TIM1 OC0 through (BASE_INIT/INIT_GPIO)
                                      ;   OC4, OC5 Tach out, GPIO outputs pins 6 and 7                                 (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
004344 7F4344 18 0B FF 02 5A              movb  #$FF,DDRP   ; Load %11111111 into Port P Data                          (BASE_INIT/INIT_GPIO)
                                                            ; Direction Register (all pins outputs)                    (BASE_INIT/INIT_GPIO)
004349 7F4349 18 0B 00 02 58              movb  #$00,PTP    ; Load %00000000 into Port P Data                          (BASE_INIT/INIT_GPIO)
                                                            ; Register (initialize all pin states low)                 (BASE_INIT/INIT_GPIO)
00434E 7F434E 18 0B 3F 03 6F              movb #$3F,PTRRR   ; Load Port R Routing Register with %00111111 (TIM1 OC channels (BASE_INIT/INIT_GPIO)
                                                            ; available on PP5,4,3,2,1,0                               (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ;*     PP0 - TIM1 OC0 Inj1 (1&10)   (output, active high, initialize low)                * (BASE_INIT/INIT_GPIO)
                                      ;*     PP1 - TIM1 OC1 Inj2 (9&4)    (output, active high, initialize low)                * (BASE_INIT/INIT_GPIO)
                                      ;*     PP2 - TIM1 OC2 Inj3 (3&6)    (output, active high, initialize low)                * (BASE_INIT/INIT_GPIO)
                                      ;*     PP3 - TIM1 OC3 Inj4 (5&8)    (output, active high, initialize low)                * (BASE_INIT/INIT_GPIO)
                                      ;*     PP4 - TIM1 OC4 Inj5 (7&2)    (output, active high, initialize low)                * (BASE_INIT/INIT_GPIO)
                                      ;*     PP5 - TIM1 OC5 PP5out        (output, initialize low, spare)                      * (BASE_INIT/INIT_GPIO)
                                      ;*     PP6 - Not used               (output, initialize low)                             * (BASE_INIT/INIT_GPIO)
                                      ;*     PP7 - Not used               (output, initialize low)                             * (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ;#macro INIT_TIM, 0                                                              (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;    movb #$FF,TIM_TIOS  ;(TIM_TIOS equ $03D0)                                   (BASE_INIT/INIT_GPIO)
                                      ;                        ; Load Timer Input capture/Output compare Select register with (BASE_INIT/INIT_GPIO)
                                      ;                        ; %11111111 (All channels output compare)               (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;    movb #$98,TIM_TSCR1 ; (TIM_TSCR1 equ $03D6)                                 (BASE_INIT/INIT_GPIO)
                                      ;                        ; Load TIM_TSCR1 with %10011000 (timer enabled, no stop in wait, (BASE_INIT/INIT_GPIO)
                                      ;                        ; no stop in freeze, fast flag clear, precision timer)  (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;    movb #$FF,TIM_TIE   ; Load TIM_TIE (Timer Interrupt Enable Register)        (BASE_INIT/INIT_GPIO)
                                      ;                        ; with %11111111 (enable interrupts all channels)       (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;    movb #$07,TIM_TSCR2 ; (TIM_TSCR2 equ $03DD)(Load TIM_TSCR2 with %00000111   (BASE_INIT/INIT_GPIO)
                                      ;                        ; (timer overflow interrupt disabled,timer counter      (BASE_INIT/INIT_GPIO)
                                      ;                        ; reset disabled, prescale divide by 128)               (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;;*    movb #$7F,TIM_PTPSR ; (TIM_PTPSR equ $03FE) Load TIM_PTPSR with %01111111 (BASE_INIT/INIT_GPIO)
                                      ;                        ; (prescale 128, 2.56us resolution,                     (BASE_INIT/INIT_GPIO)
                                      ;                        ; max period 167.7696ms)(Time base for run mode)        (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;    movb #$FF,TIM_PTPSR ; (TIM_PTPSR equ $03FE)(Load TIM_PTPSR with %11111111   (BASE_INIT/INIT_GPIO)
                                      ;                        ; (prescale 256, 5.12us resolution,                     (BASE_INIT/INIT_GPIO)
                                      ;                        ; max period 335.5ms) (time base for prime or crank modes) (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;#emac                                                                           (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ;* - NOTE! TIM1 is initialized in tim_BEEM488.s                                  (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ; - Initialize Port S. General purpose I/Os. SCI0 RS232 RXD input Pin 0, TXD output pin 1, (BASE_INIT/INIT_GPIO)
                                      ;   all others not used, set as inputs - Page 126, 128                           (BASE_INIT/INIT_GPIO)
                                      ;   Note! When SCI0 is enabled Pins 0 and 1 are under SCI control                (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
004353 7F4353 79 02 4A                    clr   DDRS        ; Load %00000000 into Port S Data Direction                (BASE_INIT/INIT_GPIO)
                                                            ; Register(all pins inputs)                                (BASE_INIT/INIT_GPIO)
004356 7F4356 18 03 FF 00 02 4C           movw #$FF00,PERS  ; Load Port S Pull Device Enable                           (BASE_INIT/INIT_GPIO)
                                                            ; Register and Port S Polarity Select                      (BASE_INIT/INIT_GPIO)
                                                            ; Register with %1111111100000000                          (BASE_INIT/INIT_GPIO)
                                                            ; (pull-ups on all pins)                                   (BASE_INIT/INIT_GPIO)
                                      ;;*************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ;; - Initialize the SCI0 interface for 115,200 Baud Rate                         (BASE_INIT/INIT_GPIO)
                                      ;;   When IREN = 0, SCI Baud Rate = SCI bus clock / 16 x SBR[12-0]               (BASE_INIT/INIT_GPIO)
                                      ;;   or SCI0BDH:SCI0BDL = (Bus Freq/16)/115200 = 21.70                           (BASE_INIT/INIT_GPIO)
                                      ;;   27.1 rounded = 27 = $1B                                                     (BASE_INIT/INIT_GPIO)
                                      ;;*************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;#macro INIT_SCI0, 0                                                             (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;    movb  #$00,SCI0BDH  ; Load SCI0BDH with %01010100, (IR disabled, 1/16 narrow pulse (BASE_INIT/INIT_GPIO)
                                      ;                        ; width, no prescale Hi Byte)                           (BASE_INIT/INIT_GPIO)
                                      ;    movb  #$1B,SCI0BDL  ; Load SCI0BDL with decimal 27, prescale Lo byte        (BASE_INIT/INIT_GPIO)
                                      ;                        ;(115,200 Baud Rate)                                    (BASE_INIT/INIT_GPIO)
                                      ;    clr   SCI0CR1       ; Load SCI0CR1 with %00000000(Normal operation, SCI enabled (BASE_INIT/INIT_GPIO)
                                      ;                        ; in wait mode. Internal receiver source. One start bit,8 data (BASE_INIT/INIT_GPIO)
                                      ;                        ; bits, one stop bit. Idle line wakeup. No parity.)     (BASE_INIT/INIT_GPIO)
                                      ;    movb  #$24,SCI0CR2  ; Load SCI0CR2 with %00100100(TDRE interrupts disabled. TCIE (BASE_INIT/INIT_GPIO)
                                      ;                        ; interrpts disabled. RIE interrupts enabled.IDLE interrupts (BASE_INIT/INIT_GPIO)
                                      ;                        ; disabled. Transmitter disabled, Receiver enabled, Normal (BASE_INIT/INIT_GPIO)
                                      ;                        ; operation, No break characters)                       (BASE_INIT/INIT_GPIO)
                                      ;                        ; (Transmitter and interrupt get enabled in SCI0_ISR)   (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;#emac                                                                           (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ;* - NOTE! SCI0 is initialized in sci0_BPEM488.s                                 (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ; - Initialize Port T. Enhanced Capture Channels IOC7-IOC0. pg 527               (BASE_INIT/INIT_GPIO)
                                      ;   Camshaft position, Crankshaft position and Vehicle Speed inputs              (BASE_INIT/INIT_GPIO)
                                      ;   Ignition control outputs                                                     (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
00435C 7F435C 18 03 FF 00 02 42           movw  #$FF00,DDRT   ; Load Port T Data Direction Register and                (BASE_INIT/INIT_GPIO)
                                                              ; Port T Reduced Drive Register with                     (BASE_INIT/INIT_GPIO)
                                                              ; %1111_0000_0000_0000                                   (BASE_INIT/INIT_GPIO)
                                                              ; Outputs on PT7,6,5,4,3 Inputs on PT2,1,0               (BASE_INIT/INIT_GPIO)
                                                              ; full drive on all pins                                 (BASE_INIT/INIT_GPIO)
004362 7F4362 18 03 07 07 02 44           movw  #$0707,PERT   ; Load Port T Pull Device Register and                   (BASE_INIT/INIT_GPIO)
                                                              ; Port T Polarity Select Register with                   (BASE_INIT/INIT_GPIO)
                                                              ; %0000_0111_0000_0111                                   (BASE_INIT/INIT_GPIO)
                                                              ; (pull device enabled on PT2,1,0                        (BASE_INIT/INIT_GPIO)
                                                              ; Disabled on PT7,6,5,4,3 Pull down on                   (BASE_INIT/INIT_GPIO)
                                                              ; PT72,1,0                                               (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ;*     PT0 - IOC0 - Camshaft Position   (input, pull-down, active high) gear tooth sens  * (BASE_INIT/INIT_GPIO)
                                      ;*     PT1 - IOC1 - Crankshaft Position (input, pull-down, active high) gear tooth sens  * (BASE_INIT/INIT_GPIO)
                                      ;*     PT2 - IOC2 - Vehicle Speed       (input, pull-down, active high) gear tooth sens  * (BASE_INIT/INIT_GPIO)
                                      ;*     PT3 - IOC3 - Ign1 (1&6)          (output, active high, initialize low)            * (BASE_INIT/INIT_GPIO)
                                      ;*     PT4 - IOC4 - Ign2 (10&5)         (output, active high, initialize low)            * (BASE_INIT/INIT_GPIO)
                                      ;*     PT5 - IOC5 - Ign3 (9&8)          (output, active high, initialize low)            * (BASE_INIT/INIT_GPIO)
                                      ;*     PT6 - IOC6 - Ign4 (4&7)          (output, active high, initialize low)            * (BASE_INIT/INIT_GPIO)
                                      ;*     PT7 - IOC7 - Ign5 (3&2)          (output, active high, initialize low)            * (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;#macro INIT_ECT, 0                                                              (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;    movb #$F8,ECT_TIOS  ; Load Timer Input capture/Output                       (BASE_INIT/INIT_GPIO)
                                      ;                        ; compare Select register with                          (BASE_INIT/INIT_GPIO)
                                      ;                        ; %11111000 Output Compare PT7,6,5,4,3                  (BASE_INIT/INIT_GPIO)
                                      ;                        ; Input Capture PT2,1,0                                 (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;    movb #$98,ECT_TSCR1 ; Load ECT_TSCR1 with %10011000                         (BASE_INIT/INIT_GPIO)
                                      ;                        ;(timer enabled, no stop in wait,                       (BASE_INIT/INIT_GPIO)
                                      ;                        ; no stop in freeze, fast flag clear,                   (BASE_INIT/INIT_GPIO)
                                      ;                        ; precision timer)                                      (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;    movb  #$FF,ECT_TIE  ; Load Timer Interrupt Enable Register                  (BASE_INIT/INIT_GPIO)
                                      ;                        ; with %11111111 (interrupts enabled                    (BASE_INIT/INIT_GPIO)
                                      ;                        ; Ch7,6,5,4,3,2,1,0)                                    (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;    movb #$07,ECT_TSCR2 ; Load ECT_TSCR2 with %00000111                         (BASE_INIT/INIT_GPIO)
                                      ;                        ; (timer overflow interrupt disabled,                   (BASE_INIT/INIT_GPIO)
                                      ;                        ; timer counter reset disabled,                         (BASE_INIT/INIT_GPIO)
                                      ;                        ; prescale divide by 128 for legacy timer only)         (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;;*    movb #$0F,ECT_PTPSR ; Load ECT_PTPSR with %00001111                       (BASE_INIT/INIT_GPIO)
                                      ;                        ; (prescale 16, 0.32us resolution,                      (BASE_INIT/INIT_GPIO)
                                      ;                        ; max period 20.9712ms)                                 (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;;*    movb #$1F,ECT_PTPSR ; Load ECT_PTPSR with %00011111                       (BASE_INIT/INIT_GPIO)
                                      ;                        ; (prescale 32, 0.64us resolution,                      (BASE_INIT/INIT_GPIO)
                                      ;                        ; max period 41.94248ms)                                (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;;*    movb #$3F,ECT_PTPSR ; Load ECT_PTPSR with %00111111                       (BASE_INIT/INIT_GPIO)
                                      ;                        ; (prescale 64, 1.28us resolution,                      (BASE_INIT/INIT_GPIO)
                                      ;                        ; max period 83.884ms)                                  (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;;*    movb #$7F,ECT_PTPSR ; Load ECT_PTPSR with %01111111  (time base for run mode) (BASE_INIT/INIT_GPIO)
                                      ;                        ; (prescale 128, 2.56us resolution,                     (BASE_INIT/INIT_GPIO)
                                      ;                        ; max period 167.7696ms)                                (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;    movb #$FF,ECT_PTPSR ; Load ECT_PTPSR with %11111111 (time base for prime or crank modes) (BASE_INIT/INIT_GPIO)
                                      ;                        ; (prescale 256, 5.12us resolution,                     (BASE_INIT/INIT_GPIO)
                                      ;                        ; max period 335.5ms)                                   (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;    movb #$00,ECT_TCTL3 ; Load ECT_TCTL3 with %00000000                         (BASE_INIT/INIT_GPIO)
                                      ;                        ; (capture disabled Ch7,6,5,4)                          (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;    movb #$15,ECT_TCTL4 ; Load ECT_TCTL4 with %00010101 (Capture disabled Ch3   (BASE_INIT/INIT_GPIO)
                                      ;                        ; rising edge capture Ch2,1,0)                          (BASE_INIT/INIT_GPIO)
                                      ;                                                                                (BASE_INIT/INIT_GPIO)
                                      ;#emac                                                                           (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ; - NOTE! ECT is initialized in ect_BEEM.s                                       (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
                                      ; - Set pull ups for BKGD, Port E and Port A                                     (BASE_INIT/INIT_GPIO)
                                      ;***************************************************************************************** (BASE_INIT/INIT_GPIO)
004368 7F4368 18 0B 51 00 0C              movb  #$51,PUCR   ; Load %01010001 into Pull Up Control                      (BASE_INIT/INIT_GPIO)
00436D 7F436D MACRO                                           INIT_ECT        ; Initialize Enhanced Captuer Timers (ect_BEEM488.s) (BASE_INIT)
                                      ;***************************************************************************************** (BASE_INIT/INIT_ECT)
                                      ; - Initialize Port T. Enhanced Capture Channels IOC7-IOC0. pg 527               (BASE_INIT/INIT_ECT)
                                      ;*     PT0 - IOC0 - Camshaft Position   (input, pull-down, active high) gear tooth sens  * (BASE_INIT/INIT_ECT)
                                      ;*     PT1 - IOC1 - Crankshaft Position (input, pull-down, active high) gear tooth sens  * (BASE_INIT/INIT_ECT)
                                      ;*     PT2 - IOC2 - Vehicle Speed       (input, pull-down, active high) gear tooth sens  * (BASE_INIT/INIT_ECT)
                                      ;*     PT3 - IOC3 - Ign1 (1&6)          (output, active high, initialize low)            * (BASE_INIT/INIT_ECT)
                                      ;*     PT4 - IOC4 - Ign2 (10&5)         (output, active high, initialize low)            * (BASE_INIT/INIT_ECT)
                                      ;*     PT5 - IOC5 - Ign3 (9&8)          (output, active high, initialize low)            * (BASE_INIT/INIT_ECT)
                                      ;*     PT6 - IOC6 - Ign4 (4&7)          (output, active high, initialize low)            * (BASE_INIT/INIT_ECT)
                                      ;*     PT7 - IOC7 - Ign5 (3&2)          (output, active high, initialize low)            * (BASE_INIT/INIT_ECT)
                                      ;***************************************************************************************** (BASE_INIT/INIT_ECT)
                                      ;***************************************************************************************** (BASE_INIT/INIT_ECT)
                                      ;* - The crank trigger wheel on the Dodge V10 has 5 pairs of two notches. Each notch is (BASE_INIT/INIT_ECT)
                                      ;    3 degrees wide. The falling edges of the notch pairs are 18 degrees apart and the (BASE_INIT/INIT_ECT)
                                      ;    pairs are 54 degrees apart. Any 3 consecutive notches will cover 72 degrees. The (BASE_INIT/INIT_ECT)
                                      ;    time period of 72 degrees can be used as a base to calculate RPM, ignition and (BASE_INIT/INIT_ECT)
                                      ;    injection timing. In order to determine the best timer rate it has to be able to (BASE_INIT/INIT_ECT)
                                      ;    accurately determine the period between notches at cranking speeds before rolling (BASE_INIT/INIT_ECT)
                                      ;    over and still have good resolution at the highest expected engine speed. Rather (BASE_INIT/INIT_ECT)
                                      ;    than make this compromise the decision was made to use the 5.12uS time base in crank (BASE_INIT/INIT_ECT)
                                      ;    mode and the 2.56uS time base in run mode. The interrupts for the crankshaft and (BASE_INIT/INIT_ECT)
                                      ;    camshaft sensors are handled in the state_BPEM488.s module. It is here that that (BASE_INIT/INIT_ECT)
                                      ;    the 72 degree period is calculated and the determination of crank mode and run mode (BASE_INIT/INIT_ECT)
                                      ;    are made.                                                                   (BASE_INIT/INIT_ECT)
                                      ;                                                                                (BASE_INIT/INIT_ECT)
                                      ;    5000RPM = 83.333Hz = .012Sec period / 5 =.0024Sec per 72 degrees            (BASE_INIT/INIT_ECT)
                                      ;                                                                                (BASE_INIT/INIT_ECT)
                                      ;    A prescale of 256 results in a 5.12uS clock tick with a maximum period of 335.5392mS (BASE_INIT/INIT_ECT)
                                      ;    Lowest cranking speed can be:                                               (BASE_INIT/INIT_ECT)
                                      ;    .3355392 * 5 = 1.677696Sec = .596Hz * 60 = 35.76RPM                         (BASE_INIT/INIT_ECT)
                                      ;    5000RPM .0024/.00000512 = 468.75 5000/468.75 = 10.666 RPM resolution        (BASE_INIT/INIT_ECT)
                                      ;                                                                                (BASE_INIT/INIT_ECT)
                                      ;    A prescale of 128 results in a 2.56uS clock tick with a maximum period of 167.7696mS (BASE_INIT/INIT_ECT)
                                      ;    Lowest cranking speed can be:                                               (BASE_INIT/INIT_ECT)
                                      ;    .1677696 * 5 = .838848Sec = 1.192111086Hz * 60 = 71.53RPM                   (BASE_INIT/INIT_ECT)
                                      ;    5000RPM .0024/.00000256 = 937.5 5000/937.5 = 5.333 RPM resolution           (BASE_INIT/INIT_ECT)
                                      ;                                                                                (BASE_INIT/INIT_ECT)
                                      ;***************************************************************************************** (BASE_INIT/INIT_ECT)
00436D 7F436D 18 0B F8 00 40               movb #$F8,ECT_TIOS  ; Load Timer Input capture/Output                       (BASE_INIT/INIT_ECT)
                                                               ; compare Select register with                          (BASE_INIT/INIT_ECT)
                                                              ; %11111000 Output Compare PT7,6,5,4,3                   (BASE_INIT/INIT_ECT)
                                                              ; Input Capture PT2,1,0                                  (BASE_INIT/INIT_ECT)
004372 7F4372 18 0B 98 00 46              movb #$98,ECT_TSCR1 ; Load ECT_TSCR1 with %10011000                          (BASE_INIT/INIT_ECT)
                                                              ;(timer enabled, no stop in wait,                        (BASE_INIT/INIT_ECT)
                                                              ; no stop in freeze, fast flag clear,                    (BASE_INIT/INIT_ECT)
                                                              ; precision timer)                                       (BASE_INIT/INIT_ECT)
004377 7F4377 18 0B FF 00 4C              movb  #$FF,ECT_TIE  ; Load Timer Interrupt Enable Register                   (BASE_INIT/INIT_ECT)
                                                              ; with %11111111 (interrupts enabled                     (BASE_INIT/INIT_ECT)
                                                              ; Ch7,6,5,4,3,2,1,0)                                     (BASE_INIT/INIT_ECT)
00437C 7F437C 18 0B 07 00 4D              movb #$07,ECT_TSCR2 ; Load ECT_TSCR2 with %00000111                          (BASE_INIT/INIT_ECT)
                                                              ; (timer overflow interrupt disabled,                    (BASE_INIT/INIT_ECT)
                                                              ; timer counter reset disabled,                          (BASE_INIT/INIT_ECT)
                                                              ; prescale divide by 128 for legacy timer only)          (BASE_INIT/INIT_ECT)
                                      ;*    movb #$0F,ECT_PTPSR ; Load ECT_PTPSR with %00001111                        (BASE_INIT/INIT_ECT)
                                                              ; (prescale 16, 0.32us resolution,                       (BASE_INIT/INIT_ECT)
                                                              ; max period 20.9712ms)                                  (BASE_INIT/INIT_ECT)
                                      ;*    movb #$1F,ECT_PTPSR ; Load ECT_PTPSR with %00011111                        (BASE_INIT/INIT_ECT)
                                                              ; (prescale 32, 0.64us resolution,                       (BASE_INIT/INIT_ECT)
                                                              ; max period 41.94248ms)                                 (BASE_INIT/INIT_ECT)
                                      ;*    movb #$3F,ECT_PTPSR ; Load ECT_PTPSR with %00111111                        (BASE_INIT/INIT_ECT)
                                                              ; (prescale 64, 1.28us resolution,                       (BASE_INIT/INIT_ECT)
                                                              ; max period 83.884ms)                                   (BASE_INIT/INIT_ECT)
                                      ;*    movb #$7F,ECT_PTPSR ; Load ECT_PTPSR with %01111111  (time base for run mode) (BASE_INIT/INIT_ECT)
                                                              ; (prescale 128, 2.56us resolution,                      (BASE_INIT/INIT_ECT)
                                                              ; max period 167.7696ms)                                 (BASE_INIT/INIT_ECT)
004381 7F4381 18 0B FF 00 6E              movb #$FF,ECT_PTPSR ; Load ECT_PTPSR with %11111111 (time base for prime or crank modes) (BASE_INIT/INIT_ECT)
                                                              ; (prescale 256, 5.12us resolution,                      (BASE_INIT/INIT_ECT)
                                                              ; max period 335.5ms)                                    (BASE_INIT/INIT_ECT)
004386 7F4386 18 0B 00 00 4A              movb #$00,ECT_TCTL3 ; Load ECT_TCTL3 with %00000000                          (BASE_INIT/INIT_ECT)
                                                              ; (capture disabled Ch7,6,5,4)                           (BASE_INIT/INIT_ECT)
00438B 7F438B 18 0B 15 00 4B              movb #$15,ECT_TCTL4 ; Load ECT_TCTL4 with %00010101 (Capture disabled Ch3    (BASE_INIT/INIT_ECT)
004390 7F4390 MACRO                                           CLR_ECT_VARS    ; Clear ECT variables  (ect_BEEM488.s)   (BASE_INIT)
                                                                    ; program counter                                  (BASE_INIT/CLR_ECT_VARS)
                                      ;***************************************************************************************** (BASE_INIT/CLR_ECT_VARS)
                                      ;* - Macros -                                                                            * (BASE_INIT/CLR_ECT_VARS)
                                      ;***************************************************************************************** (BASE_INIT/CLR_ECT_VARS)
004390 7F4390 18 79 10 12                clrw VSS1st      ; VSS input capture rising edge 1st time stamp (5.12uS or 2.56uS res) (BASE_INIT/CLR_ECT_VARS)
004394 7F4394 MACRO                               INIT_TIM        ; Initialize Timer (tim_BEEM488.s)                   (BASE_INIT)
                                                                    ; program counter                                  (BASE_INIT/INIT_TIM)
                                      ;***************************************************************************************** (BASE_INIT/INIT_TIM)
                                      ;* - Macros -                                                                            * (BASE_INIT/INIT_TIM)
                                      ;***************************************************************************************** (BASE_INIT/INIT_TIM)
                                      ;***************************************************************************************** (BASE_INIT/INIT_TIM)
                                      ; - Initialize Port P. General purpose I/Os. all pins outputs                    (BASE_INIT/INIT_TIM)
                                      ;*     PP0 - TIM1 OC0 Inj1 (1&10)   (output, active high, initialize low)                * (BASE_INIT/INIT_TIM)
                                      ;*     PP1 - TIM1 OC1 Inj2 (9&4)    (output, active high, initialize low)                * (BASE_INIT/INIT_TIM)
                                      ;*     PP2 - TIM1 OC2 Inj3 (3&6)    (output, active high, initialize low)                * (BASE_INIT/INIT_TIM)
                                      ;*     PP3 - TIM1 OC3 Inj4 (5&8)    (output, active high, initialize low)                * (BASE_INIT/INIT_TIM)
                                      ;*     PP4 - TIM1 OC4 Inj5 (7&2)    (output, active high, initialize low)                * (BASE_INIT/INIT_TIM)
                                      ;*     PP5 - TIM1 OC5 PP5out        (output, initialize low, spare)                      * (BASE_INIT/INIT_TIM)
                                      ;*     PP6 - Not used               (output, initialize low)                             * (BASE_INIT/INIT_TIM)
                                      ;*     PP7 - Not used               (output, initialize low)                     (BASE_INIT/INIT_TIM)
                                      ;***************************************************************************************** (BASE_INIT/INIT_TIM)
                                      ;***************************************************************************************** (BASE_INIT/INIT_TIM)
004394 7F4394 18 0B FF 03 6F              movb #$FF,PTRRR     ; Load Port R Routing Register with %00000101 (All TIM1 OC channels (BASE_INIT/INIT_TIM)
                                                              ; available on Port P)                                   (BASE_INIT/INIT_TIM)
004399 7F4399 18 0B FF 02 5A              movb  #$FF,DDRP     ; Load Port P Data Direction Register                    (BASE_INIT/INIT_TIM)
                                                              ; with %11111111 (all pins outputs)                      (BASE_INIT/INIT_TIM)
00439E 7F439E 18 0B 00 02 58              movb #$00,PTP       ; Load Port P with %00000000 (initialize all pins low)   (BASE_INIT/INIT_TIM)
0043A3 7F43A3 18 0B FF 03 D0              movb #$FF,TIM_TIOS  ;(TIM_TIOS equ $03D0)                                    (BASE_INIT/INIT_TIM)
                                                              ; Load Timer Input capture/Output compare Select register with (BASE_INIT/INIT_TIM)
                                                              ; %11111111 (All channels outputs)                       (BASE_INIT/INIT_TIM)
0043A8 7F43A8 18 0B 98 03 D6              movb #$98,TIM_TSCR1 ; (TIM_TSCR1 equ $03D6)                                  (BASE_INIT/INIT_TIM)
                                                              ; Load TIM_TSCR1 with %10011000 (timer enabled, no stop in wait, (BASE_INIT/INIT_TIM)
                                                              ; no stop in freeze, fast flag clear, precision timer)   (BASE_INIT/INIT_TIM)
0043AD 7F43AD 18 0B FF 03 DC              movb #$FF,TIM_TIE   ; Load TIM_TIE (Timer Interrupt Enable Register)         (BASE_INIT/INIT_TIM)
                                                              ; with %11111111 (enable interrupts all channels)        (BASE_INIT/INIT_TIM)
0043B2 7F43B2 18 0B 07 03 DD              movb #$07,TIM_TSCR2 ; (TIM_TSCR2 equ $03DD)(Load TIM_TSCR2 with %00000111    (BASE_INIT/INIT_TIM)
                                                              ; (timer overflow interrupt disabled,timer counter       (BASE_INIT/INIT_TIM)
                                                              ; reset disabled, prescale divide by 128)                (BASE_INIT/INIT_TIM)
                                      ;*    movb #$7F,TIM_PTPSR ; (TIM_PTPSR equ $03FE) Load TIM_PTPSR with %01111111  (BASE_INIT/INIT_TIM)
                                                              ; (prescale 128, 2.56us resolution,                      (BASE_INIT/INIT_TIM)
                                                              ; max period 167.7696ms)(Time base for run mode)         (BASE_INIT/INIT_TIM)
0043B7 7F43B7 18 0B FF 03 FE              movb #$FF,TIM_PTPSR ; (TIM_PTPSR equ $03FE)(Load TIM_PTPSR with %11111111    (BASE_INIT/INIT_TIM)
0043BC 7F43BC MACRO                                           CLR_IGN_VARS    ; Clear Ignition Calcs variables (igncalcs_BPEM488.s) (BASE_INIT)
                                                                    ; program counter                                  (BASE_INIT/CLR_IGN_VARS)
                                      ;***************************************************************************************** (BASE_INIT/CLR_IGN_VARS)
                                      ;* - Macros -                                                                            * (BASE_INIT/CLR_IGN_VARS)
                                      ;***************************************************************************************** (BASE_INIT/CLR_IGN_VARS)
0043BC 7F43BC 18 79 10 37                clrw Spantk         ; Ignition Span time (5.12uS or 2.56uS res)               (BASE_INIT/CLR_IGN_VARS)
0043C0 7F43C0 18 79 10 39                clrw DwellFintk     ; Time required for dwell after correction (5.12uS or 2.56uS res) (BASE_INIT/CLR_IGN_VARS)
0043C4 7F43C4 18 79 10 3B                clrw STandItrmtk    ; STcurr and Itmx10 (5.12uS or 2.56uS res)                (BASE_INIT/CLR_IGN_VARS)
0043C8 7F43C8 18 79 10 3D                clrw Advancetk      ; Delay time for desired spark advance + dwell(5.12uS or 2.56uS res) (BASE_INIT/CLR_IGN_VARS)
0043CC 7F43CC 18 79 10 3F                clrw Delaytk        ; Delay time from crank signal to energise coil(5.12uS or 2.56uS res) (BASE_INIT/CLR_IGN_VARS)
0043D0 7F43D0 18 79 10 41                clrw IgnOCadd1      ; First ignition output compare adder (5.12uS or 2.56uS res) (BASE_INIT/CLR_IGN_VARS)
0043D4 7F43D4 18 79 10 43                clrw IgnOCadd2      ; Second ignition output compare adder(5.12uS or 2.56uS res) (BASE_INIT/CLR_IGN_VARS)
0043D8 7F43D8 MACRO                                           CLR_INJ_VARS    ; Clear Injection Calcs variables (injcalcs_BPEM488.s) (BASE_INIT)
                                                                    ; program counter                                  (BASE_INIT/CLR_INJ_VARS)
                                      ;***************************************************************************************** (BASE_INIT/CLR_INJ_VARS)
                                      ;* - Macros -                                                                            * (BASE_INIT/CLR_INJ_VARS)
                                      ;***************************************************************************************** (BASE_INIT/CLR_INJ_VARS)
0043D8 7F43D8 18 79 10 45                clrw TpsPctx10last ; Throttle Position Sensor percent last (%x10)(updated every 100Msec) (BASE_INIT/CLR_INJ_VARS)
0043DC 7F43DC 18 79 10 47                clrw DdBndZ1       ; Deadband interpolation Z1 value                          (BASE_INIT/CLR_INJ_VARS)
0043E0 7F43E0 18 79 10 49                clrw DdBndZ2       ; Deadband interpolation Z2 value                          (BASE_INIT/CLR_INJ_VARS)
0043E4 7F43E4 18 79 10 4B                clrw PWcalc1       ; PW calculations result 1                                 (BASE_INIT/CLR_INJ_VARS)
0043E8 7F43E8 18 79 10 4D                clrw PWcalc2       ; PW calculations result 2                                 (BASE_INIT/CLR_INJ_VARS)
0043EC 7F43EC 18 79 10 4F                clrw PWcalc3       ; PW calculations result 3                                 (BASE_INIT/CLR_INJ_VARS)
0043F0 7F43F0 18 79 10 51                clrw PWcalc4       ; PW calculations result 4                                 (BASE_INIT/CLR_INJ_VARS)
0043F4 7F43F4 18 79 10 53                clrw PWcalc5       ; PW calculations result 5                                 (BASE_INIT/CLR_INJ_VARS)
0043F8 7F43F8 18 79 10 55                clrw ASErev        ; Afterstart Enrichment Taper (revolutions)                (BASE_INIT/CLR_INJ_VARS)
0043FC 7F43FC 18 79 10 A4                clrw ASEcnt        ; Counter for "ASErev"                                     (BASE_INIT/CLR_INJ_VARS)
004400 7F4400 18 79 10 57                clrw PrimePWtk     ; Primer injector pulswidth timer ticks(uS x 5.12)         (BASE_INIT/CLR_INJ_VARS)
004404 7F4404 18 79 10 59                clrw CrankPWtk     ; Cranking injector pulswidth timer ticks(uS x 5.12)       (BASE_INIT/CLR_INJ_VARS)
004408 7F4408 18 79 10 5B                clrw PWtk          ; Running injector pulsewidth timer ticks(uS x 2.56)       (BASE_INIT/CLR_INJ_VARS)
00440C 7F440C 18 79 10 5D                clrw InjOCadd1     ; First injector output compare adder (5.12uS res or 2.56uS res) (BASE_INIT/CLR_INJ_VARS)
004410 7F4410 18 79 10 5F                clrw InjOCadd2     ; Second injector output compare adder (5.12uS res or 2.56uS res) (BASE_INIT/CLR_INJ_VARS)
004414 7F4414 18 79 10 61                clrw FDcnt         ; Fuel delivery pulse width total(ms)(for totalizer pulse on rollover) (BASE_INIT/CLR_INJ_VARS)
004418 7F4418 79 10 63                   clr  AIOTcnt       ; Counter for AIOT totalizer pulse width                   (BASE_INIT/CLR_INJ_VARS)
00441B 7F441B MACRO                                           CLR_INTERP_VARS ; Clear Interp variables (interp_BPEM488.s) (BASE_INIT)
                                                                    ; program counter                                  (BASE_INIT/CLR_INTERP_VARS)
                                      ;***************************************************************************************** (BASE_INIT/CLR_INTERP_VARS)
                                      ;* - Macros -                                                                            * (BASE_INIT/CLR_INTERP_VARS)
                                      ;***************************************************************************************** (BASE_INIT/CLR_INTERP_VARS)
00441B 7F441B 18 79 10 25                clrw CrvPgPtr   ; Pointer to the page where the desired curve resides         (BASE_INIT/CLR_INTERP_VARS)
00441F 7F441F 18 79 10 27                clrw CrvRowOfst ; Offset from the curve page to the curve row                 (BASE_INIT/CLR_INTERP_VARS)
004423 7F4423 18 79 10 29                clrw CrvColOfst ; Offset from the curve page to the curve column              (BASE_INIT/CLR_INTERP_VARS)
004427 7F4427 18 79 10 2B                clrw CrvCmpVal  ; Curve comparison value for interpolation                    (BASE_INIT/CLR_INTERP_VARS)
00442B 7F442B 79 10 2D                   clr  CrvBinCnt  ; Number of bins in the curve row or column minus 1           (BASE_INIT/CLR_INTERP_VARS)
00442E 7F442E 79 10 2E                   clr  IndexNum   ; Position in the row or column of the curve comparison value (BASE_INIT/CLR_INTERP_VARS)
004431 7F4431 18 79 10 2F                clrw CrvRowHi   ; Curve row high boundry value for interpolation              (BASE_INIT/CLR_INTERP_VARS)
004435 7F4435 18 79 10 31                clrw CrvRowLo   ; Curve row low boundry value for interpolation               (BASE_INIT/CLR_INTERP_VARS)
004439 7F4439 18 79 10 33                clrw CrvColHi   ; Curve column high boundry value for interpolation           (BASE_INIT/CLR_INTERP_VARS)
00443D 7F443D 18 79 10 35                clrw CrvColLo   ; Curve column low boundry value for interpolation            (BASE_INIT/CLR_INTERP_VARS)
004441 7F4441 MACRO                                           CLR_STATE_VARS  ; Clear State variables (state_BPEM488.s) (BASE_INIT)
                                                                    ; program counter                                  (BASE_INIT/CLR_STATE_VARS)
                                      ;***************************************************************************************** (BASE_INIT/CLR_STATE_VARS)
                                      ;* - Macros -                                                                            * (BASE_INIT/CLR_STATE_VARS)
                                      ;***************************************************************************************** (BASE_INIT/CLR_STATE_VARS)
004441 7F4441 18 79 10 15                clrw CAS1sttk    ; CAS input capture rising edge 1st time stamp ((5.12uS or 2.56uS res) (BASE_INIT/CLR_STATE_VARS)
004445 7F4445 18 79 10 17                clrw CAS2ndtk    ; CAS input capture rising edge 2nd time stamp (5.12uS or 2.56uS res) (BASE_INIT/CLR_STATE_VARS)
004449 7F4449 18 79 10 19                clrw CASprd1tk   ; Period between CAS1st and CAS2nd (5.12uS or 2.56uS res)    (BASE_INIT/CLR_STATE_VARS)
00444D 7F444D 18 79 10 1B                clrw CASprd2tk   ; Period between CAS2nd and CAS3d ((5.12uS or 2.56uS res)    (BASE_INIT/CLR_STATE_VARS)
004451 7F4451 18 79 10 1D                clrw Degx10tk512 ; Time to rotate crankshaft 1 degree in 5.12uS resolution x 10 (BASE_INIT/CLR_STATE_VARS)
004455 7F4455 18 79 10 1F                clrw Degx10tk256 ; Time to rotate crankshaft 1 degree in 2.56uS resolution x 10 (BASE_INIT/CLR_STATE_VARS)
004459 7F4459 79 10 21                   clr  RevCntr     ; Counter for "Revmarker" flag                               (BASE_INIT/CLR_STATE_VARS)
00445C 7F445C 18 79 10 22                clrw Stallcnt    ; No crank or stall condition counter (1mS increments)       (BASE_INIT/CLR_STATE_VARS)
004460 7F4460 79 10 24                   clr  ICflgs      ; Input Capture flags bit field                              (BASE_INIT/CLR_STATE_VARS)
004463 7F4463 20 00                                           JOB     DONE        ; Jump or branch to DONE             (BASE_INIT)
004465 7F4465 -> $4465                DONE        EQU *     ; * Represents the current value of the paged              (BASE_INIT)
                                      ; - Application code -
                                      ;*****************************************************************************************
                                      ; - Clear all real time variables -
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Seconds counter variables
                                      ;*****************************************************************************************
004465 7F4465 79 10 64                   clr   SecH         ; RTI seconds count Hi byte (offset=0)
004468 7F4468 79 10 65                   clr   SecL         ; RTI seconds count Lo byte (offset=1)
                                      ;*****************************************************************************************
                                      ; - ADC variables
                                      ;*****************************************************************************************
00446B 7F446B 18 79 10 66                clrw  batAdc       ; Battery Voltage 10 bit ADC AN00(offset=2)
00446F 7F446F 18 79 10 68                clrw  BatVx10      ; Battery Voltage (Volts x 10)(offset=4)
004473 7F4473 18 79 10 6A                clrw  cltAdc       ; 10 bit ADC AN01 Engine Coolant Temperature ADC(offset=6)
004477 7F4477 18 79 10 6C                clrw  Cltx10       ; Engine Coolant Temperature (Degrees F x 10)(offset=8)
00447B 7F447B 18 79 10 6E                clrw  matAdc       ; 10 bit ADC AN02 Manifold Air Temperature ADC(offset=10)
00447F 7F447F 18 79 10 70                clrw  Matx10       ; Manifold Air Temperature (Degrees F x 10)(offset=12)
004483 7F4483 18 79 10 72                clrw  PAD03inAdc   ; 10 bit ADC AN03 Spare Temperature ADC(offset=14)
004487 7F4487 18 79 10 74                clrw  Place16      ; Place holder 16(offset=16)
00448B 7F448B 18 79 10 76                clrw  mapAdc       ; 10 bit ADC AN04 Manifold Absolute Pressure ADC(offset=18)
00448F 7F448F 18 79 10 78                clrw  Mapx10       ; Manifold Absolute Pressure (KPAx10)(offset=20)
004493 7F4493 18 79 10 7A                clrw  tpsADC       ; 10 bit ADC AN05 Throttle Position Sensor ADC (exact for TS)(offset=22)
004497 7F4497 18 79 10 7C                clrw  TpsPctx10    ; Throttle Position Sensor % of travel(%x10)(update every 100mSec)(offset=24)
00449B 7F449B 18 79 10 7E                clrw  egoAdc1      ; 10 bit ADC AN06 Exhaust Gas Oxygen ADC Left bank odd cyls(offset=26)
00449F 7F449F 18 79 10 80                clrw  afr1x10      ; Air Fuel Ratio for gasoline Left bank odd cyls(AFR1x10)(offset=28)
0044A3 7F44A3 18 79 10 82                clrw  baroAdc      ; 10 bit ADC AN07 Barometric Pressure ADC(offset=30)
0044A7 7F44A7 18 79 10 84                clrw  Barox10      ; Barometric Pressure (KPAx10)(offset=32)
0044AB 7F44AB 18 79 10 86                clrw  eopAdc       ; 10 bit ADC AN08 Engine Oil Pressure ADC(offset=34)
0044AF 7F44AF 18 79 10 88                clrw  Eopx10       ; Engine Oil Pressure (PSI x 10)(offset=36)
0044B3 7F44B3 18 79 10 8A                clrw  efpAdc       ; 10 bit ADC AN09 Engine Fuel Pressure ADC(offset=38)
0044B7 7F44B7 18 79 10 8C                clrw  Efpx10       ; Engine Fuel Pressure (PSI x 10)(offset=40)
0044BB 7F44BB 18 79 10 8E                clrw  itrmAdc      ; 10 bit ADC AN10 Ignition Trim ADC(offset=42)
0044BF 7F44BF 18 79 10 90                clrw  Itrmx10      ; Ignition Trim (degrees x 10)+-20 degrees) (offset=44)
0044C3 7F44C3 18 79 10 92                clrw  ftrmAdc      ; 10 bit ADC AN11 Fuel Trim ADC(offset=46)
0044C7 7F44C7 18 79 10 94                clrw  Ftrmx10      ; Fuel Trim (% x 10)(+-20%)(offset=48)
0044CB 7F44CB 18 79 10 96                clrw  egoAdc2      ; 10 bit ADC AN12  Exhaust Gas Oxygen ADC Right bank even cyls(offset=50)
0044CF 7F44CF 18 79 10 98                clrw  afr2x10      ; Air Fuel Ratio for gasoline Right bank even cyls(AFR2x10)(offset=52)
                                      ;*****************************************************************************************
                                      ; - Input capture variables
                                      ;*****************************************************************************************
0044D3 7F44D3 18 79 10 9A                clrw  CASprd512    ; Crankshaft Angle Sensor period (5.12uS time base(offset=54)
0044D7 7F44D7 18 79 10 9C                clrw  CASprd256    ; Crankshaft Angle Sensor period (2.56uS time base(offset=56)
0044DB 7F44DB 18 79 10 9E                clrw  VSSprd       ; Vehicle Speed Sensor period(offset=58)
0044DF 7F44DF 18 79 10 A0                clrw  RPM          ; Crankshaft Revolutions Per Minute(offset=60)
0044E3 7F44E3 18 79 10 A2                clrw  KPH          ; Vehicle speed (KpH x 10)(offset=62)
                                      ;*****************************************************************************************
                                      ; - Fuel calculation variables
                                      ;*****************************************************************************************
0044E7 7F44E7 18 79 10 A4                clrw  ASEcnt        ; Counter for "ASErev"(offset=64)
0044EB 7F44EB 18 79 10 A6                clrw  AFRcurr       ; Current value in AFR table (AFR x 100)(offset=66)
0044EF 7F44EF 18 79 10 A8                clrw  VEcurr        ; Current value in VE table (% x 10)(offset=68)
0044F3 7F44F3 18 79 10 AA                clrw  barocor       ; Barometric Pressure Correction (% x 10)(offset=70)
0044F7 7F44F7 18 79 10 AC                clrw  matcor        ; Manifold Air Temperature Correction (% x 10)(offset=72)
0044FB 7F44FB 18 79 10 AE                clrw  WUEcor        ; Warmup Enrichment Correction (% x 10)(offset=74)
0044FF 7F44FF 18 79 10 B0                clrw  ASEcor        ; Afterstart Enrichmnet Correction (% x 10)(offset=76)
004503 7F4503 18 79 10 B2                clrw  WUEandASEcor  ; the sum of WUEcor and ASEcor (% x 10)(offset=78)
004507 7F4507 18 79 10 B4                clrw  Crankcor      ; Cranking pulsewidth temperature correction (% x 10)(offset=80)
00450B 7F450B 18 79 10 B6                clrw  TpsPctDOT     ; TPS difference over time (%/Sec)(update every 100mSec)(offset=82)
00450F 7F450F 79 10 B8                   clr   TpsDOTcor     ; Throttle Opening Enrichment table value(%)(offset=84)
004512 7F4512 79 10 B9                   clr   ColdAddpct    ; Throttle Opening Enrichment cold adder (%)(offset=85)
004515 7F4515 79 10 BA                   clr   ColdMulpct    ; Throttle Opening Enrichment cold multiplier (%)(offset=86)
004518 7F4518 79 10 BB                   clr   TOEpct        ; Throttle Opening Enrichment (%)(offset=87)
00451B 7F451B 18 79 10 BC                clrw  TOEpw         ; Throttle Opening Enrichment adder (mS x 100)(offset=88)
00451F 7F451F 18 79 10 BE                clrw  PWlessTOE     ; Injector pulse width before "TOEpw" and "Deadband" (mS x 10)(offset=90)
004523 7F4523 18 79 10 C0                clrw  Deadband      ; injector deadband at current battery voltage mS*100(offset=92)
004527 7F4527 18 79 10 C2                clrw  PrimePW       ; Primer injector pulswidth (mS x 10)(offset=94)
00452B 7F452B 18 79 10 C4                clrw  CrankPW       ; Cranking injector pulswidth (mS x 10)(offset=96)
00452F 7F452F 18 79 10 C6                clrw  FDpw          ; Fuel Delivery pulse width (PW - Deadband) (mS x 10)(offset=98)
004533 7F4533 18 79 10 C8                clrw  PW            ; Running engine injector pulsewidth (mS x 10)(offset=100)
004537 7F4537 18 79 10 CA                clrw  LpH           ; Fuel burn Litres per hour(offset=102)
00453B 7F453B 18 79 10 CC                clrw  FDsec         ; Fuel delivery pulse width total over 1 second (mS x 10)(offset=104)
00453F 7F453F 79 10 CE                   clr   GearCur       ; Curent transmission gear(offset=106)
004542 7F4542 79 10 CF                   clr   TOEdurCnt     ; Throttle Opening Enrichment duration counter(offset=107)
004545 7F4545 18 79 10 D0                clrw  FDt           ; Fuel Delivery pulse width total(mS) (for FDsec calcs)(offset=108)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Ignition calculation variables
                                      ;*****************************************************************************************
004549 7F4549 18 79 10 D2                clrw  STcurr        ; Current value in ST table (Degrees x 10)(offset=110)
00454D 7F454D 18 79 10 D4                clrw  KmpL          ; Fuel burn kilometers per litre(offset=112)
004551 7F4551 18 79 10 D6                clrw  DwellCor      ; Coil dwell voltage correction (%*10)(offset=114)
004555 7F4555 18 79 10 D8                clrw  DwellFin      ; ("Dwell" * "DwellCor") (mS*10)(offset=116)
004559 7F4559 18 79 10 DA                clrw  STandItrmx10  ; stCurr and Itmx10 (degrees*10)(offset=118)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Port status variables
                                      ;*****************************************************************************************
00455D 7F455D 79 10 DC                   clr   PortAbits     ; Port A status bit field(offset=120)
004560 7F4560 79 10 DD                   clr   PortBbits     ; Port B status bit field(offset=121)
004563 7F4563 79 10 DE                   clr   PortKbits     ; Port K status bit field(offset=122)
004566 7F4566 79 10 DF                   clr   PortPbits     ; Port P status bit field(offset=123)
004569 7F4569 79 10 E0                   clr   PortTbits     ; Port T status bit field(offset=124)
                                      ;*****************************************************************************************
                                      ; - Misc variables
                                      ;*****************************************************************************************
00456C 7F456C 79 10 E1                   clr   engine        ; Engine status bit field(offset=125)
00456F 7F456F 79 10 E2                   clr   engine2       ; Engine2 status bit field(offset=126)
004572 7F4572 79 10 E3                   clr   alarmbits     ; Alarm status bit field(offset=127)
004575 7F4575 79 10 E4                   clr   AAoffbits     ; Audio Alarm Off status bit field(offset=128)
004578 7F4578 79 10 E5                   clr   StateStatus   ; State status bit field(offset=129)
00457B 7F457B 18 79 10 E6                clrw  LoopTime      ; Program main loop time (loops/Sec)(offset=130)
00457F 7F457F 18 79 10 E8                clrw  DutyCyclex10  ; Injector duty cycle in run mode (% x 10)(offset=132)
004583 7F4583 18 79 10 EA                clrw  MpG           ; Fuel burn miles per gallon Imperial (offset=134)
004587 7F4587 18 79 10 EC                clrw  TestValw      ; Word test value (for program developement only)(offset=136)
00458B 7F458B 79 10 EE                   clr   testValb      ; Byte test value (for program developement only)(offset=138)
                                      ;*****************************************************************************************
                                      ; - Clear other variables -
                                      ;*****************************************************************************************
00458E 7F458E 18 79 10 EF                clrw LoopCntr    ; Counter for "LoopTime" (incremented every Main Loop pass)
004592 7F4592 79 10 F1                   clr  tmp1w       ; Temporary word variable #1
004595 7F4595 79 10 F3                   clr  tmp2w       ; Temporary word variable #2
004598 7F4598 79 10 F5                   clr  tmp3w       ; Temporary word variable #3
00459B 7F459B 79 10 F7                   clr  tmp4w       ; Temporary word variable #4
00459E 7F459E 79 10 F9                   clr  tmp5b       ; Temporary byte variable #5
0045A1 7F45A1 79 10 FA                   clr  tmp6b       ; Temporary byte variable #6
0045A4 7F45A4 79 10 FB                   clr  tmp7b       ; Temporary byte variable #7
0045A7 7F45A7 79 10 FC                   clr  tmp8b       ; Temporary byte variable #8
0045AA 7F45AA 18 79 10 FD                clrw GearKCur    ; Variable for current gear K factor calculations
0045AE 7F45AE 18 79 10 FF                clrw baroADCsum  ; Variable for "baroADC" averaging sum
0045B2 7F45B2 79 11 01                   clr  baroADCcnt  ; Counter for "baroADC" averaging sum
                                      ;*****************************************************************************************
                                      ; - Initialize other variables -
                                      ;*****************************************************************************************
0045B5 7F45B5 18 0B 09 10 21              movb  #$09,RevCntr     ; Counter for Revolution Counter signals
                                      ;*****************************************************************************************
                                      ;
                                      ;   BPEM488 utilizes EEPROM Emulation and all configurable constants are stored in D-Flash
                                      ;   and run from Buffer Ram. Tuner Studio reads Buffer Ram on start up but if values there
                                      ;   are not within acceptable ranges the session is aborted. Default values are stored
                                      ;   in P-Flash and this code transfers those values to Buffer Ram to keep TS happy.
                                      ;   This should only have to be done once. After that, tuning changes to Buffer Ram
                                      ;   will be automatically copied to D-Flash by the EEPROM Emulation module.
                                      ;
                                      ;*****************************************************************************************
0045BA 7F45BA MACRO                       EEEM_ENABLE   ; Enable EEPROM Emulation Macro in eeemBPEM488.s  ; If this isn't here you need to do a load on each power up
                                                                          ; with $0F (FCLK=1MHz)                       (EEEM_ENABLE)
                                      ; - Enable EE Emulation -                                                        (EEEM_ENABLE)
                                      ; args:   1: branch address of error handler (optional)                          (EEEM_ENABLE)
                                      ; result: none                                                                   (EEEM_ENABLE)
                                      ; SSTACK: none                                                                   (EEEM_ENABLE)
                                      ;         X, Y, and D are preserved                                              (EEEM_ENABLE)
                                      ; - Step (1): Set FCCOBIX -                                                      (EEEM_ENABLE)
0045BA 7F45BA 79 01 02                    clr    FCCOBIX    ; Clear Flash CCOB Index Register                          (EEEM_ENABLE)
                                      ; - Step (2): Enter parameters into FCCOB -                                      (EEEM_ENABLE)
0045BD 7F45BD 18 0B 13 01 0A              movb   #$13, FCCOBHI  ; Move %00010011 into Flash Common Command Register    (EEEM_ENABLE)
                                                                ; Hi byte (Flash command enable EEEPROM Emulation)     (EEEM_ENABLE)
                                      ;     movb   #$13, FCCOBLO                                                       (EEEM_ENABLE)
                                      ; - Step (3): Launch command -                                                   (EEEM_ENABLE)
0045C2 7F45C2 18 0B B0 01 06              movb #(CCIF|ACCERR|FPVIOL), FSTAT ; Move $B0 (%10110000) into Flash Status Register (EEEM_ENABLE)
                                                                            ;( Write 1s to Command Complete Interrupt  (EEEM_ENABLE)
                                                                            ; flag, Flash Access Error Flag and Flash  (EEEM_ENABLE)
                                                                            ; Protection Violation Flag to clear flags) (EEEM_ENABLE)
                                      ; - Step (4): Wait until command is executed -                                   (EEEM_ENABLE)
0045C7 7F45C7 1F 01 06 80 FB              brclr       FSTAT, #CCIF, *  ; Loop until Command Complete Interrupt         (EEEM_ENABLE)
                                      ;    brset PORTA,PA0,PA0Set ; Pole PORTA, bit PA0 and branch to PA0Set: if bit is Hi
                                                                 ; This is the normal condition for the norally open tactile
                                                                 ; switch on the auxilliary board
                                      ;    EEEM_ENABLE   ; Enable EEPROM Emulation Macro in eeemBPEM488.s
                                      ;*********************************************************************
                                      ; - Copy page 1, VE table, ranges and other configurable constants
                                      ;   from Flash to Buffer Ram. (EPAGE=$FF)
                                      ;*********************************************************************
0045CC 7F45CC 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE
0045D1 7F45D1 CC 04 00                    ldd    #$400        ; Load accu D with decimal 1024
0045D4 7F45D4 CE 71 9A                    ldx    #veBins_F    ; Load index register X with the address  NOTE CHANGE
                                                              ; of the first value in "veBins_F" table (Flash)
0045D7 7F45D7 CD 08 00                    ldy    #veBins_E      ; Load index register Y with the address  NOTE CHANGE
                                                              ; of the first value in "veBins" table (Buffer Ram)
0045DA 7F45DA                         CopyPage1:
0045DA 7F45DA 18 0A 30 70                 movb    1,X+, 1,Y+  ; Copy byte value from Flash to Buffer Ram and
                                                              ; increment X and Y registers
0045DE 7F45DE 04 34 F9                    dbne    D,CopyPage1 ; Decrement Accu D and loop back to CopyPage1:
                                                              ; if not zero
                                      ;*********************************************************************
                                      ; - Copy page 2, ST table, ranges and other configurable constants
                                      ;   from Flash to Buffer Ram. (EPAGE=$FE)
                                      ;*********************************************************************
0045E1 7F45E1 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE
0045E6 7F45E6 CC 04 00                    ldd    #$400        ; Load accu D with decimal 1024
0045E9 7F45E9 CE 75 91                    ldx    #stBins_F    ; Load index register X with the address
                                                              ; of the first value in "stBins_F" table (Flash)
0045EC 7F45EC CD 08 00                    ldy    #stBins_E      ; Load index register Y with the address
                                                              ; of the first value in "stBins" table ( Buffer Ram)
0045EF 7F45EF                         CopyPage2:
0045EF 7F45EF 18 0A 30 70                 movb    1,X+, 1,Y+  ; Copy byte value from Flash to Buffer Ram and
                                                              ; increment X and Y registers
0045F3 7F45F3 04 34 F9                    dbne    D,CopyPage2 ; Decrement Accu D and loop back to CopyPage2:
                                                              ; if not zero
                                      ;*********************************************************************
                                      ; - Copy page 3, AFR table, ranges and other configurable constants
                                      ;   from Flash to Buffer Ram. (EPAGE=$FD)
                                      ;*********************************************************************
0045F6 7F45F6 18 0B FD 00 17              movb  #(BUF_RAM_P3_START>>16),EPAGE  ; Move $FD into EPAGE
0045FB 7F45FB CC 04 00                    ldd    #$400        ; Load accu D with decimal 1024
0045FE 7F45FE CE 78 83                    ldx    #afrBins_F   ; Load index register X with the address
                                                              ; of the first value in "afrBins_F" table (Flash)
004601 7F4601 CD 08 00                    ldy    #afrBins_E     ; Load index register Y with the address
                                                              ; of the first value in "afrBins" table (Buffer Ram)
004604 7F4604                         CopyPage3:
004604 7F4604 18 0A 30 70                 movb    1,X+, 1,Y+  ; Copy byte value from Flash to Buffer Ram and
                                                              ; increment X and Y registers
004608 7F4608 04 34 F9                    dbne    D,CopyPage3 ; Decrement Accu D and loop back to CopyPage3:
                                                              ; if not zero
00460B 7F460B                         PA0Set:
                                      ;*****************************************************************************************
00460B 7F460B 79 00 1E                    clr  IRQCR   ; Disable IRQ (won't run without this)
00460E 7F460E 10 EF                       cli          ; Clear Interrupt mask (enable interrupts)
                                      ;*****************************************************************************************
004610 7F4610 1F 10 05 08 FB              brclr clock,ms500,*  ; Wait here for 500mSec. Without this the ATD0 sequence below
                                                               ; won't work on power up. Slow start up for switching 5V power
                                                               ; supply is suspect.
                                      ;*****************************************************************************************
                                      ; - Start ATD0 conversion sequence, load all results and do conversions to user units
                                      ;   as a starting point for calculations.
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;*    Port AD:                                                                           *
                                      ;*     PAD00 - (batADC)     (analog, no pull) hard wired Bat volts ADC                   *
                                      ;*     PAD01 - (cltADC)     (analog, no pull) temperature sensor ADC                     *
                                      ;*     PAD02 - (matADC)     (analog, no pull) temperature sensor ADC                     *
                                      ;*     PAD03 - (PAD03inADC) (analog, no pull) temperature sensor ADC  spare              *
                                      ;*     PAD04 - (mapADC)     (analog, no pull) general purpose ADC                        *
                                      ;*     PAD05 - (tpsADC)     (analog, no pull) general purpose ADC                        *
                                      ;*     PAD06 - (egoADC1)(EGO)  (analog, no pull) general purpose ADC                     *
                                      ;*     PAD07 - (baroADC)    (analog, no pull) general purpose ADC                        *
                                      ;*     PAD08 - (eopADC)     (analog, no pull) general purpose ADC                        *
                                      ;*     PAD09 - (efpADC)     (analog, no pull) general purpose ADC                        *
                                      ;*     PAD10 - (itrmADC)    (analog, no pull) general purpose ADC                        *
                                      ;*     PAD11 - (ftrmADC)    (analog, no pull) general purpose ADC                        *
                                      ;*     PAD12 - (egoADC2)(PAD12) (analog, no pull) general purpose ADC                    *
                                      ;*     PAD13 - Not used     (GPIO input, pull-up)                                        *
                                      ;*     PAD14 - Not used     (GPIO input, pull-up)                                        *
                                      ;*     PAD15 - Not used     (GPIO input, pull-up)                                        *
                                      ;*****************************************************************************************
004615 7F4615 MACRO                       START_ATD0    ;(Macro in adc0_BPEM488.s)
                                                                  ; %1110000000000000 (Enable input buffer pins 15,14,13 (START_ATD0)
                                                                  ; Disable input buffer pins 12,11,10,9,8,7,6,5,4,3,2,1,0) (START_ATD0)
                                                                  ;(Register is %0000000000000000 out of reset)        (START_ATD0)
                                      ;***************************************************************************************** (START_ATD0)
                                      ;- Start ATD0 and get ADC values for all selected channels                       (START_ATD0)
                                      ;***************************************************************************************** (START_ATD0)
004615 7F4615 18 0B 30 02 C5              movb  #$30,ATD0CTL5   ; Load ATD Control Register 5 with %00110000 (no special channel,continuous (START_ATD0)
                                                                ; conversion, multi channel, initial channel 0)        (START_ATD0)
                                                                ; (Start conversion sequence)                          (START_ATD0)
                                                                ;         ^^^^^^^^                                     (START_ATD0)
                                                                ;       SC-+||||||                                     (START_ATD0)
                                                                ;     SCAN--+|||||                                     (START_ATD0)
                                                                ;     MULT---+||||                                     (START_ATD0)
                                                                ;       CD----+|||                                     (START_ATD0)
                                                                ;       CC-----+||                                     (START_ATD0)
                                                                ;       CB------+|                                     (START_ATD0)
                                                                ;       CA-------+                                     (START_ATD0)
                                                                ;(Register is %00000000 out of reset)                  (START_ATD0)
00461A 7F461A 1F 02 C6 80 FB              brclr ATD0STAT0,SCF,*  ; Loop here until Sequence Complete Flag is set       (START_ATD0)
00461F 7F461F 18 0B 80 02 C6              movb  #SCF,ATD0STAT0 ; Set the Sequence Complete Flag of ATD Status Register 0 to clear the flag (START_ATD0)
004624 7F4624 FC 02 D0                    ldd   ATD0DR0H    ; Load accumulator with value in ATD Ch00                  (START_ATD0)
004627 7F4627 7C 10 66                    std   batAdc      ; Copy to batAdc                                           (START_ATD0)
00462A 7F462A FC 02 D2                    ldd   ATD0DR1H    ; Load accumulator with value in ATD Ch01                  (START_ATD0)
00462D 7F462D 7C 10 6A                    std   cltAdc      ; Copy to cltAdc                                           (START_ATD0)
004630 7F4630 FC 02 D4                    ldd   ATD0DR2H    ; Load accumulator with value in ATD Ch02                  (START_ATD0)
004633 7F4633 7C 10 6E                    std   matAdc      ; Copy to matAdc                                           (START_ATD0)
004636 7F4636 FC 02 D6                    ldd   ATD0DR3H    ; Load accumulator with value in ATD Ch03                  (START_ATD0)
004639 7F4639 7C 10 72                    std   PAD03inAdc  ; Copy to PAD03inAdc                                       (START_ATD0)
00463C 7F463C FC 02 D8                    ldd   ATD0DR4H    ; Load accumulator with value in ATD Ch04                  (START_ATD0)
00463F 7F463F 7C 10 76                    std   mapAdc      ; Copy to mapAdc                                           (START_ATD0)
004642 7F4642 FC 02 DA                    ldd   ATD0DR5H    ; Load accumulator with value in ATD Ch05                  (START_ATD0)
004645 7F4645 7C 10 7A                    std   tpsADC      ; Copy to tpsADC                                           (START_ATD0)
004648 7F4648 FC 02 DC                    ldd   ATD0DR6H    ; Load accumulator with value in ATD Ch06                  (START_ATD0)
00464B 7F464B 7C 10 7E                    std   egoAdc1     ; Copy to egoAdc1                                          (START_ATD0)
00464E 7F464E FC 02 DE                    ldd   ATD0DR7H    ; Load accumulator with value in ATD Ch07                  (START_ATD0)
004651 7F4651 7C 10 82                    std   baroAdc     ; Copy to baroAdc                                          (START_ATD0)
004654 7F4654 FC 02 E0                    ldd   ATD0DR8H    ; Load accumulator with value in ATD Ch08                  (START_ATD0)
004657 7F4657 7C 10 86                    std   eopAdc      ; Copy to eopAdc                                           (START_ATD0)
00465A 7F465A FC 02 E2                    ldd   ATD0DR9H    ; Load accumulator with value in ATD Ch09                  (START_ATD0)
00465D 7F465D 7C 10 8A                    std   efpAdc      ; Copy to efpAdc                                           (START_ATD0)
004660 7F4660 FC 02 E4                    ldd   ATD0DR10H   ; Load accumulator with value in ATD Ch10                  (START_ATD0)
004663 7F4663 7C 10 8E                    std   itrmAdc     ; Copy to itrmAdc                                          (START_ATD0)
004666 7F4666 FC 02 E6                    ldd   ATD0DR11H   ; Load accumulator with value in ATD Ch11                  (START_ATD0)
004669 7F4669 7C 10 92                    std   ftrmAdc     ; Copy to ftrmAdc                                          (START_ATD0)
00466C 7F466C FC 02 E8                    ldd   ATD0DR12H   ; Load accumulator with value in ATD Ch12                  (START_ATD0)
00466F 7F466F 7C 10 96                    std   egoAdc2     ; Copy to egoAdc2                                          (START_ATD0)
                                      ;*****************************************************************************************
                                      ; - Convert ADC values to user units -
                                      ;*****************************************************************************************
004672 7F4672 MACRO                       CONVERT_ATD0    ;(Macro in adc0_BPEM488.s)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Battery Voltage                                                    (CONVERT_ATD0)
                                      ;   System voltage is typically ~12 volts with the engine stopped and ~14 volts with the (CONVERT_ATD0)
                                      ;   engine running and the generator charging. In order for ATD0 Ch0 to measure this (CONVERT_ATD0)
                                      ;   voltage a 49.9K and a 10K resistor are connected in series across VDD(5 volts) and (CONVERT_ATD0)
                                      ;   ground. Ch0 measures the voltage drop across the 10K resistor. This arrangement will (CONVERT_ATD0)
                                      ;   accept system voltage of 29.95 volts before the voltage drop will exceed 5 volts. (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Battery Voltage x 10 -                                             (CONVERT_ATD0)
                                      ;    (batAdc/1023)*29.95 = BatV                                                  (CONVERT_ATD0)
                                      ;             or                                                                 (CONVERT_ATD0)
                                      ;    batAdc*(29.95/1023) = BatV, batADC = BatV                                   (CONVERT_ATD0)
                                      ;    batAdc*.029276637 = BatV  batADC = batV/.029276637                          (CONVERT_ATD0)
                                      ;    batAdc*(300/1023) = BatV*10                                                 (CONVERT_ATD0)
                                      ;    batAdc*.29276637 = BatV*10 bat ADC = batV*10/.29276637                      (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004672 7F4672 FC 10 66                    ldd   batAdc       ; Load double accumulator with value in "batAdc"          (CONVERT_ATD0)
004675 7F4675 CD 01 2C                    ldy   #$012C       ; Load index register Y with decimal decimal 300          (CONVERT_ATD0)
004678 7F4678 13                          emul               ; Extended 16x16 multiply (D)x(Y)=Y:D                     (CONVERT_ATD0)
004679 7F4679 CE 03 FF                    ldx   #$03FF       ; Load index register X with decimal 1023                 (CONVERT_ATD0)
00467C 7F467C 11                          ediv               ; Extended 32x16 divide(Y:D)/(X)=Y;Rem->D                 (CONVERT_ATD0)
00467D 7F467D 7D 10 68                    sty   BatVx10      ; Copy result to "BatVx10" (Battery Voltage x 10)         (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Look up Engine Coolant Temperature (Degrees F x 10)                          (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004680 7F4680 FE 10 6A                    ldx   cltAdc            ; Load index register X with value in "cltAdc"       (CONVERT_ATD0)
004683 7F4683 18 48                       aslx                    ; Arithmetic shift left index register X (multiply "cltAdc" (CONVERT_ATD0)
                                                                  ; by two) I have no idea why I have to do this but if I don't (CONVERT_ATD0)
                                                                  ; the table look up is only half of where it shoud be ??????? (CONVERT_ATD0)
004685 7F4685 ED E2 7C 9F                 ldy   DodgeThermistor,X  ; Load index register Y with value in "DodgeThermistor" table, (CONVERT_ATD0)
                                                                  ; offset in index register X                         (CONVERT_ATD0)
004689 7F4689 7D 10 6C                    sty   Cltx10            ; Copy result to "Cltx10" Engine Coolant Temperature x 10 (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Look up Manifold Air Temperature (Degrees F x 10)                            (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
00468C 7F468C FE 10 6E                    ldx   matAdc            ; Load index register X with value in "matAdc"       (CONVERT_ATD0)
00468F 7F468F 18 48                       aslx                    ; Arithmetic shift left index register X (multiply "matAdc" (CONVERT_ATD0)
                                                                  ; by two) I have no idea why I have to do this but if I don't (CONVERT_ATD0)
                                                                  ; the table look up is only half of where it shoud be ??????? (CONVERT_ATD0)
004691 7F4691 ED E2 7C 9F                 ldy   DodgeThermistor,X  ; Load index register Y with value in "DodgeThermistor" table, (CONVERT_ATD0)
                                                                  ; offset in index register X                         (CONVERT_ATD0)
004695 7F4695 7D 10 70                    sty   Matx10            ; Copy result to "Matx100" Manifold Air Temperature x 10 (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Manifold Absolute Pressure x 10 (Used to calculate to 1 decimal place) (CONVERT_ATD0)
                                      ;   Dodge V10 MAP sensor test data 7/30/20:                                      (CONVERT_ATD0)
                                      ;   Vout = 4.57,    ADC = 935, KPA = 101.5                                       (CONVERT_ATD0)
                                      ;   Vout = .004887, ADC = 1,   KPA = 11.02                                       (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004698 7F4698 CC 00 0A                    ldd  #$000A      ; Load double accumulator with decimal 1 (.004887 volt ADC) ( x 10) (CONVERT_ATD0)
00469B 7F469B 3B                          pshd             ; Push to stack (V1)                                        (CONVERT_ATD0)
00469C 7F469C FC 10 76                    ldd  mapAdc      ; Load double accumulator with "mapAdc"                     (CONVERT_ATD0)
00469F 7F469F CD 00 0A                    ldy  #$000A      ; Load index register Y with decimal 10                     (CONVERT_ATD0)
0046A2 7F46A2 13                          emul             ; Multiply (D)x(Y)=>Y:D  (multiply "eopAdc" by 10)          (CONVERT_ATD0)
0046A3 7F46A3 3B                          pshd             ; Push to stack (V)                                         (CONVERT_ATD0)
0046A4 7F46A4 CC 24 86                    ldd  #$2486      ; Load double accumulator with decimal 935 (4.57 volt ADC) ( x 10) (CONVERT_ATD0)
0046A7 7F46A7 3B                          pshd             ; Push to stack (V2)                                        (CONVERT_ATD0)
0046A8 7F46A8 CC 00 6E                    ldd  #$006E      ; Load double accumulator with decimal 11.02 (Low range KPA) ( x 10) (CONVERT_ATD0)
0046AB 7F46AB 3B                          pshd             ; Push to stack (Z1)                                        (CONVERT_ATD0)
0046AC 7F46AC CC 03 F7                    ldd  #$03F7      ; Load double accumulator with decimal 101.5 (High range KPA) ( x 10) (CONVERT_ATD0)
0046AF 7F46AF 3B                          pshd             ; Push to stack (Z2)                                        (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z2       |  SP+ 0                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z1       |  SP+ 2                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V2       |  SP+ 4                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V        |  SP+ 6                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V1       |  SP+ 8                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                      ;                     V      V1      V2      Z1    Z2                            (CONVERT_ATD0)
0046B0 7F46B0 MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; ==========================                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CONVERT_ATD0/2D_IPOL)
                                      ; SSTACK: none                                                                   (CONVERT_ATD0/2D_IPOL)
                                      ;         no registers are preserved                                             (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    ^ V                                                                         (CONVERT_ATD0/2D_IPOL)
                                      ;    |                                                                           (CONVERT_ATD0/2D_IPOL)
                                      ;  Z2+....................*                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;    |                    :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CONVERT_ATD0/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CONVERT_ATD0/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CONVERT_ATD0/2D_IPOL)
                                      ;    |   :       :        :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
0046B0 7F46B0 EC 86                                   LDD       \1    ; load V                                         (CONVERT_ATD0/2D_IPOL)
0046B2 7F46B2 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
0046B4 7F46B4 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
0046B6 7F46B6 EC 80                                   LDD       \5    ; load Z2                                        (CONVERT_ATD0/2D_IPOL)
0046B8 7F46B8 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
0046BA 7F46BA 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CONVERT_ATD0/2D_IPOL)
0046BC 7F46BC B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
0046BE 7F46BE EC 84                                   LDD       \3    ; load V2                                        (CONVERT_ATD0/2D_IPOL)
0046C0 7F46C0 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
0046C2 7F46C2 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CONVERT_ATD0/2D_IPOL)
                                      ;*********************************************************************           (CONVERT_ATD0/2D_IPOL)
0046C4 7F46C4 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CONVERT_ATD0/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CONVERT_ATD0/2D_IPOL)
0046C6 7F46C6 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
0046C8 7F46C8 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Free stack space (result in D)                                               (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
0046CA 7F46CA 1B 8A                       leas  10,SP    ; Stack pointer -> bottom of stack                            (CONVERT_ATD0)
0046CC 7F46CC 7C 10 78                    std   Mapx10   ; Copy result to "Mapx10" Manifold Absolute Pressure x 10     (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Throttle Position Percent x 10 -                                   (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
0046CF 7F46CF 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (CONVERT_ATD0)
0046D4 7F46D4 CD 08 00                    ldy  #veBins_E   ; Load index register Y with address of first configurable constant (CONVERT_ATD0)
                                                           ; on buffer RAM page 1 (veBins)                             (CONVERT_ATD0)
0046D7 7F46D7 EC EA 03 E8                 ldd  $03E8,Y     ; Load Accu D with value in buffer RAM page 1 offset 1000 (tpsMin) (CONVERT_ATD0)
0046DB 7F46DB 3B                          pshd             ; Push to stack (V1)                                        (CONVERT_ATD0)
0046DC 7F46DC FC 10 7A                    ldd  tpsADC      ; Load double accumulator with "tpsADCAdc"                  (CONVERT_ATD0)
0046DF 7F46DF 3B                          pshd             ; Push to stack (V)                                         (CONVERT_ATD0)
0046E0 7F46E0 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (CONVERT_ATD0)
0046E5 7F46E5 CD 08 00                    ldy  #veBins_E   ; Load index register Y with address of first configurable constant (CONVERT_ATD0)
                                                           ; on buffer RAM page 1 (vebins)                             (CONVERT_ATD0)
0046E8 7F46E8 EC EA 03 EA                 ldd  $03EA,Y     ; Load Accu D with value in buffer RAM page 1 offset 1002 (tpsMax) (CONVERT_ATD0)
0046EC 7F46EC 3B                          pshd             ; Push to stack (V2)                                        (CONVERT_ATD0)
0046ED 7F46ED CC 00 00                    ldd  #$0000      ; Load double accumulator with decimal 0 (Low range %) ( x 10) (CONVERT_ATD0)
0046F0 7F46F0 3B                          pshd             ; Push to stack (Z1)                                        (CONVERT_ATD0)
0046F1 7F46F1 CC 03 E8                    ldd  #$03E8      ; Load double accumulator with decimal 1000 (High range %) ( x 10) (CONVERT_ATD0)
0046F4 7F46F4 3B                          pshd             ; Push to stack (Z2)                                        (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z2       |  SP+ 0                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z1       |  SP+ 2                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V2       |  SP+ 4                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V        |  SP+ 6                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V1       |  SP+ 8                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                      ;                     V      V1      V2      Z1    Z2                            (CONVERT_ATD0)
0046F5 7F46F5 MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; ==========================                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CONVERT_ATD0/2D_IPOL)
                                      ; SSTACK: none                                                                   (CONVERT_ATD0/2D_IPOL)
                                      ;         no registers are preserved                                             (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    ^ V                                                                         (CONVERT_ATD0/2D_IPOL)
                                      ;    |                                                                           (CONVERT_ATD0/2D_IPOL)
                                      ;  Z2+....................*                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;    |                    :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CONVERT_ATD0/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CONVERT_ATD0/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CONVERT_ATD0/2D_IPOL)
                                      ;    |   :       :        :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
0046F5 7F46F5 EC 86                                   LDD       \1    ; load V                                         (CONVERT_ATD0/2D_IPOL)
0046F7 7F46F7 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
0046F9 7F46F9 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
0046FB 7F46FB EC 80                                   LDD       \5    ; load Z2                                        (CONVERT_ATD0/2D_IPOL)
0046FD 7F46FD A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
0046FF 7F46FF 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CONVERT_ATD0/2D_IPOL)
004701 7F4701 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004703 7F4703 EC 84                                   LDD       \3    ; load V2                                        (CONVERT_ATD0/2D_IPOL)
004705 7F4705 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004707 7F4707 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CONVERT_ATD0/2D_IPOL)
                                      ;*********************************************************************           (CONVERT_ATD0/2D_IPOL)
004709 7F4709 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CONVERT_ATD0/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CONVERT_ATD0/2D_IPOL)
00470B 7F470B B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
00470D 7F470D E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Free stack space (result in D)                                               (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
00470F 7F470F 1B 8A                       leas  10,SP    ; Stack pointer -> bottom of stack                            (CONVERT_ATD0)
004711 7F4711 7C 10 7C                    std  TpsPctx10 ; Copy result to "TpsPctx10" Throttle Position Percent of travel x 10 (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Air Fuel Ratio x 10 for left bank (odd cylinders)-                 (CONVERT_ATD0)
                                      ;   Innovate LC-2 AFR is ratiometric 0V to 5V 7.35 AFR to 22.39 AFR              (CONVERT_ATD0)
                                      ;   ( All variables are multiplied by 10 for greater precision)                  (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004714 7F4714 CC 00 00                    ldd  #$0000      ; Load double accumulator with decimal 0 (0 volt ADC) ( x 10) (CONVERT_ATD0)
004717 7F4717 3B                          pshd             ; Push to stack (V1)                                        (CONVERT_ATD0)
004718 7F4718 FC 10 7E                    ldd  egoAdc1      ; Load double accumulator with "egoAdc1"                   (CONVERT_ATD0)
00471B 7F471B CD 00 0A                    ldy  #$000A      ; Load index register Y with decimal 10                     (CONVERT_ATD0)
00471E 7F471E 13                          emul             ; Multiply (D)x(Y)=>Y:D  (multiply "eopAdc" by 10)          (CONVERT_ATD0)
00471F 7F471F 3B                          pshd             ; Push to stack (V)                                         (CONVERT_ATD0)
004720 7F4720 CC 27 F6                    ldd  #$27F6      ; Load double accumulator with decimal 1023 (5 volt ADC) ( x 10) (10230) (CONVERT_ATD0)
004723 7F4723 3B                          pshd             ; Push to stack (V2)                                        (CONVERT_ATD0)
004724 7F4724 CC 00 4A                    ldd  #$004A      ; Load double accumulator with decimal 7.35 (Low range AFR) ( x 10) (74) (CONVERT_ATD0)
004727 7F4727 3B                          pshd             ; Push to stack (Z1)                                        (CONVERT_ATD0)
004728 7F4728 CC 00 E0                    ldd  #$00E0      ; Load double accumulator with decimal 22.39 (High range AFR) ( x 10) (224) (CONVERT_ATD0)
00472B 7F472B 3B                          pshd             ; Push to stack (Z2)                                        (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z2       |  SP+ 0                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z1       |  SP+ 2                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V2       |  SP+ 4                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V        |  SP+ 6                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V1       |  SP+ 8                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                      ;                     V      V1      V2      Z1    Z2                            (CONVERT_ATD0)
00472C 7F472C MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; ==========================                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CONVERT_ATD0/2D_IPOL)
                                      ; SSTACK: none                                                                   (CONVERT_ATD0/2D_IPOL)
                                      ;         no registers are preserved                                             (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    ^ V                                                                         (CONVERT_ATD0/2D_IPOL)
                                      ;    |                                                                           (CONVERT_ATD0/2D_IPOL)
                                      ;  Z2+....................*                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;    |                    :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CONVERT_ATD0/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CONVERT_ATD0/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CONVERT_ATD0/2D_IPOL)
                                      ;    |   :       :        :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
00472C 7F472C EC 86                                   LDD       \1    ; load V                                         (CONVERT_ATD0/2D_IPOL)
00472E 7F472E A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004730 7F4730 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004732 7F4732 EC 80                                   LDD       \5    ; load Z2                                        (CONVERT_ATD0/2D_IPOL)
004734 7F4734 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004736 7F4736 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CONVERT_ATD0/2D_IPOL)
004738 7F4738 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
00473A 7F473A EC 84                                   LDD       \3    ; load V2                                        (CONVERT_ATD0/2D_IPOL)
00473C 7F473C A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
00473E 7F473E B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CONVERT_ATD0/2D_IPOL)
                                      ;*********************************************************************           (CONVERT_ATD0/2D_IPOL)
004740 7F4740 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CONVERT_ATD0/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CONVERT_ATD0/2D_IPOL)
004742 7F4742 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004744 7F4744 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Free stack space (result in D)                                               (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004746 7F4746 1B 8A                       leas  10,SP       ; Stack pointer -> bottom of stack                         (CONVERT_ATD0)
004748 7F4748 7C 10 80                    std   afr1x10     ; Copy result to "afr1x10" Air Fuel Ratio x 10             (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Barometric Pressure x 10(Used to calculate to 1 decimal place)     (CONVERT_ATD0)
                                      ;   Baro sensor MPXA6115AC7U                                                     (CONVERT_ATD0)
                                      ;   Vout = Baro sensor output voltage                                            (CONVERT_ATD0)
                                      ;   P = Barometric pressure in KPA                                               (CONVERT_ATD0)
                                      ;                                                                                (CONVERT_ATD0)
                                      ;   Vout = Vs x (0.009 x P - 0.095)                                              (CONVERT_ATD0)
                                      ;   Vout = (baroAdc/1023)*5                                                      (CONVERT_ATD0)
                                      ;   P = ((Vout/5)+0.095)/0.009                                                   (CONVERT_ATD0)
                                      ; - For integer math:                                                            (CONVERT_ATD0)
                                      ;   P x 10 = ((baroAdc*10,000)/1023)+950)/9                                      (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
00474B 7F474B FC 10 82                    ldd   baroAdc       ; Load double accumulator with value in "baroAdc"        (CONVERT_ATD0)
00474E 7F474E CD 27 10                    ldy   #$2710        ; Load index register Y with decimal decimal 10,000      (CONVERT_ATD0)
004751 7F4751 13                          emul                ; Extended 16x16 multiply (D)x(Y)=Y:D                    (CONVERT_ATD0)
004752 7F4752 CE 03 FF                    ldx   #$03FF        ; Load index register X with decimal 1023                (CONVERT_ATD0)
004755 7F4755 11                          ediv                ; Extended 32x16 divide(Y:D)/(X)=Y;Rem->D                (CONVERT_ATD0)
004756 7F4756 18 CB 03 B6                 addy  #$03B6        ; Add without carry decimal 950 to Y (Y)+(M:M+1)->(Y)    (CONVERT_ATD0)
00475A 7F475A B7 64                       tfr   Y,D           ; Copy value in "Y" to "D"                               (CONVERT_ATD0)
00475C 7F475C CE 00 09                    ldx   #$0009        ; Load index register "X" with decimal 9                 (CONVERT_ATD0)
00475F 7F475F 18 10                       idiv                ; Integer divide (D)/(X)=>X Rem=>D                       (CONVERT_ATD0)
004761 7F4761 7E 10 84                    stx   Barox10        ; Copy result to "Barox10" (KPAx10)                     (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Engine Oil Pressure x 10 -                                         (CONVERT_ATD0)
                                      ;   Pressure transducer is ratiometric 1V to 5V 0PSI to 100PSI                   (CONVERT_ATD0)
                                      ;   ( All variables are multiplied by 10 for greater precision)                  (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004764 7F4764 CC 08 02                    ldd  #$0802      ; Load double accumulator with decimal 205 (1 volt ADC) ( x 10) (CONVERT_ATD0)
004767 7F4767 3B                          pshd             ; Push to stack (V1)                                        (CONVERT_ATD0)
004768 7F4768 FC 10 86                    ldd  eopAdc      ; Load double accumulator with "eopAdc"                     (CONVERT_ATD0)
00476B 7F476B CD 00 0A                    ldy  #$000A      ; Load index register Y with decimal 10                     (CONVERT_ATD0)
00476E 7F476E 13                          emul             ; Multiply (D)x(Y)=>Y:D  (multiply "eopAdc" by 10)          (CONVERT_ATD0)
00476F 7F476F 3B                          pshd             ; Push to stack (V)                                         (CONVERT_ATD0)
004770 7F4770 CC 27 F6                    ldd  #$27F6      ; Load double accumulator with decimal 1023 (5 volt ADC) ( x 10) (CONVERT_ATD0)
004773 7F4773 3B                          pshd             ; Push to stack (V2)                                        (CONVERT_ATD0)
004774 7F4774 CC 00 00                    ldd  #$0000      ; Load double accumulator with decimal 0 (Low range PSI) ( x 10) (CONVERT_ATD0)
004777 7F4777 3B                          pshd             ; Push to stack (Z1)                                        (CONVERT_ATD0)
004778 7F4778 CC 03 E8                    ldd  #$03E8      ; Load double accumulator with decimal 100 (High range PSI) ( x 10) (CONVERT_ATD0)
00477B 7F477B 3B                          pshd             ; Push to stack (Z2)                                        (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z2       |  SP+ 0                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z1       |  SP+ 2                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V2       |  SP+ 4                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V        |  SP+ 6                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V1       |  SP+ 8                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                      ;                     V      V1      V2      Z1    Z2                            (CONVERT_ATD0)
00477C 7F477C MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; ==========================                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CONVERT_ATD0/2D_IPOL)
                                      ; SSTACK: none                                                                   (CONVERT_ATD0/2D_IPOL)
                                      ;         no registers are preserved                                             (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    ^ V                                                                         (CONVERT_ATD0/2D_IPOL)
                                      ;    |                                                                           (CONVERT_ATD0/2D_IPOL)
                                      ;  Z2+....................*                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;    |                    :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CONVERT_ATD0/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CONVERT_ATD0/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CONVERT_ATD0/2D_IPOL)
                                      ;    |   :       :        :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
00477C 7F477C EC 86                                   LDD       \1    ; load V                                         (CONVERT_ATD0/2D_IPOL)
00477E 7F477E A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004780 7F4780 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004782 7F4782 EC 80                                   LDD       \5    ; load Z2                                        (CONVERT_ATD0/2D_IPOL)
004784 7F4784 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004786 7F4786 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CONVERT_ATD0/2D_IPOL)
004788 7F4788 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
00478A 7F478A EC 84                                   LDD       \3    ; load V2                                        (CONVERT_ATD0/2D_IPOL)
00478C 7F478C A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
00478E 7F478E B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CONVERT_ATD0/2D_IPOL)
                                      ;*********************************************************************           (CONVERT_ATD0/2D_IPOL)
004790 7F4790 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CONVERT_ATD0/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CONVERT_ATD0/2D_IPOL)
004792 7F4792 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004794 7F4794 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Free stack space (result in D)                                               (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004796 7F4796 1B 8A                       leas  10,SP    ; Stack pointer -> bottom of stack                            (CONVERT_ATD0)
004798 7F4798 7C 10 88                    std   Eopx10   ; Copy result to "Eopx10" Engine Oil Pressure x 10            (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Engine Fuel Pressure x 10 -                                        (CONVERT_ATD0)
                                      ;   Pressure transducer is ratiometric 1V to 5V 0PSI to 100PSI                   (CONVERT_ATD0)
                                      ;   ( All variables are multiplied by 10 for greater precision)                  (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
00479B 7F479B CC 08 02                    ldd  #$0802      ; Load double accumulator with decimal 205 (1 volt ADC) ( x 10) (CONVERT_ATD0)
00479E 7F479E 3B                          pshd             ; Push to stack (V1)                                        (CONVERT_ATD0)
00479F 7F479F FC 10 8A                    ldd  efpAdc      ; Load double accumulator with "efpAdc"                     (CONVERT_ATD0)
0047A2 7F47A2 CD 00 0A                    ldy  #$000A      ; Load index register Y with decimal 10                     (CONVERT_ATD0)
0047A5 7F47A5 13                          emul             ; Multiply (D)x(Y)=>Y:D  (multiply "eopAdc" by 10)          (CONVERT_ATD0)
0047A6 7F47A6 3B                          pshd             ; Push to stack (V)                                         (CONVERT_ATD0)
0047A7 7F47A7 CC 27 F6                    ldd  #$27F6      ; Load double accumulator with decimal 1023 (5 volt ADC) ( x 10) (CONVERT_ATD0)
0047AA 7F47AA 3B                          pshd             ; Push to stack (V2)                                        (CONVERT_ATD0)
0047AB 7F47AB CC 00 00                    ldd  #$0000      ; Load double accumulator with decimal 0 (Low range PSI) ( x 10) (CONVERT_ATD0)
0047AE 7F47AE 3B                          pshd             ; Push to stack (Z1)                                        (CONVERT_ATD0)
0047AF 7F47AF CC 03 E8                    ldd  #$03E8      ; Load double accumulator with decimal 100 (High range PSI) ( x 10) (CONVERT_ATD0)
0047B2 7F47B2 3B                          pshd             ; Push to stack (Z2)                                        (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z2       |  SP+ 0                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z1       |  SP+ 2                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V2       |  SP+ 4                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V        |  SP+ 6                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V1       |  SP+ 8                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                      ;                     V      V1      V2      Z1    Z2                            (CONVERT_ATD0)
0047B3 7F47B3 MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; ==========================                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CONVERT_ATD0/2D_IPOL)
                                      ; SSTACK: none                                                                   (CONVERT_ATD0/2D_IPOL)
                                      ;         no registers are preserved                                             (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    ^ V                                                                         (CONVERT_ATD0/2D_IPOL)
                                      ;    |                                                                           (CONVERT_ATD0/2D_IPOL)
                                      ;  Z2+....................*                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;    |                    :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CONVERT_ATD0/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CONVERT_ATD0/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CONVERT_ATD0/2D_IPOL)
                                      ;    |   :       :        :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
0047B3 7F47B3 EC 86                                   LDD       \1    ; load V                                         (CONVERT_ATD0/2D_IPOL)
0047B5 7F47B5 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
0047B7 7F47B7 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
0047B9 7F47B9 EC 80                                   LDD       \5    ; load Z2                                        (CONVERT_ATD0/2D_IPOL)
0047BB 7F47BB A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
0047BD 7F47BD 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CONVERT_ATD0/2D_IPOL)
0047BF 7F47BF B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
0047C1 7F47C1 EC 84                                   LDD       \3    ; load V2                                        (CONVERT_ATD0/2D_IPOL)
0047C3 7F47C3 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
0047C5 7F47C5 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CONVERT_ATD0/2D_IPOL)
                                      ;*********************************************************************           (CONVERT_ATD0/2D_IPOL)
0047C7 7F47C7 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CONVERT_ATD0/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CONVERT_ATD0/2D_IPOL)
0047C9 7F47C9 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
0047CB 7F47CB E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Free stack space (result in D)                                               (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
0047CD 7F47CD 1B 8A                       leas  10,SP    ; Stack pointer -> bottom of stack                            (CONVERT_ATD0)
0047CF 7F47CF 7C 10 8C                    std   Efpx10   ; Copy result to "Efpx10" Engine Fuel Pressure x 10           (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Ignition Trim (Degrees x 10)(+-20 Degrees) -                       (CONVERT_ATD0)
                                      ;   Ignition calculations delay the coil energisation time (dwell) and the discharge time (CONVERT_ATD0)
                                      ;   (spark timing) from a known crankshaft angle. A trim offset of 20 degrees is built in. (CONVERT_ATD0)
                                      ;    An Itrm value of 0 results in 20 degree retard                              (CONVERT_ATD0)
                                      ;    An Itrm value of 20 results in no ignition trim                             (CONVERT_ATD0)
                                      ;    An Itrm value of 40 results in 20 degree advance                            (CONVERT_ATD0)
                                      ;   ( All variables are multiplied by 10 for greater precision)                  (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
0047D2 7F47D2 1E 10 DC 02 39              brset PortAbits,Itrimen,NoItrim ; "If Itrimen" bit of "PortAbits" is set, branch to (CONVERT_ATD0)
                                                               ; NoItrim: (Ignition trim enable switch is off so skip over) (CONVERT_ATD0)
0047D7 7F47D7 CC 00 00                    ldd  #$0000      ; Load double accumulator with zero (0 volt ADC)            (CONVERT_ATD0)
0047DA 7F47DA 3B                          pshd             ; Push to stack (V1)                                        (CONVERT_ATD0)
0047DB 7F47DB FC 10 8E                    ldd  itrmAdc     ; Load double accumulator with "itrmAdc"                    (CONVERT_ATD0)
0047DE 7F47DE CD 00 0A                    ldy  #$000A      ; Load index register Y with decimal 10                     (CONVERT_ATD0)
0047E1 7F47E1 13                          emul             ; Multiply (D)x(Y)=>Y:D  (multiply "itrmAdc" by 10)         (CONVERT_ATD0)
0047E2 7F47E2 3B                          pshd             ; Push to stack (V)                                         (CONVERT_ATD0)
0047E3 7F47E3 CC 27 F6                    ldd  #$27F6      ; Load double accumulator with decimal 1023x10 (5 volt ADC) (CONVERT_ATD0)
0047E6 7F47E6 3B                          pshd             ; Push to stack (V2)                                        (CONVERT_ATD0)
0047E7 7F47E7 CC 00 00                    ldd  #$0000      ; Load double accumulator with zero (Low range degrees)     (CONVERT_ATD0)
0047EA 7F47EA 3B                          pshd             ; Push to stack (Z1)                                        (CONVERT_ATD0)
0047EB 7F47EB CC 01 90                    ldd  #$0190      ; Load double accumulator with decimal 40x10 (High range degrees) (CONVERT_ATD0)
0047EE 7F47EE 3B                          pshd             ; Push to stack (Z2)                                        (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z2       |  SP+ 0                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z1       |  SP+ 2                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V2       |  SP+ 4                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V        |  SP+ 6                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V1       |  SP+ 8                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                      ;                     V      V1      V2      Z1    Z2                            (CONVERT_ATD0)
0047EF 7F47EF MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; ==========================                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CONVERT_ATD0/2D_IPOL)
                                      ; SSTACK: none                                                                   (CONVERT_ATD0/2D_IPOL)
                                      ;         no registers are preserved                                             (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    ^ V                                                                         (CONVERT_ATD0/2D_IPOL)
                                      ;    |                                                                           (CONVERT_ATD0/2D_IPOL)
                                      ;  Z2+....................*                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;    |                    :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CONVERT_ATD0/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CONVERT_ATD0/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CONVERT_ATD0/2D_IPOL)
                                      ;    |   :       :        :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
0047EF 7F47EF EC 86                                   LDD       \1    ; load V                                         (CONVERT_ATD0/2D_IPOL)
0047F1 7F47F1 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
0047F3 7F47F3 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
0047F5 7F47F5 EC 80                                   LDD       \5    ; load Z2                                        (CONVERT_ATD0/2D_IPOL)
0047F7 7F47F7 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
0047F9 7F47F9 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CONVERT_ATD0/2D_IPOL)
0047FB 7F47FB B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
0047FD 7F47FD EC 84                                   LDD       \3    ; load V2                                        (CONVERT_ATD0/2D_IPOL)
0047FF 7F47FF A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004801 7F4801 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CONVERT_ATD0/2D_IPOL)
                                      ;*********************************************************************           (CONVERT_ATD0/2D_IPOL)
004803 7F4803 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CONVERT_ATD0/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CONVERT_ATD0/2D_IPOL)
004805 7F4805 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004807 7F4807 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Free stack space (result in D)                                               (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004809 7F4809 1B 8A                       leas  10,SP     ; Stack pointer -> bottom of stack                           (CONVERT_ATD0)
00480B 7F480B 7C 10 90                    std   Itrmx10   ; Copy result to "Itrmx10" Ignition Trim (Degrees x 10)      (CONVERT_ATD0)
00480E 7F480E 20 06                           bra   ItrimDone ; Branch to ItrimDone:                                   (CONVERT_ATD0)
004810 7F4810                         NoItrim:                                                                         (CONVERT_ATD0)
004810 7F4810 18 03 00 CB 10 90           movw #$00CB,Itrmx10  ; Decimal 200 -> "Itrmx10" (20 degrees, no trim)        (CONVERT_ATD0)
004816 7F4816                         ItrimDone:                                                                       (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Fuel Trim (% x 10)(+-20%) -                                        (CONVERT_ATD0)
                                      ;   (80% = 80% of VEcurr, 100% = 100% of VeCurr(no correction), 120% = 120% of VEcurr) (CONVERT_ATD0)
                                      ;   ( All variables are multiplied by 10 for greater precision)                  (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004816 7F4816 1E 10 DC 04 39              brset PortAbits,Ftrimen,NoFtrim ; "If Ftrimen" bit of "PortAbits" set, branch to (CONVERT_ATD0)
                                                                ; NoFtrim: (Fuel trim enable switch is off so skip over) (CONVERT_ATD0)
00481B 7F481B CC 00 00                    ldd   #$0000      ; Load double accumulator with zero (0 volt ADC)           (CONVERT_ATD0)
00481E 7F481E 3B                          pshd              ; Push to stack (V1)                                       (CONVERT_ATD0)
00481F 7F481F FC 10 92                    ldd   ftrmAdc     ; Load double accumulator with "ftrmAdc"                   (CONVERT_ATD0)
004822 7F4822 CD 00 0A                    ldy   #$000A      ; Load index register Y with decimal 10                    (CONVERT_ATD0)
004825 7F4825 13                          emul              ; Multiply (D)x(Y)=>Y:D  (multiply "eopAdc" by 10)         (CONVERT_ATD0)
004826 7F4826 3B                          pshd              ; Push to stack (V)                                        (CONVERT_ATD0)
004827 7F4827 CC 27 F6                    ldd   #$27F6      ; Load double accumulator with decimal 1023x10 (5 volt ADC) (CONVERT_ATD0)
00482A 7F482A 3B                          pshd              ; Push to stack (V2)                                       (CONVERT_ATD0)
00482B 7F482B CC 03 20                    ldd   #$0320      ; Load double accumulator with decimal 80x10 (Low range %) (CONVERT_ATD0)
00482E 7F482E 3B                          pshd              ; Push to stack (Z1)                                       (CONVERT_ATD0)
00482F 7F482F CC 04 B0                    ldd   #$04B0      ; Load double accumulator with decimal 120x10 (High range %) (CONVERT_ATD0)
004832 7F4832 3B                          pshd              ; Push to stack (Z2)                                       (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z2       |  SP+ 0                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z1       |  SP+ 2                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V2       |  SP+ 4                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V        |  SP+ 6                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V1       |  SP+ 8                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                      ;                     V      V1      V2      Z1    Z2                            (CONVERT_ATD0)
004833 7F4833 MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; ==========================                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CONVERT_ATD0/2D_IPOL)
                                      ; SSTACK: none                                                                   (CONVERT_ATD0/2D_IPOL)
                                      ;         no registers are preserved                                             (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    ^ V                                                                         (CONVERT_ATD0/2D_IPOL)
                                      ;    |                                                                           (CONVERT_ATD0/2D_IPOL)
                                      ;  Z2+....................*                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;    |                    :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CONVERT_ATD0/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CONVERT_ATD0/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CONVERT_ATD0/2D_IPOL)
                                      ;    |   :       :        :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004833 7F4833 EC 86                                   LDD       \1    ; load V                                         (CONVERT_ATD0/2D_IPOL)
004835 7F4835 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004837 7F4837 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004839 7F4839 EC 80                                   LDD       \5    ; load Z2                                        (CONVERT_ATD0/2D_IPOL)
00483B 7F483B A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
00483D 7F483D 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CONVERT_ATD0/2D_IPOL)
00483F 7F483F B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004841 7F4841 EC 84                                   LDD       \3    ; load V2                                        (CONVERT_ATD0/2D_IPOL)
004843 7F4843 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004845 7F4845 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CONVERT_ATD0/2D_IPOL)
                                      ;*********************************************************************           (CONVERT_ATD0/2D_IPOL)
004847 7F4847 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CONVERT_ATD0/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CONVERT_ATD0/2D_IPOL)
004849 7F4849 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
00484B 7F484B E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Free stack space (result in D)                                               (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
00484D 7F484D 1B 8A                       leas  10,SP     ; Stack pointer -> bottom of stack                           (CONVERT_ATD0)
00484F 7F484F 7C 10 94                    std   Ftrmx10   ; Copy result to "Ftrmx10" Fuel Trim (%x10)                  (CONVERT_ATD0)
004852 7F4852 20 06                           bra   FtrimDone ; Branch to FtrimDone:                                   (CONVERT_ATD0)
004854 7F4854                         NoFtrim:                                                                         (CONVERT_ATD0)
004854 7F4854 18 03 03 E8 10 94           movw #$03E8,Ftrmx10  ; Decimal 1000 -> "Ftrmx10" (100%, no trim)             (CONVERT_ATD0)
00485A 7F485A                         FtrimDone:                                                                       (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Air Fuel Ratio x 10 for right bank (even cylinders)-               (CONVERT_ATD0)
                                      ;   Innovate LC-2 AFR is ratiometric 0V to 5V 7.35 AFR to 22.39 AFR              (CONVERT_ATD0)
                                      ;   ( All variables are multiplied by 10 for greater precision)                  (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
00485A 7F485A CC 00 00                    ldd  #$0000      ; Load double accumulator with decimal 0 (0 volt ADC) ( x 10) (CONVERT_ATD0)
00485D 7F485D 3B                          pshd             ; Push to stack (V1)                                        (CONVERT_ATD0)
00485E 7F485E FC 10 96                    ldd  egoAdc2     ; Load double accumulator with "egoAdc2"                    (CONVERT_ATD0)
004861 7F4861 CD 00 0A                    ldy  #$000A      ; Load index register Y with decimal 10                     (CONVERT_ATD0)
004864 7F4864 13                          emul             ; Multiply (D)x(Y)=>Y:D  (multiply "eopAdc" by 10)          (CONVERT_ATD0)
004865 7F4865 3B                          pshd             ; Push to stack (V)                                         (CONVERT_ATD0)
004866 7F4866 CC 27 F6                    ldd  #$27F6      ; Load double accumulator with decimal 1023 (5 volt ADC) ( x 10) (10230) (CONVERT_ATD0)
004869 7F4869 3B                          pshd             ; Push to stack (V2)                                        (CONVERT_ATD0)
00486A 7F486A CC 00 4A                    ldd  #$004A      ; Load double accumulator with decimal 7.35 (Low range AFR) ( x 10) (74) (CONVERT_ATD0)
00486D 7F486D 3B                          pshd             ; Push to stack (Z1)                                        (CONVERT_ATD0)
00486E 7F486E CC 00 E0                    ldd  #$00E0      ; Load double accumulator with decimal 22.39 (High range AFR) ( x 10) (224) (CONVERT_ATD0)
004871 7F4871 3B                          pshd             ; Push to stack (Z2)                                        (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z2       |  SP+ 0                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z1       |  SP+ 2                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V2       |  SP+ 4                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V        |  SP+ 6                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V1       |  SP+ 8                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                      ;                     V      V1      V2      Z1    Z2                            (CONVERT_ATD0)
004872 7F4872 MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; ==========================                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CONVERT_ATD0/2D_IPOL)
                                      ; SSTACK: none                                                                   (CONVERT_ATD0/2D_IPOL)
                                      ;         no registers are preserved                                             (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    ^ V                                                                         (CONVERT_ATD0/2D_IPOL)
                                      ;    |                                                                           (CONVERT_ATD0/2D_IPOL)
                                      ;  Z2+....................*                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;    |                    :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CONVERT_ATD0/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CONVERT_ATD0/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CONVERT_ATD0/2D_IPOL)
                                      ;    |   :       :        :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004872 7F4872 EC 86                                   LDD       \1    ; load V                                         (CONVERT_ATD0/2D_IPOL)
004874 7F4874 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004876 7F4876 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004878 7F4878 EC 80                                   LDD       \5    ; load Z2                                        (CONVERT_ATD0/2D_IPOL)
00487A 7F487A A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
00487C 7F487C 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CONVERT_ATD0/2D_IPOL)
00487E 7F487E B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004880 7F4880 EC 84                                   LDD       \3    ; load V2                                        (CONVERT_ATD0/2D_IPOL)
004882 7F4882 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004884 7F4884 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CONVERT_ATD0/2D_IPOL)
                                      ;*********************************************************************           (CONVERT_ATD0/2D_IPOL)
004886 7F4886 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CONVERT_ATD0/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CONVERT_ATD0/2D_IPOL)
004888 7F4888 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
00488A 7F488A E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Free stack space (result in D)                                               (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
00488C 7F488C 1B 8A                       leas  10,SP       ; Stack pointer -> bottom of stack                         (CONVERT_ATD0)
00488E 7F488E 7C 10 98                    std   afr2x10     ; Copy result to "afr2x10" Air Fuel Ratio x 10             (CONVERT_ATD0)
                                      ;*****************************************************************************************
                                      ; - Calculate values at Z1 and Z2 to interpolate injector deadband at current battery
                                      ;   voltage. This is done before entering the main loop as will only change if the
                                      ;   configurable constants for injector dead time and battery voltage correction have
                                      ;   been changed.
                                      ;*****************************************************************************************
004891 7F4891 MACRO                       DEADBAND_Z1_Z2   ; Macro in injcalcs_BPEM488.s
                                      ;***************************************************************************************** (DEADBAND_Z1_Z2)
                                      ; - Injector dead band is the time required for the injectors to open and close and must (DEADBAND_Z1_Z2)
                                      ;   be included in the pulse width time. The amount of time will depend on battery voltge. (DEADBAND_Z1_Z2)
                                      ;   Battery voltage correction for injector deadband is calculated as a linear function (DEADBAND_Z1_Z2)
                                      ;   of battery voltage from 7.2 volts to 19.2 volts with 13.2 volts being the nominal (DEADBAND_Z1_Z2)
                                      ;   operating voltage where no correction is applied.                            (DEADBAND_Z1_Z2)
                                      ;***************************************************************************************** (DEADBAND_Z1_Z2)
                                      ;***************************************************************************************** (DEADBAND_Z1_Z2)
                                      ; - Calculate values at Z1 and Z2 to interpolate injector deadband at current battery (DEADBAND_Z1_Z2)
                                      ;   voltage. This is done before entering the main loop as will only change if the (DEADBAND_Z1_Z2)
                                      ;   configurable constants for injector dead time and battery voltage correction have (DEADBAND_Z1_Z2)
                                      ;   been changed.                                                                (DEADBAND_Z1_Z2)
                                      ;***************************************************************************************** (DEADBAND_Z1_Z2)
                                      ;***************************************************************************************** (DEADBAND_Z1_Z2)
                                      ;                                                                                (DEADBAND_Z1_Z2)
                                      ;  V1 = 72 (7.2 volts)                                                           (DEADBAND_Z1_Z2)
                                      ;  V  = BatVx10 (current battery voltage x 10)                                   (DEADBAND_Z1_Z2)
                                      ;  V2 = 192 (19.2volts)                                                          (DEADBAND_Z1_Z2)
                                      ;  Z1 = DdBndBase - (DdBBndCor * 6)                                              (DEADBAND_Z1_Z2)
                                      ;  Z  = unknown (deadband)                                                       (DEADBAND_Z1_Z2)
                                      ;  Z2 = DdBndBase + (DdBBndCor * 6)                                              (DEADBAND_Z1_Z2)
                                      ;                                                                                (DEADBAND_Z1_Z2)
                                      ;    |                                                                           (DEADBAND_Z1_Z2)
                                      ;  Z2+....................*                                                      (DEADBAND_Z1_Z2)
                                      ;    |                    :                                                      (DEADBAND_Z1_Z2)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (DEADBAND_Z1_Z2)
                                      ;    |           :        :        Z = Z1 + --------------                       (DEADBAND_Z1_Z2)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (DEADBAND_Z1_Z2)
                                      ;    |   :       :        :                                                      (DEADBAND_Z1_Z2)
                                      ;   -+---+-------+--------+-                                                     (DEADBAND_Z1_Z2)
                                      ;    |   V1      V        V2                                                     (DEADBAND_Z1_Z2)
                                      ;                                                                                (DEADBAND_Z1_Z2)
                                      ;***************************************************************************************** (DEADBAND_Z1_Z2)
                                      ;***************************************************************************************** (DEADBAND_Z1_Z2)
                                      ; - Calculate values at Z1 and Z2                                                (DEADBAND_Z1_Z2)
                                      ; DdBndBase_F = 90 (.9 mSec)                                                     (DEADBAND_Z1_Z2)
                                      ; DdBndCor_F = 18 (.18 mSec/V)                                                   (DEADBAND_Z1_Z2)
                                      ;***************************************************************************************** (DEADBAND_Z1_Z2)
004891 7F4891 18 0B FF 00 17                  movb   #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE              (DEADBAND_Z1_Z2)
004896 7F4896 CD 08 00                    ldy    #veBins_E    ; Load index register Y with address of first configurable (DEADBAND_Z1_Z2)
                                                              ; constant on buffer RAM page 1 (veBins_E)               (DEADBAND_Z1_Z2)
004899 7F4899 EC EA 03 CC                 ldd    $03CC,Y      ; Load Accu A with value in buffer RAM page 1 offset 972 (DEADBAND_Z1_Z2)
                                                              ; Injector deadband at 13.2V (mSec*10)(DdBndBase_F)      (DEADBAND_Z1_Z2)
00489D 7F489D 7C 10 F1                    std    tmp1w        ; Copy to "tmp1w" (Injector deadband at 13.2V (mSec * 100)) (DEADBAND_Z1_Z2)
0048A0 7F48A0 18 0B FF 00 17                  movb   #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE              (DEADBAND_Z1_Z2)
0048A5 7F48A5 CD 08 00                    ldy    #veBins_E    ; Load index register Y with address of first configurable (DEADBAND_Z1_Z2)
                                                              ; constant on buffer RAM page 1 (veBins_E)               (DEADBAND_Z1_Z2)
0048A8 7F48A8 EC EA 03 CE                 ldd    $03CE,Y      ; Load Accu A with value in buffer RAM page 1 offset 974 (DEADBAND_Z1_Z2)
                                                              ; Injector deadband voltage correction (mSec/V x 100)(DdBndCor_F) (DEADBAND_Z1_Z2)
0048AC 7F48AC 7C 10 F3                    std    tmp2w        ; Copy to "tmp2w"                                        (DEADBAND_Z1_Z2)
0048AF 7F48AF CD 00 06                    ldy    #$06         ; Decimal 6-> Accu Y                                     (DEADBAND_Z1_Z2)
0048B2 7F48B2 13                              emul                ; (D)*(Y)->Y:D "Injector deadband voltage correction" * 6 (DEADBAND_Z1_Z2)
0048B3 7F48B3 7C 10 F5                        std    tmp3w        ;("Injector deadband voltage correction" * 6)-> tmp3w (DEADBAND_Z1_Z2)
0048B6 7F48B6 F3 10 F1                        addd   tmp1w        ; A:B)+((M:M+1)->A:B  (Injector deadband at 13.2V + (Injector deadband (DEADBAND_Z1_Z2)
                                                                  ; voltage correction * 6)                            (DEADBAND_Z1_Z2)
0048B9 7F48B9 7C 10 49                        std   DdBndZ2       ; Copy result to "DdBndZ2"                           (DEADBAND_Z1_Z2)
0048BC 7F48BC FC 10 F1                    ldd   tmp1w         ; (Injector deadband at 13.2V)-> Accu A                  (DEADBAND_Z1_Z2)
0048BF 7F48BF B3 10 F5                    subd  tmp3w         ;  A:B)-((M:M+1)->A:B  ((Injector deadband at 13.2V) -   (DEADBAND_Z1_Z2)
                                                                  ; (Injector deadband voltage correction * 6))        (DEADBAND_Z1_Z2)
0048C2 7F48C2 2A 05                       bpl   NotMinus      ; N bit = 0 so not a minus result, branch to NotMinus:   (DEADBAND_Z1_Z2)
0048C4 7F48C4 79 10 47                    clr   DdBndZ1       ; Result is minus so clear "DdBndZ1"                     (DEADBAND_Z1_Z2)
0048C7 7F48C7 20 03                       bra   WasMinus      ; Branch to WasMinus: (skip over)                        (DEADBAND_Z1_Z2)
0048C9 7F48C9                         NotMinus:                                                                        (DEADBAND_Z1_Z2)
0048C9 7F48C9 7A 10 47                    staa  DdBndZ1       ; Copy result to "DdBndZ1"                               (DEADBAND_Z1_Z2)
0048CC 7F48CC                         WasMinus:                                                                        (DEADBAND_Z1_Z2)
                                      ;*****************************************************************************************
                                      ; - Injector dead band is the time required for the injectors to open and close and must
                                      ;   be included in the pulse width time. The amount of time will depend on battery voltge.
                                      ;   Battery voltage correction for injector deadband is calculated as a linear function
                                      ;   of battery voltage from 7.2 volts to 19.2 volts with 13.2 volts being the nominal
                                      ;   operating voltage where no correction is applied.
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Interpolate injector deadband at current battery voltage
                                      ;*****************************************************************************************
0048CC 7F48CC MACRO                       DEADBAND_CALCS   ; Macro in injcalcs_BPEM488.s
                                      ;***************************************************************************************** (DEADBAND_CALCS)
                                      ; - Interpolate injector deadband at current battery voltage                     (DEADBAND_CALCS)
                                      ;***************************************************************************************** (DEADBAND_CALCS)
0048CC 7F48CC CC 00 48                    ldd  #$0048      ; Decimal 72 (7.2 volts) -> Accu D                          (DEADBAND_CALCS)
0048CF 7F48CF 3B                          pshd             ; Push to stack (V1)                                        (DEADBAND_CALCS)
0048D0 7F48D0 FC 10 68                    ldd  BatVx10     ; "BatVx10"(battery volts x 10) -> Accu D                   (DEADBAND_CALCS)
0048D3 7F48D3 3B                          pshd             ; Push to stack (V)                                         (DEADBAND_CALCS)
0048D4 7F48D4 CC 00 C0                    ldd  #$00C0      ; Decimal 192 (19.2 volts) -> Accu D                        (DEADBAND_CALCS)
0048D7 7F48D7 3B                          pshd             ; Push to stack (V2)                                        (DEADBAND_CALCS)
0048D8 7F48D8 FC 10 49                        ldd  DdBndZ2     ;((Injector deadband at 13.2V) + (Injector deadband voltage (DEADBAND_CALCS)
                                                               ; correction * 6)) -> Accu D                            (DEADBAND_CALCS)
0048DB 7F48DB 3B                          pshd             ; Push to stack (Z1)                                        (DEADBAND_CALCS)
0048DC 7F48DC FC 10 47                        ldd  DdBndZ1     ;((Injector deadband at 13.2V) - (Injector deadband voltage (DEADBAND_CALCS)
                                                               ; correction * 6)) -> Accu D                            (DEADBAND_CALCS)
0048DF 7F48DF 3B                          pshd             ; Push to stack (Z2)                                        (DEADBAND_CALCS)
                                      ;***************************************************************************************** (DEADBAND_CALCS)
                                                      ;    +--------+--------+                                         (DEADBAND_CALCS)
                                                      ;    |        Z2       |  SP+ 0                                  (DEADBAND_CALCS)
                                                      ;    +--------+--------+                                         (DEADBAND_CALCS)
                                                      ;    |        Z1       |  SP+ 2                                  (DEADBAND_CALCS)
                                                      ;    +--------+--------+                                         (DEADBAND_CALCS)
                                                      ;    |        V2       |  SP+ 4                                  (DEADBAND_CALCS)
                                                      ;    +--------+--------+                                         (DEADBAND_CALCS)
                                                      ;    |        V        |  SP+ 6                                  (DEADBAND_CALCS)
                                                      ;    +--------+--------+                                         (DEADBAND_CALCS)
                                                      ;    |        V1       |  SP+ 8                                  (DEADBAND_CALCS)
                                                      ;    +--------+--------+                                         (DEADBAND_CALCS)
                                      ;                     V      V1      V2      Z1    Z2                            (DEADBAND_CALCS)
0048E0 7F48E0 MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (DEADBAND_CALCS)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (DEADBAND_CALCS/2D_IPOL)
                                      ; ==========================                                                     (DEADBAND_CALCS/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (DEADBAND_CALCS/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (DEADBAND_CALCS/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (DEADBAND_CALCS/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (DEADBAND_CALCS/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (DEADBAND_CALCS/2D_IPOL)
                                      ; result: D: interpolated result                                                 (DEADBAND_CALCS/2D_IPOL)
                                      ; SSTACK: none                                                                   (DEADBAND_CALCS/2D_IPOL)
                                      ;         no registers are preserved                                             (DEADBAND_CALCS/2D_IPOL)
                                      ;                                                                                (DEADBAND_CALCS/2D_IPOL)
                                      ;    ^ V                                                                         (DEADBAND_CALCS/2D_IPOL)
                                      ;    |                                                                           (DEADBAND_CALCS/2D_IPOL)
                                      ;  Z2+....................*                                                      (DEADBAND_CALCS/2D_IPOL)
                                      ;    |                    :                                                      (DEADBAND_CALCS/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (DEADBAND_CALCS/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (DEADBAND_CALCS/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (DEADBAND_CALCS/2D_IPOL)
                                      ;    |   :       :        :                                                      (DEADBAND_CALCS/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (DEADBAND_CALCS/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (DEADBAND_CALCS/2D_IPOL)
                                      ;                                                                                (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
0048E0 7F48E0 EC 86                                   LDD       \1    ; load V                                         (DEADBAND_CALCS/2D_IPOL)
0048E2 7F48E2 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (DEADBAND_CALCS/2D_IPOL)
0048E4 7F48E4 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
0048E6 7F48E6 EC 80                                   LDD       \5    ; load Z2                                        (DEADBAND_CALCS/2D_IPOL)
0048E8 7F48E8 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
0048EA 7F48EA 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (DEADBAND_CALCS/2D_IPOL)
0048EC 7F48EC B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
0048EE 7F48EE EC 84                                   LDD       \3    ; load V2                                        (DEADBAND_CALCS/2D_IPOL)
0048F0 7F48F0 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (DEADBAND_CALCS/2D_IPOL)
0048F2 7F48F2 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (DEADBAND_CALCS/2D_IPOL)
                                      ;*********************************************************************           (DEADBAND_CALCS/2D_IPOL)
0048F4 7F48F4 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (DEADBAND_CALCS/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (DEADBAND_CALCS/2D_IPOL)
0048F6 7F48F6 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
0048F8 7F48F8 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS)
                                      ; - Free stack space (result in D)                                               (DEADBAND_CALCS)
                                      ;***************************************************************************************** (DEADBAND_CALCS)
0048FA 7F48FA 1B 8A                       leas  10,SP     ; Stack pointer -> bottom of stack                           (DEADBAND_CALCS)
0048FC 7F48FC 7C 10 F7                    std  tmp4w      ; Copy result to "tmp4w" (Injector deadband at current battery (DEADBAND_CALCS)
                                                              ; voltage) (mSec x 100)                                  (DEADBAND_CALCS)
0048FF 7F48FF FC 10 F7                    ldd  tmp4w      ; Result in "tmp4w" -> Accu D                                (DEADBAND_CALCS)
004902 7F4902 CE 00 0A                    ldx  #$000A     ; Decimal 10-> Accu X                                        (DEADBAND_CALCS)
004905 7F4905 18 10                       idiv            ; (D)/(X)->Xrem->D ("tmp4w"/10="Deadband")(mSec*10)          (DEADBAND_CALCS)
004907 7F4907 7E 10 C0                    stx  Deadband   ; Copy result to "Deadband"(mSec*10)                         (DEADBAND_CALCS)
                                      ;*****************************************************************************************
                                      ; - Energise the Fuel pump relay and the Emergency Shutdown relay on Port B Bit0
                                      ;*****************************************************************************************
00490A 7F490A MACRO                       FUEL_PUMP_AND_ASD_ON    ; Macro in gpio_BEEM488.s
                                                            ; Register (pullups enabled BKGD, Port E and Port A        (FUEL_PUMP_AND_ASD_ON)
                                      ;***************************************************************************************** (FUEL_PUMP_AND_ASD_ON)
                                      ; - Energise the Fuel pump relay and the Emergency Shutdown relay on Port B Bit0 and Bit1 (FUEL_PUMP_AND_ASD_ON)
                                      ;***************************************************************************************** (FUEL_PUMP_AND_ASD_ON)
00490A 7F490A 4C 01 01                    bset  PORTB,FuelPump  ; Set "FuelPump" pin on Port B(LED9 board 1 to 28)     (FUEL_PUMP_AND_ASD_ON)
00490D 7F490D 4C 01 02                        bset  PORTB,ASDRelay  ; Set "ASDRelay" pin on Port B(LED23 board 1 to 28) (FUEL_PUMP_AND_ASD_ON)
                                      ;*****************************************************************************************
                                      ; --------------------------------- Priming Mode ----------------------------------------
                                      ;
                                      ; On power up before entering the main loop all injectors are pulsed with a priming pulse
                                      ; to wet the intake manifold walls and provide some initial starting fuel. The injector
                                      ; pulse width is interpolated from the Prime Pulse table which plots engine temperature
                                      ; in degrees F to 0.1 degree resoluion against time in mS to 0.1mS resoluion
                                      ;
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - The ECT and TIM timers are initilized with the 5.12uS time base. This time base is
                                      ;   used for ignition calculations in crank mode as well as injector pulse width
                                      ;   calculations in prime and crank mode. In run mode the time base is swithced to 2.56uS
                                      ;   resolution for all calculations.
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Look up the value for the prime pulse width in 5.12uS resolution
                                      ;*****************************************************************************************
004910 7F4910 MACRO                       PRIME_PW_LU              ; (Macro in injcalcs_BEEM488.s)
                                      ;***************************************************************************************** (PRIME_PW_LU)
                                      ; --------------------------------- Priming Mode ---------------------------------------- (PRIME_PW_LU)
                                      ;                                                                                (PRIME_PW_LU)
                                      ; On power up before entering the main loop all injectors are pulsed with a priming pulse (PRIME_PW_LU)
                                      ; to wet the intake manifold walls and provide some initial starting fuel. The injector (PRIME_PW_LU)
                                      ; pulse width is interpolated from the Prime Pulse table which plots engine temperature (PRIME_PW_LU)
                                      ; in degrees F to 0.1 degree resoluion against time in mS to 0.1mS resoluion     (PRIME_PW_LU)
                                      ;                                                                                (PRIME_PW_LU)
                                      ;***************************************************************************************** (PRIME_PW_LU)
                                      ;***************************************************************************************** (PRIME_PW_LU)
                                      ; - Look up current value in Prime Pulsewidth Table (PrimePW)(mS x 10)           (PRIME_PW_LU)
                                      ;***************************************************************************************** (PRIME_PW_LU)
004910 7F4910 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (PRIME_PW_LU)
004915 7F4915 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (PRIME_PW_LU)
                                                                  ; ->page where the desired curve resides             (PRIME_PW_LU)
00491B 7F491B 18 03 01 90 10 27           movw #$0190,CrvRowOfst  ; 400 -> Offset from the curve page to the curve row (PRIME_PW_LU)
                                                                      ; (tempTable2)Actual offset is 800)              (PRIME_PW_LU)
004921 7F4921 18 03 01 AC 10 29           movw #$01AC,CrvColOfst  ; 428 -> Offset from the curve page to the curve column (PRIME_PW_LU)
                                                                      ; (primePWTable)(actual offset is 856)           (PRIME_PW_LU)
004927 7F4927 18 04 10 6C 10 2B           movw Cltx10,CrvCmpVal   ; Engine Coolant Temperature (Degrees F x 10) ->     (PRIME_PW_LU)
                                                                  ; Curve comparison value                             (PRIME_PW_LU)
00492D 7F492D 18 0B 09 10 2D              movb #$09,CrvBinCnt     ; 9 -> number of bins in the curve row or column minus 1 (PRIME_PW_LU)
004932 7F4932 16 70 0F                    jsr   CRV_LU_NP         ; Jump to subroutine at CRV_LU_NP:(located in        (PRIME_PW_LU)
                                                                      ; interp_BPEM488.s module)                       (PRIME_PW_LU)
004935 7F4935 7C 10 C6                        std  FDpw               ; Result -> "FDpw" (fuel delivery pulsewidth (mS x 10) (PRIME_PW_LU)
004938 7F4938 F3 10 C0                        addd Deadband           ; (A:B)+(M:M+1)->A:B ("FDpw"+"Deadband"="PrimePW" (PRIME_PW_LU)
00493B 7F493B 7C 10 C2                        std  PrimePW            ; Result -> "PrimePW" (primer injector pulsewidth) (mS x 10) (PRIME_PW_LU)
                                      ;***************************************************************************************** (PRIME_PW_LU)
                                      ; - Convert to timer ticks in 5.12uS resolution                                  (PRIME_PW_LU)
                                      ;***************************************************************************************** (PRIME_PW_LU)
00493E 7F493E FC 10 C2                    ldd  PrimePW     ; "PrimePW" -> Accu D                                       (PRIME_PW_LU)
004941 7F4941 CD 27 10                        ldy   #$2710     ; Load index register Y with decimal 10000 (for integer math) (PRIME_PW_LU)
004944 7F4944 13                              emul             ;(D)x(Y)=Y:D "PrimePW" * 10,000                         (PRIME_PW_LU)
004945 7F4945 CE 02 00                        ldx   #$200      ; Decimal 512 -> Accu X                                 (PRIME_PW_LU)
004948 7F4948 11                          ediv             ;(Y:D)/(X)=Y;Rem->D "PrimePW" * 10,000 / 512 = "CrankPWtk"  (PRIME_PW_LU)
004949 7F4949 7D 10 57                    sty   PrimePWtk  ; Copy result to "PrimePWtk" (Priming pulse width in 5.12uS (PRIME_PW_LU)
                                                               ; resolution)                                           (PRIME_PW_LU)
00494C 7F494C 7D 10 5F                    sty   InjOCadd2  ; Second injector output compare adder (5.12uS res)         (PRIME_PW_LU)
00494F 7F494F 18 04 10 57 10 5F               movw primePWtk,InjOCadd2 ; Copy value in "primePWtk" to "InjOCadd2" (Primer pulse width
                                                                       ; in 5.12uS res to injector timer output compare adder)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - In the INIT_TIM macro, Port T PT0, PT2 and all Port P pins are set as outputs with
                                      ;   initial setting low. To control both the ignition and injector drivers two interrupts
                                      ;   are required for each ignition or injection event. At the appropriate crank angle and
                                      ;   cam phase an interrupt is triggered. In this ISR routine the channel output compare
                                      ;   register is loaded with the delay value from trigger time to the time desired to
                                      ;   energise the coil or injector and the channel interrupt is enabled. When the output
                                      ;   compare matches, the pin is commanded high and the timer channel interrupt is triggered.
                                      ;   The output compare register is then loaded with the value to keep the coil or injector
                                      ;   energised. When the output compare matches the pin is commanded low to fire the coil
                                      ;   or de-energise the injector.
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Pulse Inj1 (Cylinders 1&10) with value in "primePWtk"
                                      ;*****************************************************************************************
004955 7F4955 MACRO                       FIRE_INJ1               ; Macro in tim_BEEM488.s
                                      ;***************************************************************************************** (FIRE_INJ1)
                                      ; - PP0 - TIM1 OC0(Inj1)(1&10) Control                                           (FIRE_INJ1)
                                      ;***************************************************************************************** (FIRE_INJ1)
                                      ;***************************************************************************************** (FIRE_INJ1)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_INJ1)
                                      ;***************************************************************************************** (FIRE_INJ1)
004955 7F4955 1C 03 D9 01                 bset TIM_TCTL2,Bit0 ; Set Ch0 output line to 1 on compare                    (FIRE_INJ1)
004959 7F4959 1C 03 D9 02                 bset TIM_TCTL2,Bit1 ; Set Ch0 output line to 1 on compare                    (FIRE_INJ1)
00495D 7F495D FC 03 D4                    ldd  TIM_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_INJ1)
004960 7F4960 F3 10 5D                    addd InjOCadd1      ; (A:B)+(M:M+1->A:B Add "InjOCadd1" (Delay from trigger to start (FIRE_INJ1)
                                                              ; of injection)                                          (FIRE_INJ1)
004963 7F4963 7C 03 E0                    std  TIM_TC0H       ; Copy result to Timer IC/OC register 0 (Start OC operation) (FIRE_INJ1)
                                      ;***********************************************************************************************
                                      ; - Update Fuel Delivery Pulse Width Total so the results can be used by Tuner Studio and
                                      ;   Shadow Dash to calculate current fuel burn.
                                      ;***********************************************************************************************
004966 7F4966 FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10)-> Accu D
004969 7F4969 F3 10 C6                    addd FDpw           ; (A:B)+(M:M+1->A:B Add  Fuel Delivery pulse width (mS x 10)
00496C 7F496C 7C 10 D0                    std  FDt            ; Copy result to "FDT" (update "FDt")(mS x 10)
                                      ;***********************************************************************************************
                                      ; - Update the Fuel Delivery counter so that on roll over (65535mS)a pulsed signal can be sent to the
                                      ;   to the totalizer(open collector output)
                                      ;***********************************************************************************************
00496F 7F496F FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10)-> Accu D
004972 7F4972 F3 10 61                        addd FDcnt          ; (A:B)+(M:M+1)->A:B (fuel delivery pulsewidth + fuel delivery counter)
004975 7F4975 25 05                       bcs  Totalizer1     ; If the cary bit of CCR is set, branch to Totalizer1: ("FDcnt"
                                                                  ;  rollover, pulse the totalizer)
004977 7F4977 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
00497A 7F497A 20 0B                       bra  TotalizerDone1 ; Branch to TotalizerDone1:
00497C 7F497C                         Totalizer1:
00497C 7F497C 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
00497F 7F497F 4C 01 08                    bset PORTB,AIOT     ; Set "AIOT" pin on Port B (PB6)(start totalizer pulse)
004982 7F4982 86 03                           ldaa #$03           ; Decimal 3->Accu A (3 mS)
004984 7F4984 7A 10 63                    staa AIOTcnt        ; Copy to "AIOTcnt" ( counter for totalizer pulse width,
                                                                  ; decremented every mS)
004987 7F4987                         TotalizerDone1:
                                      ;*****************************************************************************************
                                      ; - Pulse Inj2 (Cylinders 9&4) with value in "primePWtk"
                                      ;*****************************************************************************************
004987 7F4987 MACRO                       FIRE_INJ2               ; Macro in tim_BEEM488.s
                                                                  ; (Will trigger an interrupt after the delay time)(LED off) (FIRE_INJ2)
                                      ;***************************************************************************************** (FIRE_INJ2)
                                      ; - PP1 - TIM1 OC1(Inj2)(9&4) Control                                            (FIRE_INJ2)
                                      ;***************************************************************************************** (FIRE_INJ2)
                                      ;***************************************************************************************** (FIRE_INJ2)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_INJ2)
                                      ;***************************************************************************************** (FIRE_INJ2)
004987 7F4987 1C 03 D9 04                 bset TIM_TCTL2,Bit2 ; Set Ch1 output line to 1 on compare                    (FIRE_INJ2)
00498B 7F498B 1C 03 D9 08                 bset TIM_TCTL2,Bit3 ; Set Ch1 output line to 1 on compare                    (FIRE_INJ2)
00498F 7F498F FC 03 D4                    ldd  TIM_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_INJ2)
004992 7F4992 F3 10 5D                    addd InjOCadd1      ; (A:B)+(M:M+1->A:B Add "InjOCadd1" (Delay from trigger to start (FIRE_INJ2)
                                                              ; of injection)                                          (FIRE_INJ2)
004995 7F4995 7C 03 E2                    std  TIM_TC1H       ; Copy result to Timer IC/OC register 1 (Start OC operation) (FIRE_INJ2)
                                      ;***********************************************************************************************
                                      ; - Update Fuel Delivery Pulse Width Total so the results can be used by Tuner Studio and
                                      ;   Shadow Dash to calculate current fuel burn.
                                      ;***********************************************************************************************
004998 7F4998 FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10)-> Accu D
00499B 7F499B F3 10 C6                    addd FDpw           ; (A:B)+(M:M+1->A:B Add  Fuel Delivery pulse width (mS x 10)
00499E 7F499E 7C 10 D0                    std  FDt            ; Copy result to "FDT" (update "FDt")(mS x 10)
                                      ;***********************************************************************************************
                                      ; - Update the Fuel Delivery counter so that on roll over (65535mS)a pulsed signal can be sent to the
                                      ;   to the totalizer(open collector output)
                                      ;***********************************************************************************************
0049A1 7F49A1 FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10)-> Accu D
0049A4 7F49A4 F3 10 61                        addd FDcnt          ; (A:B)+(M:M+1)->A:B (fuel delivery pulsewidth + fuel delivery counter)
0049A7 7F49A7 25 05                       bcs  Totalizer2     ; If the cary bit of CCR is set, branch to Totalizer2: ("FDcnt"
                                                                  ;  rollover, pulse the totalizer)
0049A9 7F49A9 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
0049AC 7F49AC 20 0B                       bra  TotalizerDone2 ; Branch to TotalizerDone2:
0049AE 7F49AE                         Totalizer2:
0049AE 7F49AE 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
0049B1 7F49B1 4C 01 08                    bset PORTB,AIOT     ; Set "AIOT" pin on Port B (PB6)(start totalizer pulse)
0049B4 7F49B4 86 03                           ldaa #$03           ; Decimal 3->Accu A (3 mS)
0049B6 7F49B6 7A 10 63                    staa AIOTcnt        ; Copy to "AIOTcnt" ( counter for totalizer pulse width,
                                                                  ; decremented every mS)
0049B9 7F49B9                         TotalizerDone2:
                                      ;*****************************************************************************************
                                      ; - Pulse Inj3 (Cylinders 3&6) with value in "primePWtk"
                                      ;*****************************************************************************************
0049B9 7F49B9 MACRO                       FIRE_INJ3               ; Macro in tim_BEEM488.s
                                                                  ; (Will trigger an interrupt after the delay time)(LED off) (FIRE_INJ3)
                                      ;***************************************************************************************** (FIRE_INJ3)
                                      ;; - PP2 - TIM1 OC2(Inj3)(3&6) Control                                           (FIRE_INJ3)
                                      ;***************************************************************************************** (FIRE_INJ3)
                                      ;***************************************************************************************** (FIRE_INJ3)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_INJ3)
                                      ;***************************************************************************************** (FIRE_INJ3)
0049B9 7F49B9 1C 03 D9 10                 bset TIM_TCTL2,Bit4 ; Set Ch2 output line to 1 on compare                    (FIRE_INJ3)
0049BD 7F49BD 1C 03 D9 20                 bset TIM_TCTL2,Bit5 ; Set Ch2 output line to 1 on compare                    (FIRE_INJ3)
0049C1 7F49C1 FC 03 D4                    ldd  TIM_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_INJ3)
0049C4 7F49C4 F3 10 5D                    addd InjOCadd1      ; (A:B)+(M:M+1->A:B Add "InjOCadd1" (Delay from trigger to start (FIRE_INJ3)
                                                              ; of injection)                                          (FIRE_INJ3)
0049C7 7F49C7 7C 03 E4                    std  TIM_TC2H       ; Copy result to Timer IC/OC register2 (Start OC operation) (FIRE_INJ3)
                                      ;***********************************************************************************************
                                      ; - Update Fuel Delivery Pulse Width Total so the results can be used by Tuner Studio and
                                      ;   Shadow Dash to calculate current fuel burn.
                                      ;***********************************************************************************************
0049CA 7F49CA FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10)-> Accu D
0049CD 7F49CD F3 10 C6                    addd FDpw           ; (A:B)+(M:M+1->A:B Add  Fuel Delivery pulse width (mS x 10)
0049D0 7F49D0 7C 10 D0                    std  FDt            ; Copy result to "FDT" (update "FDt")(mS x 10)
                                      ;***********************************************************************************************
                                      ; - Update the Fuel Delivery counter so that on roll over (65535mS)a pulsed signal can be sent to the
                                      ;   to the totalizer(open collector output)
                                      ;***********************************************************************************************
0049D3 7F49D3 FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10)-> Accu D
0049D6 7F49D6 F3 10 61                        addd FDcnt          ; (A:B)+(M:M+1)->A:B (fuel delivery pulsewidth + fuel delivery counter)
0049D9 7F49D9 25 05                       bcs  Totalizer3     ; If the cary bit of CCR is set, branch to Totalizer3: ("FDcnt"
                                                                  ;  rollover, pulse the totalizer)
0049DB 7F49DB 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
0049DE 7F49DE 20 0B                       bra  TotalizerDone3 ; Branch to TotalizerDone3:
0049E0 7F49E0                         Totalizer3:
0049E0 7F49E0 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
0049E3 7F49E3 4C 01 08                    bset PORTB,AIOT     ; Set "AIOT" pin on Port B (PB6)(start totalizer pulse)
0049E6 7F49E6 86 03                           ldaa #$03           ; Decimal 3->Accu A (3 mS)
0049E8 7F49E8 7A 10 63                    staa AIOTcnt        ; Copy to "AIOTcnt" ( counter for totalizer pulse width,
                                                                  ; decremented every mS)
0049EB 7F49EB                         TotalizerDone3:
                                      ;*****************************************************************************************
                                      ; - Pulse Inj4 (Cylinders 5&8) with value in "primePWtk"
                                      ;*****************************************************************************************
0049EB 7F49EB MACRO                       FIRE_INJ4               ; Macro in tim_BEEM488.s
                                                                  ; (Will trigger an interrupt after the delay time)(LED off) (FIRE_INJ4)
                                      ;***************************************************************************************** (FIRE_INJ4)
                                      ; - PP3 - TIM1 OC3(Inj4)(5&8) Control                                            (FIRE_INJ4)
                                      ;***************************************************************************************** (FIRE_INJ4)
                                      ;***************************************************************************************** (FIRE_INJ4)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_INJ4)
                                      ;***************************************************************************************** (FIRE_INJ4)
0049EB 7F49EB 1C 03 D9 40                 bset TIM_TCTL2,Bit6 ; Set Ch3 output line to 1 on compare                    (FIRE_INJ4)
0049EF 7F49EF 1C 03 D9 80                 bset TIM_TCTL2,Bit7 ; Set Ch3 output line to 1 on compare                    (FIRE_INJ4)
0049F3 7F49F3 FC 03 D4                    ldd  TIM_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_INJ4)
0049F6 7F49F6 F3 10 5D                    addd InjOCadd1      ; (A:B)+(M:M+1->A:B Add "InjOCadd1" (Delay from trigger to start (FIRE_INJ4)
                                                              ; of injection)                                          (FIRE_INJ4)
0049F9 7F49F9 7C 03 E6                    std  TIM_TC3H       ; Copy result to Timer IC/OC register 3 (Start OC operation) (FIRE_INJ4)
                                      ;***********************************************************************************************
                                      ; - Update Fuel Delivery Pulse Width Total so the results can be used by Tuner Studio and
                                      ;   Shadow Dash to calculate current fuel burn.
                                      ;***********************************************************************************************
0049FC 7F49FC FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10)-> Accu D
0049FF 7F49FF F3 10 C6                    addd FDpw           ; (A:B)+(M:M+1->A:B Add  Fuel Delivery pulse width (mS x 10)
004A02 7F4A02 7C 10 D0                    std  FDt            ; Copy result to "FDT" (update "FDt")(mS x 10)
                                      ;***********************************************************************************************
                                      ; - Update the Fuel Delivery counter so that on roll over (65535mS)a pulsed signal can be sent to the
                                      ;   to the totalizer(open collector output)
                                      ;***********************************************************************************************
004A05 7F4A05 FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10)-> Accu D
004A08 7F4A08 F3 10 61                        addd FDcnt          ; (A:B)+(M:M+1)->A:B (fuel delivery pulsewidth + fuel delivery counter)
004A0B 7F4A0B 25 05                       bcs  Totalizer4     ; If the cary bit of CCR is set, branch to Totalizer4: ("FDcnt"
                                                                  ;  rollover, pulse the totalizer)
004A0D 7F4A0D 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
004A10 7F4A10 20 0B                       bra  TotalizerDone4 ; Branch to TotalizerDone4:
004A12 7F4A12                         Totalizer4:
004A12 7F4A12 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
004A15 7F4A15 4C 01 08                    bset PORTB,AIOT     ; Set "AIOT" pin on Port B (PB6)(start totalizer pulse)
004A18 7F4A18 86 03                           ldaa #$03           ; Decimal 3->Accu A (3 mS)
004A1A 7F4A1A 7A 10 63                    staa AIOTcnt        ; Copy to "AIOTcnt" ( counter for totalizer pulse width,
                                                                  ; decremented every mS)
004A1D 7F4A1D                         TotalizerDone4:
                                      ;*****************************************************************************************
                                      ; - Pulse Inj5 (Cylinders 7&2) with value in "primePWtk"
                                      ;*****************************************************************************************
004A1D 7F4A1D MACRO                       FIRE_INJ5               ; Macro in tim_BEEM488.s
                                                                  ; (Will trigger an interrupt after the delay time)(LED off) (FIRE_INJ5)
                                      ;***************************************************************************************** (FIRE_INJ5)
                                      ; - PP4 - TIM1 OC4(Inj5)(7&2) Control                                            (FIRE_INJ5)
                                      ;***************************************************************************************** (FIRE_INJ5)
                                      ;***************************************************************************************** (FIRE_INJ5)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_INJ5)
                                      ;***************************************************************************************** (FIRE_INJ5)
004A1D 7F4A1D 1C 03 D8 01                 bset TIM_TCTL1,Bit0 ; Set Ch4 output line to 1 on compare                    (FIRE_INJ5)
004A21 7F4A21 1C 03 D8 02                 bset TIM_TCTL1,Bit1 ; Set Ch4 output line to 1 on compare                    (FIRE_INJ5)
004A25 7F4A25 FC 03 D4                    ldd  TIM_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_INJ5)
004A28 7F4A28 F3 10 5D                    addd InjOCadd1      ; (A:B)+(M:M+1->A:B Add "InjOCadd1" (Delay from trigger to start (FIRE_INJ5)
                                                              ; of injection)                                          (FIRE_INJ5)
004A2B 7F4A2B 7C 03 E8                    std  TIM_TC4H       ; Copy result to Timer IC/OC register 4(Start OC operation) (FIRE_INJ5)
                                      ;***********************************************************************************************
                                      ; - Update Fuel Delivery Pulse Width Total so the results can be used by Tuner Studio and
                                      ;   Shadow Dash to calculate current fuel burn.
                                      ;***********************************************************************************************
004A2E 7F4A2E FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10)-> Accu D
004A31 7F4A31 F3 10 C6                    addd FDpw           ; (A:B)+(M:M+1->A:B Add  Fuel Delivery pulse width (mS x 10)
004A34 7F4A34 7C 10 D0                    std  FDt            ; Copy result to "FDT" (update "FDt")(mS x 10)
                                      ;***********************************************************************************************
                                      ; - Update the Fuel Delivery counter so that on roll over (65535mS)a pulsed signal can be sent to the
                                      ;   to the totalizer(open collector output)
                                      ;***********************************************************************************************
004A37 7F4A37 FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10)-> Accu D
004A3A 7F4A3A F3 10 61                        addd FDcnt          ; (A:B)+(M:M+1)->A:B (fuel delivery pulsewidth + fuel delivery counter)
004A3D 7F4A3D 25 05                       bcs  Totalizer5     ; If the cary bit of CCR is set, branch to Totalizer5: ("FDcnt"
                                                                  ;  rollover, pulse the totalizer)
004A3F 7F4A3F 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
004A42 7F4A42 20 0B                       bra  TotalizerDone5 ; Branch to TotalizerDone5:
004A44 7F4A44                         Totalizer5:
004A44 7F4A44 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
004A47 7F4A47 4C 01 08                    bset PORTB,AIOT     ; Set "AIOT" pin on Port B (PB6)(start totalizer pulse)
004A4A 7F4A4A 86 03                           ldaa #$03           ; Decimal 3->Accu A (3 mS)
004A4C 7F4A4C 7A 10 63                    staa AIOTcnt        ; Copy to "AIOTcnt" ( counter for totalizer pulse width,
                                                                  ; decremented every mS)
004A4F 7F4A4F                         TotalizerDone5:
                                      ;*****************************************************************************************
                                      ; - Set up the "engine" bit field in preparation for cranking.
                                      ;*****************************************************************************************
004A4F 7F4A4F 1C 10 E1 02                bset engine,crank   ; Set the "crank" bit of "engine" bit field
004A53 7F4A53 1D 10 E1 04                bclr engine,run     ; Clear the "run" bit of "engine" bit field
004A57 7F4A57 1C 10 E1 10                bset engine,WUEon   ; Set "WUEon" bit of "engine" bit field
004A5B 7F4A5B 1C 10 E1 08                bset engine,ASEon   ; Set "ASEon" bit of "engine" bit field
004A5F 7F4A5F 79 10 A4                   clr  ASEcnt         ; Clear the after-start enrichment counter variable
                                      ;*****************************************************************************************
                                      ; - Set the "base512" bit and clear the "base256" bit of the "engine2" bit field in
                                      ;   preparation for cranking.
                                      ;*****************************************************************************************
004A62 7F4A62 1C 10 E2 01                bset engine2,base512   ; Set the "base512" bit of "engine2" bit field
004A66 7F4A66 1D 10 E2 02                bclr engine2,base256   ; Clear the "base256" bit of "engine2" bit field
                                      ;*****************************************************************************************
                                      ; - Load stall counter with compare value. Stall check is done in the main loop every
                                      ;   mSec. "Stallcnt" is decremented every mSec and reloaded at every crank signal.
                                      ;*****************************************************************************************
004A6A 7F4A6A 18 0B FF 00 17                  movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE
004A6F 7F4A6F CD 08 00                    ldy   #veBins_E       ; Load index register Y with address of first configurable
                                                              ; constant on buffer RAM page 1 (vebins)
004A72 7F4A72 EC EA 03 E6                 ldd   $03E6,Y       ; Load Accu A with value in buffer RAM page 1 offset 998
                                                              ; "Stallcnt" (stall counter)(offset = 998)
004A76 7F4A76 7C 10 22                    std  Stallcnt       ; Copy to "Stallcnt" (no crank or stall condition counter)
                                                              ; (1mS increments)
                                      ;*****************************************************************************************
                                      ; ----------------------- After Start Enrichment Taper (ASErev)---------------------------
                                      ;
                                      ; After Start Enrichment is applied for a specified number of engine revolutions after
                                      ; start up. This number is interpolated from the After Start Enrichment Taper table which
                                      ; plots engine temperature in degrees F to 0.1 degree resoluion against revolutions.
                                      ; The ASE starts with the value of "ASEcor" first and is linearly interpolated down to
                                      ; zero after "ASErev" crankshaft revolutions.
                                      ;
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Look up current value in Afterstart Enrichment Taper Table (ASErev) and update the
                                      ;   counter (ASEcnt)
                                      ;*****************************************************************************************
004A79 7F4A79 MACRO                       ASE_TAPER_LU       ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (ASE_TAPER_LU)
                                      ; ----------------------- After Start Enrichment Taper (ASErev)--------------------------- (ASE_TAPER_LU)
                                      ;                                                                                (ASE_TAPER_LU)
                                      ; After Start Enrichment is applied for a specified number of engine revolutions after (ASE_TAPER_LU)
                                      ; start up. This number is interpolated from the After Start Enrichment Taper table which (ASE_TAPER_LU)
                                      ; plots engine temperature in degrees F to 0.1 degree resoluion against revolutions. (ASE_TAPER_LU)
                                      ; The ASE starts with the value of "ASEcor" first and is linearly interpolated down to (ASE_TAPER_LU)
                                      ; zero after "ASErev" crankshaft revolutions.                                    (ASE_TAPER_LU)
                                      ;                                                                                (ASE_TAPER_LU)
                                      ;***************************************************************************************** (ASE_TAPER_LU)
                                      ;***************************************************************************************** (ASE_TAPER_LU)
                                      ; - Look up current value in Afterstart Enrichment Taper Table (ASErev)          (ASE_TAPER_LU)
                                      ;***************************************************************************************** (ASE_TAPER_LU)
004A79 7F4A79 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (ASE_TAPER_LU)
004A7E 7F4A7E 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (ASE_TAPER_LU)
                                                                  ; ->page where the desired curve resides             (ASE_TAPER_LU)
004A84 7F4A84 18 03 01 90 10 27           movw #$0190,CrvRowOfst  ; 400 -> Offset from the curve page to the curve row (ASE_TAPER_LU)
                                                                      ; (tempTable2)(actual offset is 800)             (ASE_TAPER_LU)
004A8A 7F4A8A 18 03 01 CA 10 29           movw #$01CA,CrvColOfst  ; 458 -> Offset from the curve page to the curve column (ASE_TAPER_LU)
                                                                      ; (aseRevTable)(actual offset is 916)            (ASE_TAPER_LU)
004A90 7F4A90 18 04 10 6C 10 2B           movw Cltx10,CrvCmpVal   ; Engine Coolant Temperature (Degrees F x 10) ->     (ASE_TAPER_LU)
                                                                  ; Curve comparison value                             (ASE_TAPER_LU)
004A96 7F4A96 18 0B 09 10 2D              movb #$09,CrvBinCnt     ; 9 -> number of bins in the curve row or column minus 1 (ASE_TAPER_LU)
004A9B 7F4A9B 16 70 0F                    jsr   CRV_LU_NP         ; Jump to subroutine at CRV_LU_NP:(located in        (ASE_TAPER_LU)
                                                                      ; interp_BEEM488.s module)                       (ASE_TAPER_LU)
004A9E 7F4A9E 7C 10 55                    std   ASErev            ; Copy result to Afterstart Enrichment Taper (revolutions) (ASE_TAPER_LU)
004AA1 7F4AA1 7C 10 A4                    std   ASEcnt            ; Copy result to Afterstart Enrichment Taper counter (ASE_TAPER_LU)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;************************* --- M A I N  E V E N T  L O O P --- ***************************
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
004AA4 7F4AA4                         MainLoop:
                                      ;*****************************************************************************************
                                      ; Coding experiments
                                      ;*****************************************************************************************
                                      ;
                                      ;    movw #$7FFF,TestVal  ; Load "TestVal" with decimal +32767
                                      ;    movw #$FFFF,TestVal  ; Load "TestVal" with decimal -1
                                      ;    movw #$FFFE,TestVal  ; Load "TestVal" with decimal -2
                                      ;    movw #$FFD8,TestVal  ; Load "TestVal" with decimal -40
                                      ;    movw #$8000,TestVal  ; Load "TestVal" with decimal -32768
                                      ;    movw #$8001,TestVal  ; Load "TestVal" with decimal -32767
                                      ;    movw #$F060,TestVal  ; Load "TestVal" with decimal -4000
                                      ;    movw #$52D0,TestVal  ; Load "TestVal" with decimal +21200
                                      ;    movw #TestVal,TestVal ; Load "TestVal" with the address of "TestVal" ($1050 decimal 4176)
                                      ;
                                      ;*****************************************************************************************
                                      ;**********************************************************************
                                      ; - De-Bug LED   Fuel Pump                                            *
                                      ;     bset  PORTB, PB0   ; Set bit0, Port B                           *
                                      ;                        ; ("Fuel Pump" LED output LEDs Board)        *
                                      ;**********************************************************************
                                      ;**********************************************************************
                                      ; - De-Bug LED   ASD Relay                                            *
                                      ;     bset  PORTB, PB1   ; Set Bit1, Port B                           *
                                      ;                        ; ("ASD Relay" LED output LEDs Board)        *
                                      ;**********************************************************************
                                      ;**********************************************************************
                                      ; - De-Bug LED  Engine Alarm                                          *
                                      ;     bset  PORTB, PB2   ; Set Bit2, Port B                           *
                                      ;                        ; ("Engine Alarm" LED output LEDs Board)     *
                                      ;**********************************************************************
                                      ;**********************************************************************
                                      ; - De-Bug LED  PB4 out                                               *
                                      ;     bset  PORTB, PB4   ; Set bit4, Port B                           *
                                      ;                        ; ("PB4 out" LED output LEDs Board)(Tach out)*
                                      ;**********************************************************************
                                      ;**********************************************************************
                                      ; - De-Bug LED  PB5 out                                               *
                                      ;     bset  PORTB, PB5   ; Set bit5, Port B                           *
                                      ;                        ; ("PB5 out" LED output LEDs Board)          *
                                      ;**********************************************************************
                                      ;**********************************************************************
                                      ; - De-Bug LED  PB6 out                                               *
                                      ;     bset  PORTB, PB6   ; Set bit6, Port B                           *
                                      ;                        ; ("PB6 out" LED output LEDs Board)          *
                                      ;**********************************************************************
                                      ;**********************************************************************
                                      ; - De-Bug LED  LOP Alarm                                             *
                                      ;     bset  PORTK, PK0   ; Set Bit0, Port K                           *
                                      ;                        ; ("LOP Alarm" LED output LEDs Board)        *
                                      ;**********************************************************************
                                      ;**********************************************************************
                                      ; - De-Bug LED  HOT Alarm                                             *
                                      ;     bset  PORTK, PK1   ; Set Bit1, Port K                           *
                                      ;                        ; ("HOT Alarm" LED output LEDs Board)        *
                                      ;**********************************************************************
                                      ;**********************************************************************
                                      ; - De-Bug LED  HET Alarm                                             *
                                      ;     bset PORTK, PK2    ; Set bit2 Port K                            *
                                      ;                        ; ("HET Alarm" LED output LEDs Board)        *
                                      ;**********************************************************************
                                      ;**********************************************************************
                                      ; - De-Bug LED  HEGT Alarm                                            *
                                      ;      bset  PORTK, PK3   ; Set Bit3 Port K                           *
                                      ;                         ; ("HEGT Alarm" LED output LEDs Board)      *
                                      ;**********************************************************************
                                      ;**********************************************************************
                                      ;**********************************************************************
                                      ; - De-Bug LED  HFT Alarm                                             *
                                      ;      bset  PORTK, PK4   ; Set Bit4 Port K                           *
                                      ;                         ; ("HFT Alarm" LED output LEDs Board)       *
                                      ;**********************************************************************
                                      ;**********************************************************************
                                      ; - De-Bug LED  LFP Alarm                                             *
                                      ;      bset  PORTK, PK5   ; Set Bit5 Port K                           *
                                      ;                         ; ("LFP Alarm" LED output LEDs Board)       *
                                      ;**********************************************************************
                                      ;**********************************************************************
                                      ; - De-Bug LED  HFP Alarm                                             *
                                      ;      bset  PORTK, PK7   ; Set Bit7 Port K                           *
                                      ;                         ; ("HFP Alarm" LED output LEDs Board)       *
                                      ;**********************************************************************
                                      ;*****************************************************************************************
                                      ; - Flash PB6out LED on output LEDs board every second just to show that the timer is
                                      ;   working
                                      ;*****************************************************************************************
                                      ;    ldaa  PORTB        ; Load ACC A with value in Port B
                                      ;    eora  #$40         ; Exclusive or with $01000000
                                      ;    staa   PORTB       ; Copy to Port B (toggle Bit6, "PB6out" LED on output LEDs board)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Update Ports A, B, K, P and T status bits
                                      ;*****************************************************************************************
004AA4 7F4AA4 96 00                       ldaa PORTA      ; Load accu A with value in Port A
004AA6 7F4AA6 7A 10 DC                    staa PortAbits  ; Copy to "PortAbits"
004AA9 7F4AA9 96 01                       ldaa PORTB      ; Load accu A with value in Port B
004AAB 7F4AAB 7A 10 DD                    staa PortBbits  ; Copy to "PortBbits"
004AAE 7F4AAE 96 32                       ldaa PORTK      ; Load accu K with value in Port K
004AB0 7F4AB0 7A 10 DE                    staa PortKbits  ; Copy to "PortKBits"
004AB3 7F4AB3 B6 02 58                    ldaa PTP        ; Load accu A with value in Port P
004AB6 7F4AB6 7A 10 DF                    staa PortPbits  ; Copy to "PortPbits"
004AB9 7F4AB9 B6 02 40                    ldaa PTT        ; Load accu A with value in Port T
004ABC 7F4ABC 7A 10 E0                    staa PortTbits  ; Copy to "PortTbits"
                                       ;*****************************************************************************************
                                      ; - Run ATD0 conversion sequence and load all results.
                                      ;*****************************************************************************************
004ABF 7F4ABF MACRO                       Run_ATD0    ;(Macro in adc0_BPEM488.s)
004ABF 7F4ABF 1F 02 C6 80 02              brclr ATD0STAT0,SCF,NoSeqCmpltLB  ; If the Sequence Cpmplet Flag is not set, branch to (RUN_ATD0)
                                                                            ; branch to NoSeqCmpltLB:                  (RUN_ATD0)
004AC4 7F4AC4 20 02                       bra  Start_ADC_Read               ; Branch to Start_ADC_Read:                (RUN_ATD0)
004AC6 7F4AC6                         NoSeqCmpltLB:                                                                    (RUN_ATD0)
004AC6 7F4AC6 20 74                       job   NoSeqCmplt  ; Jump or branch to NoSeqCmplt: (long branch)              (RUN_ATD0)
004AC8 7F4AC8                         Start_ADC_Read:                                                                  (RUN_ATD0)
004AC8 7F4AC8 18 0B 80 02 C6              movb  #SCF,ATD0STAT0 ; Set the Sequence Complete Flag of ATD0STAT0 to clear the flag (RUN_ATD0)
004ACD 7F4ACD FC 02 D0                    ldd   ATD0DR0H    ; Load accumulator with value in ATD Ch00                  (RUN_ATD0)
004AD0 7F4AD0 7C 10 66                    std   batAdc      ; Copy to batAdc                                           (RUN_ATD0)
004AD3 7F4AD3 FC 02 D2                    ldd   ATD0DR1H    ; Load accumulator with value in ATD Ch01                  (RUN_ATD0)
004AD6 7F4AD6 7C 10 6A                    std   cltAdc      ; Copy to cltAdc                                           (RUN_ATD0)
004AD9 7F4AD9 FC 02 D4                    ldd   ATD0DR2H    ; Load accumulator with value in ATD Ch02                  (RUN_ATD0)
004ADC 7F4ADC 7C 10 6E                    std   matAdc      ; Copy to matAdc                                           (RUN_ATD0)
004ADF 7F4ADF FC 02 D6                    ldd   ATD0DR3H    ; Load accumulator with value in ATD Ch03                  (RUN_ATD0)
004AE2 7F4AE2 7C 10 72                    std   PAD03inAdc  ; Copy to PAD03inAdc                                       (RUN_ATD0)
004AE5 7F4AE5 FC 02 D8                    ldd   ATD0DR4H    ; Load accumulator with value in ATD Ch04                  (RUN_ATD0)
004AE8 7F4AE8 7C 10 76                    std   mapAdc      ; Copy to mapAdc                                           (RUN_ATD0)
004AEB 7F4AEB FC 02 DA                    ldd   ATD0DR5H    ; Load accumulator with value in ATD Ch05                  (RUN_ATD0)
004AEE 7F4AEE 7C 10 7A                    std   tpsAdc      ; Copy to tpsAdc                                           (RUN_ATD0)
004AF1 7F4AF1 FC 02 DC                    ldd   ATD0DR6H    ; Load accumulator with value in ATD Ch06                  (RUN_ATD0)
004AF4 7F4AF4 7C 10 7E                    std   egoAdc1     ; Copy to egoAdc1                                          (RUN_ATD0)
                                      ;***************************************************************************************** (RUN_ATD0)
                                      ;- From observation, the MPXA6115AC7U barometric pressure sensor has an ADC jitter from (RUN_ATD0)
                                      ;  about 828 to 832 counts at sea level on the observed day. This doesn't create any (RUN_ATD0)
                                      ;  major problems with the pulse width calculations but it is irritating so I average (RUN_ATD0)
                                      ;  the ADC readings over 64 iterations to stabilize the results.                 (RUN_ATD0)
                                      ;***************************************************************************************** (RUN_ATD0)
004AF7 7F4AF7 FC 02 DE                    ldd   ATD0DR7H    ; Load accumulator with value in ATD Ch07                  (RUN_ATD0)
                                      ;    std   baroAdc     ; Copy to baroAdc                                         (RUN_ATD0)
004AFA 7F4AFA F3 10 FF                    addd  baroADCsum  ;(A:B)+(M:M+1)->A:B Add value in ATD Ch07 with value in "baroADCsum" (RUN_ATD0)
004AFD 7F4AFD 7C 10 FF                    std   baroADCsum  ; Copy result to "baroADCsum" (update "baroADCsum"         (RUN_ATD0)
004B00 7F4B00 72 11 01                    inc   baroADCcnt  ; Increment "baroADCcnt" (increment counter to average "baroADC") (RUN_ATD0)
004B03 7F4B03 B6 11 01                    ldaa  baroADCcnt  ; Load Accu A with value in "baroADCcnt"                   (RUN_ATD0)
004B06 7F4B06 81 40                       cmpa  #$40        ; (A)-(M) (Compare "baroADCcnt" with decimal 64)           (RUN_ATD0)
004B08 7F4B08 27 02                       beq   AVbaroADC   ; If equal branch to AVbaroADC:                            (RUN_ATD0)
004B0A 7F4B0A 20 12                       bra   Do_ATD_Ch08 ; Branch to Do_ATD_Ch08 (compare not equal so fall through) (RUN_ATD0)
004B0C 7F4B0C                         AVbaroADC:                                                                       (RUN_ATD0)
004B0C 7F4B0C 79 11 01                    clr   baroADCcnt  ; Clear "baroADCcnt" (ready to start count again)          (RUN_ATD0)
004B0F 7F4B0F FC 10 FF                    ldd   baroADCsum  ; Load accumulator with value in "baroADCsum"              (RUN_ATD0)
004B12 7F4B12 CE 00 40                    ldx   #$40        ; Load Accu X with decimal 64                              (RUN_ATD0)
004B15 7F4B15 18 10                       idiv              ; (D)/(X)->X Rem->D ("baroADCsum / 64)                     (RUN_ATD0)
004B17 7F4B17 7E 10 82                    stx   baroADC     ; Copy result to "baroADC"                                 (RUN_ATD0)
004B1A 7F4B1A 18 79 10 FF                 clrw  baroADCsum  ; Clear "baroADCsum" (ready to start sum again)            (RUN_ATD0)
004B1E 7F4B1E                         Do_ATD_Ch08:                                                                     (RUN_ATD0)
004B1E 7F4B1E FC 02 E0                    ldd   ATD0DR8H    ; Load accumulator with value in ATD Ch08                  (RUN_ATD0)
004B21 7F4B21 7C 10 86                    std   eopAdc      ; Copy to eopAdc                                           (RUN_ATD0)
004B24 7F4B24 FC 02 E2                    ldd   ATD0DR9H    ; Load accumulator with value in ATD Ch09                  (RUN_ATD0)
004B27 7F4B27 7C 10 8A                    std   efpAdc      ; Copy to efpAdc                                           (RUN_ATD0)
004B2A 7F4B2A FC 02 E4                    ldd   ATD0DR10H   ; Load accumulator with value in ATD Ch10                  (RUN_ATD0)
004B2D 7F4B2D 7C 10 8E                    std   itrmAdc     ; Copy to itrmAdc                                          (RUN_ATD0)
004B30 7F4B30 FC 02 E6                    ldd   ATD0DR11H   ; Load accumulator with value in ATD Ch11                  (RUN_ATD0)
004B33 7F4B33 7C 10 92                    std   ftrmAdc     ; Copy to ftrmAdc                                          (RUN_ATD0)
004B36 7F4B36 FC 02 E8                    ldd   ATD0DR12H   ; Load accumulator with value in ATD Ch12                  (RUN_ATD0)
004B39 7F4B39 7C 10 96                    std   egoAdc2     ; Copy to egoAdc2                                          (RUN_ATD0)
004B3C 7F4B3C                         NoSeqCmplt:                                                                      (RUN_ATD0)
                                      ;*****************************************************************************************
                                      ; - Convert ADC values to user units -
                                      ;*****************************************************************************************
004B3C 7F4B3C MACRO                       CONVERT_ATD0    ;(Macro in adc0_BPEM488.s)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Battery Voltage                                                    (CONVERT_ATD0)
                                      ;   System voltage is typically ~12 volts with the engine stopped and ~14 volts with the (CONVERT_ATD0)
                                      ;   engine running and the generator charging. In order for ATD0 Ch0 to measure this (CONVERT_ATD0)
                                      ;   voltage a 49.9K and a 10K resistor are connected in series across VDD(5 volts) and (CONVERT_ATD0)
                                      ;   ground. Ch0 measures the voltage drop across the 10K resistor. This arrangement will (CONVERT_ATD0)
                                      ;   accept system voltage of 29.95 volts before the voltage drop will exceed 5 volts. (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Battery Voltage x 10 -                                             (CONVERT_ATD0)
                                      ;    (batAdc/1023)*29.95 = BatV                                                  (CONVERT_ATD0)
                                      ;             or                                                                 (CONVERT_ATD0)
                                      ;    batAdc*(29.95/1023) = BatV, batADC = BatV                                   (CONVERT_ATD0)
                                      ;    batAdc*.029276637 = BatV  batADC = batV/.029276637                          (CONVERT_ATD0)
                                      ;    batAdc*(300/1023) = BatV*10                                                 (CONVERT_ATD0)
                                      ;    batAdc*.29276637 = BatV*10 bat ADC = batV*10/.29276637                      (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004B3C 7F4B3C FC 10 66                    ldd   batAdc       ; Load double accumulator with value in "batAdc"          (CONVERT_ATD0)
004B3F 7F4B3F CD 01 2C                    ldy   #$012C       ; Load index register Y with decimal decimal 300          (CONVERT_ATD0)
004B42 7F4B42 13                          emul               ; Extended 16x16 multiply (D)x(Y)=Y:D                     (CONVERT_ATD0)
004B43 7F4B43 CE 03 FF                    ldx   #$03FF       ; Load index register X with decimal 1023                 (CONVERT_ATD0)
004B46 7F4B46 11                          ediv               ; Extended 32x16 divide(Y:D)/(X)=Y;Rem->D                 (CONVERT_ATD0)
004B47 7F4B47 7D 10 68                    sty   BatVx10      ; Copy result to "BatVx10" (Battery Voltage x 10)         (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Look up Engine Coolant Temperature (Degrees F x 10)                          (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004B4A 7F4B4A FE 10 6A                    ldx   cltAdc            ; Load index register X with value in "cltAdc"       (CONVERT_ATD0)
004B4D 7F4B4D 18 48                       aslx                    ; Arithmetic shift left index register X (multiply "cltAdc" (CONVERT_ATD0)
                                                                  ; by two) I have no idea why I have to do this but if I don't (CONVERT_ATD0)
                                                                  ; the table look up is only half of where it shoud be ??????? (CONVERT_ATD0)
004B4F 7F4B4F ED E2 7C 9F                 ldy   DodgeThermistor,X  ; Load index register Y with value in "DodgeThermistor" table, (CONVERT_ATD0)
                                                                  ; offset in index register X                         (CONVERT_ATD0)
004B53 7F4B53 7D 10 6C                    sty   Cltx10            ; Copy result to "Cltx10" Engine Coolant Temperature x 10 (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Look up Manifold Air Temperature (Degrees F x 10)                            (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004B56 7F4B56 FE 10 6E                    ldx   matAdc            ; Load index register X with value in "matAdc"       (CONVERT_ATD0)
004B59 7F4B59 18 48                       aslx                    ; Arithmetic shift left index register X (multiply "matAdc" (CONVERT_ATD0)
                                                                  ; by two) I have no idea why I have to do this but if I don't (CONVERT_ATD0)
                                                                  ; the table look up is only half of where it shoud be ??????? (CONVERT_ATD0)
004B5B 7F4B5B ED E2 7C 9F                 ldy   DodgeThermistor,X  ; Load index register Y with value in "DodgeThermistor" table, (CONVERT_ATD0)
                                                                  ; offset in index register X                         (CONVERT_ATD0)
004B5F 7F4B5F 7D 10 70                    sty   Matx10            ; Copy result to "Matx100" Manifold Air Temperature x 10 (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Manifold Absolute Pressure x 10 (Used to calculate to 1 decimal place) (CONVERT_ATD0)
                                      ;   Dodge V10 MAP sensor test data 7/30/20:                                      (CONVERT_ATD0)
                                      ;   Vout = 4.57,    ADC = 935, KPA = 101.5                                       (CONVERT_ATD0)
                                      ;   Vout = .004887, ADC = 1,   KPA = 11.02                                       (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004B62 7F4B62 CC 00 0A                    ldd  #$000A      ; Load double accumulator with decimal 1 (.004887 volt ADC) ( x 10) (CONVERT_ATD0)
004B65 7F4B65 3B                          pshd             ; Push to stack (V1)                                        (CONVERT_ATD0)
004B66 7F4B66 FC 10 76                    ldd  mapAdc      ; Load double accumulator with "mapAdc"                     (CONVERT_ATD0)
004B69 7F4B69 CD 00 0A                    ldy  #$000A      ; Load index register Y with decimal 10                     (CONVERT_ATD0)
004B6C 7F4B6C 13                          emul             ; Multiply (D)x(Y)=>Y:D  (multiply "eopAdc" by 10)          (CONVERT_ATD0)
004B6D 7F4B6D 3B                          pshd             ; Push to stack (V)                                         (CONVERT_ATD0)
004B6E 7F4B6E CC 24 86                    ldd  #$2486      ; Load double accumulator with decimal 935 (4.57 volt ADC) ( x 10) (CONVERT_ATD0)
004B71 7F4B71 3B                          pshd             ; Push to stack (V2)                                        (CONVERT_ATD0)
004B72 7F4B72 CC 00 6E                    ldd  #$006E      ; Load double accumulator with decimal 11.02 (Low range KPA) ( x 10) (CONVERT_ATD0)
004B75 7F4B75 3B                          pshd             ; Push to stack (Z1)                                        (CONVERT_ATD0)
004B76 7F4B76 CC 03 F7                    ldd  #$03F7      ; Load double accumulator with decimal 101.5 (High range KPA) ( x 10) (CONVERT_ATD0)
004B79 7F4B79 3B                          pshd             ; Push to stack (Z2)                                        (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z2       |  SP+ 0                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z1       |  SP+ 2                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V2       |  SP+ 4                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V        |  SP+ 6                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V1       |  SP+ 8                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                      ;                     V      V1      V2      Z1    Z2                            (CONVERT_ATD0)
004B7A 7F4B7A MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; ==========================                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CONVERT_ATD0/2D_IPOL)
                                      ; SSTACK: none                                                                   (CONVERT_ATD0/2D_IPOL)
                                      ;         no registers are preserved                                             (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    ^ V                                                                         (CONVERT_ATD0/2D_IPOL)
                                      ;    |                                                                           (CONVERT_ATD0/2D_IPOL)
                                      ;  Z2+....................*                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;    |                    :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CONVERT_ATD0/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CONVERT_ATD0/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CONVERT_ATD0/2D_IPOL)
                                      ;    |   :       :        :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004B7A 7F4B7A EC 86                                   LDD       \1    ; load V                                         (CONVERT_ATD0/2D_IPOL)
004B7C 7F4B7C A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004B7E 7F4B7E B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004B80 7F4B80 EC 80                                   LDD       \5    ; load Z2                                        (CONVERT_ATD0/2D_IPOL)
004B82 7F4B82 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004B84 7F4B84 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CONVERT_ATD0/2D_IPOL)
004B86 7F4B86 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004B88 7F4B88 EC 84                                   LDD       \3    ; load V2                                        (CONVERT_ATD0/2D_IPOL)
004B8A 7F4B8A A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004B8C 7F4B8C B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CONVERT_ATD0/2D_IPOL)
                                      ;*********************************************************************           (CONVERT_ATD0/2D_IPOL)
004B8E 7F4B8E 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CONVERT_ATD0/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CONVERT_ATD0/2D_IPOL)
004B90 7F4B90 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004B92 7F4B92 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Free stack space (result in D)                                               (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004B94 7F4B94 1B 8A                       leas  10,SP    ; Stack pointer -> bottom of stack                            (CONVERT_ATD0)
004B96 7F4B96 7C 10 78                    std   Mapx10   ; Copy result to "Mapx10" Manifold Absolute Pressure x 10     (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Throttle Position Percent x 10 -                                   (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004B99 7F4B99 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (CONVERT_ATD0)
004B9E 7F4B9E CD 08 00                    ldy  #veBins_E   ; Load index register Y with address of first configurable constant (CONVERT_ATD0)
                                                           ; on buffer RAM page 1 (veBins)                             (CONVERT_ATD0)
004BA1 7F4BA1 EC EA 03 E8                 ldd  $03E8,Y     ; Load Accu D with value in buffer RAM page 1 offset 1000 (tpsMin) (CONVERT_ATD0)
004BA5 7F4BA5 3B                          pshd             ; Push to stack (V1)                                        (CONVERT_ATD0)
004BA6 7F4BA6 FC 10 7A                    ldd  tpsADC      ; Load double accumulator with "tpsADCAdc"                  (CONVERT_ATD0)
004BA9 7F4BA9 3B                          pshd             ; Push to stack (V)                                         (CONVERT_ATD0)
004BAA 7F4BAA 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (CONVERT_ATD0)
004BAF 7F4BAF CD 08 00                    ldy  #veBins_E   ; Load index register Y with address of first configurable constant (CONVERT_ATD0)
                                                           ; on buffer RAM page 1 (vebins)                             (CONVERT_ATD0)
004BB2 7F4BB2 EC EA 03 EA                 ldd  $03EA,Y     ; Load Accu D with value in buffer RAM page 1 offset 1002 (tpsMax) (CONVERT_ATD0)
004BB6 7F4BB6 3B                          pshd             ; Push to stack (V2)                                        (CONVERT_ATD0)
004BB7 7F4BB7 CC 00 00                    ldd  #$0000      ; Load double accumulator with decimal 0 (Low range %) ( x 10) (CONVERT_ATD0)
004BBA 7F4BBA 3B                          pshd             ; Push to stack (Z1)                                        (CONVERT_ATD0)
004BBB 7F4BBB CC 03 E8                    ldd  #$03E8      ; Load double accumulator with decimal 1000 (High range %) ( x 10) (CONVERT_ATD0)
004BBE 7F4BBE 3B                          pshd             ; Push to stack (Z2)                                        (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z2       |  SP+ 0                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z1       |  SP+ 2                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V2       |  SP+ 4                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V        |  SP+ 6                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V1       |  SP+ 8                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                      ;                     V      V1      V2      Z1    Z2                            (CONVERT_ATD0)
004BBF 7F4BBF MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; ==========================                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CONVERT_ATD0/2D_IPOL)
                                      ; SSTACK: none                                                                   (CONVERT_ATD0/2D_IPOL)
                                      ;         no registers are preserved                                             (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    ^ V                                                                         (CONVERT_ATD0/2D_IPOL)
                                      ;    |                                                                           (CONVERT_ATD0/2D_IPOL)
                                      ;  Z2+....................*                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;    |                    :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CONVERT_ATD0/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CONVERT_ATD0/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CONVERT_ATD0/2D_IPOL)
                                      ;    |   :       :        :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004BBF 7F4BBF EC 86                                   LDD       \1    ; load V                                         (CONVERT_ATD0/2D_IPOL)
004BC1 7F4BC1 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004BC3 7F4BC3 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004BC5 7F4BC5 EC 80                                   LDD       \5    ; load Z2                                        (CONVERT_ATD0/2D_IPOL)
004BC7 7F4BC7 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004BC9 7F4BC9 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CONVERT_ATD0/2D_IPOL)
004BCB 7F4BCB B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004BCD 7F4BCD EC 84                                   LDD       \3    ; load V2                                        (CONVERT_ATD0/2D_IPOL)
004BCF 7F4BCF A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004BD1 7F4BD1 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CONVERT_ATD0/2D_IPOL)
                                      ;*********************************************************************           (CONVERT_ATD0/2D_IPOL)
004BD3 7F4BD3 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CONVERT_ATD0/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CONVERT_ATD0/2D_IPOL)
004BD5 7F4BD5 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004BD7 7F4BD7 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Free stack space (result in D)                                               (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004BD9 7F4BD9 1B 8A                       leas  10,SP    ; Stack pointer -> bottom of stack                            (CONVERT_ATD0)
004BDB 7F4BDB 7C 10 7C                    std  TpsPctx10 ; Copy result to "TpsPctx10" Throttle Position Percent of travel x 10 (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Air Fuel Ratio x 10 for left bank (odd cylinders)-                 (CONVERT_ATD0)
                                      ;   Innovate LC-2 AFR is ratiometric 0V to 5V 7.35 AFR to 22.39 AFR              (CONVERT_ATD0)
                                      ;   ( All variables are multiplied by 10 for greater precision)                  (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004BDE 7F4BDE CC 00 00                    ldd  #$0000      ; Load double accumulator with decimal 0 (0 volt ADC) ( x 10) (CONVERT_ATD0)
004BE1 7F4BE1 3B                          pshd             ; Push to stack (V1)                                        (CONVERT_ATD0)
004BE2 7F4BE2 FC 10 7E                    ldd  egoAdc1      ; Load double accumulator with "egoAdc1"                   (CONVERT_ATD0)
004BE5 7F4BE5 CD 00 0A                    ldy  #$000A      ; Load index register Y with decimal 10                     (CONVERT_ATD0)
004BE8 7F4BE8 13                          emul             ; Multiply (D)x(Y)=>Y:D  (multiply "eopAdc" by 10)          (CONVERT_ATD0)
004BE9 7F4BE9 3B                          pshd             ; Push to stack (V)                                         (CONVERT_ATD0)
004BEA 7F4BEA CC 27 F6                    ldd  #$27F6      ; Load double accumulator with decimal 1023 (5 volt ADC) ( x 10) (10230) (CONVERT_ATD0)
004BED 7F4BED 3B                          pshd             ; Push to stack (V2)                                        (CONVERT_ATD0)
004BEE 7F4BEE CC 00 4A                    ldd  #$004A      ; Load double accumulator with decimal 7.35 (Low range AFR) ( x 10) (74) (CONVERT_ATD0)
004BF1 7F4BF1 3B                          pshd             ; Push to stack (Z1)                                        (CONVERT_ATD0)
004BF2 7F4BF2 CC 00 E0                    ldd  #$00E0      ; Load double accumulator with decimal 22.39 (High range AFR) ( x 10) (224) (CONVERT_ATD0)
004BF5 7F4BF5 3B                          pshd             ; Push to stack (Z2)                                        (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z2       |  SP+ 0                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z1       |  SP+ 2                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V2       |  SP+ 4                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V        |  SP+ 6                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V1       |  SP+ 8                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                      ;                     V      V1      V2      Z1    Z2                            (CONVERT_ATD0)
004BF6 7F4BF6 MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; ==========================                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CONVERT_ATD0/2D_IPOL)
                                      ; SSTACK: none                                                                   (CONVERT_ATD0/2D_IPOL)
                                      ;         no registers are preserved                                             (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    ^ V                                                                         (CONVERT_ATD0/2D_IPOL)
                                      ;    |                                                                           (CONVERT_ATD0/2D_IPOL)
                                      ;  Z2+....................*                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;    |                    :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CONVERT_ATD0/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CONVERT_ATD0/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CONVERT_ATD0/2D_IPOL)
                                      ;    |   :       :        :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004BF6 7F4BF6 EC 86                                   LDD       \1    ; load V                                         (CONVERT_ATD0/2D_IPOL)
004BF8 7F4BF8 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004BFA 7F4BFA B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004BFC 7F4BFC EC 80                                   LDD       \5    ; load Z2                                        (CONVERT_ATD0/2D_IPOL)
004BFE 7F4BFE A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004C00 7F4C00 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CONVERT_ATD0/2D_IPOL)
004C02 7F4C02 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004C04 7F4C04 EC 84                                   LDD       \3    ; load V2                                        (CONVERT_ATD0/2D_IPOL)
004C06 7F4C06 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004C08 7F4C08 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CONVERT_ATD0/2D_IPOL)
                                      ;*********************************************************************           (CONVERT_ATD0/2D_IPOL)
004C0A 7F4C0A 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CONVERT_ATD0/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CONVERT_ATD0/2D_IPOL)
004C0C 7F4C0C B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004C0E 7F4C0E E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Free stack space (result in D)                                               (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004C10 7F4C10 1B 8A                       leas  10,SP       ; Stack pointer -> bottom of stack                         (CONVERT_ATD0)
004C12 7F4C12 7C 10 80                    std   afr1x10     ; Copy result to "afr1x10" Air Fuel Ratio x 10             (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Barometric Pressure x 10(Used to calculate to 1 decimal place)     (CONVERT_ATD0)
                                      ;   Baro sensor MPXA6115AC7U                                                     (CONVERT_ATD0)
                                      ;   Vout = Baro sensor output voltage                                            (CONVERT_ATD0)
                                      ;   P = Barometric pressure in KPA                                               (CONVERT_ATD0)
                                      ;                                                                                (CONVERT_ATD0)
                                      ;   Vout = Vs x (0.009 x P - 0.095)                                              (CONVERT_ATD0)
                                      ;   Vout = (baroAdc/1023)*5                                                      (CONVERT_ATD0)
                                      ;   P = ((Vout/5)+0.095)/0.009                                                   (CONVERT_ATD0)
                                      ; - For integer math:                                                            (CONVERT_ATD0)
                                      ;   P x 10 = ((baroAdc*10,000)/1023)+950)/9                                      (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004C15 7F4C15 FC 10 82                    ldd   baroAdc       ; Load double accumulator with value in "baroAdc"        (CONVERT_ATD0)
004C18 7F4C18 CD 27 10                    ldy   #$2710        ; Load index register Y with decimal decimal 10,000      (CONVERT_ATD0)
004C1B 7F4C1B 13                          emul                ; Extended 16x16 multiply (D)x(Y)=Y:D                    (CONVERT_ATD0)
004C1C 7F4C1C CE 03 FF                    ldx   #$03FF        ; Load index register X with decimal 1023                (CONVERT_ATD0)
004C1F 7F4C1F 11                          ediv                ; Extended 32x16 divide(Y:D)/(X)=Y;Rem->D                (CONVERT_ATD0)
004C20 7F4C20 18 CB 03 B6                 addy  #$03B6        ; Add without carry decimal 950 to Y (Y)+(M:M+1)->(Y)    (CONVERT_ATD0)
004C24 7F4C24 B7 64                       tfr   Y,D           ; Copy value in "Y" to "D"                               (CONVERT_ATD0)
004C26 7F4C26 CE 00 09                    ldx   #$0009        ; Load index register "X" with decimal 9                 (CONVERT_ATD0)
004C29 7F4C29 18 10                       idiv                ; Integer divide (D)/(X)=>X Rem=>D                       (CONVERT_ATD0)
004C2B 7F4C2B 7E 10 84                    stx   Barox10        ; Copy result to "Barox10" (KPAx10)                     (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Engine Oil Pressure x 10 -                                         (CONVERT_ATD0)
                                      ;   Pressure transducer is ratiometric 1V to 5V 0PSI to 100PSI                   (CONVERT_ATD0)
                                      ;   ( All variables are multiplied by 10 for greater precision)                  (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004C2E 7F4C2E CC 08 02                    ldd  #$0802      ; Load double accumulator with decimal 205 (1 volt ADC) ( x 10) (CONVERT_ATD0)
004C31 7F4C31 3B                          pshd             ; Push to stack (V1)                                        (CONVERT_ATD0)
004C32 7F4C32 FC 10 86                    ldd  eopAdc      ; Load double accumulator with "eopAdc"                     (CONVERT_ATD0)
004C35 7F4C35 CD 00 0A                    ldy  #$000A      ; Load index register Y with decimal 10                     (CONVERT_ATD0)
004C38 7F4C38 13                          emul             ; Multiply (D)x(Y)=>Y:D  (multiply "eopAdc" by 10)          (CONVERT_ATD0)
004C39 7F4C39 3B                          pshd             ; Push to stack (V)                                         (CONVERT_ATD0)
004C3A 7F4C3A CC 27 F6                    ldd  #$27F6      ; Load double accumulator with decimal 1023 (5 volt ADC) ( x 10) (CONVERT_ATD0)
004C3D 7F4C3D 3B                          pshd             ; Push to stack (V2)                                        (CONVERT_ATD0)
004C3E 7F4C3E CC 00 00                    ldd  #$0000      ; Load double accumulator with decimal 0 (Low range PSI) ( x 10) (CONVERT_ATD0)
004C41 7F4C41 3B                          pshd             ; Push to stack (Z1)                                        (CONVERT_ATD0)
004C42 7F4C42 CC 03 E8                    ldd  #$03E8      ; Load double accumulator with decimal 100 (High range PSI) ( x 10) (CONVERT_ATD0)
004C45 7F4C45 3B                          pshd             ; Push to stack (Z2)                                        (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z2       |  SP+ 0                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z1       |  SP+ 2                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V2       |  SP+ 4                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V        |  SP+ 6                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V1       |  SP+ 8                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                      ;                     V      V1      V2      Z1    Z2                            (CONVERT_ATD0)
004C46 7F4C46 MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; ==========================                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CONVERT_ATD0/2D_IPOL)
                                      ; SSTACK: none                                                                   (CONVERT_ATD0/2D_IPOL)
                                      ;         no registers are preserved                                             (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    ^ V                                                                         (CONVERT_ATD0/2D_IPOL)
                                      ;    |                                                                           (CONVERT_ATD0/2D_IPOL)
                                      ;  Z2+....................*                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;    |                    :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CONVERT_ATD0/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CONVERT_ATD0/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CONVERT_ATD0/2D_IPOL)
                                      ;    |   :       :        :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004C46 7F4C46 EC 86                                   LDD       \1    ; load V                                         (CONVERT_ATD0/2D_IPOL)
004C48 7F4C48 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004C4A 7F4C4A B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004C4C 7F4C4C EC 80                                   LDD       \5    ; load Z2                                        (CONVERT_ATD0/2D_IPOL)
004C4E 7F4C4E A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004C50 7F4C50 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CONVERT_ATD0/2D_IPOL)
004C52 7F4C52 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004C54 7F4C54 EC 84                                   LDD       \3    ; load V2                                        (CONVERT_ATD0/2D_IPOL)
004C56 7F4C56 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004C58 7F4C58 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CONVERT_ATD0/2D_IPOL)
                                      ;*********************************************************************           (CONVERT_ATD0/2D_IPOL)
004C5A 7F4C5A 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CONVERT_ATD0/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CONVERT_ATD0/2D_IPOL)
004C5C 7F4C5C B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004C5E 7F4C5E E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Free stack space (result in D)                                               (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004C60 7F4C60 1B 8A                       leas  10,SP    ; Stack pointer -> bottom of stack                            (CONVERT_ATD0)
004C62 7F4C62 7C 10 88                    std   Eopx10   ; Copy result to "Eopx10" Engine Oil Pressure x 10            (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Engine Fuel Pressure x 10 -                                        (CONVERT_ATD0)
                                      ;   Pressure transducer is ratiometric 1V to 5V 0PSI to 100PSI                   (CONVERT_ATD0)
                                      ;   ( All variables are multiplied by 10 for greater precision)                  (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004C65 7F4C65 CC 08 02                    ldd  #$0802      ; Load double accumulator with decimal 205 (1 volt ADC) ( x 10) (CONVERT_ATD0)
004C68 7F4C68 3B                          pshd             ; Push to stack (V1)                                        (CONVERT_ATD0)
004C69 7F4C69 FC 10 8A                    ldd  efpAdc      ; Load double accumulator with "efpAdc"                     (CONVERT_ATD0)
004C6C 7F4C6C CD 00 0A                    ldy  #$000A      ; Load index register Y with decimal 10                     (CONVERT_ATD0)
004C6F 7F4C6F 13                          emul             ; Multiply (D)x(Y)=>Y:D  (multiply "eopAdc" by 10)          (CONVERT_ATD0)
004C70 7F4C70 3B                          pshd             ; Push to stack (V)                                         (CONVERT_ATD0)
004C71 7F4C71 CC 27 F6                    ldd  #$27F6      ; Load double accumulator with decimal 1023 (5 volt ADC) ( x 10) (CONVERT_ATD0)
004C74 7F4C74 3B                          pshd             ; Push to stack (V2)                                        (CONVERT_ATD0)
004C75 7F4C75 CC 00 00                    ldd  #$0000      ; Load double accumulator with decimal 0 (Low range PSI) ( x 10) (CONVERT_ATD0)
004C78 7F4C78 3B                          pshd             ; Push to stack (Z1)                                        (CONVERT_ATD0)
004C79 7F4C79 CC 03 E8                    ldd  #$03E8      ; Load double accumulator with decimal 100 (High range PSI) ( x 10) (CONVERT_ATD0)
004C7C 7F4C7C 3B                          pshd             ; Push to stack (Z2)                                        (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z2       |  SP+ 0                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z1       |  SP+ 2                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V2       |  SP+ 4                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V        |  SP+ 6                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V1       |  SP+ 8                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                      ;                     V      V1      V2      Z1    Z2                            (CONVERT_ATD0)
004C7D 7F4C7D MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; ==========================                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CONVERT_ATD0/2D_IPOL)
                                      ; SSTACK: none                                                                   (CONVERT_ATD0/2D_IPOL)
                                      ;         no registers are preserved                                             (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    ^ V                                                                         (CONVERT_ATD0/2D_IPOL)
                                      ;    |                                                                           (CONVERT_ATD0/2D_IPOL)
                                      ;  Z2+....................*                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;    |                    :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CONVERT_ATD0/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CONVERT_ATD0/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CONVERT_ATD0/2D_IPOL)
                                      ;    |   :       :        :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004C7D 7F4C7D EC 86                                   LDD       \1    ; load V                                         (CONVERT_ATD0/2D_IPOL)
004C7F 7F4C7F A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004C81 7F4C81 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004C83 7F4C83 EC 80                                   LDD       \5    ; load Z2                                        (CONVERT_ATD0/2D_IPOL)
004C85 7F4C85 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004C87 7F4C87 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CONVERT_ATD0/2D_IPOL)
004C89 7F4C89 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004C8B 7F4C8B EC 84                                   LDD       \3    ; load V2                                        (CONVERT_ATD0/2D_IPOL)
004C8D 7F4C8D A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004C8F 7F4C8F B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CONVERT_ATD0/2D_IPOL)
                                      ;*********************************************************************           (CONVERT_ATD0/2D_IPOL)
004C91 7F4C91 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CONVERT_ATD0/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CONVERT_ATD0/2D_IPOL)
004C93 7F4C93 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004C95 7F4C95 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Free stack space (result in D)                                               (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004C97 7F4C97 1B 8A                       leas  10,SP    ; Stack pointer -> bottom of stack                            (CONVERT_ATD0)
004C99 7F4C99 7C 10 8C                    std   Efpx10   ; Copy result to "Efpx10" Engine Fuel Pressure x 10           (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Ignition Trim (Degrees x 10)(+-20 Degrees) -                       (CONVERT_ATD0)
                                      ;   Ignition calculations delay the coil energisation time (dwell) and the discharge time (CONVERT_ATD0)
                                      ;   (spark timing) from a known crankshaft angle. A trim offset of 20 degrees is built in. (CONVERT_ATD0)
                                      ;    An Itrm value of 0 results in 20 degree retard                              (CONVERT_ATD0)
                                      ;    An Itrm value of 20 results in no ignition trim                             (CONVERT_ATD0)
                                      ;    An Itrm value of 40 results in 20 degree advance                            (CONVERT_ATD0)
                                      ;   ( All variables are multiplied by 10 for greater precision)                  (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004C9C 7F4C9C 1E 10 DC 02 39              brset PortAbits,Itrimen,NoItrim ; "If Itrimen" bit of "PortAbits" is set, branch to (CONVERT_ATD0)
                                                               ; NoItrim: (Ignition trim enable switch is off so skip over) (CONVERT_ATD0)
004CA1 7F4CA1 CC 00 00                    ldd  #$0000      ; Load double accumulator with zero (0 volt ADC)            (CONVERT_ATD0)
004CA4 7F4CA4 3B                          pshd             ; Push to stack (V1)                                        (CONVERT_ATD0)
004CA5 7F4CA5 FC 10 8E                    ldd  itrmAdc     ; Load double accumulator with "itrmAdc"                    (CONVERT_ATD0)
004CA8 7F4CA8 CD 00 0A                    ldy  #$000A      ; Load index register Y with decimal 10                     (CONVERT_ATD0)
004CAB 7F4CAB 13                          emul             ; Multiply (D)x(Y)=>Y:D  (multiply "itrmAdc" by 10)         (CONVERT_ATD0)
004CAC 7F4CAC 3B                          pshd             ; Push to stack (V)                                         (CONVERT_ATD0)
004CAD 7F4CAD CC 27 F6                    ldd  #$27F6      ; Load double accumulator with decimal 1023x10 (5 volt ADC) (CONVERT_ATD0)
004CB0 7F4CB0 3B                          pshd             ; Push to stack (V2)                                        (CONVERT_ATD0)
004CB1 7F4CB1 CC 00 00                    ldd  #$0000      ; Load double accumulator with zero (Low range degrees)     (CONVERT_ATD0)
004CB4 7F4CB4 3B                          pshd             ; Push to stack (Z1)                                        (CONVERT_ATD0)
004CB5 7F4CB5 CC 01 90                    ldd  #$0190      ; Load double accumulator with decimal 40x10 (High range degrees) (CONVERT_ATD0)
004CB8 7F4CB8 3B                          pshd             ; Push to stack (Z2)                                        (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z2       |  SP+ 0                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z1       |  SP+ 2                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V2       |  SP+ 4                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V        |  SP+ 6                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V1       |  SP+ 8                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                      ;                     V      V1      V2      Z1    Z2                            (CONVERT_ATD0)
004CB9 7F4CB9 MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; ==========================                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CONVERT_ATD0/2D_IPOL)
                                      ; SSTACK: none                                                                   (CONVERT_ATD0/2D_IPOL)
                                      ;         no registers are preserved                                             (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    ^ V                                                                         (CONVERT_ATD0/2D_IPOL)
                                      ;    |                                                                           (CONVERT_ATD0/2D_IPOL)
                                      ;  Z2+....................*                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;    |                    :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CONVERT_ATD0/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CONVERT_ATD0/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CONVERT_ATD0/2D_IPOL)
                                      ;    |   :       :        :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004CB9 7F4CB9 EC 86                                   LDD       \1    ; load V                                         (CONVERT_ATD0/2D_IPOL)
004CBB 7F4CBB A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004CBD 7F4CBD B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004CBF 7F4CBF EC 80                                   LDD       \5    ; load Z2                                        (CONVERT_ATD0/2D_IPOL)
004CC1 7F4CC1 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004CC3 7F4CC3 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CONVERT_ATD0/2D_IPOL)
004CC5 7F4CC5 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004CC7 7F4CC7 EC 84                                   LDD       \3    ; load V2                                        (CONVERT_ATD0/2D_IPOL)
004CC9 7F4CC9 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004CCB 7F4CCB B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CONVERT_ATD0/2D_IPOL)
                                      ;*********************************************************************           (CONVERT_ATD0/2D_IPOL)
004CCD 7F4CCD 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CONVERT_ATD0/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CONVERT_ATD0/2D_IPOL)
004CCF 7F4CCF B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004CD1 7F4CD1 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Free stack space (result in D)                                               (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004CD3 7F4CD3 1B 8A                       leas  10,SP     ; Stack pointer -> bottom of stack                           (CONVERT_ATD0)
004CD5 7F4CD5 7C 10 90                    std   Itrmx10   ; Copy result to "Itrmx10" Ignition Trim (Degrees x 10)      (CONVERT_ATD0)
004CD8 7F4CD8 20 06                           bra   ItrimDone ; Branch to ItrimDone:                                   (CONVERT_ATD0)
004CDA 7F4CDA                         NoItrim:                                                                         (CONVERT_ATD0)
004CDA 7F4CDA 18 03 00 CB 10 90           movw #$00CB,Itrmx10  ; Decimal 200 -> "Itrmx10" (20 degrees, no trim)        (CONVERT_ATD0)
004CE0 7F4CE0                         ItrimDone:                                                                       (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Fuel Trim (% x 10)(+-20%) -                                        (CONVERT_ATD0)
                                      ;   (80% = 80% of VEcurr, 100% = 100% of VeCurr(no correction), 120% = 120% of VEcurr) (CONVERT_ATD0)
                                      ;   ( All variables are multiplied by 10 for greater precision)                  (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004CE0 7F4CE0 1E 10 DC 04 39              brset PortAbits,Ftrimen,NoFtrim ; "If Ftrimen" bit of "PortAbits" set, branch to (CONVERT_ATD0)
                                                                ; NoFtrim: (Fuel trim enable switch is off so skip over) (CONVERT_ATD0)
004CE5 7F4CE5 CC 00 00                    ldd   #$0000      ; Load double accumulator with zero (0 volt ADC)           (CONVERT_ATD0)
004CE8 7F4CE8 3B                          pshd              ; Push to stack (V1)                                       (CONVERT_ATD0)
004CE9 7F4CE9 FC 10 92                    ldd   ftrmAdc     ; Load double accumulator with "ftrmAdc"                   (CONVERT_ATD0)
004CEC 7F4CEC CD 00 0A                    ldy   #$000A      ; Load index register Y with decimal 10                    (CONVERT_ATD0)
004CEF 7F4CEF 13                          emul              ; Multiply (D)x(Y)=>Y:D  (multiply "eopAdc" by 10)         (CONVERT_ATD0)
004CF0 7F4CF0 3B                          pshd              ; Push to stack (V)                                        (CONVERT_ATD0)
004CF1 7F4CF1 CC 27 F6                    ldd   #$27F6      ; Load double accumulator with decimal 1023x10 (5 volt ADC) (CONVERT_ATD0)
004CF4 7F4CF4 3B                          pshd              ; Push to stack (V2)                                       (CONVERT_ATD0)
004CF5 7F4CF5 CC 03 20                    ldd   #$0320      ; Load double accumulator with decimal 80x10 (Low range %) (CONVERT_ATD0)
004CF8 7F4CF8 3B                          pshd              ; Push to stack (Z1)                                       (CONVERT_ATD0)
004CF9 7F4CF9 CC 04 B0                    ldd   #$04B0      ; Load double accumulator with decimal 120x10 (High range %) (CONVERT_ATD0)
004CFC 7F4CFC 3B                          pshd              ; Push to stack (Z2)                                       (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z2       |  SP+ 0                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z1       |  SP+ 2                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V2       |  SP+ 4                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V        |  SP+ 6                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V1       |  SP+ 8                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                      ;                     V      V1      V2      Z1    Z2                            (CONVERT_ATD0)
004CFD 7F4CFD MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; ==========================                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CONVERT_ATD0/2D_IPOL)
                                      ; SSTACK: none                                                                   (CONVERT_ATD0/2D_IPOL)
                                      ;         no registers are preserved                                             (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    ^ V                                                                         (CONVERT_ATD0/2D_IPOL)
                                      ;    |                                                                           (CONVERT_ATD0/2D_IPOL)
                                      ;  Z2+....................*                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;    |                    :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CONVERT_ATD0/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CONVERT_ATD0/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CONVERT_ATD0/2D_IPOL)
                                      ;    |   :       :        :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004CFD 7F4CFD EC 86                                   LDD       \1    ; load V                                         (CONVERT_ATD0/2D_IPOL)
004CFF 7F4CFF A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004D01 7F4D01 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004D03 7F4D03 EC 80                                   LDD       \5    ; load Z2                                        (CONVERT_ATD0/2D_IPOL)
004D05 7F4D05 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004D07 7F4D07 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CONVERT_ATD0/2D_IPOL)
004D09 7F4D09 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004D0B 7F4D0B EC 84                                   LDD       \3    ; load V2                                        (CONVERT_ATD0/2D_IPOL)
004D0D 7F4D0D A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004D0F 7F4D0F B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CONVERT_ATD0/2D_IPOL)
                                      ;*********************************************************************           (CONVERT_ATD0/2D_IPOL)
004D11 7F4D11 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CONVERT_ATD0/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CONVERT_ATD0/2D_IPOL)
004D13 7F4D13 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004D15 7F4D15 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Free stack space (result in D)                                               (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004D17 7F4D17 1B 8A                       leas  10,SP     ; Stack pointer -> bottom of stack                           (CONVERT_ATD0)
004D19 7F4D19 7C 10 94                    std   Ftrmx10   ; Copy result to "Ftrmx10" Fuel Trim (%x10)                  (CONVERT_ATD0)
004D1C 7F4D1C 20 06                           bra   FtrimDone ; Branch to FtrimDone:                                   (CONVERT_ATD0)
004D1E 7F4D1E                         NoFtrim:                                                                         (CONVERT_ATD0)
004D1E 7F4D1E 18 03 03 E8 10 94           movw #$03E8,Ftrmx10  ; Decimal 1000 -> "Ftrmx10" (100%, no trim)             (CONVERT_ATD0)
004D24 7F4D24                         FtrimDone:                                                                       (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Calculate Air Fuel Ratio x 10 for right bank (even cylinders)-               (CONVERT_ATD0)
                                      ;   Innovate LC-2 AFR is ratiometric 0V to 5V 7.35 AFR to 22.39 AFR              (CONVERT_ATD0)
                                      ;   ( All variables are multiplied by 10 for greater precision)                  (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004D24 7F4D24 CC 00 00                    ldd  #$0000      ; Load double accumulator with decimal 0 (0 volt ADC) ( x 10) (CONVERT_ATD0)
004D27 7F4D27 3B                          pshd             ; Push to stack (V1)                                        (CONVERT_ATD0)
004D28 7F4D28 FC 10 96                    ldd  egoAdc2     ; Load double accumulator with "egoAdc2"                    (CONVERT_ATD0)
004D2B 7F4D2B CD 00 0A                    ldy  #$000A      ; Load index register Y with decimal 10                     (CONVERT_ATD0)
004D2E 7F4D2E 13                          emul             ; Multiply (D)x(Y)=>Y:D  (multiply "eopAdc" by 10)          (CONVERT_ATD0)
004D2F 7F4D2F 3B                          pshd             ; Push to stack (V)                                         (CONVERT_ATD0)
004D30 7F4D30 CC 27 F6                    ldd  #$27F6      ; Load double accumulator with decimal 1023 (5 volt ADC) ( x 10) (10230) (CONVERT_ATD0)
004D33 7F4D33 3B                          pshd             ; Push to stack (V2)                                        (CONVERT_ATD0)
004D34 7F4D34 CC 00 4A                    ldd  #$004A      ; Load double accumulator with decimal 7.35 (Low range AFR) ( x 10) (74) (CONVERT_ATD0)
004D37 7F4D37 3B                          pshd             ; Push to stack (Z1)                                        (CONVERT_ATD0)
004D38 7F4D38 CC 00 E0                    ldd  #$00E0      ; Load double accumulator with decimal 22.39 (High range AFR) ( x 10) (224) (CONVERT_ATD0)
004D3B 7F4D3B 3B                          pshd             ; Push to stack (Z2)                                        (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z2       |  SP+ 0                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        Z1       |  SP+ 2                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V2       |  SP+ 4                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V        |  SP+ 6                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                                      ;    |        V1       |  SP+ 8                                  (CONVERT_ATD0)
                                                      ;    +--------+--------+                                         (CONVERT_ATD0)
                                      ;                     V      V1      V2      Z1    Z2                            (CONVERT_ATD0)
004D3C 7F4D3C MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; ==========================                                                     (CONVERT_ATD0/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CONVERT_ATD0/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CONVERT_ATD0/2D_IPOL)
                                      ; SSTACK: none                                                                   (CONVERT_ATD0/2D_IPOL)
                                      ;         no registers are preserved                                             (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    ^ V                                                                         (CONVERT_ATD0/2D_IPOL)
                                      ;    |                                                                           (CONVERT_ATD0/2D_IPOL)
                                      ;  Z2+....................*                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;    |                    :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CONVERT_ATD0/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CONVERT_ATD0/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CONVERT_ATD0/2D_IPOL)
                                      ;    |   :       :        :                                                      (CONVERT_ATD0/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CONVERT_ATD0/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;                                                                                (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004D3C 7F4D3C EC 86                                   LDD       \1    ; load V                                         (CONVERT_ATD0/2D_IPOL)
004D3E 7F4D3E A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004D40 7F4D40 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004D42 7F4D42 EC 80                                   LDD       \5    ; load Z2                                        (CONVERT_ATD0/2D_IPOL)
004D44 7F4D44 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004D46 7F4D46 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CONVERT_ATD0/2D_IPOL)
004D48 7F4D48 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004D4A 7F4D4A EC 84                                   LDD       \3    ; load V2                                        (CONVERT_ATD0/2D_IPOL)
004D4C 7F4D4C A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CONVERT_ATD0/2D_IPOL)
004D4E 7F4D4E B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CONVERT_ATD0/2D_IPOL)
                                      ;*********************************************************************           (CONVERT_ATD0/2D_IPOL)
004D50 7F4D50 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CONVERT_ATD0/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CONVERT_ATD0/2D_IPOL)
004D52 7F4D52 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0/2D_IPOL)
004D54 7F4D54 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CONVERT_ATD0/2D_IPOL)
                                      ;***************************************************************************************** (CONVERT_ATD0)
                                      ; - Free stack space (result in D)                                               (CONVERT_ATD0)
                                      ;***************************************************************************************** (CONVERT_ATD0)
004D56 7F4D56 1B 8A                       leas  10,SP       ; Stack pointer -> bottom of stack                         (CONVERT_ATD0)
004D58 7F4D58 7C 10 98                    std   afr2x10     ; Copy result to "afr2x10" Air Fuel Ratio x 10             (CONVERT_ATD0)
                                      ;*****************************************************************************************
                                      ; - BPEM488 allows for the following alarms:
                                      ;   High Engine Temperature
                                      ;   High Oil Temperature         NOT USED
                                      ;   High Fuel Temperature        NOT USED
                                      ;   High Exhaust Gas Temperture  NOT USED
                                      ;   Low Oil Pressure
                                      ;   High Fuel Pressure
                                      ;   Low Fuel Pressure
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Check to see if we have any alarm conditions.
                                      ;*****************************************************************************************
004D5B 7F4D5B MACRO                       CHECK_ALARMS    ; Macro in adc0BPEM488.s
                                      ;***************************************************************************************** (CHECK_ALARMS)
                                      ; - BPEM488 allows for the following alarms:                                     (CHECK_ALARMS)
                                      ;   High Engine Temperature                                                      (CHECK_ALARMS)
                                      ;   High Oil Temperature                                                         (CHECK_ALARMS)
                                      ;   High Fuel Temperature                                                        (CHECK_ALARMS)
                                      ;   High Exhaust Gas Temperture                                                  (CHECK_ALARMS)
                                      ;   Low Oil Pressure                                                             (CHECK_ALARMS)
                                      ;   High Fuel Pressure                                                           (CHECK_ALARMS)
                                      ;   Low Fuel Pressure                                                            (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
                                      ; - Check for high engine temperature.                                           (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
004D5B 7F4D5B                         CHK_HET_OFF:                                                                     (CHECK_ALARMS)
004D5B 7F4D5B 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                   (CHECK_ALARMS)
004D60 7F4D60 CD 08 00                    ldy  #stBins_E    ; Load index register Y with address of first configurable constant (CHECK_ALARMS)
                                                          ; on buffer RAM page 2 (stBins)                              (CHECK_ALARMS)
004D63 7F4D63 EC EA 02 D2                 ldd  $02D2,Y    ; Load Accu D with value in buffer RAM page 2 offset 722 (hetoff) (CHECK_ALARMS)
004D67 7F4D67 BC 10 6C                        cpd  Cltx10     ; (A:B)-(M:M+1) Compare "hetoff" with "Cltx10            (CHECK_ALARMS)
004D6A 7F4D6A 24 02                       bhs  CLEAR_HET  ; If "hetoff" is higher or the same as "Cltx10" branch to CLEAR_HET (CHECK_ALARMS)
004D6C 7F4D6C 20 0E                       bra  CHK_HET_ON ; Branch to CHK_HET_ON:                                      (CHECK_ALARMS)
004D6E 7F4D6E                         CLEAR_HET:                                                                       (CHECK_ALARMS)
004D6E 7F4D6E 1F 10 E3 04 28               brclr   alarmbits,HET,HET_ALARM_DONE ; If "HET" bit of "alarmbits" is clear, (CHECK_ALARMS)
                                                                                ; branch to HET_ALARM_DONE:            (CHECK_ALARMS)
004D73 7F4D73 1D 10 E3 04                  bclr    alarmbits,HET                ; Clear "HET" bit of "alarmbits"       (CHECK_ALARMS)
004D77 7F4D77 4D 32 04                     bclr    PORTK,HETalrm                ; Clear "HETalrm" bit of Port K (indicator off) (CHECK_ALARMS)
004D7A 7F4D7A 20 1F                        bra     HET_ALARM_DONE               ; Branch to HET_ALARM_DONE:            (CHECK_ALARMS)
004D7C 7F4D7C                         CHK_HET_ON:                                                                      (CHECK_ALARMS)
004D7C 7F4D7C 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                   (CHECK_ALARMS)
004D81 7F4D81 CD 08 00                    ldy  #stBins_E    ; Load index register Y with address of first configurable constant (CHECK_ALARMS)
                                                          ; on buffer RAM page 2 (stBins)                              (CHECK_ALARMS)
004D84 7F4D84 EC EA 02 D0                 ldd  $02D0,Y    ; Load Accu D with value in buffer RAM page 2 offset 720 (heton) (CHECK_ALARMS)
004D88 7F4D88 BC 10 6C                        cpd  Cltx10     ; (A:B)-(M:M+1) Compare "heton" with "Cltx10"            (CHECK_ALARMS)
004D8B 7F4D8B 23 02                       bls  SET_HET    ; If "heton" is lower or the same as "Cltx10" branch to SET_HET (CHECK_ALARMS)
004D8D 7F4D8D 20 0C                       bra  HET_ALARM_DONE ; Branch to HET_ALARM_DONE:                              (CHECK_ALARMS)
004D8F 7F4D8F                         SET_HET:                                                                         (CHECK_ALARMS)
004D8F 7F4D8F 1E 10 E3 04 07               brset   alarmbits,HET,HET_ALARM_DONE ; If "HET" bit of "alarmbits" is set, branch to (CHECK_ALARMS)
                                                                                ; HET_ALARM_DONE:                      (CHECK_ALARMS)
004D94 7F4D94 1C 10 E3 04                  bset    alarmbits,HET                ; Set "HET" bit of "alarmbits"         (CHECK_ALARMS)
004D98 7F4D98 4C 32 04                     bset    PORTK,HETalrm                ; Set "HETalrm" bit of Port K (indicator on) (CHECK_ALARMS)
004D9B 7F4D9B                         HET_ALARM_DONE:                                                                  (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
                                      ; - Check for high oil temperature.                                              (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
                                      ;*CHK_HOT_OFF:                                                                   (CHECK_ALARMS)
                                      ;*    movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                 (CHECK_ALARMS)
                                      ;*    ldy  #stBins_E    ; Load index register Y with address of first configurable constant (CHECK_ALARMS)
                                      ;*                    ; on buffer RAM page 2 (stBins)                            (CHECK_ALARMS)
                                      ;*    ldd  $02D6,Y    ; Load Accu D with value in buffer RAM page 2 offset 726 (hotoff) (CHECK_ALARMS)
                                      ;*      cpd  Eotx10     ; (A:B)-(M:M+1) Compare "hotoff" with "Eotx10"           (CHECK_ALARMS)
                                      ;*    bhs  CLEAR_HOT  ; If "hotoff" is higher or the same as "Eotx10" branch to CLEAR_HOT (CHECK_ALARMS)
                                      ;*    bra  CHK_HOT_ON ; Branch to CHK_HOT_ON:                                    (CHECK_ALARMS)
                                      ;*CLEAR_HOT:                                                                     (CHECK_ALARMS)
                                      ;*     brclr   alarmbits,HOT,HOT_ALARM_DONE ; If "HOT" bit of "alarmbits" is clear, (CHECK_ALARMS)
                                      ;*                                          ; branch to HOT_ALARM_DONE:          (CHECK_ALARMS)
                                      ;*     bclr    alarmbits,HOT                ; Clear "HOT" bit of "alarmbits"     (CHECK_ALARMS)
                                      ;*     bclr    PORTK,HOTalrm                ; Clear "HOTalrm" bit of Port K (indicator off) (CHECK_ALARMS)
                                      ;*     bra     HOT_ALARM_DONE               ; Branch to HOT_ALARM_DONE:          (CHECK_ALARMS)
                                      ;*CHK_HOT_ON:                                                                    (CHECK_ALARMS)
                                      ;*    movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                 (CHECK_ALARMS)
                                      ;*    ldy  #stBins_E    ; Load index register Y with address of first configurable constant (CHECK_ALARMS)
                                      ;*                    ; on buffer RAM page 2 (stBins)                            (CHECK_ALARMS)
                                      ;*    ldd  $02D4,Y    ; Load Accu D with value in buffer RAM page 2 offset 724 (hoton) (CHECK_ALARMS)
                                      ;*      cpd  Eotx10     ; (A:B)-(M:M+1) Compare "hoton" with "Eotx10"            (CHECK_ALARMS)
                                      ;*    bls  SET_HOT    ; If "hoton" is lower or the same as "Eotx10" branch to SET_HOT (CHECK_ALARMS)
                                      ;*    bra  HOT_ALARM_DONE ; Branch to HOT_ALARM_DONE:                            (CHECK_ALARMS)
                                      ;*                                                                               (CHECK_ALARMS)
                                      ;*SET_HOT:                                                                       (CHECK_ALARMS)
                                      ;*     brset   alarmbits,HOT,HOT_ALARM_DONE ; If "HOT" bit of "alarmbits" is set, branch to (CHECK_ALARMS)
                                      ;*                                          ; HOT_ALARM_DONE:                    (CHECK_ALARMS)
                                      ;*     bset    alarmbits,HOT                ; Set "HOT" bit of "alarmbits"       (CHECK_ALARMS)
                                      ;*     bset    PORTK,HOTalrm                ; Set "HOTalrm" bit of Port K (indicator on) (CHECK_ALARMS)
                                      ;*                                                                               (CHECK_ALARMS)
                                      ;*HOT_ALARM_DONE:                                                                (CHECK_ALARMS)
                                      ;*                                                                               (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
                                      ; - Check for high fuel temperature.                                             (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
                                      ;*                                                                               (CHECK_ALARMS)
                                      ;*CHK_HFT_OFF:                                                                   (CHECK_ALARMS)
                                      ;*    movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                 (CHECK_ALARMS)
                                      ;*    ldy  #stBins_E    ; Load index register Y with address of first configurable constant (CHECK_ALARMS)
                                      ;*                    ; on buffer RAM page 2 (stBins)                            (CHECK_ALARMS)
                                      ;*    ldd  $02DA,Y    ; Load Accu D with value in buffer RAM page 2 offset 730 (hftoff) (CHECK_ALARMS)
                                      ;*      cpd  Eftx10     ; (A:B)-(M:M+1) Compare "hftoff" with "Eftx10"           (CHECK_ALARMS)
                                      ;*    bhs  CLEAR_HFT  ; If "hftoff" is higher or the same as "Eftx10" branch to CLEAR_HFT (CHECK_ALARMS)
                                      ;*    bra  CHK_HFT_ON ; Branch to CHK_HFT_ON:                                    (CHECK_ALARMS)
                                      ;*                                                                               (CHECK_ALARMS)
                                      ;*CLEAR_HFT:                                                                     (CHECK_ALARMS)
                                      ;*     brclr   alarmbits,HFT,HFT_ALARM_DONE ; If "HFT" bit of "alarmbits" is clear, (CHECK_ALARMS)
                                      ;*                                          ; branch to HFT_ALARM_DONE:          (CHECK_ALARMS)
                                      ;*     bclr    alarmbits,HFT                ; Clear "HFT" bit of "alarmbits"     (CHECK_ALARMS)
                                      ;*     bclr    PORTK,HFTalrm                ; Clear "HFTalrm" bit of Port K (indicator off) (CHECK_ALARMS)
                                      ;*     bra     HFT_ALARM_DONE               ; Branch to HFT_ALARM_DONE:          (CHECK_ALARMS)
                                      ;*                                                                               (CHECK_ALARMS)
                                      ;*CHK_HFT_ON:                                                                    (CHECK_ALARMS)
                                      ;*    movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                 (CHECK_ALARMS)
                                      ;*    ldy  #stBins_E    ; Load index register Y with address of first configurable constant (CHECK_ALARMS)
                                      ;*                    ; on buffer RAM page 2 (stBins)                            (CHECK_ALARMS)
                                      ;*    ldd  $02D8,Y    ; Load Accu D with value in buffer RAM page 2 offset 728 (hfton) (CHECK_ALARMS)
                                      ;*      cpd  Eftx10     ; (A:B)-(M:M+1) Compare "hfton" with "Eftx10"            (CHECK_ALARMS)
                                      ;*    bls  SET_HFT    ; If "hfton" is lower or the same as "Eftx10" branch to SET_HFT (CHECK_ALARMS)
                                      ;*    bra  HFT_ALARM_DONE ; Branch to HFT_ALARM_DONE:                            (CHECK_ALARMS)
                                      ;*                                                                               (CHECK_ALARMS)
                                      ;*SET_HFT:                                                                       (CHECK_ALARMS)
                                      ;*     brset   alarmbits,HFT,HFT_ALARM_DONE ; If "HFT" bit of "alarmbits" is set, branch to (CHECK_ALARMS)
                                      ;*                                          ; HFT_ALARM_DONE:                    (CHECK_ALARMS)
                                      ;*     bset    alarmbits,HFT                ; Set "HFT" bit of "alarmbits"       (CHECK_ALARMS)
                                      ;*     bset    PORTK,HFTalrm                ; Set "HFTalrm" bit of Port K (indicator on) (CHECK_ALARMS)
                                      ;*                                                                               (CHECK_ALARMS)
                                      ;*HFT_ALARM_DONE:                                                                (CHECK_ALARMS)
                                      ;*                                                                               (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
                                      ; - Check for high exhaust gas temperature.                                      (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
                                      ;*                                                                               (CHECK_ALARMS)
                                      ;*CHK_HEGT_OFF:                                                                  (CHECK_ALARMS)
                                      ;*    movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                 (CHECK_ALARMS)
                                      ;*    ldy  #stBins_E     ; Load index register Y with address of first configurable constant (CHECK_ALARMS)
                                      ;*                     ; on buffer RAM page 2 (stBins)                           (CHECK_ALARMS)
                                      ;*    ldd  $02DE,Y     ; Load Accu D with value in buffer RAM page 2 offset 734 (hegtoff) (CHECK_ALARMS)
                                      ;*      cpd  Egt         ; (A:B)-(M:M+1) Compare "hegt_ff" with "Egt"            (CHECK_ALARMS)
                                      ;*    bhs  CLEAR_HEGT  ; If "hegtoff" is higher or the same as "Egt" branch to CLEAR_HEGT (CHECK_ALARMS)
                                      ;*    bra  CHK_HEGT_ON ; Branch to CHK_HEGT_ON:                                  (CHECK_ALARMS)
                                      ;*                                                                               (CHECK_ALARMS)
                                      ;*CLEAR_HEGT:                                                                    (CHECK_ALARMS)
                                      ;*     brclr   alarmbits,HEGT,HEGT_ALARM_DONE ; If "HEGT" bit of "alarmbits" is clear, (CHECK_ALARMS)
                                      ;*                                            ; branch to HEGT_ALARM_DONE:       (CHECK_ALARMS)
                                      ;*     bclr    alarmbits,HEGT                 ; Clear "HEGT" bit of "alarmbits"  (CHECK_ALARMS)
                                      ;*     bclr    PORTK,HEGTalrm                 ; Clear "HEGTalrm" bit of Port K (indicator off) (CHECK_ALARMS)
                                      ;*     bra     HEGT_ALARM_DONE                ; Branch to HEGT_ALARM_DONE:       (CHECK_ALARMS)
                                      ;*                                                                               (CHECK_ALARMS)
                                      ;*CHK_HEGT_ON:                                                                   (CHECK_ALARMS)
                                      ;*    movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                 (CHECK_ALARMS)
                                      ;*    ldy  #stBins_E     ; Load index register Y with address of first configurable constant (CHECK_ALARMS)
                                      ;*                     ; on buffer RAM page 2 (stBins)                           (CHECK_ALARMS)
                                      ;*    ldd  $02DC,Y     ; Load Accu D with value in buffer RAM page 2 offset 732 (hegton) (CHECK_ALARMS)
                                      ;*      cpd  Egt         ; (A:B)-(M:M+1) Compare "hegton" with "Egt"             (CHECK_ALARMS)
                                      ;*    bls  SET_HEGT    ; If "hegton" is lower or the same as "Egt" branch to SET_HEGT (CHECK_ALARMS)
                                      ;*    bra  HEGT_ALARM_DONE ; Branch to HEGT_ALARM_DONE:                          (CHECK_ALARMS)
                                      ;*                                                                               (CHECK_ALARMS)
                                      ;*SET_HEGT:                                                                      (CHECK_ALARMS)
                                      ;*     brset   alarmbits,HEGT,HEGT_ALARM_DONE ; If "HEGT" bit of "alarmbits" is set, branch to (CHECK_ALARMS)
                                      ;*                                            ; HEGT_ALARM_DONE:                 (CHECK_ALARMS)
                                      ;*     bset    alarmbits,HEGT                 ; Set "HEGT" bit of "alarmbits"    (CHECK_ALARMS)
                                      ;*     bset    PORTK,HEGTalrm                 ; Set "HEGTalrm" bit of Port K (indicator on) (CHECK_ALARMS)
                                      ;*                                                                               (CHECK_ALARMS)
                                      ;*HEGT_ALARM_DONE:                                                               (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
                                      ; - Check for low oil pressure                                                   (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
004D9B 7F4D9B                         CHK_LOP_OFF:                                                                     (CHECK_ALARMS)
004D9B 7F4D9B 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                   (CHECK_ALARMS)
004DA0 7F4DA0 CD 08 00                    ldy  #stBins_E    ; Load index register Y with address of first configurable constant (CHECK_ALARMS)
                                                          ; on buffer RAM page 2 (stBins)                              (CHECK_ALARMS)
004DA3 7F4DA3 EC EA 02 E2                 ldd  $02E2,Y    ; Load Accu D with value in buffer RAM page 2 offset 738 (lopoff) (CHECK_ALARMS)
004DA7 7F4DA7 BC 10 88                        cpd  Eopx10     ; (A:B)-(M:M+1) Compare "lopoff" with "Eopx10"           (CHECK_ALARMS)
004DAA 7F4DAA 23 02                       bls  CLEAR_LOP  ; If "lopoff" is lower or the same as "Eopx10" branch to CLEAR_LOP (CHECK_ALARMS)
004DAC 7F4DAC 20 0E                       bra  CHK_LOP_ON ; Branch to CHK_LOP_ON:                                      (CHECK_ALARMS)
004DAE 7F4DAE                         CLEAR_LOP:                                                                       (CHECK_ALARMS)
004DAE 7F4DAE 1F 10 E3 01 28               brclr   alarmbits,LOP,LOP_ALARM_DONE ; If "LOP" bit of "alarmbits" is clear, (CHECK_ALARMS)
                                                                                ; branch to LOP_ALARM_DONE:            (CHECK_ALARMS)
004DB3 7F4DB3 1D 10 E3 01                  bclr    alarmbits,LOP                ; Clear "LOP" bit of "alarmbits"       (CHECK_ALARMS)
004DB7 7F4DB7 4D 32 01                     bclr    PORTK,LOPalrm                ; Clear "LOPalrm" bit of Port K (indicator off) (CHECK_ALARMS)
004DBA 7F4DBA 20 1F                        bra     LOP_ALARM_DONE               ; Branch to LOP_ALARM_DONE:            (CHECK_ALARMS)
004DBC 7F4DBC                         CHK_LOP_ON:                                                                      (CHECK_ALARMS)
004DBC 7F4DBC 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                   (CHECK_ALARMS)
004DC1 7F4DC1 CD 08 00                    ldy  #stBins_E     ; Load index register Y with address of first configurable constant (CHECK_ALARMS)
                                                           ; on buffer RAM page 2 (stBins)                             (CHECK_ALARMS)
004DC4 7F4DC4 EC EA 02 E0                 ldd  $02E0,Y     ; Load Accu D with value in buffer RAM page 2 offset 736 (lopon) (CHECK_ALARMS)
004DC8 7F4DC8 BC 10 88                        cpd  Eopx10      ; (A:B)-(M:M+1) Compare "lopon" with "Eopx10"           (CHECK_ALARMS)
004DCB 7F4DCB 24 02                       bhs  SET_LOP     ; If "lopon" is higher or the same as "Eopx10" branch to SET_LOP (CHECK_ALARMS)
004DCD 7F4DCD 20 0C                       bra  LOP_ALARM_DONE ; Branch to LOP_ALARM_DONE:                              (CHECK_ALARMS)
004DCF 7F4DCF                         SET_LOP:                                                                         (CHECK_ALARMS)
004DCF 7F4DCF 1E 10 E3 01 07               brset   alarmbits,LOP,LOP_ALARM_DONE ; If "LOP" bit of "alarmbits" is set, branch to (CHECK_ALARMS)
                                                                                ; LOP_ALARM_DONE:                      (CHECK_ALARMS)
004DD4 7F4DD4 1C 10 E3 01                  bset    alarmbits,LOP                ; Set "LOP" bit of "alarmbits"         (CHECK_ALARMS)
004DD8 7F4DD8 4C 32 01                     bset    PORTK,LOPalrm                 ; Set "LOPalrm" bit of Port K (indicator on) (CHECK_ALARMS)
004DDB 7F4DDB                         LOP_ALARM_DONE:                                                                  (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
                                      ; - Check for high fuel pressure                                                 (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
004DDB 7F4DDB                         CHK_HFP_OFF:                                                                     (CHECK_ALARMS)
004DDB 7F4DDB 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                   (CHECK_ALARMS)
004DE0 7F4DE0 CD 08 00                    ldy  #stBins_E    ; Load index register Y with address of first configurable constant (CHECK_ALARMS)
                                                          ; on buffer RAM page 2 (stBins)                              (CHECK_ALARMS)
004DE3 7F4DE3 EC EA 02 E6                 ldd  $02E6,Y    ; Load Accu D with value in buffer RAM page 2 offset 742 (hfpoff) (CHECK_ALARMS)
004DE7 7F4DE7 BC 10 8C                        cpd  Efpx10     ; (A:B)-(M:M+1) Compare "hfp_off" with "Efpx10"          (CHECK_ALARMS)
004DEA 7F4DEA 24 02                       bhs  CLEAR_HFP  ; If "hfpoff" is higher or he same as "Efpx10" branch to CLEAR_HFP (CHECK_ALARMS)
004DEC 7F4DEC 20 0E                       bra  CHK_HFP_ON ; Branch to CHK_HFP_ON:                                      (CHECK_ALARMS)
004DEE 7F4DEE                         CLEAR_HFP:                                                                       (CHECK_ALARMS)
004DEE 7F4DEE 1F 10 E3 40 28               brclr   alarmbits,HFP,HFP_ALARM_DONE ; If "HFP" bit of "alarmbits" is clear, (CHECK_ALARMS)
                                                                                ; branch to HFP_ALARM_DONE:            (CHECK_ALARMS)
004DF3 7F4DF3 1D 10 E3 40                  bclr    alarmbits,HFP                ; Clear "HFP" bit of "alarmbits"       (CHECK_ALARMS)
004DF7 7F4DF7 4D 32 80                     bclr    PORTK,HFPalrm                ; Clear "HFPalrm" bit of Port K (indicator off) (CHECK_ALARMS)
004DFA 7F4DFA 20 1F                        bra     HFP_ALARM_DONE               ; Branch to HFP_ALARM_DONE:            (CHECK_ALARMS)
004DFC 7F4DFC                         CHK_HFP_ON:                                                                      (CHECK_ALARMS)
004DFC 7F4DFC 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                   (CHECK_ALARMS)
004E01 7F4E01 CD 08 00                    ldy  #stBins_E     ; Load index register Y with address of first configurable constant (CHECK_ALARMS)
                                                           ; on buffer RAM page 2 (stBins)                             (CHECK_ALARMS)
004E04 7F4E04 EC EA 02 E4                 ldd  $02E4,Y     ; Load Accu D with value in buffer RAM page 2 offset 740 (hfpon) (CHECK_ALARMS)
004E08 7F4E08 BC 10 8C                        cpd  Efpx10      ; (A:B)-(M:M+1) Compare "hfpon" with "Efpx10"           (CHECK_ALARMS)
004E0B 7F4E0B 23 02                       bls  SET_HFP     ; If "hfpon" is lower or the same as "Efpx10" branch to SET_HFP (CHECK_ALARMS)
004E0D 7F4E0D 20 0C                       bra  HFP_ALARM_DONE ; Branch to HFP_ALARM_DONE:                              (CHECK_ALARMS)
004E0F 7F4E0F                         SET_HFP:                                                                         (CHECK_ALARMS)
004E0F 7F4E0F 1E 10 E3 40 07               brset   alarmbits,HFP,HFP_ALARM_DONE ; If "LOP" bit of "alarmbits" is set, branch to (CHECK_ALARMS)
                                                                                ; HFP_ALARM_DONE:                      (CHECK_ALARMS)
004E14 7F4E14 1C 10 E3 40                  bset    alarmbits,HFP                ; Set "HFP" bit of "alarmbits"         (CHECK_ALARMS)
004E18 7F4E18 4C 32 80                     bset    PORTK,HFPalrm                ; Set "HFPalrm" bit of Port K (indicator on) (CHECK_ALARMS)
004E1B 7F4E1B                         HFP_ALARM_DONE:                                                                  (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
                                      ; - Check for low fuel pressure                                                  (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
004E1B 7F4E1B                         CHK_LFP_OFF:                                                                     (CHECK_ALARMS)
004E1B 7F4E1B 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                   (CHECK_ALARMS)
004E20 7F4E20 CD 08 00                    ldy  #stBins_E    ; Load index register Y with address of first configurable constant (CHECK_ALARMS)
                                                          ; on buffer RAM page 2 (stBins)                              (CHECK_ALARMS)
004E23 7F4E23 EC EA 02 EA                 ldd  $02EA,Y    ; Load Accu D with value in buffer RAM page 2 offset 746 (lfpoff) (CHECK_ALARMS)
004E27 7F4E27 BC 10 8C                        cpd  Efpx10     ; (A:B)-(M:M+1) Compare "lfpoff" with "Efpx10"           (CHECK_ALARMS)
004E2A 7F4E2A 23 02                       bls  CLEAR_LFP  ; If "lfpoff" is lower or the same as "Efpx10" branch to CLEAR_LFP (CHECK_ALARMS)
004E2C 7F4E2C 20 0E                       bra  CHK_LFP_ON ; Branch to CHK_LFP_ON:                                      (CHECK_ALARMS)
004E2E 7F4E2E                         CLEAR_LFP:                                                                       (CHECK_ALARMS)
004E2E 7F4E2E 1F 10 E3 20 28               brclr   alarmbits,LFP,LFP_ALARM_DONE ; If "LFP" bit of "alarmbits" is clear, (CHECK_ALARMS)
                                                                                ; branch to LFP_ALARM_DONE:            (CHECK_ALARMS)
004E33 7F4E33 1D 10 E3 20                  bclr    alarmbits,LFP                ; Clear "LFP" bit of "alarmbits"       (CHECK_ALARMS)
004E37 7F4E37 4D 32 20                     bclr    PORTK,LFPalrm                ; Clear "LFPalrm" bit of Port K (indicator off) (CHECK_ALARMS)
004E3A 7F4E3A 20 1F                        bra     LFP_ALARM_DONE               ; Branch to LFP_ALARM_DONE:            (CHECK_ALARMS)
004E3C 7F4E3C                         CHK_LFP_ON:                                                                      (CHECK_ALARMS)
004E3C 7F4E3C 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                   (CHECK_ALARMS)
004E41 7F4E41 CD 08 00                    ldy  #stBins_E     ; Load index register Y with address of first configurable constant (CHECK_ALARMS)
                                                           ; on buffer RAM page 2 (stBins)                             (CHECK_ALARMS)
004E44 7F4E44 EC EA 02 E8                 ldd  $02E8,Y     ; Load Accu D with value in buffer RAM page 2 offset 744 (lfpon) (CHECK_ALARMS)
004E48 7F4E48 BC 10 8C                        cpd  Efpx10      ; (A:B)-(M:M+1) Compare "lfpon" with "Efpx10"           (CHECK_ALARMS)
004E4B 7F4E4B 24 02                       bhs  SET_LFP     ; If "lfpon" is higher or the same as "Efpx10" branch to SET_LFP (CHECK_ALARMS)
004E4D 7F4E4D 20 0C                       bra  LFP_ALARM_DONE ; Branch to LFP_ALARM_DONE:                              (CHECK_ALARMS)
004E4F 7F4E4F                         SET_LFP:                                                                         (CHECK_ALARMS)
004E4F 7F4E4F 1E 10 E3 20 07               brset   alarmbits,LFP,LFP_ALARM_DONE ; If "LOP" bit of "alarmbits" is set, branch to (CHECK_ALARMS)
                                                                                ; LFP_ALARM_DONE:                      (CHECK_ALARMS)
004E54 7F4E54 1C 10 E3 20                  bset    alarmbits,LFP                ; Set "LFP" bit of "alarmbits"         (CHECK_ALARMS)
004E58 7F4E58 4C 32 20                     bset    PORTK,LFPalrm                ; Set "LFPalrm" bit of Port K (indicator on) (CHECK_ALARMS)
004E5B 7F4E5B                         LFP_ALARM_DONE:                                                                  (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
                                      ; - When an engine alarm condition occurs an indicator light on the dashbord is  (CHECK_ALARMS)
                                      ;   illuminated and an audible alarm will sound. The alarm can be silenced by switching (CHECK_ALARMS)
                                      ;   the alarm silence switch on the dashboard to the on position but the light will remain (CHECK_ALARMS)
                                      ;   illuminated  until the alarm conditionn is no longer met. When the alarm silence (CHECK_ALARMS)
                                      ;   switch is in the on posiiton an indicator on the dashboard will warn the driver that (CHECK_ALARMS)
                                      ;   feature is off and that subsequent alarms will be indicator lights only.     (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
                                      ; - If we have an audible alarm see if it should be silenced.                    (CHECK_ALARMS)
                                      ;***************************************************************************************** (CHECK_ALARMS)
004E5B 7F4E5B 4F 00 08 06                 brclr PORTA,AudAlrmSil,NoAudAlrm ; If "AudAlrmSil"(PA3) pin on portA is clear, branch to (CHECK_ALARMS)
                                                                           ; NoAudAlrm: (Switch is on so prohibit audible alarm) (CHECK_ALARMS)
004E5F 7F4E5F 1D 10 E2 04                 bclr engine2,AudAlrm             ; Clear "AudAlrm" bit of "engine2" bit field (CHECK_ALARMS)
004E63 7F4E63 20 04                       bra  ChkAlarmbits                ; Branch to ChkAlarmbits:                   (CHECK_ALARMS)
004E65 7F4E65                         NoAudAlrm:                                                                       (CHECK_ALARMS)
004E65 7F4E65 1C 10 E2 04                 bset engine2,AudAlrm             ; Set "AudAlrm" bit of "engine2" bit field  (CHECK_ALARMS)
004E69 7F4E69                         ChkAlarmbits:                                                                    (CHECK_ALARMS)
004E69 7F4E69 B6 10 E3                    ldaa  alarmbits                  ; "alarmbits"-> Accu A                      (CHECK_ALARMS)
004E6C 7F4E6C 8A 00                       oraa  #$00000000                 ; Inclusive or with %00000000 (all bits cleared (CHECK_ALARMS)
                                                                           ; on power up and bit 7 is not assigned     (CHECK_ALARMS)
004E6E 7F4E6E 27 0A                       beq   AudibleAlarmOff            ; If all bits are zero branch to AudibleAlarmOff: (CHECK_ALARMS)
004E70 7F4E70 1E 10 E2 04 05              brset engine2,AudAlrm,AudibleAlarmOff  ; if "AudAlrm" bit of "engine2" is set branch (CHECK_ALARMS)
                                                                           ; to AudibleAlarmOff: (Switch is on so prohibit audible (CHECK_ALARMS)
                                                                           ; alarm)                                    (CHECK_ALARMS)
004E75 7F4E75 4C 01 04                    bset  PORTB,EngAlarm             ; Set "EngAlarm pin on Port B (audible alarm on) (CHECK_ALARMS)
004E78 7F4E78 20 03                       bra   AudibleAlarmDone           ; Branch to AudibleAlarmDone:               (CHECK_ALARMS)
004E7A 7F4E7A                         AudibleAlarmOff:                                                                 (CHECK_ALARMS)
004E7A 7F4E7A 4D 01 04                    bclr  PORTB,EngAlarm             ; Clear "EngAlarm" pin on port B (audible alarm off) (CHECK_ALARMS)
004E7D 7F4E7D                         AudibleAlarmDone:                                                                (CHECK_ALARMS)
                                      ;*****************************************************************************************
                                      ; - Do RPM calculations when there is a new input capture period.
                                      ;*****************************************************************************************
004E7D 7F4E7D 1F 10 24 01 29             brclr ICflgs,RPMcalc,NoRPMcalc ; If "RPMcalc" bit of "ICflgs" is clear,
                                                                        ; branch to "NoRPMcalc:"(bit is set in State_BPEM.s
                                                                                                        ; and cleared in ect_BPEM.s)
004E82 7F4E82 MACRO                       CALC_RPM   ; (Macro in ect_BEEM488.s)
                                                              ; rising edge capture Ch2,1,0)                           (CALC_RPM)
                                      ;***************************************************************************************** (CALC_RPM)
                                      ; ------------------------------- RPM CALCULATION SECTION -------------------------------- (CALC_RPM)
                                      ;***************************************************************************************** (CALC_RPM)
                                      ;                                                                                (CALC_RPM)
                                      ; RPM = CONSTANT/PERIOD                                                          (CALC_RPM)
                                      ; Where:                                                                         (CALC_RPM)
                                      ; RPM    = Engine RPM                                                            (CALC_RPM)
                                      ; RPMk   = 24 bit constant using 5.12uS IC clock tick (195.3125khz)              (CALC_RPM)
                                      ;             ((195,312.5 tickpsec*60secpmin)/(360/72))                          (CALC_RPM)
                                      ; CASprd = 16 bit period count between three consecutive IC events in 5.12uS     (CALC_RPM)
                                      ;               resolution                                                       (CALC_RPM)
                                      ;   RPMk                                                                         (CALC_RPM)
                                      ;   ----- = RPM                                                                  (CALC_RPM)
                                      ;   CASprd512                                                                    (CALC_RPM)
                                      ;                                                                                (CALC_RPM)
                                      ; RPMk = ((195312.5*60)/5) = 2343750 = $0023C346                                 (CALC_RPM)
                                      ;                                                                                (CALC_RPM)
                                      ;***************************************************************************************** (CALC_RPM)
                                      ;***************************************************************************************** (CALC_RPM)
                                      ;                                                                                (CALC_RPM)
                                      ; RPM = CONSTANT/PERIOD                                                          (CALC_RPM)
                                      ; Where:                                                                         (CALC_RPM)
                                      ; RPM    = Engine RPM                                                            (CALC_RPM)
                                      ; RPMk   = 24 bit constant using 2.56uS IC clock tick (390.625khz)               (CALC_RPM)
                                      ;             ((390,625 tickpsec*60secpmin)/(360/72))                            (CALC_RPM)
                                      ; CASprd256 = 16 bit period count between three consecutive IC events in 2.56uS  (CALC_RPM)
                                      ;               resolution                                                       (CALC_RPM)
                                      ;   RPMk                                                                         (CALC_RPM)
                                      ;   ----- = RPM                                                                  (CALC_RPM)
                                      ;   CASprd256                                                                    (CALC_RPM)
                                      ;                                                                                (CALC_RPM)
                                      ; RPMk = ((390,625*60)/5) = 4,687,500 = $0047868C                                (CALC_RPM)
                                      ;                                                                                (CALC_RPM)
                                      ;***************************************************************************************** (CALC_RPM)
                                      ;***************************************************************************************** (CALC_RPM)
                                      ; - Check the state of the "Run" bit in "engine" bit field. If it is set we are running (CALC_RPM)
                                      ;   so change the calculations from timer base from 5.12uS to 2.56 uS.           (CALC_RPM)
                                      ;****************************************************************************************** (CALC_RPM)
004E82 7F4E82 1E 10 E1 04 13                  brset engine,run,RunRPM ; If "run" bit of "engine variable is set branch to RunRPM: (CALC_RPM)
                                      ;***************************************************************************************** (CALC_RPM)
                                      ; - Do RPM calculations for 5.12uS time base when there is a new input capture period (CALC_RPM)
                                      ;   using 32x16 divide                                                           (CALC_RPM)
                                      ;***************************************************************************************** (CALC_RPM)
004E87 7F4E87 CC C3 46                    ldd  #$C346         ; Load accu D with Lo word of  10 cyl RPMk (5.12uS clock tick) (CALC_RPM)
004E8A 7F4E8A CD 00 23                    ldy  #$0023         ; Load accu Y with Hi word of 10 cyl RPMk (5.12uS clock tick) (CALC_RPM)
004E8D 7F4E8D FE 10 9A                    ldx  CASprd512      ; Load "X" register with value in "CASprd512"            (CALC_RPM)
004E90 7F4E90 11                          ediv                ; Extended divide (Y:D)/(X)=>Y;Rem=>D                    (CALC_RPM)
                                                                  ;(Divide "RPMk" by "CASprd512")                      (CALC_RPM)
004E91 7F4E91 7D 10 A0                    sty  RPM            ; Copy result to "RPM"                                   (CALC_RPM)
004E94 7F4E94 1D 10 24 01                 bclr ICflgs,RPMcalc ; Clear "RPMcalc" bit of "ICflgs"                        (CALC_RPM)
004E98 7F4E98 20 11                           bra  RunRPMDone     ; Branch to RunRPMDone:                              (CALC_RPM)
                                      ;***************************************************************************************** (CALC_RPM)
                                      ; - Do RPM calculations for 2.56uS time base when there is a new input capture period (CALC_RPM)
                                      ;   using 32x16 divide                                                           (CALC_RPM)
                                      ;***************************************************************************************** (CALC_RPM)
004E9A 7F4E9A                         RunRPM:                                                                          (CALC_RPM)
004E9A 7F4E9A CC 86 8C                    ldd  #$868C         ; Load accu D with Lo word of  10 cyl RPMk (2.56uS clock tick) (CALC_RPM)
004E9D 7F4E9D CD 00 47                    ldy  #$0047         ; Load accu Y with Hi word of 10 cyl RPMk (2.56uS clock tick) (CALC_RPM)
004EA0 7F4EA0 FE 10 9C                    ldx  CASprd256      ; Load "X" register with value in "CASprd256"            (CALC_RPM)
004EA3 7F4EA3 11                          ediv                ; Extended divide (Y:D)/(X)=>Y;Rem=>D                    (CALC_RPM)
                                                                  ;(Divide "RPMk" by "CASprd256")                      (CALC_RPM)
004EA4 7F4EA4 7D 10 A0                    sty  RPM            ; Copy result to "RPM"                                   (CALC_RPM)
004EA7 7F4EA7 1D 10 24 01                 bclr ICflgs,RPMcalc ; Clear "RPMcalc" bit of "ICflgs"                        (CALC_RPM)
004EAB 7F4EAB                         RunRPMDone:                                                                      (CALC_RPM)
004EAB 7F4EAB                         NoRPMcalc
                                      ;*****************************************************************************************
                                      ; - Do KPH calculations when there is a new input capture period.
                                      ;*****************************************************************************************
004EAB 7F4EAB 1F 10 24 02 56              brclr ICflgs,KPHcalc,NoKPHcalc ; If "KPHcalc" bit of "ICflgs" is clear,
                                                                         ; branch to "NoKPHcalc:"(bit is set and cleared in
                                                                                                         ; ect_BPEM.s)
004EB0 7F4EB0 MACRO                       CALC_KPH   ; (Macro in ect_BEEM488.s)
                                      ;***************************************************************************************** (CALC_KPH)
                                      ; ------------------------------- KPH CALCULATION SECTION -------------------------------- (CALC_KPH)
                                      ;***************************************************************************************** (CALC_KPH)
                                      ;                                                                                (CALC_KPH)
                                      ; KPH = CONSTANT/PERIOD                                                          (CALC_KPH)
                                      ; Where:                                                                         (CALC_KPH)
                                      ; KPH         = Vehicle speed in Kilometers per Hour                             (CALC_KPH)
                                      ; KPHk = 19 bit constant using 2.56uS IC clock tick (390.625khz)                 (CALC_KPH)
                                      ;             ((390.625 tickpsec*60secpmin*60minphr)/4971pulsepkm                (CALC_KPH)
                                      ; VSSprd = 16 bit period count between consecutive IC events in 2.56uS           (CALC_KPH)
                                      ;               resolution. 8000 pulse per mile, 4971 pulse per KM               (CALC_KPH)
                                      ;   KPHk                                                                         (CALC_KPH)
                                      ;   ----- = KPH                                                                  (CALC_KPH)
                                      ;   VSSprd                                                                       (CALC_KPH)
                                      ;                                                                                (CALC_KPH)
                                      ; KPHk = ((390,625*60*60)/4971) = 282890.7664 = $0004510B                        (CALC_KPH)
                                      ; min 4.316636368 KPH                                                            (CALC_KPH)
                                      ; Resolution @ 100KPH = .0796KM                                                  (CALC_KPH)
                                      ;                                                                                (CALC_KPH)
                                      ;***************************************************************************************** (CALC_KPH)
                                      ;***************************************************************************************** (CALC_KPH)
                                      ; - Do KPH calculations for 2.56uS time base when there is a new input capture period (CALC_KPH)
                                      ;   using 32x16 divide                                                           (CALC_KPH)
                                      ; - NOTE! for KPH in 0.1KPH resolution use 2828907 $002B2A6B                     (CALC_KPH)
                                      ;***************************************************************************************** (CALC_KPH)
004EB0 7F4EB0                         RunKPH:                                                                          (CALC_KPH)
                                      ;    ldd  #$510B         ; Load accu D with Lo word of KPHk                      (CALC_KPH)
                                      ;    ldy  #$0004         ; Load accu Y with Hi word of KPHk                      (CALC_KPH)
004EB0 7F4EB0 CC 2A 6B                    ldd  #$2A6B         ; Load accu D with Lo word of KPHk                       (CALC_KPH)
004EB3 7F4EB3 CD 00 2B                    ldy  #$002B         ; Load accu Y with Hi word of KPHk                       (CALC_KPH)
004EB6 7F4EB6 FE 10 9E                    ldx  VSSprd         ; Load "X" register with value in "VSSprd"               (CALC_KPH)
004EB9 7F4EB9 11                          ediv                ; Extended divide (Y:D)/(X)=>Y;Rem=>D (Divide "KPHk" by "VSSprd") (CALC_KPH)
                                      ;    sty  KPH            ; Copy result to "KPH"                                  (CALC_KPH)
004EBA 7F4EBA 7D 10 A2                    sty  KPH            ; Copy result to "KPH" (KPH*10)                          (CALC_KPH)
004EBD 7F4EBD 1D 10 24 02                 bclr ICflgs,KPHcalc ; Clear "KPHcalc" bit of "ICflgs"                        (CALC_KPH)
004EC1 7F4EC1                         RunKPHDone:                                                                      (CALC_KPH)
                                      ;***************************************************************************************** (CALC_KPH)
                                      ; - If we know the speed of the speed of the engine, the speed of the vehicle, the final (CALC_KPH)
                                      ;   drive gear ratio, the transmission gear ratios and the drive wheel diameter, we (CALC_KPH)
                                      ;   can calculate which gear the transmission is currently in. In this case the  (CALC_KPH)
                                      ;   Final drive ratio is 3.54:1                                                  (CALC_KPH)
                                      ;   1st gear ratio is 5.00:1, total first gear ratio is 3.54 * 5.00 = 17.7:1     (CALC_KPH)
                                      ;   2nd gear ratio is 3.04:1, total 2nd gear ratio is 3.54 * 3.04 = 10.7616:1    (CALC_KPH)
                                      ;   3d gear ratio is 1.67:1, total 3d gear ratio is 3.54 * 1.67 = 5.9118:1       (CALC_KPH)
                                      ;   4th gear ratio is 1:1, total 4th gear ratio is 3.54 * 1.00 = 3.54:1          (CALC_KPH)
                                      ;   5th gear ratio is 0.74:1, total 5th gear ratio is 3.54 * 0.74 = 2.6196:1     (CALC_KPH)
                                      ;   Drive wheel diameter is 0.7774 m                                             (CALC_KPH)
                                      ;   Drive wheel circumferance is 0.7774 * 3.142857143 = 2.4432571m, or .002443257Km (CALC_KPH)
                                      ;                                                                                (CALC_KPH)
                                      ;   We can develop a K factor for each final ratio by converting engine RPM to RPH (CALC_KPH)
                                      ;   (1 RPM = 60 RPH), divide this by the total gear ratio and multiply the result by the (CALC_KPH)
                                      ;   drive wheel circumferance in Km. The K factors are as follows:               (CALC_KPH)
                                      ;   1st gear: 60 / 17.7 * .002443257 = .008282                                   (CALC_KPH)
                                      ;   2nd gear: 60 / 10.7616 * .002443257 = .013622                                (CALC_KPH)
                                      ;   3d gear: 60 / 5.9118 * .002443257 = .024797                                  (CALC_KPH)
                                      ;   4th gear: 60 / 3.54 * .002443257 = .041411                                   (CALC_KPH)
                                      ;   5th gear: 60 / 2.6196 * .002443257 = .055961                                 (CALC_KPH)
                                      ;                                                                                (CALC_KPH)
                                      ;   If we divide the vehicle speed in KPH by the engine speed in RPM the result will be the (CALC_KPH)
                                      ;   K factor of the current gear we are in. Because there may be errors in the speeds, exact (CALC_KPH)
                                      ;   ratios and wheel diameter I use a range of K factor values as opposed to the exact (CALC_KPH)
                                      ;   calculated value to determine the current gear.                              (CALC_KPH)
                                      ;                                                                                (CALC_KPH)
                                      ;   K factor < .0109520 = 1st gear                                               (CALC_KPH)
                                      ;   K factor >= .0109520 and < .0191955 = 2nd gear                               (CALC_KPH)
                                      ;   K factor >= .0191955 and < .0330900 = 3d gear                                (CALC_KPH)
                                      ;   K factor >= .0330900 and < .0486860 = 4th gear                               (CALC_KPH)
                                      ;   K factor >= .0486860 = 5th gear                                              (CALC_KPH)
                                      ;                                                                                (CALC_KPH)
                                      ;   The vehicle speed variable is in KPKx10. In order to use integer math this variable is (CALC_KPH)
                                      ;   multilied by 10,000 for calculations. for the same reason the comparison values are also (CALC_KPH)
                                      ;   multiplied by 10,000 and now become:                                         (CALC_KPH)
                                      ;                                                                                (CALC_KPH)
                                      ;   K factor < 109 = 1st gear                                                    (CALC_KPH)
                                      ;   K factor >= 109 and < 191 = 2nd gear                                         (CALC_KPH)
                                      ;   K factor >= 191 and < 330 = 3d gear                                          (CALC_KPH)
                                      ;   K factor >= 330 and < 486 = 4th gear                                         (CALC_KPH)
                                      ;   K factor >= 486 = 5th gear                                                   (CALC_KPH)
                                      ;                                                                                (CALC_KPH)
                                      ;   Because the vehicle speed period will overflow at ~4.317 KPH these calculations won't work (CALC_KPH)
                                      ;   at speeds less than this. Nor will they work if the transfer case is in low range as this (CALC_KPH)
                                      ;   changes the final drive ratio.                                               (CALC_KPH)
                                      ;                                                                                (CALC_KPH)
                                      ;***************************************************************************************** (CALC_KPH)
004EC1 7F4EC1 FC 10 A2                    ldd  KPH         ; "KPH" (vehicle speed x 10) -> Accu D                      (CALC_KPH)
004EC4 7F4EC4 CD 27 10                    ldy  #$2710      ; Decimal 10,000 -> Accu Y                                  (CALC_KPH)
004EC7 7F4EC7 13                          emul             ;(D)x(Y)=Y:D "KPH" * 10000                                  (CALC_KPH)
004EC8 7F4EC8 FE 10 A0                        ldx  RPM         ; "RPM" (engine RPM) -> Accu X                          (CALC_KPH)
004ECB 7F4ECB 11                              ediv             ;(Y:D)/(X)=Y;Rem->D ("KPH" * "10,000" )/ RPM            (CALC_KPH)
004ECC 7F4ECC 7D 10 FD                    sty  GearKCur    ; Copy result to "GearKCur"                                 (CALC_KPH)
004ECF 7F4ECF 8D 00 6D                    cpy  #$006D      ; Compare "GearKCur" with decimal 109                       (CALC_KPH)
004ED2 7F4ED2 25 11                       blo  Gear1       ; If "GearKCur is less than 109 branch to Gear1:            (CALC_KPH)
004ED4 7F4ED4 8D 00 BF                    cpy  #$00BF      ; Compare "GearKCur" with decimal 191                       (CALC_KPH)
004ED7 7F4ED7 25 13                       blo  Gear2       ; If "GearKCur is less than 191 branch to Gear2:            (CALC_KPH)
004ED9 7F4ED9 8D 01 4A                    cpy  #$014A      ; Compare "GearKCur" with decimal 330                       (CALC_KPH)
004EDC 7F4EDC 25 15                       blo  Gear3       ; If "GearKCur is less than 330 branch to Gear3:            (CALC_KPH)
004EDE 7F4EDE 8D 01 E6                    cpy  #$01E6      ; Compare "GearKCur" with decimal 486                       (CALC_KPH)
004EE1 7F4EE1 25 17                       blo  Gear4       ; If "GearKCur is less than 486 branch to Gear4:            (CALC_KPH)
004EE3 7F4EE3 20 1C                       bra  Gear5       ; "GearKCur is >= 486 so branch to Gear5:                   (CALC_KPH)
004EE5 7F4EE5                         Gear1:                                                                           (CALC_KPH)
004EE5 7F4EE5 18 0B 01 10 CE              movb  #$01,GearCur  ; Load "GearCur" with decimal 1                          (CALC_KPH)
004EEA 7F4EEA 20 1A                       bra   GearCurDone   ; Branch to GearCurDone:                                 (CALC_KPH)
004EEC 7F4EEC                         Gear2:                                                                           (CALC_KPH)
004EEC 7F4EEC 18 0B 02 10 CE              movb  #$02,GearCur  ; Load "GearCur" with decimal 2                          (CALC_KPH)
004EF1 7F4EF1 20 13                       bra   GearCurDone   ; Branch to GearCurDone:                                 (CALC_KPH)
004EF3 7F4EF3                         Gear3:                                                                           (CALC_KPH)
004EF3 7F4EF3 18 0B 03 10 CE              movb  #$03,GearCur  ; Load "GearCur" with decimal 3                          (CALC_KPH)
004EF8 7F4EF8 20 0C                       bra   GearCurDone   ; Branch to GearCurDone:                                 (CALC_KPH)
004EFA 7F4EFA                         Gear4:                                                                           (CALC_KPH)
004EFA 7F4EFA 18 0B 04 10 CE              movb  #$04,GearCur  ; Load "GearCur" with decimal 4                          (CALC_KPH)
004EFF 7F4EFF 20 05                       bra   GearCurDone   ; Branch to GearCurDone:                                 (CALC_KPH)
004F01 7F4F01                         Gear5:                                                                           (CALC_KPH)
004F01 7F4F01 18 0B 05 10 CE              movb  #$05,GearCur  ; Load "GearCur" with decimal 5                          (CALC_KPH)
004F06 7F4F06                         GearCurDone:                                                                     (CALC_KPH)
004F06 7F4F06                         NoKPHcalc:
                                      ;*****************************************************************************************
                                      ; ----------------------- Ignition Calculations Section ----------------------------------
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;
                                      ; - Ignition timing in degrees to 0.1 degree resolution is selected from the 3D
                                      ;   lookup table "ST" which plots manifold pressure against RPM. A potentiometer on the
                                      ;   dash board allows a manual trim of the "ST" values of from 0 to 20 degrees advance
                                      ;   and from 0 to 20 degrees retard. The ignition system is what is called "waste spark",
                                      ;   which pairs cylinders on a single coil. The spark is delivered to both cylinders at
                                      ;   the same time. One cylinder recieves the spark at the appropriate time for ignition.
                                      ;   The other recieves it when the exhaust valve is open. Hence the name "waste spark".
                                      ;   On this 10 cylinder engine there are 5 coils, each controlled by its own hardware
                                      ;   timer. The cylinders are paired 1&6, 10&5, 9&8, 4&7, 3&2
                                      ;   In an ignition event the timer is first loaded with the output compare value in
                                      ;   "Delaytk". At the compare interrupt the coil is energised and the timer is loaded
                                      ;   with the output compare value in "DwllFintk". At the compare interrupt the coil is
                                      ;   de-energized to fire the spark. The delay in timer ticks will depend on the timer base
                                      ;   rate of either 5.12 uS for cranking or 2.56uS for running.
                                      ;
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Look up current value in ST table (STcurr) (degrees*10)
                                      ;*****************************************************************************************
                                      ;*    ST_LU    ; Macro in igncalcs_BPEM.s ; Macro call moved to state_BPEM488.s 5-4-21
                                      ;*****************************************************************************************
                                      ; - Look up current value in Dwell Battery Adjustment Table (dwellcor)(% x 10)
                                      ;*****************************************************************************************
                                      ;*    DWELL_COR_LU    ; Macro in igncalcs_BPEM.s ; Macro call moved to state_BPEM488.s 5-4-21
                                      ;*****************************************************************************************
                                      ; The determination of whether the engine is cranking or running is made in the
                                      ; State_BPEM488.s module within the Crank Angle Sensor interrupt. It is here that the
                                      ; "crank" and "run" bits of the "engine" bit field are set or cleared.
                                      ;*****************************************************************************************
004F06 7F4F06 1E 10 E1 02 02              brset engine,crank,CrankTime ; If "crank" bit of "engine" bit field is set branch
                                                                           ; to CrankTime:
004F0B 7F4F0B 20 67                           bra   RunTime                ; Branch to RunTime:(no need to test "run" bit)
004F0D 7F4F0D                         CrankTime:
                                      ;*****************************************************************************************
                                      ; - Do ignition calculations for a 5.12uS time base.
                                      ;*****************************************************************************************
004F0D 7F4F0D MACRO                       IGN_CALCS_512      ; Macro in igncalcsBPEM488.s
                                      ;***************************************************************************************** (IGN_CALCS_512)
                                      ; - Convert the Igntion Span(170 degrees) to time in 5.12uS resolution (Spantk)  (IGN_CALCS_512)
                                      ;***************************************************************************************** (IGN_CALCS_512)
004F0D 7F4F0D CC 06 A4                    ldd  #$06A4       ; Decimal 1700 -> Accu D (170 *10 for 0.1 degree resolution calcs) (IGN_CALCS_512)
004F10 7F4F10 FD 10 1D                    ldy  Degx10tk512  ;(Time for 1 degree of rotation in 5.12uS resolution x 10) (IGN_CALCS_512)
004F13 7F4F13 13                          emul              ;(D)x(Y)=Y:D "1700" * Degx10tk512                          (IGN_CALCS_512)
004F14 7F4F14 CE 00 64                        ldx  #$0064       ; Decimal 100 -> Accu X                                (IGN_CALCS_512)
004F17 7F4F17 11                              ediv              ;(Y:D)/(X)=Y;Rem->D (("STandItrmx10" * Degx10tk512)/100 (IGN_CALCS_512)
                                                                ; = "Spantk"                                           (IGN_CALCS_512)
004F18 7F4F18 7D 10 37                        sty  Spantk       ; Copy result to "Spantk"                              (IGN_CALCS_512)
                                      ;****************************************************************************************** (IGN_CALCS_512)
                                      ; - Multiply dwell time (mS*10) by the correction and divide by 1000 (%*10)("DwellFin") (IGN_CALCS_512)
                                      ;****************************************************************************************** (IGN_CALCS_512)
004F1B 7F4F1B 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                   (IGN_CALCS_512)
004F20 7F4F20 CD 08 00                    ldy  #stBins_E    ; Load index register Y with address of first configurable constant (IGN_CALCS_512)
                                                          ; on buffer RAM page 2 (stBins)                              (IGN_CALCS_512)
004F23 7F4F23 EC EA 02 EC                 ldd  $02EC,Y    ; Load Accu D with value in buffer RAM page 2 offset 748 ("Dwell") (IGN_CALCS_512)
004F27 7F4F27 FD 10 D6                    ldy   DwellCor      ; "DwellCor" -> Accu Y (%*10)                            (IGN_CALCS_512)
004F2A 7F4F2A 13                          emul                ;(D)x(Y)=Y:D "Dwell" * "DwellCor"                        (IGN_CALCS_512)
004F2B 7F4F2B CE 03 E8                    ldx   #$03E8        ; Decimal 1000 -> Accu Y (for integer math)              (IGN_CALCS_512)
004F2E 7F4F2E 11                          ediv                ; (Y:D)/(X)=Y;Rem->D (("Dwell" * "DwellCor")/1000) = "DwellFin" (IGN_CALCS_512)
004F2F 7F4F2F 7D 10 D8                        sty   DwellFin      ; Copy result to "DwellFin                           (IGN_CALCS_512)
                                      ;****************************************************************************************** (IGN_CALCS_512)
                                      ; - Convert "DwellFin" to time in 5.12uS resolution.("DwellFintk")               (IGN_CALCS_512)
                                      ;****************************************************************************************** (IGN_CALCS_512)
004F32 7F4F32 FC 10 D8                        ldd   DwellFin      ; "DwellFin" -> Accu D                               (IGN_CALCS_512)
004F35 7F4F35 CD 27 10                        ldy   #$2710        ; Load index register Y with decimal 10000 (for integer math) (IGN_CALCS_512)
004F38 7F4F38 13                              emul                ;(D)x(Y)=Y:D "DwellFin" * 10,000                     (IGN_CALCS_512)
004F39 7F4F39 CE 02 00                        ldx   #$200         ; Load index register X decimal 512                  (IGN_CALCS_512)
004F3C 7F4F3C 11                          ediv                ;(Y:D)/(X)=Y;Rem->D ("DwellFin" * 10,000) / 512 = "DwellFintk" (IGN_CALCS_512)
004F3D 7F4F3D 7D 10 39                    sty   DwellFintk    ; Copy result to "DwellFintk" (Time required for dwell after (IGN_CALCS_512)
                                                                  ; correction in 5.12uS resolution                    (IGN_CALCS_512)
004F40 7F4F40 7D 10 43                        sty   IgnOCadd2     ; Copy result to "IgnOCadd2" (Time required for dwell after (IGN_CALCS_512)
                                                                  ; correction in 5.12uS resolution                    (IGN_CALCS_512)
                                                              ; This is the second OC value loaded into the timer      (IGN_CALCS_512)
                                      ;***************************************************************************************** (IGN_CALCS_512)
                                      ; - Correct the current ST value for trim (degrees*10)("STandItrmx10")           (IGN_CALCS_512)
                                      ;***************************************************************************************** (IGN_CALCS_512)
004F43 7F4F43 FC 10 D2                    ldd   STcurr      ; Current value in ST table (Degrees x 10) -> Accu D       (IGN_CALCS_512)
004F46 7F4F46 C3 00 CB                    addd  #$00CB      ; (A:B)+(M:M+1)->A:B "STdeg" + decimal 200 = "Igncalc1" (Degrees*10) (IGN_CALCS_512)
004F49 7F4F49 F3 10 90                    addd  Itrmx10     ; (A:B)+(M:M+1)->A:B "Igncalc1" + Itrm10th) = "Igncalc2" (Degrees*10) (IGN_CALCS_512)
004F4C 7F4F4C 83 00 CB                    subd  #$00CB      ; Subtract (A:B)-(M:M+1)=>A:B  "Igncalc2" - decimal 200 = "STandItrm" (IGN_CALCS_512)
                                                                ;(Degrees*10)                                          (IGN_CALCS_512)
004F4F 7F4F4F 7C 10 DA                        std  STandItrmx10 ; Copy result to "STandItrmx10"(Degrees*10)            (IGN_CALCS_512)
                                      ;***************************************************************************************** (IGN_CALCS_512)
                                      ; - Convert "STandItrmx10" to time in 5.12uS resolution ("STandItrmtk")          (IGN_CALCS_512)
                                      ;***************************************************************************************** (IGN_CALCS_512)
004F52 7F4F52 FD 10 1D                    ldy  Degx10tk512  ;(Time for 1 degree of rotation in 2.56uS resolution x 10) (IGN_CALCS_512)
004F55 7F4F55 13                          emul              ;(D)x(Y)=Y:D "STandItrmx10" * Degx10tk512                  (IGN_CALCS_512)
004F56 7F4F56 CE 00 64                        ldx  #$0064       ; Decimal 100 -> Accu X                                (IGN_CALCS_512)
004F59 7F4F59 11                              ediv              ;(Y:D)/(X)=Y;Rem->D (("STandItrmx10" * Degx10tk512)/100 (IGN_CALCS_512)
                                                                ; = "Spantk"                                           (IGN_CALCS_512)
004F5A 7F4F5A 7D 10 3B                        sty  STandItrmtk  ; Copy result to "STandItrmtk"                         (IGN_CALCS_512)
                                      ;***************************************************************************************** (IGN_CALCS_512)
                                      ; - Add "STandItrmtk" and "DwellFintk" = "Advancetk"                             (IGN_CALCS_512)
                                      ;***************************************************************************************** (IGN_CALCS_512)
004F5D 7F4F5D FC 10 3B                   ldd   STandItrmtk     ; "STandItrmtk" -> Accu D                               (IGN_CALCS_512)
004F60 7F4F60 F3 10 39                   addd  DwellFintk      ; (A:B)+(M:M+1)->A:B "STandItrmtk" + "DwellFintk" = "Advancetk" (IGN_CALCS_512)
004F63 7F4F63 7C 10 3D                   std   Advancetk       ; Copy result to "Advancetk"                            (IGN_CALCS_512)
                                      ;***************************************************************************************** (IGN_CALCS_512)
                                      ; - Subtract "Advancetk" from "Spantk" = "Delaytk"                               (IGN_CALCS_512)
                                      ;***************************************************************************************** (IGN_CALCS_512)
004F66 7F4F66 FC 10 37                        ldd   Spantk     ; "Spantk" -> Accu D                                    (IGN_CALCS_512)
004F69 7F4F69 B3 10 3D                        subd  Advancetk  ; Subtract (A:B)-(M:M+1)=>A:B "Spantk" - "Advancetk" = "Delaytk" (IGN_CALCS_512)
004F6C 7F4F6C 7C 10 3F                        std   Delaytk    ; Copy result to "Delaytk"                              (IGN_CALCS_512)
004F6F 7F4F6F 7C 10 41                        std   IgnOCadd1  ; Copy result to "IgnOCadd1"                            (IGN_CALCS_512)
004F72 7F4F72 20 65                           bra  IgnCalcsDone  ; Branch to IgnCalcsDone:
004F74 7F4F74                         RunTime:
                                      ;*****************************************************************************************
                                      ; - Do ignition calculations for a 2.56uS time base.
                                      ;*****************************************************************************************
004F74 7F4F74 MACRO                       IGN_CALCS_256    ; Macro in igncalcsBPEM488.s
                                                           ; This is the first OC value loaded into the timer          (IGN_CALCS_256)
                                      ;***************************************************************************************** (IGN_CALCS_256)
                                      ; - Convert the Igntion Span(170 degrees) to time in 2.56uS resolution (Spantk)  (IGN_CALCS_256)
                                      ;***************************************************************************************** (IGN_CALCS_256)
004F74 7F4F74 CC 06 A4                    ldd  #$06A4       ; Decimal 1700 -> Accu D (170 *10 for 0.1 degree resolution calcs) (IGN_CALCS_256)
004F77 7F4F77 FD 10 1F                    ldy  Degx10tk256  ;(Time for 1 degree of rotation in 2.56uS resolution x 10) (IGN_CALCS_256)
004F7A 7F4F7A 13                          emul              ;(D)x(Y)=Y:D "1700" * Degx10tk256                          (IGN_CALCS_256)
004F7B 7F4F7B CE 00 64                        ldx  #$0064       ; Decimal 100 -> Accu X                                (IGN_CALCS_256)
004F7E 7F4F7E 11                              ediv              ;(Y:D)/(X)=Y;Rem->D (("STandItrmx10" * Degx10tk256)/100 (IGN_CALCS_256)
                                                                ; = "Spantk"                                           (IGN_CALCS_256)
004F7F 7F4F7F 7D 10 37                        sty  Spantk       ; Copy result to "Spantk"                              (IGN_CALCS_256)
                                      ;****************************************************************************************** (IGN_CALCS_256)
                                      ; - Multiply dwell time (mS*10) by the correction and divide by 1000 (%*10)("DwellFin") (IGN_CALCS_256)
                                      ;****************************************************************************************** (IGN_CALCS_256)
004F82 7F4F82 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                   (IGN_CALCS_256)
004F87 7F4F87 CD 08 00                    ldy  #stBins_E     ; Load index register Y with address of first configurable constant (IGN_CALCS_256)
                                                             ; on buffer RAM page 2 (stBins_E)                         (IGN_CALCS_256)
004F8A 7F4F8A EC EA 02 EC                 ldd  $02EC,Y       ; Load Accu D with value in buffer RAM page 2 offset 748 ("Dwell") (IGN_CALCS_256)
004F8E 7F4F8E FD 10 D6                    ldy  DwellCor      ; "DwellCor" -> Accu Y (%*10)                             (IGN_CALCS_256)
004F91 7F4F91 13                          emul               ;(D)x(Y)=Y:D "Dwell" * "DwellCor"                         (IGN_CALCS_256)
004F92 7F4F92 CE 03 E8                    ldx  #$03E8        ; Decimal 1000 -> Accu Y (for integer math)               (IGN_CALCS_256)
004F95 7F4F95 11                          ediv               ; (Y:D)/(X)=Y;Rem->D (("Dwell" * "DwellCor")/1000) = "DwellFin" (IGN_CALCS_256)
004F96 7F4F96 7D 10 D8                        sty  DwellFin      ; Copy result to "DwellFin                            (IGN_CALCS_256)
                                      ;****************************************************************************************** (IGN_CALCS_256)
                                      ; - Convert "DwellFin" to time in 2.56uS resolution.("DwellFintk")               (IGN_CALCS_256)
                                      ;****************************************************************************************** (IGN_CALCS_256)
004F99 7F4F99 FC 10 D8                        ldd   DwellFin      ; "DwellFin" -> Accu D                               (IGN_CALCS_256)
004F9C 7F4F9C CD 27 10                        ldy   #$2710        ; Load index register Y with decimal 10000 (for integer math) (IGN_CALCS_256)
004F9F 7F4F9F 13                              emul                ;(D)x(Y)=Y:D "DwellFin" * 10,000                     (IGN_CALCS_256)
004FA0 7F4FA0 CE 01 00                        ldx   #$100         ; Load index register X decimal 256                  (IGN_CALCS_256)
004FA3 7F4FA3 11                          ediv                ;(Y:D)/(X)=Y;Rem->D ("DwellFin" * 10,000) / 256 = "DwellFintk" (IGN_CALCS_256)
004FA4 7F4FA4 7D 10 39                    sty   DwellFintk    ; Copy result to "DwellFintk" (Time required for dwell after (IGN_CALCS_256)
                                                                  ; correction in 2.56uS resolution                    (IGN_CALCS_256)
004FA7 7F4FA7 7D 10 43                        sty   IgnOCadd2     ; Copy result to "IgnOCadd2" (Time required for dwell after (IGN_CALCS_256)
                                                                  ; correction in 2.56uS resolution                    (IGN_CALCS_256)
                                                              ; This is the second OC value loaded into the timer      (IGN_CALCS_256)
                                      ;***************************************************************************************** (IGN_CALCS_256)
                                      ; - Correct the current ST value for trim (degrees*10)("STandItrmx10")           (IGN_CALCS_256)
                                      ;***************************************************************************************** (IGN_CALCS_256)
004FAA 7F4FAA FC 10 D2                    ldd   STcurr      ; Current value in ST table (Degrees x 10) -> Accu D       (IGN_CALCS_256)
004FAD 7F4FAD C3 00 CB                    addd  #$00CB      ; (A:B)+(M:M+1)->A:B "STdeg" + decimal 200 = "Igncalc1" (Degrees*10) (IGN_CALCS_256)
004FB0 7F4FB0 F3 10 90                    addd  Itrmx10     ; (A:B)+(M:M+1)->A:B "Igncalc1" + Itrm10th) = "Igncalc2" (Degrees*10) (IGN_CALCS_256)
004FB3 7F4FB3 83 00 CB                    subd  #$00CB      ; Subtract (A:B)-(M:M+1)=>A:B  "Igncalc2" - decimal 200 = "STandItrm" (IGN_CALCS_256)
                                                                ;(Degrees*10)                                          (IGN_CALCS_256)
004FB6 7F4FB6 7C 10 DA                        std  STandItrmx10 ; Copy result to "STandItrmx10"(Degrees*10)            (IGN_CALCS_256)
                                      ;***************************************************************************************** (IGN_CALCS_256)
                                      ; - Convert "STandItrmx10" to time in 2.56uS resolution ("STandItrmtk")          (IGN_CALCS_256)
                                      ;***************************************************************************************** (IGN_CALCS_256)
004FB9 7F4FB9 FD 10 1F                    ldy  Degx10tk256   ;(Time for 1 degree of rotation in 2.56uS resolution x 10) (IGN_CALCS_256)
004FBC 7F4FBC 13                          emul              ;(D)x(Y)=Y:D "STandItrmx10" * Degx10tk256                  (IGN_CALCS_256)
004FBD 7F4FBD CE 00 64                        ldx  #$0064       ; Decimal 100 -> Accu X                                (IGN_CALCS_256)
004FC0 7F4FC0 11                              ediv              ;(Y:D)/(X)=Y;Rem->D (("STandItrmx10" * Degx10tk256)/100 (IGN_CALCS_256)
                                                                ; = "Spantk"                                           (IGN_CALCS_256)
004FC1 7F4FC1 7D 10 3B                        sty  STandItrmtk  ; Copy result to "STandItrmtk"                         (IGN_CALCS_256)
                                      ;***************************************************************************************** (IGN_CALCS_256)
                                      ; - Add "STandItrmtk" and "DwellFintk" = "Advancetk"                             (IGN_CALCS_256)
                                      ;***************************************************************************************** (IGN_CALCS_256)
004FC4 7F4FC4 FC 10 3B                   ldd   STandItrmtk     ; "STandItrmtk" -> Accu D                               (IGN_CALCS_256)
004FC7 7F4FC7 F3 10 39                   addd  DwellFintk      ; (A:B)+(M:M+1)->A:B "STandItrmtk" + "DwellFintk" = "Advancetk" (IGN_CALCS_256)
004FCA 7F4FCA 7C 10 3D                   std   Advancetk       ; Copy result to "Advancetk"                            (IGN_CALCS_256)
                                      ;***************************************************************************************** (IGN_CALCS_256)
                                      ; - Subtract "Advancetk" from "Spantk" = "Delaytk"                               (IGN_CALCS_256)
                                      ;***************************************************************************************** (IGN_CALCS_256)
004FCD 7F4FCD FC 10 37                        ldd   Spantk     ; "Spantk" -> Accu D                                    (IGN_CALCS_256)
004FD0 7F4FD0 B3 10 3D                        subd  Advancetk  ; Subtract (A:B)-(M:M+1)=>A:B "Spantk" - "Advancetk" = "Delaytk" (IGN_CALCS_256)
004FD3 7F4FD3 7C 10 3F                        std   Delaytk    ; Copy result to "Delaytk"                              (IGN_CALCS_256)
004FD6 7F4FD6 7C 10 41                        std   IgnOCadd1  ; Copy result to "IgnOCadd1"                            (IGN_CALCS_256)
004FD9 7F4FD9                         IgnCalcsDone:
                                      ;*****************************************************************************************
                                      ; ---------------------- End Of Ignition Calculations Section ----------------------------
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; The base value for injector pulse width calculations in mS to 0.1mS resolution is called
                                      ; "ReqFuel". It represents the pulse width reqired to achieve 14.7:1 Air/Fuel Ratio at
                                      ; 100% volumetric efficiency. The VE table contains percentage values to 0.1 percent
                                      ; resolultion and plots intake manifold pressure in KPA to 0.1KPA resolution against RPM.
                                      ; These values are part of the injector pulse width calculations for a running engine.
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Look up current value in VE table (veCurr)(%x10)
                                      ;*****************************************************************************************
                                      ;*    VE_LU       ; Macro in injcalcsBPEM.s ; Macro call moved to state_BPEM488.s 5-4-21
                                      ;*****************************************************************************************
                                      ; The Air/Fuel Ratio of the fuel mixture affects how an engine will run. Generally
                                      ; speaking AFRs of less than ~7:1 are too rich to ignite. Ratios of greater than ~20:1 are
                                      ; too lean to ignite. Stoichiometric ratio is at ~14.7:1. This is the ratio at which all
                                      ; the fuel and all the oxygen are consumed and is best for emmisions concerns. Best power
                                      ; is obtained between ratios of ~12:1 and ~13:1. Best economy is obtained as lean as ~18:1
                                      ; in some engines. This controller runs in open loop so the AFR numbers are used as
                                      ; a tuning aid only.
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Look up current value in AFR table (afrCurr)(AFRx10)
                                      ;*****************************************************************************************
                                      ;*    AFR_LU       ; Macro in injcalcsBPEM.s ; Macro call moved to state_BPEM488.s 5-4-21
                                      ;*****************************************************************************************
                                      ; - Injector dead band is the time required for the injectors to open and close and must
                                      ;   be included in the pulse width time. The amount of time will depend on battery voltge.
                                      ;   Battery voltage correction for injector deadband is calculated as a linear function
                                      ;   of battery voltage from 7.2 volts to 19.2 volts with 13.2 volts being the nominal
                                      ;   operating voltage where no correction is applied.
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Interpolate injector deadband at current battery voltage
                                      ;*****************************************************************************************
004FD9 7F4FD9 MACRO                       DEADBAND_CALCS   ; Macro in injcalcs_BPEM488.s
                                      ;***************************************************************************************** (DEADBAND_CALCS)
                                      ; - Interpolate injector deadband at current battery voltage                     (DEADBAND_CALCS)
                                      ;***************************************************************************************** (DEADBAND_CALCS)
004FD9 7F4FD9 CC 00 48                    ldd  #$0048      ; Decimal 72 (7.2 volts) -> Accu D                          (DEADBAND_CALCS)
004FDC 7F4FDC 3B                          pshd             ; Push to stack (V1)                                        (DEADBAND_CALCS)
004FDD 7F4FDD FC 10 68                    ldd  BatVx10     ; "BatVx10"(battery volts x 10) -> Accu D                   (DEADBAND_CALCS)
004FE0 7F4FE0 3B                          pshd             ; Push to stack (V)                                         (DEADBAND_CALCS)
004FE1 7F4FE1 CC 00 C0                    ldd  #$00C0      ; Decimal 192 (19.2 volts) -> Accu D                        (DEADBAND_CALCS)
004FE4 7F4FE4 3B                          pshd             ; Push to stack (V2)                                        (DEADBAND_CALCS)
004FE5 7F4FE5 FC 10 49                        ldd  DdBndZ2     ;((Injector deadband at 13.2V) + (Injector deadband voltage (DEADBAND_CALCS)
                                                               ; correction * 6)) -> Accu D                            (DEADBAND_CALCS)
004FE8 7F4FE8 3B                          pshd             ; Push to stack (Z1)                                        (DEADBAND_CALCS)
004FE9 7F4FE9 FC 10 47                        ldd  DdBndZ1     ;((Injector deadband at 13.2V) - (Injector deadband voltage (DEADBAND_CALCS)
                                                               ; correction * 6)) -> Accu D                            (DEADBAND_CALCS)
004FEC 7F4FEC 3B                          pshd             ; Push to stack (Z2)                                        (DEADBAND_CALCS)
                                      ;***************************************************************************************** (DEADBAND_CALCS)
                                                      ;    +--------+--------+                                         (DEADBAND_CALCS)
                                                      ;    |        Z2       |  SP+ 0                                  (DEADBAND_CALCS)
                                                      ;    +--------+--------+                                         (DEADBAND_CALCS)
                                                      ;    |        Z1       |  SP+ 2                                  (DEADBAND_CALCS)
                                                      ;    +--------+--------+                                         (DEADBAND_CALCS)
                                                      ;    |        V2       |  SP+ 4                                  (DEADBAND_CALCS)
                                                      ;    +--------+--------+                                         (DEADBAND_CALCS)
                                                      ;    |        V        |  SP+ 6                                  (DEADBAND_CALCS)
                                                      ;    +--------+--------+                                         (DEADBAND_CALCS)
                                                      ;    |        V1       |  SP+ 8                                  (DEADBAND_CALCS)
                                                      ;    +--------+--------+                                         (DEADBAND_CALCS)
                                      ;                     V      V1      V2      Z1    Z2                            (DEADBAND_CALCS)
004FED 7F4FED MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (DEADBAND_CALCS)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (DEADBAND_CALCS/2D_IPOL)
                                      ; ==========================                                                     (DEADBAND_CALCS/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (DEADBAND_CALCS/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (DEADBAND_CALCS/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (DEADBAND_CALCS/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (DEADBAND_CALCS/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (DEADBAND_CALCS/2D_IPOL)
                                      ; result: D: interpolated result                                                 (DEADBAND_CALCS/2D_IPOL)
                                      ; SSTACK: none                                                                   (DEADBAND_CALCS/2D_IPOL)
                                      ;         no registers are preserved                                             (DEADBAND_CALCS/2D_IPOL)
                                      ;                                                                                (DEADBAND_CALCS/2D_IPOL)
                                      ;    ^ V                                                                         (DEADBAND_CALCS/2D_IPOL)
                                      ;    |                                                                           (DEADBAND_CALCS/2D_IPOL)
                                      ;  Z2+....................*                                                      (DEADBAND_CALCS/2D_IPOL)
                                      ;    |                    :                                                      (DEADBAND_CALCS/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (DEADBAND_CALCS/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (DEADBAND_CALCS/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (DEADBAND_CALCS/2D_IPOL)
                                      ;    |   :       :        :                                                      (DEADBAND_CALCS/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (DEADBAND_CALCS/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (DEADBAND_CALCS/2D_IPOL)
                                      ;                                                                                (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
004FED 7F4FED EC 86                                   LDD       \1    ; load V                                         (DEADBAND_CALCS/2D_IPOL)
004FEF 7F4FEF A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (DEADBAND_CALCS/2D_IPOL)
004FF1 7F4FF1 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
004FF3 7F4FF3 EC 80                                   LDD       \5    ; load Z2                                        (DEADBAND_CALCS/2D_IPOL)
004FF5 7F4FF5 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
004FF7 7F4FF7 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (DEADBAND_CALCS/2D_IPOL)
004FF9 7F4FF9 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
004FFB 7F4FFB EC 84                                   LDD       \3    ; load V2                                        (DEADBAND_CALCS/2D_IPOL)
004FFD 7F4FFD A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (DEADBAND_CALCS/2D_IPOL)
004FFF 7F4FFF B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (DEADBAND_CALCS/2D_IPOL)
                                      ;*********************************************************************           (DEADBAND_CALCS/2D_IPOL)
005001 7F5001 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (DEADBAND_CALCS/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (DEADBAND_CALCS/2D_IPOL)
005003 7F5003 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS/2D_IPOL)
005005 7F5005 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (DEADBAND_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (DEADBAND_CALCS)
                                      ; - Free stack space (result in D)                                               (DEADBAND_CALCS)
                                      ;***************************************************************************************** (DEADBAND_CALCS)
005007 7F5007 1B 8A                       leas  10,SP     ; Stack pointer -> bottom of stack                           (DEADBAND_CALCS)
005009 7F5009 7C 10 F7                    std  tmp4w      ; Copy result to "tmp4w" (Injector deadband at current battery (DEADBAND_CALCS)
                                                              ; voltage) (mSec x 100)                                  (DEADBAND_CALCS)
00500C 7F500C FC 10 F7                    ldd  tmp4w      ; Result in "tmp4w" -> Accu D                                (DEADBAND_CALCS)
00500F 7F500F CE 00 0A                    ldx  #$000A     ; Decimal 10-> Accu X                                        (DEADBAND_CALCS)
005012 7F5012 18 10                       idiv            ; (D)/(X)->Xrem->D ("tmp4w"/10="Deadband")(mSec*10)          (DEADBAND_CALCS)
005014 7F5014 7E 10 C0                    stx  Deadband   ; Copy result to "Deadband"(mSec*10)                         (DEADBAND_CALCS)
                                      ;*****************************************************************************************
                                      ; - Look up current value in Barometric Correction Table (barocor)
                                      ;*****************************************************************************************
                                      ;*    BARO_COR_LU       ; Macro in injcalcsBPEM.s ; Macro call moved to state_BPEM488.s 5-4-21
                                      ;*****************************************************************************************
                                      ; - Look up current value in MAT Air Density Table (matcor)
                                      ;*****************************************************************************************
                                      ;*    MAT_COR_LU       ; Macro in injcalcsBPEM.s ; Macro call moved to state_BPEM488.s 5-4-21
                                      ;*****************************************************************************************
                                      ; - Every mS:
                                      ;   Decrement "AIOTcnt" (AIOT pulse width counter)
                                      ;   Decrement "Stallcnt" (stall counter)
                                      ;   Check for no crank or stall condition.
                                      ;*****************************************************************************************
005017 7F5017 1F 10 05 01 02              brclr clock,ms1,NoMS1Routines1 ; If "ms1" bit of "clock" bit field is clear branch
                                                                         ; to NoMS1Routines1:
00501C 7F501C 20 03                       bra  DO_MS1_ROUTINES           ; Branch to DO_MS1_ROUTINES:
00501E 7F501E                         NoMS1Routines1:
00501E 7F501E 06 51 36                    job  NoMS1Routines             ; Long branch
005021 7F5021                         DO_MS1_ROUTINES:
005021 7F5021 MACRO                       MILLISEC_ROUTINES             ; (Macro in rti_BEEM488.s)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
                                      ; - Every mS:                                                                    (MILLISEC_ROUTINES)
                                      ;   Decrement "AIOTcnt" (AIOT pulse width counter)                               (MILLISEC_ROUTINES)
                                      ;   Decrement "Stallcnt" (stall counter)                                         (MILLISEC_ROUTINES)
                                      ;   Check for no crank or stall condition.                                       (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
                                      ;********************************************************************************************** (MILLISEC_ROUTINES)
                                      ; - Check the value of the AIOT pulse width counter, if other than zero, decrement it. (MILLISEC_ROUTINES)
                                      ;   When it reaches zero, shut the AIOT trigger off(open collector output)       (MILLISEC_ROUTINES)
                                      ;********************************************************************************************** (MILLISEC_ROUTINES)
005021 7F5021 B6 10 63                    ldaa    AIOTcnt         ; "AIOTcnt"->Accu A                                  (MILLISEC_ROUTINES)
005024 7F5024 27 0D                       beq     AIOT_CHK_DONE   ; If "Z" bit of "CCR is set, branch to AIOT_CHK_DONE: (MILLISEC_ROUTINES)
005026 7F5026 73 10 63                    dec     AIOTcnt         ; Decrement "AIOTcnt"                                (MILLISEC_ROUTINES)
005029 7F5029 B6 10 63                    ldaa    AIOTcnt         ; load accumulator with value in "AIOTcnt"           (MILLISEC_ROUTINES)
00502C 7F502C 27 02                       beq     AIOT_OFF        ; If "Z" bit of "CCR is set, branch to AIOT_OFF:     (MILLISEC_ROUTINES)
00502E 7F502E 20 03                       bra     AIOT_CHK_DONE   ; Branch to AIOT_CHK_DONE:                           (MILLISEC_ROUTINES)
005030 7F5030                         AIOT_OFF:                                                                        (MILLISEC_ROUTINES)
005030 7F5030 4D 01 08                    bclr PORTB,AIOT         ; Clear "AIOT" pin on Port B (PB6)(end totalizer pulse) (MILLISEC_ROUTINES)
005033 7F5033                         AIOT_CHK_DONE:                                                                   (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
                                      ;   Decrement "Stallcnt" (no crank or stall condition counter)(1mS increments)   (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
005033 7F5033 FC 10 22                   ldd Stallcnt        ; "Stallcnt" -> Accu D                                    (MILLISEC_ROUTINES)
005036 7F5036 27 04                      beq  NoStallcntDec  ; If zero branch to NoStallcntDec:                        (MILLISEC_ROUTINES)
005038 7F5038 18 73 10 22                decw Stallcnt       ; Decrement "Stallcnt" (no crank or stall condition counter) (MILLISEC_ROUTINES)
00503C 7F503C                         NoStallcntDec:                                                                   (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
                                      ;   Check for no crank or stall condition.                                       (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
00503C 7F503C 27 04                      beq  DoStall ; If "Stallcnt" has decremented to zero branch to DoStall:       (MILLISEC_ROUTINES)
00503E 7F503E 18 20 00 F0                bra  NoStall ; Branch to NoStall: (counter is not zero so fall through)       (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
                                      ;   Engine either hasn't begun to crank yet or has stalled                       (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
005042 7F5042                         DoStall:                                                                         (MILLISEC_ROUTINES)
005042 7F5042 MACRO                      FUEL_PUMP_AND_ASD_OFF ; Shut fuel pump and ASD relay off(macro in gpio_BEEM.s) (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES/FUEL_PUMP_AND_ASD_OFF)
                                      ; - De-energise the Fuel pump relay and the Emergency Shutdown relay on Port B Bit0, Bit1 (MILLISEC_ROUTINES/FUEL_PUMP_AND_ASD_OFF)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES/FUEL_PUMP_AND_ASD_OFF)
005042 7F5042 4D 01 01                    bclr  PORTB,FuelPump  ; Clear "FuelPump" pin on Port B(LED9 board 1 to 28)   (MILLISEC_ROUTINES/FUEL_PUMP_AND_ASD_OFF)
005045 7F5045 4D 01 02                        bclr  PORTB,ASDRelay  ; Clear "ASDRelay" pin on Port B(LED23 board 1 to 28) (MILLISEC_ROUTINES/FUEL_PUMP_AND_ASD_OFF)
005048 7F5048 18 79 10 A0                clrw RPM          ; Clear "RPM" (engine RPM)                                  (MILLISEC_ROUTINES)
00504C 7F504C 79 10 14                   clr  State        ; Clear "State" (Cam-Crank state machine current state )    (MILLISEC_ROUTINES)
00504F 7F504F 79 10 E1                   clr  engine       ; Clear all flags in "engine" bit field                     (MILLISEC_ROUTINES)
005052 7F5052 79 10 E2                   clr  engine2      ; Clear all flags in "engine2" bit field                    (MILLISEC_ROUTINES)
005055 7F5055 79 10 24                   clr  ICflgs       ; Clear all flags in "ICflgs" bit field                     (MILLISEC_ROUTINES)
005058 7F5058 79 10 E5                   clr  StateStatus  ; Clear "StateStatus" bit field                             (MILLISEC_ROUTINES)
00505B 7F505B 18 79 10 9A                clrw CASprd512    ; Clear Crankshaft Angle Sensor period (5.12uS time base    (MILLISEC_ROUTINES)
00505F 7F505F 18 79 10 9C                clrw CASprd256    ; Clear Crankshaft Angle Sensor period (2.56uS time base    (MILLISEC_ROUTINES)
005063 7F5063 18 79 10 1D                clrw Degx10tk512  ; Clear Time to rotate crankshaft 1 degree (5.12uS x 10)    (MILLISEC_ROUTINES)
005067 7F5067 18 79 10 1F                clrw Degx10tk256  ; Clear Time to rotate crankshaft 1 degree (2.56uS x 10)    (MILLISEC_ROUTINES)
00506B 7F506B 18 79 10 D6                clrw DwellCor     ; Coil dwell voltage correction (%*10)                      (MILLISEC_ROUTINES)
00506F 7F506F 18 79 10 D8                clrw DwellFin     ; ("Dwell" * "DwellCor") (mS*10)                            (MILLISEC_ROUTINES)
005073 7F5073 18 79 10 DA                clrw STandItrmx10 ; stCurr and Itmx10 (degrees*10)                            (MILLISEC_ROUTINES)
005077 7F5077 18 79 10 A4                clrw ASEcnt       ; Counter for "ASErev"                                      (MILLISEC_ROUTINES)
00507B 7F507B 18 79 10 A6                clrw AFRcurr      ; Current value in AFR table (AFR x 100)                    (MILLISEC_ROUTINES)
00507F 7F507F 18 79 10 A8                clrw VEcurr       ; Current value in VE table (% x 10)                        (MILLISEC_ROUTINES)
005083 7F5083 18 79 10 AA                clrw barocor      ; Barometric Pressure Correction (% x 10)                   (MILLISEC_ROUTINES)
005087 7F5087 18 79 10 AC                clrw matcor       ; Manifold Air Temperature Correction (% x 10)              (MILLISEC_ROUTINES)
00508B 7F508B 18 79 10 AE                clrw WUEcor       ; Warmup Enrichment Correction (% x 10)                     (MILLISEC_ROUTINES)
00508F 7F508F 18 79 10 B0                clrw ASEcor       ; Afterstart Enrichmnet Correction (% x 10)                 (MILLISEC_ROUTINES)
005093 7F5093 18 79 10 B2                clrw WUEandASEcor ; the sum of WUEcor and ASEcor (% x 10)                     (MILLISEC_ROUTINES)
005097 7F5097 18 79 10 B4                clrw Crankcor     ; Cranking pulsewidth temperature correction (% x 10)       (MILLISEC_ROUTINES)
00509B 7F509B 18 79 10 B6                clrw TpsPctDOT    ; TPS difference over time (%/Sec)(update every 100mSec)    (MILLISEC_ROUTINES)
00509F 7F509F 79 10 B8                   clr  TpsDOTcor    ; Throttle Opening Enrichment table value(%)                (MILLISEC_ROUTINES)
0050A2 7F50A2 79 10 B9                   clr  ColdAddpct   ; Throttle Opening Enrichment cold adder (%)                (MILLISEC_ROUTINES)
0050A5 7F50A5 79 10 BA                   clr  ColdMulpct   ; Throttle Opening Enrichment cold multiplier (%)           (MILLISEC_ROUTINES)
0050A8 7F50A8 79 10 BB                   clr  TOEpct       ; Throttle Opening Enrichment (%)                           (MILLISEC_ROUTINES)
0050AB 7F50AB 18 79 10 BC                clrw TOEpw        ; Throttle Opening Enrichment adder (mS x 100)              (MILLISEC_ROUTINES)
0050AF 7F50AF 18 79 10 BE                clrw PWlessTOE    ; Injector pulse width before "TOEpw" and "Deadband" (mS x 10) (MILLISEC_ROUTINES)
0050B3 7F50B3 18 79 10 C0                clrw Deadband     ; injector deadband at current battery voltage mS*100       (MILLISEC_ROUTINES)
                                      ;   clrw PrimePW      ; Primer injector pulswidth (mS x 10)                      (MILLISEC_ROUTINES)
0050B7 7F50B7 18 79 10 C4                clrw CrankPW      ; Cranking injector pulswidth (mS x 10)                     (MILLISEC_ROUTINES)
0050BB 7F50BB 18 79 10 C6                clrw FDpw         ; Fuel Delivery pulse width (PW - Deadband) (mS x 10)       (MILLISEC_ROUTINES)
0050BF 7F50BF 18 79 10 C8                clrw PW           ; Running engine injector pulsewidth (mS x 10)              (MILLISEC_ROUTINES)
0050C3 7F50C3 18 79 10 CC                clrw FDsec        ; Fuel delivery pulse width total over 1 second (mS)        (MILLISEC_ROUTINES)
0050C7 7F50C7 79 10 CF                   clr  TOEdurCnt    ; Throttle Opening Enrichment duration counter              (MILLISEC_ROUTINES)
0050CA 7F50CA 1C 10 E5 02                bset StateStatus,SynchLost ; Set "SynchLost" bit of "StateStatus" bit field (bit1) (MILLISEC_ROUTINES)
0050CE 7F50CE 18 0B FF 00 6E             movb #$FF,ECT_PTPSR        ; Load ECT_PTPSR with %11111111 (prescale 256, 5.12us (MILLISEC_ROUTINES)
                                                                    ; resolution, max period 335.5ms)                  (MILLISEC_ROUTINES)
0050D3 7F50D3 18 0B FF 03 FE             movb #$FF,TIM_PTPSR        ; Load TIM_PTPSR with %11111111 (prescale 256, 5.12us (MILLISEC_ROUTINES)
                                                                    ; resolution, max period 335.5ms)(min RPM = ~85)   (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
                                      ; - Set up the "engine" bit field in preparation for cranking.                   (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
0050D8 7F50D8 1C 10 E1 02                bset engine,crank   ; Set the "crank" bit of "engine" bit field               (MILLISEC_ROUTINES)
0050DC 7F50DC 1D 10 E1 04                bclr engine,run     ; Clear the "run" bit of "engine" bit field               (MILLISEC_ROUTINES)
0050E0 7F50E0 1C 10 E1 10                bset engine,WUEon   ; Set "WUEon" bit of "engine" bit field                   (MILLISEC_ROUTINES)
0050E4 7F50E4 1C 10 E1 08                bset engine,ASEon   ; Set "ASEon" bit of "engine" bit field                   (MILLISEC_ROUTINES)
0050E8 7F50E8 79 10 A4                   clr   ASEcnt        ; Clear the after-start enrichment counter variable       (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
                                      ; - Set the "base512" bit and clear the "base256" bit of the "engine2" bit field in (MILLISEC_ROUTINES)
                                      ;   preparation for cranking.                                                    (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
0050EB 7F50EB 1C 10 E2 01                bset engine2,base512   ; Set the "base512" bit of "engine" bit field          (MILLISEC_ROUTINES)
0050EF 7F50EF 1D 10 E2 02                bclr engine2,base256   ; Clear the "base256" bit of "engine" bit field        (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
                                      ; - Load stall counter with compare value. Stall check is done in the main loop every (MILLISEC_ROUTINES)
                                      ;   mSec. "Stallcnt" is decremented every mSec and reloaded at every crank signal. (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
0050F3 7F50F3 18 0B FF 00 17                  movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE               (MILLISEC_ROUTINES)
0050F8 7F50F8 CD 08 00                    ldy   #veBins_E       ; Load index register Y with address of first configurable (MILLISEC_ROUTINES)
                                                              ; constant on buffer RAM page 1 (vebins)                 (MILLISEC_ROUTINES)
0050FB 7F50FB EC EA 03 E6                 ldd   $03E6,Y       ; Load Accu A with value in buffer RAM page 1 offset 998 (MILLISEC_ROUTINES)
                                                              ; "Stallcnt" (stall counter)(offset = 998)               (MILLISEC_ROUTINES)
0050FF 7F50FF 7C 10 22                    std  Stallcnt       ; Copy to "Stallcnt" (no crank or stall condition counter) (MILLISEC_ROUTINES)
                                                              ; (1mS increments)                                       (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
                                      ; ----------------------- After Start Enrichment Taper (ASErev)--------------------------- (MILLISEC_ROUTINES)
                                      ;                                                                                (MILLISEC_ROUTINES)
                                      ; After Start Enrichment is applied for a specified number of engine revolutions after (MILLISEC_ROUTINES)
                                      ; start up. This number is interpolated from the After Start Enrichment Taper table which (MILLISEC_ROUTINES)
                                      ; plots engine temperature in degrees F to 0.1 degree resolution against revolutions. (MILLISEC_ROUTINES)
                                      ; The ASE starts with the value of "ASEcor" first and is linearly interpolated down to (MILLISEC_ROUTINES)
                                      ; zero after "ASErev" crankshaft revolutions.                                    (MILLISEC_ROUTINES)
                                      ;                                                                                (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
                                      ; - Look up current value in Afterstart Enrichment Taper Table (ASErev) and update the (MILLISEC_ROUTINES)
                                      ;   counter (ASEcnt)                                                             (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
005102 7F5102 MACRO                       ASE_TAPER_LU       ; Macro in injcalcsBPEM.s                                 (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                      ; ----------------------- After Start Enrichment Taper (ASErev)--------------------------- (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                      ;                                                                                (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                      ; After Start Enrichment is applied for a specified number of engine revolutions after (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                      ; start up. This number is interpolated from the After Start Enrichment Taper table which (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                      ; plots engine temperature in degrees F to 0.1 degree resoluion against revolutions. (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                      ; The ASE starts with the value of "ASEcor" first and is linearly interpolated down to (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                      ; zero after "ASErev" crankshaft revolutions.                                    (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                      ;                                                                                (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                      ; - Look up current value in Afterstart Enrichment Taper Table (ASErev)          (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES/ASE_TAPER_LU)
005102 7F5102 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (MILLISEC_ROUTINES/ASE_TAPER_LU)
005107 7F5107 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                                                  ; ->page where the desired curve resides             (MILLISEC_ROUTINES/ASE_TAPER_LU)
00510D 7F510D 18 03 01 90 10 27           movw #$0190,CrvRowOfst  ; 400 -> Offset from the curve page to the curve row (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                                                      ; (tempTable2)(actual offset is 800)             (MILLISEC_ROUTINES/ASE_TAPER_LU)
005113 7F5113 18 03 01 CA 10 29           movw #$01CA,CrvColOfst  ; 458 -> Offset from the curve page to the curve column (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                                                      ; (aseRevTable)(actual offset is 916)            (MILLISEC_ROUTINES/ASE_TAPER_LU)
005119 7F5119 18 04 10 6C 10 2B           movw Cltx10,CrvCmpVal   ; Engine Coolant Temperature (Degrees F x 10) ->     (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                                                  ; Curve comparison value                             (MILLISEC_ROUTINES/ASE_TAPER_LU)
00511F 7F511F 18 0B 09 10 2D              movb #$09,CrvBinCnt     ; 9 -> number of bins in the curve row or column minus 1 (MILLISEC_ROUTINES/ASE_TAPER_LU)
005124 7F5124 16 70 0F                    jsr   CRV_LU_NP         ; Jump to subroutine at CRV_LU_NP:(located in        (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                                                      ; interp_BEEM488.s module)                       (MILLISEC_ROUTINES/ASE_TAPER_LU)
005127 7F5127 7C 10 55                    std   ASErev            ; Copy result to Afterstart Enrichment Taper (revolutions) (MILLISEC_ROUTINES/ASE_TAPER_LU)
00512A 7F512A 7C 10 A4                    std   ASEcnt            ; Copy result to Afterstart Enrichment Taper counter (MILLISEC_ROUTINES/ASE_TAPER_LU)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
                                      ; - Initialize other variables -                                                 (MILLISEC_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC_ROUTINES)
00512D 7F512D 18 0B 09 10 21              movb  #$09,RevCntr     ; Counter for Revolution Counter signals              (MILLISEC_ROUTINES)
005132 7F5132                         NoStall:                                                                         (MILLISEC_ROUTINES)
005132 7F5132 1D 10 05 01                     bclr clock,ms1                ; Clear "ms1" bit of "clock" bit field
005136 7F5136                         NoMS1Routines:
                                      ;*****************************************************************************************
                                      ; - Every 100 mS:
                                      ;   Decrement "OFCdelcmp" (counter for Overrun Fuel Cut delay calculations)
                                      ;   Decrement "TOEtimcmp" (counter for Throttle Opening Enrichment calculations)
                                      ;   Save current TPS percent reading "TpsPctx10" as "TpsPctx10last" to compute "tpsDOT"
                                      ;   in acceleration  enrichment section.
                                      ;*****************************************************************************************
005136 7F5136 1F 10 05 02 12              brclr clock,ms100,NoMS100Routines ; If "ms100" bit of "clock" bit field is clear
                                                                            ; branch to NoMS100Routines:
00513B 7F513B MACRO                       MILLISEC100_ROUTINES              ; (Macro in rti_BEEM488.s)
                                      ;***************************************************************************************** (MILLISEC100_ROUTINES)
                                      ; - Every 100 mS:                                                                (MILLISEC100_ROUTINES)
                                      ;   Decrement "TOEtimcmp" (counter for Throttle Opening Enrichment calculations) (MILLISEC100_ROUTINES)
                                      ;   Save current TPS percent reading "TpsPctx10" as "TpsPctx10last" to compute "tpsDOT" (MILLISEC100_ROUTINES)
                                      ;   in acceleration  enrichment section.                                         (MILLISEC100_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC100_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC100_ROUTINES)
                                      ; - Decrement "TOEdurCnt" Throttle Opening Enrichment duration counter           (MILLISEC100_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC100_ROUTINES)
00513B 7F513B B6 10 CF                    ldaa TOEdurCnt    ; "TOEdurCnt" -> Accu A                                    (MILLISEC100_ROUTINES)
00513E 7F513E 27 03                       beq  NoTOEdurDec  ; If zero branch to NoTOEdurDec:                           (MILLISEC100_ROUTINES)
005140 7F5140 73 10 CF                    dec  TOEdurCnt    ; Decrement Throttle Opening Enrichment duration counter   (MILLISEC100_ROUTINES)
005143 7F5143                         NoTOEdurDec:                                                                     (MILLISEC100_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC100_ROUTINES)
                                      ; - "TPSdot" is throttle position percent rate of change in 100mS. Save current TPS (MILLISEC100_ROUTINES)
                                      ;   percent reading "TpsPctx10" as "TpsPctx10last" to compute "tpsDOT" in acceleration (MILLISEC100_ROUTINES)
                                      ;   enrichment section.                                                          (MILLISEC100_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC100_ROUTINES)
005143 7F5143 18 04 10 7C 10 45           movw  TpsPctx10,TpsPctx10last   ; Copy value in "TpsPctx10" to "TpsPctx10last" (MILLISEC100_ROUTINES)
005149 7F5149 1D 10 05 02                     bclr clock,ms100                  ; Clear "ms100" bit of "clock" bit field
00514D 7F514D                         NoMS100Routines:
                                      ;*****************************************************************************************
                                      ; - Every 1000mS:
                                      ;   Save the current fuel delivery total ("FDt") as "FDsec" so it can be used by Tuner
                                      ;   Studio and Shadow Dash for fuel burn calculations
                                      ;*****************************************************************************************
00514D 7F514D 1F 10 05 10 18              brclr clock,ms1000,NoMS1000Routines ; If "ms1000" bit of "clock" bit field is clear
                                                                              ; branch to NoMS1000Routines:
005152 7F5152 MACRO                       MILLISEC1000_ROUTINES               ; (Macro in rti_BEEM488.s)
                                                                          ;(current becomes last)                      (MILLISEC1000_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC1000_ROUTINES)
                                      ; - Save the current value of "LoopCntr" as "LoopTime" (loops per second)        (MILLISEC1000_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC1000_ROUTINES)
005152 7F5152 FC 10 EF                        ldd  LoopCntr      ; "LoopCntr" (counter for "LoopTime") ->Accu D        (MILLISEC1000_ROUTINES)
005155 7F5155 7C 10 E6                    std  LoopTime      ; Copy to "LoopTime" (Program loop time (loops/Sec)       (MILLISEC1000_ROUTINES)
005158 7F5158 18 79 10 EF                 clrw LoopCntr      ; Clear "LoopCntr" (incremented every Main Loop pass)     (MILLISEC1000_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC1000_ROUTINES)
                                      ; - Save the current fuel delivery total ("FDt") as "FDsec" so it can be used by Tuner (MILLISEC1000_ROUTINES)
                                      ;   Studio and Shadow Dash for fuel burn calculations                            (MILLISEC1000_ROUTINES)
                                      ;***************************************************************************************** (MILLISEC1000_ROUTINES)
00515C 7F515C FC 10 D0                    ldd   FDt     ; "FDt"->Accu D (fuel delivery pulse width time total)(mS x 10) (MILLISEC1000_ROUTINES)
00515F 7F515F 7C 10 CC                        Std   FDsec   ; Copy to "FDsec" (fuel delivery pulse width time total per second) (MILLISEC1000_ROUTINES)
005162 7F5162 18 79 10 D0                     clrw  FDt     ; Clear "FDt" (fuel delivery pulse width time total)(mS x 10) (MILLISEC1000_ROUTINES)
005166 7F5166 1D 10 05 10                     bclr clock,ms1000                   ; Clear "ms1000" bit of "clock" bit field
00516A 7F516A                         NoMS1000Routines:
                                      ;*****************************************************************************************
                                      ; ------------------------ Injector Calculations Section ---------------------------------
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - The fuel injectors are wired in pairs arranged in the firing order 1&10, 9&4, 3&6, 5&8
                                      ;   7&2. This arrangement allows a "semi sequential" injection strategy with only 5
                                      ;   injector drivers. The cylinder pairs are 54 degrees apart in crankshaft rotation so
                                      ;   the injector pulse for the trailing cylinder will lag the leading cylinder by 54
                                      ;   degrees. The benefits of injector timing is an open question but its effect is most
                                      ;   felt at idle when the injection pulse can be timed to an opeing intake valve. At
                                      ;   higher speeds and loads the effect is less becasue the pulse width is longer than the
                                      ;   opening time of the valve. The engine has 10 trigger points on the crankshaft so
                                      ;   there is lots of choice where to refernce the start of the pulse from. I have chosen
                                      ;   to use the point when the intake valve on the leading cylinder is just starting to
                                      ;   open. Actual injector pulse start time can be delayed from this point by the value in
                                      ;   "InjDelDegx10". The delay in timer ticks will depend on the timer base rate of either
                                      ;   5.12 uS for cranking or 2.56uS for running.
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; The determination of whether the engine is cranking or running is made in the
                                      ; State_BPEM488.s module within the Crank Angle Sensor interrupt. It is here that the
                                      ; "crank" and "run" bits of the "engine" bit field are set or cleared.
                                      ;*****************************************************************************************
00516A 7F516A 1E 10 E1 02 04              brset engine,crank,CrankMode ; If "crank" bit of "engine" bit field is set branch
                                                                           ; to CrankMode:
00516F 7F516F 18 20 00 9D                     bra   RunMode                ; Branch to RunMode:(no need to test "run" bit)
005173 7F5173                         CrankMode:
                                      ;*****************************************************************************************
                                      ; Check if we are in flood clear or normal crank mode
                                      ;*****************************************************************************************
005173 7F5173 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE
005178 7F5178 CD 08 00                    ldy   #veBins_E     ; Load index register Y with address of first configurable
                                                              ; constant on buffer RAM page 1 (veBins_E)
00517B 7F517B EE EA 03 E4                 ldx   $03E4,Y       ; Load Accu X with value in buffer RAM page 1 offset 996
                                                              ; "FloodClear" (Flood Clear threshold)
00517F 7F517F BE 10 7C                    cpx   TpsPctx10     ; Compare "FloodClear" with "TpsPctx10"
005182 7F5182 22 13                       bhi   NoFloodClear  ; If "FloodClear" is greater than "TpsPctx10", branch to
                                                                  ; NoFloodClear: ("TpsPctx10" below threshold so interpolate
                                                                                  ; the cranking pulse width)
005184 7F5184 1C 10 E1 80                     bset  engine,FldClr ; Set "FldClr" bit of "engine" bit field
005188 7F5188 18 79 10 59                 clrw  CrankPWtk     ; Clear Cranking injector pulswidth timer ticks(uS x 5.12)
00518C 7F518C 18 79 10 C4                 clrw  CrankPW       ; Cranking injector pulswidth (mS x 10)
005190 7F5190 18 79 10 C6                 clrw  FDpw          ; Fuel Delivery pulse width (PW - Deadband) (mS x 10)
005194 7F5194 06 53 36                    job   MainLoopEnd   ; Jump or branch to "MainLoop" (keep looping here until no
                                                                  ; longer in flood clear mode)
005197 7F5197                         NoFloodClear:
005197 7F5197 1D 10 E1 80                     bclr  engine,FldClr ; Clear "FldClr" bit of "engine" bit field
                                      ;*****************************************************************************************
                                      ; - Calculate the delay time to start injection in 5.12uS resoluion.
                                      ;*****************************************************************************************
00519B 7F519B MACRO                       INJ_DEL_CALC_512    ; Macro in tim_BPEM.s
                                                              ; (prescale 256, 5.12us resolution,                      (INJ_DEL_CALC_512)
                                                              ; max period 335.5ms) (time base for prime or crank modes) (INJ_DEL_CALC_512)
                                      ;***************************************************************************************** (INJ_DEL_CALC_512)
                                      ; - The fuel injectors are wired in pairs arranged in the firing order 1&10, 9&4, 3&6, 5&8 (INJ_DEL_CALC_512)
                                      ;   7&2. This arrangement allows a "semi sequential" injection strategy with only 5 (INJ_DEL_CALC_512)
                                      ;   injector drivers. The cylinder pairs are 54 degrees apart in crankshaft rotation so (INJ_DEL_CALC_512)
                                      ;   the injector pulse for the trailing cylinder will lag the leading cylinder by 54 (INJ_DEL_CALC_512)
                                      ;   degrees. The benefits of injector timing is an open question but its effect is most (INJ_DEL_CALC_512)
                                      ;   felt at idle when the injection pulse can be timed to an opeing intake valve. At (INJ_DEL_CALC_512)
                                      ;   higher speeds and loads the effect is less becasue the pulse width is longer than the (INJ_DEL_CALC_512)
                                      ;   opening time of the valve. The engine has 10 trigger points on the crankshaft so (INJ_DEL_CALC_512)
                                      ;   there is lots of choice where to refernce the start of the pulse from. I have chosen (INJ_DEL_CALC_512)
                                      ;   to use the point when the intake valve on the leading cylinder is just starting to (INJ_DEL_CALC_512)
                                      ;   open. Actual injector pulse start time can be delayed from this point by the value in (INJ_DEL_CALC_512)
                                      ;   "InjDelDegx10". The delay in timer ticks will depend on the timer base rate of either (INJ_DEL_CALC_512)
                                      ;   5.12 uS for cranking or 2.56uS for running.                                  (INJ_DEL_CALC_512)
                                      ;***************************************************************************************** (INJ_DEL_CALC_512)
                                      ;***************************************************************************************** (INJ_DEL_CALC_512)
                                      ; - Calculate the delay time from crankshaft trigger to start of the injector pulse in (INJ_DEL_CALC_512)
                                      ;   5.12uS resolution.                                                           (INJ_DEL_CALC_512)
                                      ;***************************************************************************************** (INJ_DEL_CALC_512)
00519B 7F519B 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (INJ_DEL_CALC_512)
0051A0 7F51A0 CD 08 00                    ldy   #veBins_E   ; Load index register Y with address of first configurable (INJ_DEL_CALC_512)
                                                            ; constant on buffer RAM page 1 (vebins)                   (INJ_DEL_CALC_512)
0051A3 7F51A3 EE EA 03 D8                 ldx   $03D8,Y     ; Load Accu X with value in buffer RAM page 1 (offset 984)($03D8) (INJ_DEL_CALC_512)
                                                            ; ("InjDelDegx10")                                         (INJ_DEL_CALC_512)
0051A7 7F51A7 B7 54                       tfr  X,D          ; "InjDelDegx10" -> Accu D                                 (INJ_DEL_CALC_512)
0051A9 7F51A9 FD 10 1D                    ldy  Degx10tk512  ;(Time for 1 degree of rotation in 5.12uS resolution x 10) (INJ_DEL_CALC_512)
0051AC 7F51AC 13                          emul              ;(D)x(Y)=Y:D "InjDelDegx10" * Degx10tk512                  (INJ_DEL_CALC_512)
0051AD 7F51AD CE 00 64                        ldx  #$0064       ; Decimal 100 -> Accu X                                (INJ_DEL_CALC_512)
0051B0 7F51B0 11                              ediv              ;(Y:D)/(X)=Y;Rem->D ((InjDelDegx10" * Degx10tk512)/100 (INJ_DEL_CALC_512)
                                                                ; = "InjOCadd1"                                        (INJ_DEL_CALC_512)
0051B1 7F51B1 7D 10 5D                        sty  InjOCadd1    ; Copy result to "InjOCadd1"                           (INJ_DEL_CALC_512)
                                      ;*****************************************************************************************
                                      ; - Look up current value in Cranking Pulsewidth Correction Table (Crankcor)
                                      ;*****************************************************************************************
0051B4 7F51B4 MACRO                       CRANK_COR_LU       ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (CRANK_COR_LU)
                                      ; --------------------------------- Cranking Mode ---------------------------------------- (CRANK_COR_LU)
                                      ; When the engine is cranking the injector pulse width is calculated by          (CRANK_COR_LU)
                                      ; multiplying the value in ReqFuel by the pertentage value in "Crankcor". "Crankcor" is (CRANK_COR_LU)
                                      ; interpolated from the Cranking Pulse table which plots engine temperature in degrees F (CRANK_COR_LU)
                                      ; to 0.1 degree resoluion against percent to 0.1 percent resolution.             (CRANK_COR_LU)
                                      ;***************************************************************************************** (CRANK_COR_LU)
                                      ;***************************************************************************************** (CRANK_COR_LU)
                                      ; - Look up current value in Cranking Pulsewidth Correction Table (Crankcor)     (CRANK_COR_LU)
                                      ;***************************************************************************************** (CRANK_COR_LU)
0051B4 7F51B4 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (CRANK_COR_LU)
0051B9 7F51B9 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (CRANK_COR_LU)
                                                                  ; ->page where the desired curve resides             (CRANK_COR_LU)
0051BF 7F51BF 18 03 01 90 10 27           movw #$0190,CrvRowOfst  ; 400 -> Offset from the curve page to the curve row( (CRANK_COR_LU)
                                                                      ; tempTable2)(actual offset is 800)              (CRANK_COR_LU)
0051C5 7F51C5 18 03 01 B6 10 29           movw #$01B6,CrvColOfst  ; 438 -> Offset from the curve page to the curve column (CRANK_COR_LU)
                                                                      ; (crankPctTable)(actual offset is 876)          (CRANK_COR_LU)
0051CB 7F51CB 18 04 10 6C 10 2B           movw Cltx10,CrvCmpVal   ; Engine Coolant Temperature (Degrees F x 10) ->     (CRANK_COR_LU)
                                                                  ; Curve comparison value                             (CRANK_COR_LU)
0051D1 7F51D1 18 0B 09 10 2D              movb #$09,CrvBinCnt     ; 9 -> number of bins in the curve row or column minus 1 (CRANK_COR_LU)
0051D6 7F51D6 16 70 0F                    jsr   CRV_LU_NP         ; Jump to subroutine at CRV_LU_NP:(located in interp_BEEM488.s (CRANK_COR_LU)
                                                                      ; module)                                        (CRANK_COR_LU)
0051D9 7F51D9 7C 10 B4                    std   Crankcor          ; Copy result to Cranking Pulsewidth Correction (% x 10) (CRANK_COR_LU)
                                      ;*****************************************************************************************
                                      ; - Calculate the cranking pulsewidth.
                                      ;*****************************************************************************************
0051DC 7F51DC MACRO                       CRANK_PW_CALC       ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (CRANK_PW_CALC)
                                      ; - Calculate the cranking pulsewidth.                                           (CRANK_PW_CALC)
                                      ;***************************************************************************************** (CRANK_PW_CALC)
                                      ;***************************************************************************************** (CRANK_PW_CALC)
                                      ; - Multiply "ReqFuel"(mS x 10) by "Crankcor" (%) = (mS * 10)                    (CRANK_PW_CALC)
                                      ;***************************************************************************************** (CRANK_PW_CALC)
0051DC 7F51DC 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (CRANK_PW_CALC)
0051E1 7F51E1 CD 08 00                    ldy   #veBins_E    ; Load index register Y with address of first configurable (CRANK_PW_CALC)
                                                           ; constant on buffer RAM page 1 (vebins)                    (CRANK_PW_CALC)
0051E4 7F51E4 EC EA 03 EC                 ldd   $03EC,Y    ; Load Accu X with value in buffer RAM page 1 (offset 1004)($03EC) (CRANK_PW_CALC)
                                                           ; ("ReqFuel")                                               (CRANK_PW_CALC)
0051E8 7F51E8 FD 10 B4                    ldy  Crankcor    ;Cranking Pulsewidth Correction (% x 10) -> Accu Y          (CRANK_PW_CALC)
0051EB 7F51EB 13                          emul             ;(D)x(Y)=Y:D "ReqFuel" * "Crankcor"                         (CRANK_PW_CALC)
0051EC 7F51EC CE 03 E8                        ldx  #$03E8      ; Decimal 1000 -> Accu X                                (CRANK_PW_CALC)
0051EF 7F51EF 11                              ediv             ;(Y:D)/(X)=Y;Rem->D ("ReqFuel" * "Crankcor" )/10000     (CRANK_PW_CALC)
                                      ;***************************************************************************************** (CRANK_PW_CALC)
                                      ; - Store the result as "FDpw"(fuel delivery pulse width)(mS x 10)               (CRANK_PW_CALC)
                                      ;***************************************************************************************** (CRANK_PW_CALC)
0051F0 7F51F0 7D 10 C6                        sty  FDpw        ; Result -> "FDpw" (fuel delivery pulsewidth (mS x 10)  (CRANK_PW_CALC)
                                      ;***************************************************************************************** (CRANK_PW_CALC)
                                      ; - Add "deadband and store the result as "CrankPW"(cranking injector pulsewidth)(mS x 10) (CRANK_PW_CALC)
                                      ;***************************************************************************************** (CRANK_PW_CALC)
0051F3 7F51F3 FC 10 C6                    ldd  FDpw        ; "FDpw"-> Accu D                                           (CRANK_PW_CALC)
0051F6 7F51F6 F3 10 C0                        addd Deadband    ; (A:B)+(M:M+1)->A:B ("FDpw"+"Deadband"="CrankPW"       (CRANK_PW_CALC)
0051F9 7F51F9 7C 10 C4                        std  CrankPW     ; Result -> "CrankPW" (cranking injector pulsewidth) (mS x 10) (CRANK_PW_CALC)
                                      ;***************************************************************************************** (CRANK_PW_CALC)
                                      ; - Convert the result to timer ticks in 5.12uS resolution                       (CRANK_PW_CALC)
                                      ;***************************************************************************************** (CRANK_PW_CALC)
0051FC 7F51FC FC 10 C4                    ldd   CrankPW    ; "CrankPW"->Accu D (cranking injector pulsewidth) (mS x 10) (CRANK_PW_CALC)
0051FF 7F51FF CD 27 10                        ldy   #$2710     ; Load index register Y with decimal 10000 (for integer math) (CRANK_PW_CALC)
005202 7F5202 13                              emul             ;(D)x(Y)=Y:D ("ReqFuel" * "crankcor" )/100) * 10,000)   (CRANK_PW_CALC)
005203 7F5203 CE 02 00                        ldx   #$200      ; Decimal 512 -> Accu X                                 (CRANK_PW_CALC)
005206 7F5206 11                          ediv             ;(Y:D)/(X)=Y;Rem->D                                         (CRANK_PW_CALC)
                                                               ; ((("ReqFuel" * "crankcor" )/100) * 10,000) / 512 = "CrankPWtk" (CRANK_PW_CALC)
005207 7F5207 7D 10 59                    sty   CrankPWtk  ; Copy result to "CrankPWtk" (Cranking pulse width in 5.12uS (CRANK_PW_CALC)
                                                               ; resolution)                                           (CRANK_PW_CALC)
00520A 7F520A 7D 10 5F                    sty   InjOCadd2  ; Second injector output compare adder (5.12uS res)         (CRANK_PW_CALC)
00520D 7F520D 06 53 36                    job  MainLoopEnd   ; Jump or branch to "MainLoopEnd:" (keep looping here until no
                                                                 ; longer in crank mode
005210 7F5210                         RunMode:
                                      ;*****************************************************************************************
                                      ; - Calculate the delay time to start injection in 2.56uS resoluion.
                                      ;*****************************************************************************************
005210 7F5210 MACRO                       INJ_DEL_CALC_256    ; Macro in tim_BPEM.s
                                      ;***************************************************************************************** (INJ_DEL_CALC_256)
                                      ; - Calculate the delay time from crankshaft trigger to start of the injector pulse in (INJ_DEL_CALC_256)
                                      ;   2.56uS resolution.                                                           (INJ_DEL_CALC_256)
                                      ;***************************************************************************************** (INJ_DEL_CALC_256)
005210 7F5210 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (INJ_DEL_CALC_256)
005215 7F5215 CD 08 00                    ldy   #veBins_E   ; Load index register Y with address of first configurable (INJ_DEL_CALC_256)
                                                            ; constant on buffer RAM page 1 (vebins)                   (INJ_DEL_CALC_256)
005218 7F5218 EE EA 03 D8                 ldx   $03D8,Y     ; Load Accu X with value in buffer RAM page 1 (offset 984)($03D8) (INJ_DEL_CALC_256)
                                                            ; ("InjDelDegx10")                                         (INJ_DEL_CALC_256)
00521C 7F521C B7 54                       tfr  X,D          ; "InjDelDegx10" -> Accu D                                 (INJ_DEL_CALC_256)
00521E 7F521E FD 10 1F                    ldy  Degx10tk256  ;(Time for 1 degree of rotation in 2.56uS resolution x 10) (INJ_DEL_CALC_256)
005221 7F5221 13                          emul              ;(D)x(Y)=Y:D "InjDelDegx10" * Degx10tk256                  (INJ_DEL_CALC_256)
005222 7F5222 CE 00 64                        ldx  #$0064       ; Decimal 100 -> Accu X                                (INJ_DEL_CALC_256)
005225 7F5225 11                              ediv              ;(Y:D)/(X)=Y;Rem->D ((InjDelDegx10" * Degx10tk256)/100 (INJ_DEL_CALC_256)
                                                                ; = "InjOCadd1"                                        (INJ_DEL_CALC_256)
005226 7F5226 7D 10 5D                        sty  InjOCadd1    ; Copy result to "InjOCadd1"                           (INJ_DEL_CALC_256)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Determine if we will require Warmup Enrichments and or After Start Enrichments
                                      ;*****************************************************************************************
005229 7F5229 1E 10 E1 08 0A              brset  engine,ASEon,CHECK_WUE_ASE   ; If "ASEon" bit of "engine" bit field is set, branch
                                                                              ; to CHECK_WUE_ASE:
00522E 7F522E 1F 10 E1 10 02              brclr  engine,WUEon,NO_WUE_ASE1 ; If "WUEon" bit of "engine" bit field is clear
                                                                          ; Branch to NO_WUE_ASE1: (engine is warm and ASE is
                                                                                                              ; not in progress so no enrichments are required)
005233 7F5233 20 03                       bra  CHECK_WUE_ASE              ; branch to CHECK_WUE_ASE:
005235 7F5235                         NO_WUE_ASE1:
005235 7F5235 06 52 F4                    job NO_WUE_ASE                     ; Jump or branch to NO_WUE_ASE (long branch)
005238 7F5238                         CHECK_WUE_ASE:
                                      ;*****************************************************************************************
                                      ; ---------------------------- Warm Up Enrichment (WUEcor)--------------------------------
                                      ;
                                      ; Warm Up Enrichment is applied until the engine is up to full operating temperature.
                                      ; "WUEcor" specifies how much fuel is added as a percentage. It is interpolated from the
                                      ; Warm Up Enrichment table which plots engine temperature in degrees F to 0.1 degree
                                      ; resoluion against percent to 0.1 percent resolution and is part of the calculations
                                      ; to determine pulse width when the engine is running.
                                      ;
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Look up current value in Warmup Enrichment Table (WUEcor)
                                      ;*****************************************************************************************
005238 7F5238 MACRO                       WUE_COR_LU       ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (WUE_COR_LU)
                                      ; ---------------------------- Warm Up Enrichment (WUEcor)-------------------------------- (WUE_COR_LU)
                                      ;                                                                                (WUE_COR_LU)
                                      ; Warm Up Enrichment is applied until the engine is up to full operating temperature. (WUE_COR_LU)
                                      ; "WUEcor" specifies how much fuel is added as a percentage. It is interpolated from the (WUE_COR_LU)
                                      ; Warm Up Enrichment table which plots engine temperature in degrees F to 0.1 degree (WUE_COR_LU)
                                      ; resoluion against percent to 0.1 percent resolution and is part of the calculations (WUE_COR_LU)
                                      ; to determine pulse width when the engine is running.                           (WUE_COR_LU)
                                      ;                                                                                (WUE_COR_LU)
                                      ;***************************************************************************************** (WUE_COR_LU)
                                      ;***************************************************************************************** (WUE_COR_LU)
                                      ; - Look up current value in Warmup Enrichment Table (WUEcor)                    (WUE_COR_LU)
                                      ;***************************************************************************************** (WUE_COR_LU)
005238 7F5238 1F 10 E1 10 28              brclr  engine,WUEon,NO_WUE_LU ; If "WUEon" bit of "engine" bit field is clear, branch (WUE_COR_LU)
                                                                  ; to NO_WUE_LU: (Engine has reached operating temperature and (WUE_COR_LU)
                                                                  ; bit has been cleared)                              (WUE_COR_LU)
00523D 7F523D 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (WUE_COR_LU)
005242 7F5242 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr ; Address of the first value in VE table(in RAM)(page pointer) (WUE_COR_LU)
                                                                  ; ->page where the desired curve resides             (WUE_COR_LU)
005248 7F5248 18 03 01 86 10 27           movw #$0186,CrvRowOfst  ; 390 -> Offset from the curve page to the curve row (WUE_COR_LU)
                                                                      ; (tempTable1)(actual offset is 780              (WUE_COR_LU)
00524E 7F524E 18 03 01 D4 10 29           movw #$01D4,CrvColOfst  ; 468 -> Offset from the curve page to the curve column( (WUE_COR_LU)
                                                                      ; wueBins)(actual offset is 936)                 (WUE_COR_LU)
005254 7F5254 18 04 10 6C 10 2B           movw Cltx10,CrvCmpVal   ; Engine Coolant Temperature (Degrees F x 10) ->     (WUE_COR_LU)
                                                                  ; Curve comparison value                             (WUE_COR_LU)
00525A 7F525A 18 0B 09 10 2D              movb #$09,CrvBinCnt     ; 9 -> number of bins in the curve row or column minus 1 (WUE_COR_LU)
00525F 7F525F 16 70 0F                    jsr   CRV_LU_NP         ; Jump to subroutine at CRV_LU_NP:(located in        (WUE_COR_LU)
                                                                      ; interp_BEEM488.s module)                       (WUE_COR_LU)
005262 7F5262 7C 10 AE                    std   WUEcor            ; Copy result to Warmup Enrichment Correction (% x 10) (WUE_COR_LU)
005265 7F5265                         NO_WUE_LU:                                                                       (WUE_COR_LU)
                                      ;*****************************************************************************************
                                      ; -------------------------- After Start Enrichment (ASEcor)------------------------------
005265 7F5265                         :
                                      ; Immediately after the engine has started it is normal to need additional fuel for a
                                      ; short period of time. "ASEcor"specifies how much fuel is added as a percentage. It is
                                      ; interpolated from the After Start Enrichment table which plots engine temperature in
                                      ; degrees F to 0.1 degree resoluion against percent to 0.1 percent resolution and is added
                                      ; to "WUEcor" as part of the calculations to determine pulse width when the engine is
                                      ; running.
                                      ;
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Look up current value in Afterstart Enrichment Percentage Table (ASEcor)
                                      ;*****************************************************************************************
005265 7F5265 MACRO                       ASE_COR_LU       ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (ASE_COR_LU)
                                      ; -------------------------- After Start Enrichment (ASEcor)------------------------------ (ASE_COR_LU)
005265 7F5265                         :                                                                                (ASE_COR_LU)
                                      ; Immediately after the engine has started it is normal to need additional fuel for a (ASE_COR_LU)
                                      ; short period of time. "ASEcor"specifies how much fuel is added as a percentage. It is (ASE_COR_LU)
                                      ; interpolated from the After Start Enrichment table which plots engine temperature in (ASE_COR_LU)
                                      ; degrees F to 0.1 degree resoluion against percent to 0.1 percent resolution and is added (ASE_COR_LU)
                                      ; to "WUEcor" as part of the calculations to determine pulse width when the engine is (ASE_COR_LU)
                                      ; running.                                                                       (ASE_COR_LU)
                                      ;                                                                                (ASE_COR_LU)
                                      ;***************************************************************************************** (ASE_COR_LU)
                                      ;***************************************************************************************** (ASE_COR_LU)
                                      ; - Look up current value in Afterstart Enrichment Percentage Table (ASEcor)     (ASE_COR_LU)
                                      ;***************************************************************************************** (ASE_COR_LU)
005265 7F5265 1F 10 E1 08 28              brclr  engine,ASEon,NO_ASE_LU ; If "ASEon" bit of "engine" bit field is clear, branch (ASE_COR_LU)
                                                                  ; to NO_ASE_LU: (Engine has finished ASE and bit has been (ASE_COR_LU)
                                                                  ; cleared)                                           (ASE_COR_LU)
00526A 7F526A 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (ASE_COR_LU)
00526F 7F526F 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (ASE_COR_LU)
                                                                  ; ->page where the desired curve resides             (ASE_COR_LU)
005275 7F5275 18 03 01 90 10 27           movw #$0190,CrvRowOfst  ; 400 -> Offset from the curve page to the curve row (ASE_COR_LU)
                                                                      ; (tempTable2)(actual offset is 800)             (ASE_COR_LU)
00527B 7F527B 18 03 01 C0 10 29           movw #$01C0,CrvColOfst  ; 448 -> Offset from the curve page to the curve column (ASE_COR_LU)
                                                                      ; (asePctTable)(actual offset is 896)            (ASE_COR_LU)
005281 7F5281 18 04 10 6C 10 2B           movw Cltx10,CrvCmpVal   ; Engine Coolant Temperature (Degrees F x 10) ->     (ASE_COR_LU)
                                                                  ; Curve comparison value                             (ASE_COR_LU)
005287 7F5287 18 0B 09 10 2D              movb #$09,CrvBinCnt     ; 9 -> number of bins in the curve row or column minus 1 (ASE_COR_LU)
00528C 7F528C 16 70 0F                    jsr   CRV_LU_NP         ; Jump to subroutine at CRV_LU_NP:(located in        (ASE_COR_LU)
                                                                      ; interp_BEEM488.s module)                       (ASE_COR_LU)
00528F 7F528F 7C 10 B0                    std   ASEcor            ; Copy result to  Afterstart Enrichmnet Correction (% x 10) (ASE_COR_LU)
005292 7F5292                         NO_ASE_LU:                                                                       (ASE_COR_LU)
                                      ;*****************************************************************************************
                                      ; - WUE and or ASE is in progress so do the WUE/ASE calculations
                                      ;*****************************************************************************************
005292 7F5292 MACRO                       WUE_ASE_CALCS       ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (WUE_ASE_CALCS)
                                      ; - Do the WUE and ASE calculations                                              (WUE_ASE_CALCS)
                                      ;***************************************************************************************** (WUE_ASE_CALCS)
005292 7F5292 1F 10 E1 08 02              brclr engine,ASEon,WUEcheck1 ; If "ASEon" bit of "engine" bit field is clear, (WUE_ASE_CALCS)
                                                                      ; branch to WUEcheck1:(ASE is finished, see if we are (WUE_ASE_CALCS)
                                                                                                      ; still in warm up mode) (WUE_ASE_CALCS)
005297 7F5297 20 02                       bra  N0_WUEcheck_LONG_BRANCH ; Branch to N0_WUEcheck_LONG_BRANCH:            (WUE_ASE_CALCS)
005299 7F5299                         WUEcheck1:                                                                       (WUE_ASE_CALCS)
005299 7F5299 20 4B                       job   WUEcheck              ; Jump or branch to WUEcheck: (long branch)      (WUE_ASE_CALCS)
00529B 7F529B                         N0_WUEcheck_LONG_BRANCH:                                                         (WUE_ASE_CALCS)
                                      ;***************************************************************************************** (WUE_ASE_CALCS)
                                      ; Interpolate "ASEcor" as "ASEcnt" is decremented. ASEcnt is decremented every revolution (WUE_ASE_CALCS)
                                      ; in the Crank Angle Sensor interrupt in the state_BEEM488 module                (WUE_ASE_CALCS)
                                      ;***************************************************************************************** (WUE_ASE_CALCS)
00529B 7F529B CC 00 00                    ldd  #$0000      ; Load double accumulator with zero (final value of "ASErev") (WUE_ASE_CALCS)
00529E 7F529E 3B                          pshd             ; Push to stack (V1)                                        (WUE_ASE_CALCS)
00529F 7F529F FC 10 A4                    ldd  ASEcnt      ; Load double accumulator with "ASEcnt"                     (WUE_ASE_CALCS)
0052A2 7F52A2 3B                          pshd             ; Push to stack (V)                                         (WUE_ASE_CALCS)
0052A3 7F52A3 FC 10 55                    ldd  ASErev      ; Load double accumulator with (Start value of "ASErev")    (WUE_ASE_CALCS)
0052A6 7F52A6 3B                          pshd             ; Push to stack (V2)                                        (WUE_ASE_CALCS)
0052A7 7F52A7 CC 00 00                    ldd  #$0000      ; Load double accumulator with zero (Low range of "ASEcor") (WUE_ASE_CALCS)
0052AA 7F52AA 3B                          pshd             ; Push to stack (Z1)                                        (WUE_ASE_CALCS)
0052AB 7F52AB FC 10 B0                    ldd  ASEcor      ; Load double accumulator with (High range of "ASEcor")     (WUE_ASE_CALCS)
0052AE 7F52AE 3B                          pshd             ; Push to stack (Z2)                                        (WUE_ASE_CALCS)
                                      ;***************************************************************************************** (WUE_ASE_CALCS)
                                                      ;    +--------+--------+                                         (WUE_ASE_CALCS)
                                                      ;    |        Z2       |  SP+ 0                                  (WUE_ASE_CALCS)
                                                      ;    +--------+--------+                                         (WUE_ASE_CALCS)
                                                      ;    |        Z1       |  SP+ 2                                  (WUE_ASE_CALCS)
                                                      ;    +--------+--------+                                         (WUE_ASE_CALCS)
                                                      ;    |        V2       |  SP+ 4                                  (WUE_ASE_CALCS)
                                                      ;    +--------+--------+                                         (WUE_ASE_CALCS)
                                                      ;    |        V        |  SP+ 6                                  (WUE_ASE_CALCS)
                                                      ;    +--------+--------+                                         (WUE_ASE_CALCS)
                                                      ;    |        V1       |  SP+ 8                                  (WUE_ASE_CALCS)
                                                      ;    +--------+--------+                                         (WUE_ASE_CALCS)
                                      ;                     V      V1      V2      Z1    Z2                            (WUE_ASE_CALCS)
0052AF 7F52AF MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (WUE_ASE_CALCS)
                                      ;***************************************************************************************** (WUE_ASE_CALCS/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (WUE_ASE_CALCS/2D_IPOL)
                                      ; ==========================                                                     (WUE_ASE_CALCS/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (WUE_ASE_CALCS/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (WUE_ASE_CALCS/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (WUE_ASE_CALCS/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (WUE_ASE_CALCS/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (WUE_ASE_CALCS/2D_IPOL)
                                      ; result: D: interpolated result                                                 (WUE_ASE_CALCS/2D_IPOL)
                                      ; SSTACK: none                                                                   (WUE_ASE_CALCS/2D_IPOL)
                                      ;         no registers are preserved                                             (WUE_ASE_CALCS/2D_IPOL)
                                      ;                                                                                (WUE_ASE_CALCS/2D_IPOL)
                                      ;    ^ V                                                                         (WUE_ASE_CALCS/2D_IPOL)
                                      ;    |                                                                           (WUE_ASE_CALCS/2D_IPOL)
                                      ;  Z2+....................*                                                      (WUE_ASE_CALCS/2D_IPOL)
                                      ;    |                    :                                                      (WUE_ASE_CALCS/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (WUE_ASE_CALCS/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (WUE_ASE_CALCS/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (WUE_ASE_CALCS/2D_IPOL)
                                      ;    |   :       :        :                                                      (WUE_ASE_CALCS/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (WUE_ASE_CALCS/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (WUE_ASE_CALCS/2D_IPOL)
                                      ;                                                                                (WUE_ASE_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (WUE_ASE_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (WUE_ASE_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (WUE_ASE_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (WUE_ASE_CALCS/2D_IPOL)
0052AF 7F52AF EC 86                                   LDD       \1    ; load V                                         (WUE_ASE_CALCS/2D_IPOL)
0052B1 7F52B1 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (WUE_ASE_CALCS/2D_IPOL)
0052B3 7F52B3 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (WUE_ASE_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (WUE_ASE_CALCS/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (WUE_ASE_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (WUE_ASE_CALCS/2D_IPOL)
0052B5 7F52B5 EC 80                                   LDD       \5    ; load Z2                                        (WUE_ASE_CALCS/2D_IPOL)
0052B7 7F52B7 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (WUE_ASE_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (WUE_ASE_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (WUE_ASE_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (WUE_ASE_CALCS/2D_IPOL)
0052B9 7F52B9 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (WUE_ASE_CALCS/2D_IPOL)
0052BB 7F52BB B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (WUE_ASE_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (WUE_ASE_CALCS/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (WUE_ASE_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (WUE_ASE_CALCS/2D_IPOL)
0052BD 7F52BD EC 84                                   LDD       \3    ; load V2                                        (WUE_ASE_CALCS/2D_IPOL)
0052BF 7F52BF A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (WUE_ASE_CALCS/2D_IPOL)
0052C1 7F52C1 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (WUE_ASE_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (WUE_ASE_CALCS/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (WUE_ASE_CALCS/2D_IPOL)
                                      ;*********************************************************************           (WUE_ASE_CALCS/2D_IPOL)
0052C3 7F52C3 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (WUE_ASE_CALCS/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (WUE_ASE_CALCS/2D_IPOL)
0052C5 7F52C5 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (WUE_ASE_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (WUE_ASE_CALCS/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (WUE_ASE_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (WUE_ASE_CALCS/2D_IPOL)
0052C7 7F52C7 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (WUE_ASE_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (WUE_ASE_CALCS)
                                      ; - Free stack space (result in D)                                               (WUE_ASE_CALCS)
                                      ;***************************************************************************************** (WUE_ASE_CALCS)
0052C9 7F52C9 1B 8A                       leas  10,SP     ; Stack pointer -> bottom of stack                           (WUE_ASE_CALCS)
0052CB 7F52CB 7C 10 B0                    std   ASEcor    ; Copy result to "ASEcor" ASE correction (%)                 (WUE_ASE_CALCS)
                                      ;***************************************************************************************** (WUE_ASE_CALCS)
                                      ; - "WUEcor" + "ASEcor" = "WUEandASEcor" (%*10)                                  (WUE_ASE_CALCS)
                                      ;***************************************************************************************** (WUE_ASE_CALCS)
0052CE 7F52CE FC 10 AE                   ldd   WUEcor        ; "WUEcor" (%x10) -> Accu D                               (WUE_ASE_CALCS)
0052D1 7F52D1 F3 10 B0                   addd  ASEcor        ; (A:B)+(M:M+1)->A:B "WUEcor" + "ASEcor" = "WUEcor" (%*10) (WUE_ASE_CALCS)
0052D4 7F52D4 7C 10 B2                   std   WUEandASEcor  ; Copy result to "WUEandASEcor" (%*10)                    (WUE_ASE_CALCS)
                                      ;***************************************************************************************** (WUE_ASE_CALCS)
                                      ; - Check to see if we are finished with ASE                                     (WUE_ASE_CALCS)
                                      ;***************************************************************************************** (WUE_ASE_CALCS)
0052D7 7F52D7 FC 10 A4                   ldd  ASEcnt     ; "ASEcnt" -> Accu D                                          (WUE_ASE_CALCS)
0052DA 7F52DA 27 02                      beq  ASEdone    ; If "ASEcnt" has been decremented to zero branch to ASEdone: (WUE_ASE_CALCS)
0052DC 7F52DC 20 08                      bra  WUEcheck   ; Branch to WUEcheck:                                         (WUE_ASE_CALCS)
0052DE 7F52DE                         ASEdone:                                                                         (WUE_ASE_CALCS)
0052DE 7F52DE 1D 10 E1 08                bclr engine,ASEon  ; Clear "ASEon" bit of "engine" bit field                  (WUE_ASE_CALCS)
0052E2 7F52E2 18 79 10 B0                clrw ASEcor        ; Clear "ASEcor"                                           (WUE_ASE_CALCS)
                                      ;***************************************************************************************** (WUE_ASE_CALCS)
                                      ; - Check to see if we are finished with WUE                                     (WUE_ASE_CALCS)
                                      ;***************************************************************************************** (WUE_ASE_CALCS)
0052E6 7F52E6                         WUEcheck:                                                                        (WUE_ASE_CALCS)
0052E6 7F52E6 FC 10 AE                   ldd  WUEcor        ; "WUEcor" -> Accu D                                       (WUE_ASE_CALCS)
0052E9 7F52E9 8C 03 E8                   cpd  #$03E8        ; Decimal 1000 (100.0%)                                    (WUE_ASE_CALCS)
0052EC 7F52EC 27 02                      beq  WUEdone       ; If "WUEcor" has been reduced to 100.0 %, branch to WUEdone: (WUE_ASE_CALCS)
0052EE 7F52EE 20 04                      bra  WUEandASEdone ; Branch to WUEandASEdone:                                 (WUE_ASE_CALCS)
0052F0 7F52F0                         WUEdone:                                                                         (WUE_ASE_CALCS)
0052F0 7F52F0 1D 10 E1 10                bclr engine,WUEon  ; Clear "WUEon" bit of "engine" bit field                  (WUE_ASE_CALCS)
0052F4 7F52F4                         WUEandASEdone:        ; Finished with WUE and ASE                                (WUE_ASE_CALCS)
0052F4 7F52F4                         NO_WUE_ASE:
                                      ;*****************************************************************************************
                                      ; - When the engine is running and the throttle is opened quickly a richer mixture is
                                      ;   required for a short period of time. This additional pulse width time is called
                                      ;   Throttle Opening Enrichment. Conversly, when the engine is in over run
                                      ;   conditions no fuel is required so the injectors can be turned off, subject to
                                      ;   permissives. This condtion is call Overrun Fuel Cut.
                                      ;*****************************************************************************************
                                      ; - Determine if we are in steady state, TOE mode or OFC mode and do the calculations
                                      ;   accordingly.
                                      ;*****************************************************************************************
                                      ;    TOE_OFC_CALCS       ; Macro in injcalcsBPEM.s ; macro call moved to state BPEM488
                                      ;*****************************************************************************************
                                      ; - Calculate injector pulse width for a running engine "PW" (mS x 10)
                                      ;*****************************************************************************************
                                      ;    RUN_PW_CALCS       ; Macro in injcalcsBPEM.s  ; macro call moved to state BPEM488
                                      ;*****************************************************************************************
                                      ; - Calculate fuel burn Litres per Hour ("LpH"), Kilometers per Litre ("KmpL") and
                                      ;   Miles per Gallon Imperial ("MpG")
                                      ;*****************************************************************************************
0052F4 7F52F4 MACRO                       FUEL_BURN_CALCS       ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (FUEL_BURN_CALCS)
                                      ; - Look up the injector flow rate for 2 injectors (CC/Min)                                                                            * (FUEL_BURN_CALCS)
                                      ;***************************************************************************************** (FUEL_BURN_CALCS)
0052F4 7F52F4 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (FUEL_BURN_CALCS)
0052F9 7F52F9 CD 08 00                    ldy   #veBins_E   ; Load index register Y with address of first configurable (FUEL_BURN_CALCS)
                                                            ; constant on buffer RAM page 1 (veBins_E)                 (FUEL_BURN_CALCS)
0052FC 7F52FC EE EA 03 F0                 ldx   $03F0,Y     ; Load Accu X with value in buffer RAM page 1 (offset 1008)($03F0) (FUEL_BURN_CALCS)
                                                            ; ("InjPrFlo_F")                                           (FUEL_BURN_CALCS)
005300 7F5300 B7 56                       tfr  X,Y          ; "InjPrFlo_F"-> Accu Y                                    (FUEL_BURN_CALCS)
                                      ;***************************************************************************************** (FUEL_BURN_CALCS)
                                      ; - Calculate current fuel burn in Litres per Hour: (Injector open time over 1 second (FUEL_BURN_CALCS)
                                      ;   x 60 = Injector open time for 1 minute. Injector open time for 1 minute x injector (FUEL_BURN_CALCS)
                                      ;   flow rate per minute = injector flow for 1 minute. Injector flow for 1 minute x 60 (FUEL_BURN_CALCS)
                                      ;   = injector flow per hour. For integer math:                                  (FUEL_BURN_CALCS)
                                      ;    ((("FDsec"/10)*6)*InjPrFlo_F)/10,000= "LpH"(Litres per hour x 10)           (FUEL_BURN_CALCS)
                                      ;***************************************************************************************** (FUEL_BURN_CALCS)
005302 7F5302 FC 10 CC                    ldd  FDsec       ; "FDsec"->Accu D (Fuel delivery pulse width total for 1 Sec (mS*10) (FUEL_BURN_CALCS)
005305 7F5305 CE 00 0A                    ldx  #$000A      ; Decimal 10 -> Accu X                                      (FUEL_BURN_CALCS)
005308 7F5308 18 10                       idiv             ;(D)/(X)->Xrem->D "FDsec"/10                                (FUEL_BURN_CALCS)
00530A 7F530A B7 54                       tfr  X,D         ; Result-> Accu D                                           (FUEL_BURN_CALCS)
00530C 7F530C 13                          emul             ; (D)*(Y)->Y:D ("FDsec"/10)*"InjPrFlo_F"                    (FUEL_BURN_CALCS)
00530D 7F530D CE 27 10                    ldx  #$2710      ; Decimal 10,000-> Accu X                                   (FUEL_BURN_CALCS)
005310 7F5310 11                              ediv             ;(Y:D)/)X)->Y;Rem->D (("FDsec"/10)*"InjPrFlo_F")/10,000="LpH" (FUEL_BURN_CALCS)
005311 7F5311 7D 10 CA                    sty  LpH         ; Copy result to "LpH" (Litres per hour x 10)               (FUEL_BURN_CALCS)
                                      ;***************************************************************************************** (FUEL_BURN_CALCS)
                                      ; - Calculate current fuel burn in Kilometers per Litre                          (FUEL_BURN_CALCS)
                                      ;***************************************************************************************** (FUEL_BURN_CALCS)
005314 7F5314 FC 10 A2                    ldd  KPH         ; "KPH" -> Accu D                                           (FUEL_BURN_CALCS)
005317 7F5317 CD 00 0A                    ldy  #$000A      ; Decimal 10 -> Accy Y                                      (FUEL_BURN_CALCS)
00531A 7F531A 13                          emul             ; (D)*(Y)->Y:D "KPH"*10                                     (FUEL_BURN_CALCS)
00531B 7F531B FE 10 CA                    ldx  LpH         ; "LpH"-> Accu X                                            (FUEL_BURN_CALCS)
00531E 7F531E 11                              ediv             ;(Y:D)/)X)->Y;Rem->D ("KPH"*10)/LpH = KmpL              (FUEL_BURN_CALCS)
00531F 7F531F 7D 10 D4                    sty  KmpL        ; Result -> "KmpL"                                          (FUEL_BURN_CALCS)
                                      ;***************************************************************************************** (FUEL_BURN_CALCS)
                                      ; - Convert fuel burn in Kilometers per Litre to Miles per Gallon Imperial       (FUEL_BURN_CALCS)
                                      ;***************************************************************************************** (FUEL_BURN_CALCS)
005322 7F5322 FC 10 D4                    ldd  KmpL        ; "KmpL" -> Accu D                                          (FUEL_BURN_CALCS)
005325 7F5325 CD 00 64                    ldy  #$0064      ; Decimal 100 -> Accy Y                                     (FUEL_BURN_CALCS)
005328 7F5328 13                          emul             ; (D)*(Y)->Y:D "KmpL"*100                                   (FUEL_BURN_CALCS)
005329 7F5329 B7 46                       tfr  D,Y         ; Result Lo word-> Accu Y                                   (FUEL_BURN_CALCS)
00532B 7F532B CC 01 1A                    ldd  #$011A      ; Decimal 282-> Accu D (2.82 is conversion factor)          (FUEL_BURN_CALCS)
00532E 7F532E 13                          emul             ; (D)*(Y)->Y:D ("KmpL"*100)*282                             (FUEL_BURN_CALCS)
00532F 7F532F CE 27 00                    ldx  #$2700      ; Decimal 10,000 -> Accu X                                  (FUEL_BURN_CALCS)
005332 7F5332 11                              ediv             ;(Y:D)/)X)->Y;Rem->D (("KmpL"*100)*282)/10,000= "MpG"   (FUEL_BURN_CALCS)
005333 7F5333 7D 10 EA                    sty   MpG        ; Result -> "MpG"                                           (FUEL_BURN_CALCS)
                                      ;*****************************************************************************************
                                      ; ----------------------- End Of Injector Calculations Section ---------------------------
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Increment "LoopCntr" (counter for "LoopTime")
                                      ;*****************************************************************************************
005336 7F5336                         MainLoopEnd:
005336 7F5336 18 72 10 EF                     incw LoopCntr  ; Increment "LoopCntr"(counter for "LoopTime")
00533A 7F533A 06 4A A4                    job  MainLoop  ; Jump or branch to "MainLoop" (end of main loop, start again)
                                      ;*****************************************************************************************
                                      ; --------------------------------- End of Main Loop -------------------------------------
                                      ;*****************************************************************************************
00533D 7F533D -> $533D                BPEM488_CODE_END                EQU     *     ; * Represents the current value of the paged
                                                                        ; program counter
00533D 7F533D -> $7F533D              BPEM488_CODE_END_LIN    EQU     @     ; @ Represents the current value of the linear
                                                                        ; program counter
                                      ;*****************************************************************************************
                                      ;* - Tables -                                                                            *
                                      ;*****************************************************************************************
00719A 7F719A                                                 ORG     BPEM488_TABS_START, BPEM488_TABS_START_LIN
00719A 7F719A -> $7F719A              BPEM488_TABS_START_LIN  EQU     @     ; @ Represents the current value of the linear
                                                                        ; program counter
                                      ;*********************************************************************
                                      ; Page 1 copied into RAM on start up. All pages 1024 bytes
                                      ; VE table, ranges and other configurable constants
                                      ; veBins values are %x10, verpmBins values are RPM, vemapBins values
                                      ; are KPAx10
                                      ;*********************************************************************
00719A 7F719A                         veBins_F:         ; (% X 10) (648 bytes)(offset = 0)
                                             ;ROW------------>
00719A 7F719A 01 E0 01 E0 01 E0 01 E0     dw $1E0,$1E0,$1E0,$1E0,$1D6,$1CC,$1CC,$1C2,$1B8,$1B8,$1C2,$1E0,$1FE,$208,$21C,$21C,$21C,$21C ; C
              01 D6 01 CC 01 CC 01 C2 
              01 B8 01 B8 01 C2 01 E0 
              01 FE 02 08 02 1C 02 1C 
              02 1C 02 1C             
                                      ;       480, 480, 480, 480, 470, 460, 460, 450, 440, 440, 450, 480, 510, 520, 540, 540, 540, 540 ; O
0071BE 7F71BE 01 E0 01 E0 01 E0 01 E0     dw $1E0,$1E0,$1E0,$1E0,$1D6,$1CC,$1CC,$1C2,$1B8,$1B8,$1C2,$1E0,$1FE,$208,$21C,$21C,$21C,$21C ; L
              01 D6 01 CC 01 CC 01 C2 
              01 B8 01 B8 01 C2 01 E0 
              01 FE 02 08 02 1C 02 1C 
              02 1C 02 1C             
                                      ;       480, 480, 480, 480, 470, 460, 460, 450, 440, 440, 450, 480, 510, 520, 540, 540, 540, 540 ; |
0071E2 7F71E2 01 E0 01 E0 01 E0 01 E0     dw $1E0,$1E0,$1E0,$1E0,$1D6,$1CC,$1CC,$1C2,$1B8,$1B8,$1C2,$1E0,$1FE,$208,$21C,$21C,$21C,$21C ; |
              01 D6 01 CC 01 CC 01 C2 
              01 B8 01 B8 01 C2 01 E0 
              01 FE 02 08 02 1C 02 1C 
              02 1C 02 1C             
                                      ;       480, 480, 480, 480, 470, 460, 460, 450, 440, 440, 450, 480, 510, 520, 540, 540, 540, 540 ; |
007206 7F7206 01 E0 01 E0 01 E0 01 E0     dw $1E0,$1E0,$1E0,$1E0,$1D6,$1CC,$1CC,$1C2,$1B8,$1B8,$1C2,$1E0,$1FE,$208,$21C,$21C,$21C,$21C ; |
              01 D6 01 CC 01 CC 01 C2 
              01 B8 01 B8 01 C2 01 E0 
              01 FE 02 08 02 1C 02 1C 
              02 1C 02 1C             
                                      ;       480, 480, 480, 480, 470, 460, 460, 450, 440, 440, 450, 480, 510, 520, 540, 540, 540, 540 ; |
00722A 7F722A 01 F4 01 F4 01 F4 01 F4     dw $1F4,$1F4,$1F4,$1F4,$1F4,$1F4,$1F4,$1F4,$212,$21C,$226,$230,$23A,$23A,$244,$244,$244,$244 ; |
              01 F4 01 F4 01 F4 01 F4 
              02 12 02 1C 02 26 02 30 
              02 3A 02 3A 02 44 02 44 
              02 44 02 44             
                                      ;       500, 500, 500, 500, 500, 500, 500, 500, 530, 540, 550, 560, 570, 570, 580, 580, 580, 580 ; |
00724E 7F724E 02 12 02 12 02 12 02 12     dw $212,$212,$212,$212,$1F4,$1F4,$1FE,$212,$21C,$21C,$23A,$244,$24E,$258,$262,$262,$262,$262 ; V
              01 F4 01 F4 01 FE 02 12 
              02 1C 02 1C 02 3A 02 44 
              02 4E 02 58 02 62 02 62 
              02 62 02 62             
                                      ;       530, 530, 530, 530, 500, 500, 510, 530, 540, 540, 570, 580, 590, 600, 610, 610, 610, 610 ;
007272 7F7272 02 12 02 12 02 12 02 12     dw $212,$212,$212,$212,$208,$208,$21C,$226,$230,$230,$23A,$244,$258,$26C,$276,$276,$276,$276 ;
              02 08 02 08 02 1C 02 26 
              02 30 02 30 02 3A 02 44 
              02 58 02 6C 02 76 02 76 
              02 76 02 76             
                                      ;       530, 530, 530, 530, 520, 520, 540, 550, 560, 560, 570, 580, 600, 620, 630, 630, 630, 630 ;
007296 7F7296 02 62 02 62 02 58 02 4E     dw $262,$262,$258,$24E,$21C,$226,$230,$230,$23A,$23A,$24E,$258,$26C,$276,$28A,$28A,$28A,$28A ;
              02 1C 02 26 02 30 02 30 
              02 3A 02 3A 02 4E 02 58 
              02 6C 02 76 02 8A 02 8A 
              02 8A 02 8A             
                                      ;       610, 610, 600, 590, 540, 550, 560, 560, 570, 570, 590, 600, 620, 630, 650, 650, 650, 650 ;
0072BA 7F72BA 02 8A 02 8A 02 80 02 76     dw $28A,$28A,$280,$276,$230,$230,$23A,$258,$258,$258,$258,$26C,$276,$280,$28A,$28A,$28A,$28A ;
              02 30 02 30 02 3A 02 58 
              02 58 02 58 02 58 02 6C 
              02 76 02 80 02 8A 02 8A 
              02 8A 02 8A             
                                      ;       650, 650, 640, 630, 560, 560, 570, 600, 600, 600, 600, 620, 630, 640, 650, 650, 650, 650 ;
0072DE 7F72DE 02 D0 02 D0 02 B2 02 6C     dw $2D0,$2D0,$2B2,$26C,$23A,$23A,$262,$262,$262,$26C,$26C,$276,$280,$28A,$28A,$28A,$28A,$28A ;
              02 3A 02 3A 02 62 02 62 
              02 62 02 6C 02 6C 02 76 
              02 80 02 8A 02 8A 02 8A 
              02 8A 02 8A             
                                      ;       720, 720, 690, 620, 570, 570, 610, 610, 610, 620, 620, 630, 640, 650, 650, 650, 650, 650 ;
007302 7F7302 03 02 03 02 02 BC 02 76     dw $302,$302,$2BC,$276,$24E,$24E,$26C,$26C,$276,$276,$276,$294,$294,$294,$294,$294,$294,$294 ;
              02 4E 02 4E 02 6C 02 6C 
              02 76 02 76 02 76 02 94 
              02 94 02 94 02 94 02 94 
              02 94 02 94             
                                      ;       770, 770, 700, 630, 590, 590, 620, 620, 630, 630, 630, 660, 660, 660, 660, 660, 660, 660 ;
007326 7F7326 03 52 03 52 03 0C 02 C6     dw $352,$352,$30C,$2C6,$28A,$26C,$26C,$26C,$276,$276,$276,$280,$28A,$294,$294,$294,$294,$294 ;
              02 8A 02 6C 02 6C 02 6C 
              02 76 02 76 02 76 02 80 
              02 8A 02 94 02 94 02 94 
              02 94 02 94             
                                      ;       850, 850, 780, 710, 650, 620, 620, 620, 630, 630, 630, 640, 650, 660, 660, 660, 660, 660 ;
00734A 7F734A 03 52 03 52 03 16 02 D0     dw $352,$352,$316,$2D0,$294,$28A,$28A,$28A,$28A,$28A,$28A,$29E,$2B2,$2B2,$2B2,$2B2,$2B2,$2B2 ;
              02 94 02 8A 02 8A 02 8A 
              02 8A 02 8A 02 8A 02 9E 
              02 B2 02 B2 02 B2 02 B2 
              02 B2 02 B2             
                                      ;       850, 850, 790, 720, 660, 650, 650, 650, 650, 650, 650, 670, 690, 690, 690, 690, 690, 690 ;
00736E 7F736E 03 70 03 70 03 20 02 EE     dw $370,$370,$320,$2EE,$2EE,$2E4,$2E4,$2E4,$2EE,$2F8,$302,$370,$352,$352,$352,$352,$352,$352 ;
              02 EE 02 E4 02 E4 02 E4 
              02 EE 02 F8 03 02 03 70 
              03 52 03 52 03 52 03 52 
              03 52 03 52             
                                      ;       880, 880, 800, 750, 750, 740, 740, 740, 750, 760, 770, 800, 850, 850, 850, 850, 850, 850 ;
007392 7F7392 03 84 03 84 03 84 03 84     dw $384,$384,$384,$384,$38E,$398,$3A2,$3AC,$386,$3C0,$3E8,$3F2,$3FC,$406,$410,$410,$410,$410 ;
              03 8E 03 98 03 A2 03 AC 
              03 86 03 C0 03 E8 03 F2 
              03 FC 04 06 04 10 04 10 
              04 10 04 10             
                                      ;       900, 900, 900, 900, 910, 920, 930, 940, 950, 960,1000,1010,1020,1030,1040,1040,1040,1040 ;
0073B6 7F73B6 03 CA 03 CA 03 98 03 98     dw $3CA,$3CA,$398,$398,$398,$3AE,$3AC,$386,$3CA,$3E8,$3F2,$3FC,$406,$410,$410,$410,$410,$410 ;
              03 98 03 AE 03 AC 03 86 
              03 CA 03 E8 03 F2 03 FC 
              04 06 04 10 04 10 04 10 
              04 10 04 10             
                                      ;       970, 970, 920, 920, 920, 930, 940, 950, 970,1000,1010,1020,1030,1040,1040,1040,1040,1040 ;
0073DA 7F73DA 03 CA 03 CA 03 98 03 98     dw $3CA,$3CA,$398,$398,$398,$3AE,$3AC,$386,$3CA,$3E8,$3F2,$3FC,$406,$410,$410,$410,$410,$410 ;
              03 98 03 AE 03 AC 03 86 
              03 CA 03 E8 03 F2 03 FC 
              04 06 04 10 04 10 04 10 
              04 10 04 10             
                                      ;       970, 970, 920, 920, 920, 930, 940, 950, 970,1000,1010,1020,1030,1040,1040,1040,1040,1040 ;
0073FE 7F73FE 03 CA 03 CA 03 98 03 98     dw $3CA,$3CA,$398,$398,$398,$3AE,$3AC,$386,$3CA,$3E8,$3F2,$3FC,$406,$410,$410,$410,$410,$410 ;
              03 98 03 AE 03 AC 03 86 
              03 CA 03 E8 03 F2 03 FC 
              04 06 04 10 04 10 04 10 
              04 10 04 10             
                                      ;       970, 970, 920, 920, 920, 930, 940, 950, 970,1000,1010,1020,1030,1040,1040,1040,1040,1040 ;
007422 7F7422                         verpmBins_F:       ; row bin(36 bytes)(offset = 648)($0288)
007422 7F7422 01 90 02 71 03 52 04 33     dw $190,$271,$352,$433,$514,$5F5,$6D6,$7B7,$898,$979,$A5A,$B3B,$C1C,$CFD,$DDE,$EBF,$FA0,$1081
              05 14 05 F5 06 D6 07 B7 
              08 98 09 79 0A 5A 0B 3B 
              0C 1C 0C FD 0D DE 0E BF 
              0F A0 10 81             
                                      ; RPM   400, 625, 850,1075,1300,1525,1750,1975,2200,2425,2650,2875,3100,3325,3550,3775,4000,4225
007446 7F7446                         vemapBins_F:       ; column bins(36 bytes)(offset = 684)($02AC)
007446 7F7446 00 96 00 C8 00 FA 01 2C     dw $96,$C8,$FA,$12C,$15E,$190,$1C2,$1F4,$226,$258,$28A,$2BC,$2EE,$320,$352,$384,$3B6,$3E8
              01 5E 01 90 01 C2 01 F4 
              02 26 02 58 02 8A 02 BC 
              02 EE 03 20 03 52 03 84 
              03 B6 03 E8             
                                      ;KPAx10 150,200,250,300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950,1000
                                      ; ADC   42, 89,136, 183, 230, 277, 323, 370, 417, 464, 511, 558, 605, 652, 699, 746, 793,840
                                      ; V    .20,.43,.66, .89,1.12,1.35,1.58,1.81,2.04,2.27,2.50,2.73,2.96,3.19,3.42,3.65,3.88,4.11
00746A 7F746A                         barCorVals_F:      ; 18 bytes for barometric correction values (KpA x 10)(offset = 720)($02D0)
00746A 7F746A 03 16 03 34 03 52 03 70     dw $0316,$0334,$0352,$0370,$038E,$03AC,$03CA,$03E8,$0406
              03 8E 03 AC 03 CA 03 E8 
              04 06                   
                                      ;        790,  820,  850,  880,  910,  940,  970, 1000, 1030
00747C 7F747C                         barCorDelta_F:     ; 18 bytes for barometric correction  (% x 10)(offset = 738)($02E2)
00747C 7F747C 04 56 04 47 04 38 04 29     dw $0456,$0447,$0438,$0429,$041A,$040B,$03FC,$03ED,$03DE
              04 1A 04 0B 03 FC 03 ED 
              03 DE                   
                                      ;       1110, 1095, 1080, 1065, 1050, 1035, 1020, 1005, 990
00748E 7F748E                         dwellvolts_F:      ; 12 bytes for dwell battery correction (volts x 10)(offset = 756)($02F4)
00748E 7F748E 00 3C 00 50 00 64 00 78     dw $003C,$0050,$0064,$0078,$008C,$00A0
              00 8C 00 A0             
                                      ;         60,   80,  100,  120,  140,  160
00749A 7F749A                         dwellcorr_F:       ; 12 bytes for dwell battery correction (% x 10)(offset = 768)($0300)
00749A 7F749A 13 88 09 B0 06 90 05 00     dw $1388,$09B0,$0690,$0500,$03FC,$0370
              03 FC 03 70             
                                      ;       5000, 2480, 1680, 1280, 1020,  880
0074A6 7F74A6                         tempTable1_F:      ; 20 bytes for table common temperature values (degrees C or F x 10)(offset = 780)($030C)
0074A6 7F74A6 FE 70 FF FE 00 02 00 C8     dw $FE70,$FFFE,$0002,$00C8,$0190,$0258,$0320,$03E8,$0514,$0708
              01 90 02 58 03 20 03 E8 
              05 14 07 08             
                                      ;       -400,   -2,    2,  200,  400,  600,  800, 1000, 1300, 1800
0074BA 7F74BA                         tempTable2_F:      ; 20 bytes for table common temperature values (degrees C or F x 10)(offset = 800)($0320)
0074BA 7F74BA FF 9C FF FE 00 02 02 16     dw $FF9C,$FFFE,$0002,$0216,$02E9,$03BC,$048F,$0562,$0635,$0708
              02 E9 03 BC 04 8F 05 62 
              06 35 07 08             
                                      ;        -100,  -2,    2,  534,  745, 956, 1167, 1378, 1589, 1800
0074CE 7F74CE                         matCorrTemps2_F:   ; 18 bytes for MAT correction temperature (degrees C or F x 10)(offset = 820)($0334)
0074CE 7F74CE FE 70 FF FE 00 02 02 4E     dw $FE70,$FFFE,$0002,$024E,$035C,$046A,$0578,$0794,$09B0
              03 5C 04 6A 05 78 07 94 
              09 B0                   
                                      ;       -400,   -2,    2,  590,  860, 1130, 1400, 1940, 2480
0074E0 7F74E0                         matCorrDelta2_F:   ; 18 bytes for MAT correction (% x 10)(offset = 838)($0346)
0074E0 7F74E0 04 E9 04 7D 04 7C 03 F9     dw $04E9,$047D,$047C,$03F9,$03C7,$0399,$0370,$0327,$02EA
              03 C7 03 99 03 70 03 27 
              02 EA                   
                                      ;       1257, 1149, 1148, 1017,  967,  921,  880,  807,  746
0074F2 7F74F2                         primePWTable_F:    ; 20 bytes for priming pulse width (msec x 10)(offset = 856)($0358)
0074F2 7F74F2 02 8F 02 82 02 81 02 1D     dw $028F,$0282,$0281,$021D,$01EE,$01AB,$015D,$0121,$00E1,$009E
              01 EE 01 AB 01 5D 01 21 
              00 E1 00 9E             
                                      ;        655,  642,  641,  541,  494,  427,  349,  289,  225,  158
007506 7F7506                         crankPctTable_F:   ; 20 bytes for cranking pulsewidth adder (% x 10 of reqFuel)(offset = 876)($036C)
007506 7F7506 0C B2 0C 3E 0C 3A 09 C4     dw $0CB2,$0C3E,$0C3A,$09C4,$08CA,$07D0,$06D6,$05DC,$04E2,$03E8
              08 CA 07 D0 06 D6 05 DC 
              04 E2 03 E8             
                                      ;       3250, 3134, 3130, 2500, 2250, 2000, 1750, 1500, 1250, 1000
00751A 7F751A                         asePctTable_F:     ; 20 bytes for after start enrichment adder (% x 10)(offset = 896)($0380)
00751A 7F751A 02 08 01 FA 01 FA 01 AE     dw $0208,$01FA,$01FA,$01AE,$0190,$0172,$0154,$0136,$0118,$00FA
              01 90 01 72 01 54 01 36 
              01 18 00 FA             
                                      ;        520,  506,  506,  430,  400,  370,  340,  310,  280,  250
00752E 7F752E                         aseRevTable_F:     ; 20 bytes for after start enrichment time (engine revolutions)(offset = 916)($0394)
00752E 7F752E 01 5E 01 55 01 54 01 22     dw $015E,$0155,$0154,$0122,$010E,$00FA,$00E6,$00D2,$00BE,$00AA
              01 0E 00 FA 00 E6 00 D2 
              00 BE 00 AA             
                                      ;        350,  341,  340,  290,  270,  250,  230,  210,  190,  170
007542 7F7542                         wueBins_F:         ; 20 bytes for after warm up enrichment adder (% x 10)(offset = 936)($03A8)
007542 7F7542 06 40 05 AA 05 AA 05 46     dw $0640,$05AA,$05AA,$0546,$0514,$04E2,$04B0,$047E,$044E,$03E8
              05 14 04 E2 04 B0 04 7E 
              04 4E 03 E8             
                                      ;       1600, 1450, 1450, 1350, 1300, 1250, 1200, 1150, 1100, 1000
007556 7F7556                         TOEbins_F:         ; 8 bytes for Throttle Opening Enrichment adder (%)(offset = 956)($03BC)
007556 7F7556 00 14 00 19 00 1E 00 23     dw $0014,$0019,$001E,$0023
                                      ;         20,   25,   30,   35
00755E 7F755E                         TOErates_F:        ; 8 bytes for Throttle Opening Enrichment rate (TpsPctDOT x 10)(offset = 964)($03C4)
00755E 7F755E 00 32 00 64 00 FA 01 F4     dw $0032,$0064,$00FA,$01F4
                                      ;         50,  100,  250,  500
007566 7F7566                         DdBndBase_F:       ; 2 bytes for injector deadband at 13.2V (mSec * 100)(offset = 972)($03CC)
007566 7F7566 00 5A                       dw $005A       ; 90 = .9mS
007568 7F7568                         DdBndCor_F:        ; 2 bytes for injector deadband voltage correction (mSec/V x 100)(offset = 974)($03CE)
007568 7F7568 00 12                       dw $0012       ; 18 = .18mS/V
00756A 7F756A                         tpsThresh_F:       ; 2 bytes for Throttle Opening Enrichment threshold (%/Sec)(offset = 976)($03D0)
00756A 7F756A 00 2D                       dw $002D       ; 45 = 45% per Sec
00756C 7F756C                         TOEtime_F:         ; 2 bytes for Throttle Opening Enrich time in 100mS increments(mSx10)(offset = 978)($03D2)
00756C 7F756C 00 05                       dw $0005       ; 5 = 0.5 Sec
00756E 7F756E                         ColdAdd_F:         ; 2 bytes for Throttle Opening Enrichment cold temperature adder at -40F (%)(offset = 980)($03D4)
00756E 7F756E 00 14                       dw $0014       ; 20%
007570 7F7570                         ColdMul_F:         ; 2 bytes for Throttle Opening Enrichment multiplyer at -40F (%)(offset = 982)($03D6)
007570 7F7570 00 82                       dw $0082         ; 130%
007572 7F7572                         InjDelDegx10_F:    ; 2 bytes for Injection delay from trigger to start of injection (deg x 10) (offset = 984)($03D8)
007572 7F7572 02 1C                       dw $021C       ; 540 = 54.0 degrees
007574 7F7574                         OFCtps_F:          ; 2 bytes for Overrun Fuel Cut min TpS%x10(offset = 986)($03DA)
007574 7F7574 00 14                       dw $0014       ; 20 = 2%
007576 7F7576                         OFCrpm_F:          ; 2 bytes for Overrun Fuel Cut min RPM(offset = 988)($03DC)
007576 7F7576 03 84                       dw $0384       ; 900
007578 7F7578                         OFCmap_F:          ; 2 bytes for Overrun Fuel Cut maximum manifold pressure permissive (KPAx10)(offset = 990)($03DE)(NOT USED)
007578 7F7578 00 FA                       dw $00FA       ; 250 = 25.0KPA
00757A 7F757A                         OFCdel_F:          ; 2 bytes for Overrun Fuel Cut delay time (Sec x 10)(offset = 992)($03E0)(NOT USED)
00757A 7F757A 00 14                       dw $0014       ; 20 = 2.0Sec
00757C 7F757C                         crankingRPM_F:     ; 2 bytes for crank/run transition (RPM)(offset = 994)($03E2)
00757C 7F757C 01 2C                       dw $012C       ; 300
00757E 7F757E                         floodClear_F:      ; 2 bytes for TPS position for flood clear (% x 10)(offset = 996)($03E4)
00757E 7F757E 03 84                       dw $0384       ; 900
007580 7F7580                         Stallcnt_F:        ; 2 bytes for no crank or stall condition counter (1mS increments) (offset = 998)($03E6)
007580 7F7580 07 D0                       dw $07D0       ; 2000 = 2 seconds
007582 7F7582                         tpsMin_F:          ; 2 bytes for TPS calibration closed throttle ADC(offset = 1000)($03E8)
007582 7F7582 00 7D                       dw $007D       ; 125 test engine, 147 Morgan
007584 7F7584                         tpsMax_F:          ; 2 bytes for TPS calibration wide open throttle ADC(offset = 1002)($03EA)
007584 7F7584 02 DD                       dw $02DD       ; 733 test engine, 712 Morgan
007586 7F7586                         reqFuel_F:         ; 2 bytes for Pulse width for 14.7 AFR @ 100% VE (mS x 10)(offset = 1004)($03EC)
                                      ;*    dw $0852       ; 2130 = 21.30 mS
                                      ;*    dw $042E       ; 1070 = 10.70 mS
007586 7F7586 00 D5                       dw $00D5       ; 0213 = 21.3 mS
007588 7F7588                         enginesize_F:      ; 2 bytes for displacement of two engine cylinders (for TS reqFuel calcs only)(cc)(offset = 1006)($03EE)
007588 7F7588 06 40                       dw $640        ; 1600
00758A 7F758A                         InjPrFlo_F         ; 2 bytes for Pair of injectors flow rate (CC/Min)(offset = 1008)($03F0)
00758A 7F758A 01 9C                       dw $019C       ; Decimal 412 = 412 CC/Min
00758C 7F758C                         staged_pri_size_F: ; 1 byte for flow rate of 1 injector (for TS reqFuel calcs only)(cc)(offset = 1010)($03F2)
00758C 7F758C FC                          db $FC         ; 252
00758D 7F758D                         alternate_F:       ; 1 byte for injector staging bit field (for TS reqFuel calcs only)(offset = 1011)($03F3)
00758D 7F758D 00                          db $00         ; 0
00758E 7F758E                         nCylinders_F:      ; 1 byte for number of engine cylinders bit field (for TS reqFuel calcs only)(offset = 1012)($03F4)
00758E 7F758E 02                          db $02         ; 2
00758F 7F758F                         nInjectors_F:      ; 1 byte for number of injectors bit field (for TS reqFuel calcs only)(offset = 1013)($03F5)
00758F 7F758F 02                          db $02         ; 2
007590 7F7590                         divider_F:         ; 1 byte for squirts per cycle bit field (for TS reqFuel calcs only)(offset = 1014)($03F6)
007590 7F7590 01                          db $01         ; 1
                                      ; 1015 bytes used, 1024 - 1015 = 9 bytes left
                                      ;*********************************************************************
                                      ; Page 2 copied into RAM on start up. All pages 1024 bytes
                                      ; ST table, ranges and other configurable constants
                                      ; stBins values are degrees x10, strpmBins values are RPM,
                                      ; stmapBins values are KPAx10
                                      ;*********************************************************************
007591 7F7591                         stBins_F:         ; (Degrees X 10)(648 bytes)(offset = 0)
                                             ;ROW------------>
007591 7F7591 00 FA 01 06 01 12 01 1D     dw $00FA,$0106,$0112,$011D,$0129,$0135,$0141,$014D,$0159,$0164,$0170,$017C,$017C,$017C,$017C,$017C,$017C,$017C ; C
              01 29 01 35 01 41 01 4D 
              01 59 01 64 01 70 01 7C 
              01 7C 01 7C 01 7C 01 7C 
              01 7C 01 7C             
                                      ;        250,  262,  274,  285,  297,  309,  321,  333,  345,  356,  368,  380,  380,  380,  380,  380,  380,  380 ; O
0075B5 7F75B5 00 FA 01 06 01 12 01 1D     dw $00FA,$0106,$0112,$011D,$0129,$0135,$0141,$014D,$0159,$0164,$0170,$017C,$017C,$017C,$017C,$017C,$017C,$017C ; L
              01 29 01 35 01 41 01 4D 
              01 59 01 64 01 70 01 7C 
              01 7C 01 7C 01 7C 01 7C 
              01 7C 01 7C             
                                      ;        250,  262,  274,  285,  297,  309,  321,  333,  345,  356,  368,  380,  380,  380,  380,  380,  380,  380 ; |
0075D9 7F75D9 00 FA 01 06 01 12 01 1D     dw $00FA,$0106,$0112,$011D,$0129,$0135,$0141,$014D,$0159,$0164,$0170,$017C,$017C,$017C,$017C,$017C,$017C,$017C ; |
              01 29 01 35 01 41 01 4D 
              01 59 01 64 01 70 01 7C 
              01 7C 01 7C 01 7C 01 7C 
              01 7C 01 7C             
                                      ;        250,  262,  274,  285,  297,  309,  321,  333,  345,  356,  368,  380,  380,  380,  380,  380,  380,  380 ; |
0075FD 7F75FD 00 FA 01 06 01 12 01 1D     dw $00FA,$0106,$0112,$011D,$0129,$0135,$0141,$014D,$0159,$0164,$0170,$017C,$017C,$017C,$017C,$017C,$017C,$017C ; |
              01 29 01 35 01 41 01 4D 
              01 59 01 64 01 70 01 7C 
              01 7C 01 7C 01 7C 01 7C 
              01 7C 01 7C             
                                      ;        250,  262,  274,  285,  297,  309,  321,  333,  345,  356,  368,  380,  380,  380,  380,  380,  380,  380 ; |
007621 7F7621 00 FA 01 06 01 12 01 1D     dw $00FA,$0106,$0112,$011D,$0129,$0135,$0141,$014D,$0159,$0164,$0170,$017C,$017C,$017C,$017C,$017C,$017C,$017C ; |
              01 29 01 35 01 41 01 4D 
              01 59 01 64 01 70 01 7C 
              01 7C 01 7C 01 7C 01 7C 
              01 7C 01 7C             
                                      ;        250,  262,  274,  285,  297,  309,  321,  333,  345,  356,  368,  380,  380,  380,  380,  380,  380,  380 ; |
007645 7F7645 00 FA 01 06 01 12 01 1D     dw $00FA,$0106,$0112,$011D,$0129,$0135,$0141,$014D,$0159,$0164,$0170,$017C,$017C,$017C,$017C,$017C,$017C,$017C ; |
              01 29 01 35 01 41 01 4D 
              01 59 01 64 01 70 01 7C 
              01 7C 01 7C 01 7C 01 7C 
              01 7C 01 7C             
                                      ;        250,  262,  274,  285,  297,  309,  321,  333,  345,  356,  368,  380,  380,  380,  380,  380,  380,  380 ; V
007669 7F7669 00 FA 01 06 01 12 01 1D     dw $00FA,$0106,$0112,$011D,$0129,$0135,$0141,$014D,$0159,$0164,$0170,$017C,$017C,$017C,$017C,$017C,$017C,$017C ;
              01 29 01 35 01 41 01 4D 
              01 59 01 64 01 70 01 7C 
              01 7C 01 7C 01 7C 01 7C 
              01 7C 01 7C             
                                      ;        250,  262,  274,  285,  297,  309,  321,  333,  345,  356,  368,  380,  380,  380,  380,  380,  380,  380 ;
00768D 7F768D 00 FA 01 06 01 12 01 1D     dw $00FA,$0106,$0112,$011D,$0129,$0135,$0141,$014D,$0159,$0164,$0170,$017C,$017C,$017C,$017C,$017C,$017C,$017C ;
              01 29 01 35 01 41 01 4D 
              01 59 01 64 01 70 01 7C 
              01 7C 01 7C 01 7C 01 7C 
              01 7C 01 7C             
                                      ;        250,  262,  274,  285,  297,  309,  321,  333,  345,  356,  368,  380,  380,  380,  380,  380,  380,  380 ;
0076B1 7F76B1 00 EB 00 F7 01 03 01 0E     dw $00EB,$00F7,$0103,$010E,$011A,$0126,$0132,$013E,$014A,$0155,$0161,$016D,$016D,$016D,$016D,$016D,$016D,$016D ;
              01 1A 01 26 01 32 01 3E 
              01 4A 01 55 01 61 01 6D 
              01 6D 01 6D 01 6D 01 6D 
              01 6D 01 6D             
                                      ;        235,  247,  259,  270,  282,  294,  306,  318,  330,  341,  353,  365,  365,  365,  365,  365,  365,  365 ;
0076D5 7F76D5 00 DC 00 E8 00 F4 00 FF     dw $00DC,$00E8,$00F4,$00FF,$010B,$0117,$0123,$012F,$013B,$0146,$0152,$015E,$015E,$015E,$015E,$015E,$015E,$015E ;
              01 0B 01 17 01 23 01 2F 
              01 3B 01 46 01 52 01 5E 
              01 5E 01 5E 01 5E 01 5E 
              01 5E 01 5E             
                                      ;        220,  232,  244,  255,  267,  279,  291,  303,  315,  326,  338,  350,  350,  350,  350,  350,  350,  350 ;
0076F9 7F76F9 00 CD 00 D9 00 E5 00 F0     dw $00CD,$00D9,$00E5,$00F0,$00FC,$0108,$0114,$0120,$012C,$0137,$0143,$014F,$014F,$014F,$014F,$014F,$014F,$014F ;
              00 FC 01 08 01 14 01 20 
              01 2C 01 37 01 43 01 4F 
              01 4F 01 4F 01 4F 01 4F 
              01 4F 01 4F             
                                      ;        205,  217,  229,  240,  252,  264,  276,  288,  300,  311,  323,  335,  335,  335,  335,  335,  335,  335 ;
00771D 7F771D 00 BE 00 CA 00 D6 00 E1     dw $00BE,$00CA,$00D6,$00E1,$00ED,$00F9,$0105,$0111,$011D,$0128,$0134,$0140,$0140,$0140,$0140,$0140,$0140,$0140 ;
              00 ED 00 F9 01 05 01 11 
              01 1D 01 28 01 34 01 40 
              01 40 01 40 01 40 01 40 
              01 40 01 40             
                                      ;        190,  202,  214,  225,  237,  249,  261,  273,  285,  296,  308,  320,  320,  320,  320,  320,  320,  320 ;
007741 7F7741 00 AF 00 BB 00 C7 00 D2     dw $00AF,$00BB,$00C7,$00D2,$00DE,$00EA,$00F6,$0102,$010E,$0119,$0125,$0131,$0131,$0131,$0131,$0131,$0131,$0131 ;
              00 DE 00 EA 00 F6 01 02 
              01 0E 01 19 01 25 01 31 
              01 31 01 31 01 31 01 31 
              01 31 01 31             
                                      ;        175,  187,  199,  210,  222,  234,  246,  258,  270,  281,  293,  305,  305,  305,  305,  305,  305,  305 ;
007765 7F7765 00 A0 00 AC 00 B8 00 C3     dw $00A0,$00AC,$00B8,$00C3,$00CF,$00DB,$00E7,$00F3,$00FF,$010A,$0116,$0122,$0122,$0122,$0122,$0122,$0122,$0122 ;
              00 CF 00 DB 00 E7 00 F3 
              00 FF 01 0A 01 16 01 22 
              01 22 01 22 01 22 01 22 
              01 22 01 22             
                                      ;        160,  172,  184,  195,  207,  219,  231,  243,  255,  266,  278,  290,  290,  290,  290,  290,  290,  290 ;
007789 7F7789 00 91 00 9D 00 A9 00 B4     dw $0091,$009D,$00A9,$00B4,$00C0,$00CC,$00D8,$00E4,$00F0,$00FB,$0107,$0113,$0113,$0113,$0113,$0113,$0113,$0113 ;
              00 C0 00 CC 00 D8 00 E4 
              00 F0 00 FB 01 07 01 13 
              01 13 01 13 01 13 01 13 
              01 13 01 13             
                                      ;        145,  157,  169,  180,  192,  204,  216,  228,  240,  251,  263,  275,  275,  275,  275,  275,  275,  275 ;
0077AD 7F77AD 00 82 00 8E 00 9A 00 A5     dw $0082,$008E,$009A,$00A5,$00B1,$00BD,$00C9,$00D5,$00E1,$00EC,$00F8,$0104,$0104,$0104,$0104,$0104,$0104,$0104 ;
              00 B1 00 BD 00 C9 00 D5 
              00 E1 00 EC 00 F8 01 04 
              01 04 01 04 01 04 01 04 
              01 04 01 04             
                                      ;        130,  142,  154,  165,  177,  189,  201,  213,  225,  236,  248,  260,  260,  260,  260,  260,  260,  260 ;
0077D1 7F77D1 00 73 00 7F 00 8B 00 96     dw $0073,$007F,$008B,$0096,$00A2,$00AE,$00BA,$00C6,$00D2,$00DD,$00E9,$00F5,$00F5,$00F5,$00F5,$00F5,$00F5,$00F5 ;
              00 A2 00 AE 00 BA 00 C6 
              00 D2 00 DD 00 E9 00 F5 
              00 F5 00 F5 00 F5 00 F5 
              00 F5 00 F5             
                                      ;        115,  127,  139,  150,  162,  174,  186,  198,  210,  221,  233,  245,  245,  245,  245,  245,  245,  245 ;
0077F5 7F77F5 00 64 00 70 00 7C 00 87     dw $0064,$0070,$007C,$0087,$0093,$009F,$00AB,$00B7,$00C3,$00CE,$00DA,$00E6,$00E6,$00E6,$00E6,$00E6,$00E6,$00E6 ;
              00 93 00 9F 00 AB 00 B7 
              00 C3 00 CE 00 DA 00 E6 
              00 E6 00 E6 00 E6 00 E6 
              00 E6 00 E6             
                                      ;        100,  112,  124,  135,  147,  159,  171,  183,  195,  206,  218,  230,  230,  230,  230,  230,  230,  230 ;
007819 7F7819                         strpmBins_F:       ; row bins (36 bytes)(offset = 648)($0288)
007819 7F7819 01 90 02 71 03 52 04 33     dw $190,$271,$352,$433,$514,$5F5,$6D6,$7B7,$898,$979,$A5A,$B3B,$C1C,$CFD,$DDE,$EBF,$FA0,$1081
              05 14 05 F5 06 D6 07 B7 
              08 98 09 79 0A 5A 0B 3B 
              0C 1C 0C FD 0D DE 0E BF 
              0F A0 10 81             
                                      ; RPM   400, 625, 850,1075,1300,1525,1750,1975,2200,2425,2650,2875,3100,3325,3550,3775,4000,4225
00783D 7F783D                         stmapBins_F:       ; column bins 936 bytes)(offset = 684)($02AC)
00783D 7F783D 00 96 00 C8 00 FA 01 2C     dw $96,$C8,$FA,$12C,$15E,$190,$1C2,$1F4,$226,$258,$28A,$2BC,$2EE,$320,$352,$384,$3B6,$3E8
              01 5E 01 90 01 C2 01 F4 
              02 26 02 58 02 8A 02 BC 
              02 EE 03 20 03 52 03 84 
              03 B6 03 E8             
                                      ;KPAx10 150,200,250,300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950,1000
                                      ; ADC   42, 89,136, 183, 230, 277, 323, 370, 417, 464, 511, 558, 605, 652, 699, 746, 793,840
                                      ; V    .20,.43,.66, .89,1.12,1.35,1.58,1.81,2.04,2.27,2.50,2.73,2.96,3.19,3.42,3.65,3.88,4.11
007861 7F7861                         heton_F:      ; 2 bytes for High engine temperature alarm on set point (degF*10)(offset = 720)($02D0)
007861 7F7861 08 66                       dw $0866  ; Decimal 2150 = 215 degF
007863 7F7863                         hetoff_F:     ; 2 bytes for High engine temperature alarm off set point (degF*10)(offset = 722)($02D2)
007863 7F7863 08 34                       dw $0834  ; Decimal 2100 = 210 degF
007865 7F7865                         hoton_F:      ; 2 bytes for High oil temperature alarm on set point (degF*10)(offset = 724)($02D4)
007865 7F7865 08 FC                       dw $08FC  ; Decimal 2300 = 230 degF
007867 7F7867                         hotoff_F:     ; 2 bytes for High oil temperature alarm off set point (degF*10)(offset = 726)($02D6)
007867 7F7867 08 98                       dw $0898  ; Decimal 2200 = 220 degF
007869 7F7869                         hfton_F:      ; 2 bytes for High fuel temperature alarm on set point (degF*10)(offset = 728)($02D8)
007869 7F7869 08 66                       dw $0866  ; Decimal 2150 = 215 degF
00786B 7F786B                         hftoff_F:     ; 2 bytes for High fuel temperature alarm off set point (degF*10)(offset = 730)($02DA)
00786B 7F786B 08 34                       dw $0834  ; Decimal 2100 = 210 degF
00786D 7F786D                         hegton_F:      ; 2 bytes for High exhaust gas temperature alarm on set point (degF)(offset = 732)($02DC)
00786D 7F786D 04 B0                       dw $04B0   ; Decimal 1200 = 1200 degF
00786F 7F786F                         hegtoff_F:     ; 2 bytes for High exhaust gas temperature alarm off set point (deg)(offset = 734)($02DE)
00786F 7F786F 04 4C                       dw $044C   ; Decimal 1100 = 1100 degF
007871 7F7871                         lopon_F:      ; 2 bytes for Low engine oil pressure alarm on set point (psi*10)(offset = 736)($02E0)
007871 7F7871 00 64                       dw $0064  ; Decimal 100 = 10PSI
007873 7F7873                         lopoff_F:     ; 2 bytes for Low oil engine pressure alarm off set point (psi*10)(offset = 738)($02E2)
007873 7F7873 00 96                       dw $0096  ; Decimal 150 = 15PSI
007875 7F7875                         hfpon_F:      ; 2 bytes for High fuel pressure alarm on set point (psi*10)(offset = 740)($02E4)
007875 7F7875 02 26                       dw $0226  ; Decimal 550 = 55PSI
007877 7F7877                         hfpoff_F:     ; 2 bytes for High fuel pressure alarm off set point (psi*10)(offset = 742)($02E6)
007877 7F7877 01 F4                       dw $01F4  ; Decimal 500 = 50PSI
007879 7F7879                         lfpon_F:      ; 2 bytes for Low fuel pressure alarm on set point (psi*10)(offset = 744)($02E8)
007879 7F7879 01 5E                       dw $015E  ; Decimal 350 = 35PSI
00787B 7F787B                         lfpoff_F:     ; 2 bytes for Low fuel pressure alarm off set point (psi*10)(offset = 746)($02EA)
00787B 7F787B 01 90                       dw $0190  ; Decimal 400 = 40PSI
00787D 7F787D                         Dwell_F       ; 2 bytes for run mode dwell time (mSec*10)(offset = 748)($02EC)
00787D 7F787D 00 28                      dw $0028   ; 40 = 4.0mSec
00787F 7F787F                         CrnkDwell_F   ; 2 bytes for crank mode dwell time (mSec*10)(offset = 750)($02EE)
00787F 7F787F 00 3C                      dw $003C   ; 60 = 6.0 mSec
007881 7F7881                         CrnkAdv_F     ; 2 bytes for crank mode ignition advance (Deg*10)(offset = 752)($02F0)
007881 7F7881 00 64                      dw $0064   ; 100 = 10.0 degrees
                                      ; 752 + 2 = 754 bytes used, 1024 - 754 = 270 bytes left
                                      ;*********************************************************************
                                      ; Page 3 copied into RAM on start up. All pages 1024 bytes
                                      ; AFR table, ranges and other configurable constants
                                      ; afrBins values are Air Fuel Ratio x10, afrrpmBins values are RPM,
                                      ; afrmapBins values are KPAx10
                                      ;*********************************************************************
007883 7F7883                         afrBins_F:         ; (AFR X 100) (648 bytes)(offset = 0)
                                             ;ROW------------>
007883 7F7883 05 14 05 78 05 78 05 78     dw  $514, $578, $578, $578, $640, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4 ; C
              06 40 06 A4 06 A4 06 A4 
              06 A4 06 A4 06 A4 06 A4 
              06 A4 06 A4 06 A4 06 A4 
              06 A4 06 A4             
                                      ;       1300, 1400, 1400, 1400, 1600, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700 ; O
0078A7 7F78A7 05 14 05 78 05 78 05 78     dw  $514, $578, $578, $578, $640, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4 ; L
              06 40 06 A4 06 A4 06 A4 
              06 A4 06 A4 06 A4 06 A4 
              06 A4 06 A4 06 A4 06 A4 
              06 A4 06 A4             
                                      ;       1300, 1400, 1400, 1400, 1600, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700 ; |
0078CB 7F78CB 05 14 05 78 05 78 05 78     dw  $514, $578, $578, $578, $640, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4 ; |
              06 40 06 A4 06 A4 06 A4 
              06 A4 06 A4 06 A4 06 A4 
              06 A4 06 A4 06 A4 06 A4 
              06 A4 06 A4             
                                      ;       1300, 1400, 1400, 1400, 1600, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700 ; |
0078EF 7F78EF 05 14 05 78 05 78 05 78     dw  $514, $578, $578, $578, $640, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4, $6A4; |
              06 40 06 A4 06 A4 06 A4 
              06 A4 06 A4 06 A4 06 A4 
              06 A4 06 A4 06 A4 06 A4 
              06 A4 06 A4             
                                      ;       1300, 1400, 1400, 1400, 1600, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700 ; |
007913 7F7913 05 14 05 78 05 78 05 78     dw  $514, $578, $578, $578, $6A4, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708 ; |
              06 A4 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08             
                                      ;       1300, 1400, 1400, 1400, 1700, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800 ; |
007937 7F7937 05 14 05 78 05 78 05 DC     dw  $514, $578, $578, $5DC, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708 ; V
              07 08 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08             
                                      ;       1300, 1400, 1400, 1500, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800 ;
00795B 7F795B 05 14 05 78 05 78 06 40     dw  $514, $578, $578, $640, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708 ;
              07 08 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08             
                                      ;       1300, 1400, 1400, 1600, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800 ;
00797F 7F797F 05 14 05 78 05 78 06 40     dw  $514, $578, $578, $640, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708 ;
              07 08 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08             
                                      ;       1300, 1400, 1400, 1600, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800 ;
0079A3 7F79A3 05 14 05 78 05 78 06 40     dw  $514, $578, $578, $640, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708 ;
              07 08 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08             
                                      ;       1300, 1400, 1400, 1600, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800 ;
0079C7 7F79C7 05 14 05 78 05 78 06 40     dw  $514, $578, $578, $640, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708 ;
              07 08 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08             
                                      ;       1300, 1400, 1400, 1640, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800 ;
0079EB 7F79EB 05 14 05 78 05 78 06 40     dw  $514, $578, $578, $640, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708 ;
              07 08 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08             
                                      ;       1300, 1400, 1400, 1600, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800 ;
007A0F 7F7A0F 05 14 05 78 05 78 06 40     dw  $514, $578, $578, $640, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708 ;
              07 08 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08             
                                      ;       1300, 1400, 1400, 1600, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800 ;
007A33 7F7A33 05 14 05 14 05 14 06 40     dw  $514, $514, $514, $640, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708, $708 ;
              07 08 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08 07 08 07 08 
              07 08 07 08             
                                      ;       1300, 1300, 1300, 1600, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800 ;
007A57 7F7A57 05 14 05 14 05 14 05 DC     dw  $514, $514, $514, $5DC, $640, $640, $640, $640, $640, $640, $640, $640, $640, $640, $640, $640, $640, $640 ;
              06 40 06 40 06 40 06 40 
              06 40 06 40 06 40 06 40 
              06 40 06 40 06 40 06 40 
              06 40 06 40             
                                      ;       1300, 1300, 1300, 1500, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600 ;
007A7B 7F7A7B 05 14 05 14 05 14 05 14     dw  $514, $514, $514, $514, $514, $514, $514, $514, $514, $514, $514, $514, $514, $514, $50A, $50A, $50A, $500 ;
              05 14 05 14 05 14 05 14 
              05 14 05 14 05 14 05 14 
              05 14 05 14 05 0A 05 0A 
              05 0A 05 00             
                                      ;       1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1290, 1290, 1290, 1280 ;
007A9F 7F7A9F 05 14 05 14 05 14 05 14     dw  $514, $514, $514, $514, $514, $514, $514, $50A, $50A, $50A, $500, $500, $500, $4F6, $4F6, $4F6, $4EC, $4EC ;
              05 14 05 14 05 14 05 0A 
              05 0A 05 0A 05 00 05 00 
              05 00 04 F6 04 F6 04 F6 
              04 EC 04 EC             
                                      ;       1300, 1300, 1300, 1300, 1300, 1300, 1300, 1290, 1290, 1290, 1280, 1280, 1280, 1270, 1270, 1270, 1260, 1260 ;
007AC3 7F7AC3 05 14 05 14 05 14 05 14     dw  $514, $514, $514, $514, $50A, $50A, $50A, $500, $500, $500, $4F6, $4F6, $4F6, $4EC, $4EC, $4EC, $4E2, $4E2 ;
              05 0A 05 0A 05 0A 05 00 
              05 00 05 00 04 F6 04 F6 
              04 F6 04 EC 04 EC 04 EC 
              04 E2 04 E2             
                                      ;       1300, 1300, 1300, 1300, 1290, 1290, 1290, 1280, 1280, 1280, 1270, 1270, 1270, 1260, 1260, 1260, 1250, 1250 ;
007AE7 7F7AE7 05 14 05 14 05 14 05 14     dw  $514, $514, $514, $514, $50A, $50A, $50A, $500, $500, $500, $4F6, $4F6, $4F6, $4EC, $4EC, $4EC, $4E2, $4E2 ;
              05 0A 05 0A 05 0A 05 00 
              05 00 05 00 04 F6 04 F6 
              04 F6 04 EC 04 EC 04 EC 
              04 E2 04 E2             
                                      ;       1300, 1300, 1300, 1300, 1290, 1290, 1290, 1280, 1280, 1280, 1270, 1270, 1270, 1260, 1260, 1260, 1250, 1250 ;
007B0B 7F7B0B                         afrrpmBins_F:       ; row bins (36 bytes)(offset = 648)($0288)
007B0B 7F7B0B 01 90 02 71 03 52 04 33     dw $190,$271,$352,$433,$514,$5F5,$6D6,$7B7,$898,$979,$A5A,$B3B,$C1C,$CFD,$DDE,$EBF,$FA0,$1081
              05 14 05 F5 06 D6 07 B7 
              08 98 09 79 0A 5A 0B 3B 
              0C 1C 0C FD 0D DE 0E BF 
              0F A0 10 81             
                                      ; RPM   400, 625, 850,1075,1300,1525,1750,1975,2200,2425,2650,2875,3100,3325,3550,3775,4000,4225
007B2F 7F7B2F                         afrmapBins_F:       ; column bins (36 bytes)(offset = 684)($02AC)
007B2F 7F7B2F 00 96 00 C8 00 FA 01 2C     dw $96,$C8,$FA,$12C,$15E,$190,$1C2,$1F4,$226,$258,$28A,$2BC,$2EE,$320,$352,$384,$3B6,$3E8
              01 5E 01 90 01 C2 01 F4 
              02 26 02 58 02 8A 02 BC 
              02 EE 03 20 03 52 03 84 
              03 B6 03 E8             
                                      ;KPAx10 150,200,250,300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950,1000
                                      ; ADC   42, 89,136, 183, 230, 277, 323, 370, 417, 464, 511, 558, 605, 652, 699, 746, 793,840
                                      ; V    .20,.43,.66, .89,1.12,1.35,1.58,1.81,2.04,2.27,2.50,2.73,2.96,3.19,3.42,3.65,3.88,4.11
                                      ; 720 bytes used, 1024 - 720 = 304 bytes left
007B53 7F7B53 -> $7B53                BPEM488_TABS_END                EQU     *     ; * Represents the current value of the paged
                                                                        ; program counter
007B53 7F7B53 -> $7F7B53              BPEM488_TABS_END_LIN    EQU     @     ; @ Represents the current value of the linear
                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (base_BPEM488.s)                                                           *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BPEM488 Engine Controller for the Dodge 488CID (8.0L) V10 engine  *
                                      ;*    by Robert Hiebert.                                                                 *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teaching    *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*    This module bundles all the BPEM488 engine controller modules into one             *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project (This module)            *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map                                       *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project               *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map                                         *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features                     *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler              *
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications                  *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)                                     *
                                      ;*   gpio_BPEM488.s       - Initialization all ports                                     *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros                         *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing                              *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths                       *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors                   *
                                      ;*****************************************************************************************
                                      ;* Version History:                                                                      *
                                      ;*    May 25 2020                                                                        *
                                      ;*    - BPEM488 dedicated hardware version begins (work in progress)                     *
                                      ;*    - Update December 10 2020                                                          *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
007B53 7F7B53 S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ;*****************************************************************************************
                                      ;* - Variables -                                                                         *
                                      ;*****************************************************************************************
001000 0FD000                                                 ORG     BASE_VARS_START, BASE_VARS_START_LIN
001000 0FD000 -> $1000                VECTAB_VARS_START           EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
001000 0FD000 -> $FD000               VECTAB_VARS_START_LIN   EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
001002 0FD002                                                 ORG     VECTAB_VARS_END, VECTAB_VARS_END_LIN
001002 0FD002 -> $1002                EEEM_VARS_START         EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
001002 0FD002 -> $FD002               EEEM_VARS_START_LIN         EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
001002 0FD002                                                 ORG     EEEM_VARS_END, EEEM_VARS_END_LIN
001002 0FD002 -> $1002                CLOCK_VARS_START                    EQU *     ; * Represents the current value of the paged
                                                                            ; program counter
001002 0FD002 -> $FD002               CLOCK_VARS_START_LIN        EQU @     ; @ Represents the current value of the linear
                                                                            ; program counter
001002 0FD002                                                 ORG     CLOCK_VARS_END, CLOCK_VARS_END_LIN
001002 0FD002 -> $1002                RTI_VARS_START              EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
001002 0FD002 -> $FD002               RTI_VARS_START_LIN          EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
001006 0FD006                                                 ORG     RTI_VARS_END, RTI_VARS_END_LIN
001006 0FD006 -> $1006                SCI0_VARS_START         EQU     *     ; * Represents the current value of the paged
                                                                        ; program counter
001006 0FD006 -> $FD006               SCI0_VARS_START_LIN         EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
001012 0FD012                                                 ORG     SCI0_VARS_END, SCI0_VARS_END_LIN
001012 0FD012 -> $1012                ADC0_VARS_START         EQU     *     ; * Represents the current value of the paged
                                                                        ; program counter
001012 0FD012 -> $FD012               ADC0_VARS_START_LIN         EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
001012 0FD012                                                 ORG     ADC0_VARS_END, ADC0_VARS_END_LIN
001012 0FD012 -> $1012                GPIO_VARS_START             EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
001012 0FD012 -> $FD012               GPIO_VARS_START_LIN         EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
001012 0FD012                                                 ORG     GPIO_VARS_END, GPIO_VARS_END_LIN
001012 0FD012 -> $1012                ECT_VARS_START              EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
001012 0FD012 -> $FD012               ECT_VARS_START_LIN          EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
001014 0FD014                                                 ORG     ECT_VARS_END, ECT_VARS_END_LIN
001014 0FD014 -> $1014                TIM_VARS_START              EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
001014 0FD014 -> $FD014               TIM_VARS_START_LIN          EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
001014 0FD014                                                 ORG     TIM_VARS_END, TIM_VARS_END_LIN
001014 0FD014 -> $1014                STATE_VARS_START            EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
001014 0FD014 -> $FD014               STATE_VARS_START_LIN    EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
001025 0FD025                                                 ORG     STATE_VARS_END, STATE_VARS_END_LIN
001025 0FD025 -> $1025                INTERP_VARS_START           EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
001025 0FD025 -> $FD025               INTERP_VARS_START_LIN   EQU     @     ; @ Represents the current value of the linear
                                                                        ; program counter
001037 0FD037                                                 ORG     INTERP_VARS_END, INTERP_VARS_END_LIN
001037 0FD037 -> $1037                IGNCALCS_VARS_START             EQU * ; * Represents the current value of the paged
                                                                        ; program counter
001037 0FD037 -> $FD037               IGNCALCS_VARS_START_LIN     EQU @ ; @ Represents the current value of the linear
                                                                        ; program counter
001045 0FD045                                                 ORG     IGNCALCS_VARS_END, IGNCALCS_VARS_END_LIN
001045 0FD045 -> $1045                INJCALCS_VARS_START             EQU * ; * Represents the current value of the paged
                                                                        ; program counter
001045 0FD045 -> $FD045               INJCALCS_VARS_START_LIN     EQU @ ; @ Represents the current value of the linear
                                                                        ; program counter
001064 0FD064                                                 ORG     INJCALCS_VARS_END, INJCALCS_VARS_END_LIN
001064 0FD064 -> $1064                DODGETHERM_VARS_START       EQU *     ; * Represents the current value of the paged
                                                                            ; program counter
001064 0FD064 -> $FD064               DODGETHERM_VARS_START_LIN       EQU @     ; @ Represents the current value of the linear
                                                                            ; program counter
001064 0FD064                                                 ORG     DODGETHERM_VARS_END, DODGETHERM_VARS_END_LIN
001064 0FD064 -> $1064                BASE_VARS_END               EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
001064 0FD064 -> $FD064               BASE_VARS_END_LIN           EQU @     ; @ Represents the current value of the linear
                                                            ; program counter
                                      ;*****************************************************************************************
                                      ;* - Code -                                                                              *
                                      ;*****************************************************************************************
00533D 7F533D                                                 ORG     BASE_CODE_START, BASE_CODE_START_LIN
00533D 7F533D -> $533D                VECTAB_CODE_START           EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
00533D 7F533D -> $7F533D              VECTAB_CODE_START_LIN   EQU     @     ; @ Represents the current value of the linear
                                                                        ; program counter
00561F 7F561F                                                 ORG     VECTAB_CODE_END, VECTAB_CODE_END_LIN
00561F 7F561F -> $561F                EEEM_CODE_START     EQU *     ; * Represents the current value of the paged
                                                                    ; program counter
00561F 7F561F -> $7F561F              EEEM_CODE_START_LIN     EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
00561F 7F561F                                                 ORG     EEEM_CODE_END, EEEM_CODE_END_LIN
00561F 7F561F -> $561F                CLOCK_CODE_START            EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
00561F 7F561F -> $7F561F              CLOCK_CODE_START_LIN    EQU     @     ; @ Represents the current value of the linear
                                                                        ; program counter
00561F 7F561F                                                 ORG     CLOCK_CODE_END, CLOCK_CODE_END_LIN
00561F 7F561F -> $561F                RTI_CODE_START              EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
00561F 7F561F -> $7F561F              RTI_CODE_START_LIN          EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
005681 7F5681                                                 ORG     RTI_CODE_END, RTI_CODE_END_LIN
005681 7F5681 -> $5681                SCI0_CODE_START         EQU     *     ; * Represents the current value of the paged
                                                                        ; program counter
005681 7F5681 -> $7F5681              SCI0_CODE_START_LIN         EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
005989 7F5989                                                 ORG     SCI0_CODE_END, SCI0_CODE_END_LIN
005989 7F5989 -> $5989                ADC0_CODE_START         EQU     *     ; * Represents the current value of the paged
                                                                        ; program counter
005989 7F5989 -> $7F5989              ADC0_CODE_START_LIN         EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
005989 7F5989                                                 ORG     ADC0_CODE_END, ADC0_CODE_END_LIN
005989 7F5989 -> $5989                GPIO_CODE_START     EQU *     ; * Represents the current value of the paged
                                                                    ; program counter
005989 7F5989 -> $7F5989              GPIO_CODE_START_LIN     EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
005989 7F5989                                                 ORG     GPIO_CODE_END, GPIO_CODE_END_LIN
005989 7F5989 -> $5989                ECT_CODE_START              EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
005989 7F5989 -> $7F5989              ECT_CODE_START_LIN          EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
0059F0 7F59F0                                                 ORG     ECT_CODE_END, ECT_CODE_END_LIN
0059F0 7F59F0 -> $59F0                TIM_CODE_START              EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
0059F0 7F59F0 -> $7F59F0              TIM_CODE_START_LIN          EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
005A4A 7F5A4A                                                 ORG     TIM_CODE_END, TIM_CODE_END_LIN
005A4A 7F5A4A -> $5A4A                STATE_CODE_START            EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
005A4A 7F5A4A -> $7F5A4A              STATE_CODE_START_LIN    EQU     @     ; @ Represents the current value of the linear
                                                                        ; program counter
006E77 7F6E77                                                 ORG     STATE_CODE_END, STATE_CODE_END_LIN
006E77 7F6E77 -> $6E77                INTERP_CODE_START           EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
006E77 7F6E77 -> $7F6E77              INTERP_CODE_START_LIN   EQU     @     ; @ Represents the current value of the linear
                                                                        ; program counter
00719A 7F719A                                                 ORG     INTERP_CODE_END, INTERP_CODE_END_LIN
00719A 7F719A -> $719A                IGNCALCS_CODE_START             EQU     * ; * Represents the current value of the paged
                                                                        ; program counter
00719A 7F719A -> $7F719A              IGNCALCS_CODE_START_LIN     EQU @ ; @ Represents the current value of the linear
                                                                        ; program counter
00719A 7F719A                                                 ORG     IGNCALCS_CODE_END, IGNCALCS_CODE_END_LIN
00719A 7F719A -> $719A                INJCALCS_CODE_START             EQU     * ; * Represents the current value of the paged
                                                                        ; program counter
00719A 7F719A -> $7F719A              INJCALCS_CODE_START_LIN     EQU @ ; @ Represents the current value of the linear
                                                                        ; program counter
00719A 7F719A                                                 ORG     INJCALCS_CODE_END, INJCALCS_CODE_END_LIN
00719A 7F719A -> $719A                DODGETHERM_CODE_START       EQU *     ; * Represents the current value of the paged
                                                                            ; program counter
00719A 7F719A -> $7F719A              DODGETHERM_CODE_START_LIN       EQU     @     ; @ Represents the current value of the linear
                                                                            ; program counter
00719A 7F719A                                                 ORG     DODGETHERM_CODE_END, DODGETHERM_CODE_END_LIN
00719A 7F719A -> $719A                BASE_CODE_END               EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
00719A 7F719A -> $7F719A              BASE_CODE_END_LIN           EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
                                      ;*****************************************************************************************
                                      ;* - Tables -                                                                            *
                                      ;*****************************************************************************************
007B53 7F7B53                                                 ORG     BASE_TABS_START, BASE_TABS_START_LIN
007B53 7F7B53 -> $7B53                VECTAB_TABS_START           EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
007B53 7F7B53 -> $7F7B53              VECTAB_TABS_START_LIN   EQU     @     ; @ Represents the current value of the linear
                                                                        ; program counter
007B53 7F7B53                                                 ORG     VECTAB_TABS_END, VECTAB_TABS_END_LIN
007B53 7F7B53 -> $7B53                EEEM_TABS_START     EQU *     ; * Represents the current value of the paged
                                                                    ; program counter
007B53 7F7B53 -> $7F7B53              EEEM_TABS_START_LIN     EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
007B53 7F7B53                                                 ORG     EEEM_TABS_END, EEEM_TABS_END_LIN
007B53 7F7B53 -> $7B53                CLOCK_TABS_START            EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
007B53 7F7B53 -> $7F7B53              CLOCK_TABS_START_LIN    EQU     @     ; @ Represents the current value of the linear
                                                                        ; program counter
007B53 7F7B53                                                 ORG     CLOCK_TABS_END, CLOCK_TABS_END_LIN
007B53 7F7B53 -> $7B53                RTI_TABS_START              EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
007B53 7F7B53 -> $7F7B53              RTI_TABS_START_LIN          EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
007B53 7F7B53                                                 ORG     RTI_TABS_END, RTI_TABS_END_LIN
007B53 7F7B53 -> $7B53                SCI0_TABS_START         EQU     *     ; * Represents the current value of the paged
                                                                        ; program counter
007B53 7F7B53 -> $7F7B53              SCI0_TABS_START_LIN         EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
007B9F 7F7B9F                                                 ORG     SCI0_TABS_END, SCI0_TABS_END_LIN
007B9F 7F7B9F -> $7B9F                ADC0_TABS_START         EQU     *     ; * Represents the current value of the paged
                                                                        ; program counter
007B9F 7F7B9F -> $7F7B9F              ADC0_TABS_START_LIN         EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
007B9F 7F7B9F                                                 ORG     ADC0_TABS_END, ADC0_TABS_END_LIN
007B9F 7F7B9F -> $7B9F                GPIO_TABS_START     EQU *     ; * Represents the current value of the paged
                                                                    ; program counter
007B9F 7F7B9F -> $7F7B9F              GPIO_TABS_START_LIN     EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
007B9F 7F7B9F                                                 ORG     GPIO_TABS_END, GPIO_TABS_END_LIN
007B9F 7F7B9F -> $7B9F                ECT_TABS_START              EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
007B9F 7F7B9F -> $7F7B9F              ECT_TABS_START_LIN          EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
007B9F 7F7B9F                                                 ORG     ECT_TABS_END, ECT_TABS_END_LIN
007B9F 7F7B9F -> $7B9F                TIM_TABS_START              EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
007B9F 7F7B9F -> $7F7B9F              TIM_TABS_START_LIN          EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
007B9F 7F7B9F                                                 ORG     TIM_TABS_END, TIM_TABS_END_LIN
007B9F 7F7B9F -> $7B9F                STATE_TABS_START            EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
007B9F 7F7B9F -> $7F7B9F              STATE_TABS_START_LIN    EQU     @     ; @ Represents the current value of the linear
                                                                        ; program counter
007C9F 7F7C9F                                                 ORG     STATE_TABS_END, STATE_TABS_END_LIN
007C9F 7F7C9F -> $7C9F                INTERP_TABS_START           EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
007C9F 7F7C9F -> $7F7C9F              INTERP_TABS_START_LIN   EQU     @     ; @ Represents the current value of the linear
                                                                        ; program counter
007C9F 7F7C9F                                                 ORG     INTERP_TABS_END, INTERP_TABS_END_LIN
007C9F 7F7C9F -> $7C9F                IGNCALCS_TABS_START             EQU     *     ; * Represents the current value of the paged
                                                                        ; program counter
007C9F 7F7C9F -> $7F7C9F              IGNCALCS_TABS_START_LIN     EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
007C9F 7F7C9F                                                 ORG     IGNCALCS_TABS_END, IGNCALCS_TABS_END_LIN
007C9F 7F7C9F -> $7C9F                INJCALCS_TABS_START             EQU     *     ; * Represents the current value of the paged
                                                                        ; program counter
007C9F 7F7C9F -> $7F7C9F              INJCALCS_TABS_START_LIN     EQU @     ; @ Represents the current value of the linear
                                                                        ; program counter
007C9F 7F7C9F                                                 ORG     INJCALCS_TABS_END, INJCALCS_TABS_END_LIN
007C9F 7F7C9F -> $7C9F                DODGETHERM_TABS_START       EQU *     ; * Represents the current value of the paged
                                                                            ; program counter
007C9F 7F7C9F -> $7F7C9F              DODGETHERM_TABS_START_LIN       EQU     @     ; @ Represents the current value of the linear
                                                                            ; program counter
00849D 7F849D                                                 ORG     DODGETHERM_TABS_END, DODGETHERM_TABS_END_LIN
00849D 7F849D -> $849D                BASE_TABS_END               EQU *     ; * Represents the current value of the paged
                                                                        ; program counter
00849D 7F849D -> $7F849D              BASE_TABS_END_LIN           EQU @     ; @ Represents the current value of the linear
                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (regdefs_BPEM488.s)                                                        *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BPEM488 Engine Controller for the Dodge 488CID (8.0L) V10 engine  *
                                      ;*    by Robert Hiebert.                                                                 *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teaching    *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*    This module contains the 9S12XEP100 register definitions for the BPEM488 project   *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project                          *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map (This module)                         *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project               *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map                                         *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features                     *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler              *
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications                  *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)                                     *
                                      ;*   gpio_BPEM488.s       - Initialization all ports                                     *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros                         *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing                              *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths                       *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors                   *
                                      ;*****************************************************************************************
                                      ;* Version History:                                                                      *
                                      ;*    May 19 2020                                                                        *
                                      ;*    - BPEM488 version begins (work in progress)                                        *
                                      ;*    - Update December 10 2020                                                          *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
00849D 7F849D S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ;*****************************************************************************************
                                      ; - Port Integration Module (S12XEPIMV1) Port A equates
                                      ;*****************************************************************************************
00849D 7F849D -> $0000                PORTA:       equ $0000 ; Port A Data Register (pg 108)
00849D 7F849D -> $0080                PA7:         equ $80   ; %10000000 Port A General purpose I/O data bit 7 pin #64
00849D 7F849D -> $0040                PA6:         equ $40   ; %01000000 Port A General purpose I/O data bit 6 pin #63
00849D 7F849D -> $0020                PA5:         equ $20   ; %00100000 Port A General purpose I/O data bit 5 pin #62
00849D 7F849D -> $0010                PA4:         equ $10   ; %00010000 Port A General purpose I/O data bit 4 pin #61
00849D 7F849D -> $0008                PA3:         equ $08   ; %00001000 Port A General purpose I/O data bit 3 pin #60
00849D 7F849D -> $0004                PA2:         equ $04   ; %00000100 Port A General purpose I/O data bit 2 pin #59
00849D 7F849D -> $0002                PA1:         equ $02   ; %00000010 Port A General purpose I/O data bit 1 pin #58
00849D 7F849D -> $0001                PA0:         equ $01   ; %00000001 Port A General purpose I/O data bit 0 pin #57
00849D 7F849D -> $0002                DDRA:        equ $0002 ; Port A Data Direction Register (pg 109)
                                                             ; 1 = output, 0 = HiZ input
00849D 7F849D -> $0080                DDRA7:       equ $80   ; %10000000 Port A Data Direction bit 7 pin #64
00849D 7F849D -> $0040                DDRA6:       equ $40   ; %01000000 Port A Data Direction bit 6 pin #63
00849D 7F849D -> $0020                DDRA5:       equ $20   ; %00100000 Port A Data Direction bit 5 pin #62
00849D 7F849D -> $0010                DDRA4:       equ $10   ; %00010000 Port A Data Direction bit 4 pin #61
00849D 7F849D -> $0008                DDRA3:       equ $08   ; %00001000 Port A Data Direction bit 3 pin #60
00849D 7F849D -> $0004                DDRA2:       equ $04   ; %00000100 Port A Data Direction bit 2 pin #59
00849D 7F849D -> $0002                DDRA1:       equ $02   ; %00000010 Port A Data Direction bit 1 pin #58
00849D 7F849D -> $0001                DDRA0:       equ $01   ; %00000001 Port A Data Direction bit 0 pin #57
                                      ;*****************************************************************************************
                                      ; - Port Integration Module (S12XEPIMV1) Port B equates
                                      ;*****************************************************************************************
00849D 7F849D -> $0001                PORTB:       equ $0001 ; Port B Data Register (pg 108)
00849D 7F849D -> $0080                PB7:         equ $80   ; %10000000 Port B General purpose I/O data bit 7 pin #31
00849D 7F849D -> $0040                PB6:         equ $40   ; %01000000 Port B General purpose I/O data bit 6 pin #30
00849D 7F849D -> $0020                PB5:         equ $20   ; %00100000 Port B General purpose I/O data bit 5 pin #29
00849D 7F849D -> $0010                PB4:         equ $10   ; %00010000 Port B General purpose I/O data bit 4 pin #28
00849D 7F849D -> $0008                PB3:         equ $08   ; %00001000 Port B General purpose I/O data bit 3 pin #27
00849D 7F849D -> $0004                PB2:         equ $04   ; %00000100 Port B General purpose I/O data bit 2 pin #26
00849D 7F849D -> $0002                PB1:         equ $02   ; %00000010 Port B General purpose I/O data bit 1 pin #25
00849D 7F849D -> $0001                PB0:         equ $01   ; %00000001 Port B General purpose I/O data bit 0 pin #24
00849D 7F849D -> $0003                DDRB:        equ $0003 ; Port B Data Direction Register (pg 109)
                                                             ; 1 = output, 0 = HiZ input
00849D 7F849D -> $0080                DDRB7:       equ $80   ; %10000000 Port B Data Direction bit 7 pin #31
00849D 7F849D -> $0040                DDRB6:       equ $40   ; %01000000 Port B Data Direction bit 6 pin #30
00849D 7F849D -> $0020                DDRB5:       equ $20   ; %00100000 Port B Data Direction bit 5 pin #29
00849D 7F849D -> $0010                DDRB4:       equ $10   ; %00010000 Port B Data Direction bit 4 pin #28
00849D 7F849D -> $0008                DDRB3:       equ $08   ; %00001000 Port B Data Direction bit 3 pin #27
00849D 7F849D -> $0004                DDRB2:       equ $04   ; %00000100 Port B Data Direction bit 2 pin #26
00849D 7F849D -> $0002                DDRB1:       equ $02   ; %00000010 Port B Data Direction bit 1 pin #25
00849D 7F849D -> $0001                DDRB0:       equ $01   ; %00000001 Port B Data Direction bit 0 pin #24
                                      ;*****************************************************************************************
                                      ; - Port Integration Module (S12XEPIMV1) Port E equates
                                      ;*****************************************************************************************
00849D 7F849D -> $0008                PORTE:       equ $0008 ; Port E Data Register (pg 113)
00849D 7F849D -> $0080                PE7:         equ $80   ; %10000000 Port B General purpose I/O data bit 7 pin #36
00849D 7F849D -> $0040                PE6:         equ $40   ; %01000000 Port B General purpose I/O data bit 6 pin #37
00849D 7F849D -> $0020                PE5:         equ $20   ; %00100000 Port B General purpose I/O data bit 5 pin #38
00849D 7F849D -> $0010                PE4:         equ $10   ; %00010000 Port B General purpose I/O data bit 4 pin #39
00849D 7F849D -> $0008                PE3:         equ $08   ; %00001000 Port B General purpose I/O data bit 3 pin #53
00849D 7F849D -> $0004                PE2:         equ $04   ; %00000100 Port B General purpose I/O data bit 2 pin #54
00849D 7F849D -> $0002                PE1:         equ $02   ; %00000010 Port B General purpose input data and interrupt bit 1 pin #55
00849D 7F849D -> $0001                PE0:         equ $01   ; %00000001 Port B General purpose input data and interrupt bit 0 pin #56
00849D 7F849D -> $0009                DDRE:        equ $0009 ; Port B Data Direction Register (pg 114)
                                                             ; 1 = output, 0 = HiZ input
00849D 7F849D -> $0080                DDRE7:       equ $80   ; %10000000 Port B Data Direction bit 7 pin #36
00849D 7F849D -> $0040                DDRE6:       equ $40   ; %01000000 Port B Data Direction bit 6 pin #37
00849D 7F849D -> $0020                DDRE5:       equ $20   ; %00100000 Port B Data Direction bit 5 pin #38
00849D 7F849D -> $0010                DDRE4:       equ $10   ; %00010000 Port B Data Direction bit 4 pin #39
00849D 7F849D -> $0008                DDRE3:       equ $08   ; %00001000 Port B Data Direction bit 3 pin #53
00849D 7F849D -> $0004                DDRE2:       equ $04   ; %00000100 Port B Data Direction bit 2 pin #54
                                      ;*****************************************************************************************
                                      ; - Port Integration Module (S12XEPIMV1) PUCR equates
                                      ;*****************************************************************************************
00849D 7F849D -> $000C                PUCR:        equ $000C ; S12X_EBI ports, BKGD pin Pull-up Control Register (pg 114)
                                                             ; 1 = pull-up device enabled, 0 = pull-up device disabled
00849D 7F849D -> $0080                PUPKE:       equ $80   ; %10000000 Pull-up Port K Enable bit 7
00849D 7F849D -> $0040                BKPUE:       equ $40   ; %01000000 BKGD pin pull-up Enable bit 6
00849D 7F849D -> $0010                PUPEE:       equ $10   ; %00010000 Pull-up Port E Enable bit 4
00849D 7F849D -> $0008                PUPDE:       equ $08   ; %00001000 Pull-up Port D Enable bit 3
00849D 7F849D -> $0004                PUPCE:       equ $04   ; %00000100 Pull-up Port C Enable bit 2
00849D 7F849D -> $0002                PUPBE:       equ $02   ; %00000010 Pull-up Port B Enable bit 1
00849D 7F849D -> $0001                PUPAE:       equ $01   ; %00000001 Pull-up Port A Enable bit 0
                                      ;*****************************************************************************************
                                      ; - Memory Mapping Control (S12XMMCV4) equates
                                      ;*****************************************************************************************
00849D 7F849D -> $0017                EPAGE:       equ $0017 ;EEEPROM Page Index Register (pg 203)
00849D 7F849D -> $0080                EP7:         equ $80   ; %10000000 EEPROM Page Index bit 7
00849D 7F849D -> $0040                EP6:         equ $40   ; %01000000 EEPROM Page Index bit 6
00849D 7F849D -> $0020                EP5:         equ $20   ; %00100000 EEPROM Page Index bit 5
00849D 7F849D -> $0010                EP4:         equ $10   ; %00010000 EEPROM Page Index bit 4
00849D 7F849D -> $0008                EP3:         equ $08   ; %00001000 EEPROM Page Index bit 3
00849D 7F849D -> $0004                EP2:         equ $04   ; %00000100 EEPROM Page Index bit 2
00849D 7F849D -> $0002                EP1:         equ $02   ; %00000010 EEPROM Page Index bit 1
00849D 7F849D -> $0001                EP0:         equ $01   ; %00000001 EEPROM Page Index bit 0
                                      ;*****************************************************************************************
                                      ; - Port Integration Module (S12XEPIMV1) IRQCR equates
                                      ;*****************************************************************************************
00849D 7F849D -> $001E                IRQCR:       equ $001E ; IRQ Control Register (pg 119)
00849D 7F849D -> $0080                IRQE:        equ $80   ; %10000000 IRQ Select Edge Sensitive Only bit 7
00849D 7F849D -> $0040                IRQEN:       equ $40   ; %01000000 External IRQ Enable bit 6
                                      ;*****************************************************************************************
                                      ; - Port Integration Module (S12XEPIMV1) Port K equates
                                      ;*****************************************************************************************
00849D 7F849D -> $0032                PORTK:       equ $0032 ; Port K Data Register (pg 120)
00849D 7F849D -> $0080                PK7:         equ $80   ; %10000000 Port K general purpose I/O data bit 7 pin #108
00849D 7F849D -> $0040                PK6:         equ $40   ; %01000000 N/C
00849D 7F849D -> $0020                PK5:         equ $20   ; %00100000 Port K general purpose I/O data bit 5 pin #19
00849D 7F849D -> $0010                PK4:         equ $10   ; %00010000 Port K general purpose I/O data bit 4 pin #20
00849D 7F849D -> $0008                PK3:         equ $08   ; %00001000 Port K general purpose I/O data bit 3 pin #5
00849D 7F849D -> $0004                PK2:         equ $04   ; %00000100 Port K general purpose I/O data bit 2 pin #6
00849D 7F849D -> $0002                PK1:         equ $02   ; %00000010 Port K general purpose I/O data bit 1 pin #7
00849D 7F849D -> $0001                PK0:         equ $01   ; %00000001 Port K general purpose I/O data bit 0 pin #8
00849D 7F849D -> $0033                DDRK:        equ $0033 ; Port K Data Direction Register (pg 120)
                                                             ; 1 = output, 0 = HiZ input
00849D 7F849D -> $0080                DDRK7:       equ $80   ; %10000000 Port K Data Direction bit 7 pin #108
00849D 7F849D -> $0040                DDRK6:       equ $40   ; %01000000 N/C
00849D 7F849D -> $0020                DDRK5:       equ $20   ; %00100000 Port K Data Direction bit 5 pin #19
00849D 7F849D -> $0010                DDRK4:       equ $10   ; %00010000 Port K Data Direction bit 4 pin #20
00849D 7F849D -> $0008                DDRK3:       equ $08   ; %00001000 Port K Data Direction bit 3 pin #5
00849D 7F849D -> $0004                DDRK2:       equ $04   ; %00000100 Port K Data Direction bit 2 pin #6
00849D 7F849D -> $0002                DDRK1:       equ $02   ; %00000010 Port K Data Direction bit 1 pin #7
00849D 7F849D -> $0001                DDRK0:       equ $01   ; %00000001 Port K Data Direction bit 0 pin #8
                                      ;*****************************************************************************************
                                      ; - Enhanced Capture Timer (ECT16B8CV3) equates
                                      ;*****************************************************************************************
00849D 7F849D -> $0040                ECT_TIOS:    equ $0040 ; Timer Input Capture/Output Compare Select Register (pg 535)
                                                             ; 1 = input capture, 0 = output compare
00849D 7F849D -> $0080                IOS7:        equ $80   ; %10000000 Input Capture or Output Compare Channel Config bit 7
00849D 7F849D -> $0040                IOS6:        equ $40   ; %01000000 Input Capture or Output Compare Channel Config bit 6
00849D 7F849D -> $0020                IOS5:        equ $20   ; %00100000 Input Capture or Output Compare Channel Config bit 5
00849D 7F849D -> $0010                IOS4:        equ $10   ; %00010000 Input Capture or Output Compare Channel Config bit 4
00849D 7F849D -> $0008                IOS3:        equ $08   ; %00001000 Input Capture or Output Compare Channel Config bit 3
00849D 7F849D -> $0004                IOS2:        equ $04   ; %00000100 Input Capture or Output Compare Channel Config bit 2
00849D 7F849D -> $0002                IOS1:        equ $02   ; %00000010 Input Capture or Output Compare Channel Config bit 1
00849D 7F849D -> $0001                IOS0:        equ $01   ; %00000001 Input Capture or Output Compare Channel Config bit 0
00849D 7F849D -> $0041                ECT_CFORC:   equ $0041 ; Timer Compare Force Register (pg 536)
00849D 7F849D -> $0080                FOC7:        equ $80   ; %10000000 Force Output Compare Action For Channel 7 bit 7
00849D 7F849D -> $0040                FOC6:        equ $40   ; %01000000 Force Output Compare Action For Channel 6 bit 6
00849D 7F849D -> $0020                FOC5:        equ $20   ; %00100000 Force Output Compare Action For Channel 5 bit 5
00849D 7F849D -> $0010                FOC4:        equ $10   ; %00010000 Force Output Compare Action For Channel 4 bit 4
00849D 7F849D -> $0008                FOC3:        equ $08   ; %00001000 Force Output Compare Action For Channel 3 bit 3
00849D 7F849D -> $0004                FOC2:        equ $04   ; %00000100 Force Output Compare Action For Channel 2 bit 2
00849D 7F849D -> $0002                FOC1:        equ $02   ; %00000010 Force Output Compare Action For Channel 1 bit 1
00849D 7F849D -> $0001                FOC0:        equ $01   ; %00000001 Force Output Compare Action For Channel 0 bit 0
00849D 7F849D -> $0042                ECT_OC7M:    equ $0042 ; Output Compare 7 Mask Register (pg 536)
00849D 7F849D -> $0080                OC7M7:       equ $80   ; %10000000 Output Compare 7 Mask bit 7
00849D 7F849D -> $0040                OC7M6:       equ $40   ; %01000000 Output Compare 7 Mask bit 6
00849D 7F849D -> $0020                OC7M5:       equ $20   ; %00100000 Output Compare 7 Mask bit 5
00849D 7F849D -> $0010                OC7M4:       equ $10   ; %00010000 Output Compare 7 Mask bit 4
00849D 7F849D -> $0008                OC7M3:       equ $08   ; %00001000 Output Compare 7 Mask bit 3
00849D 7F849D -> $0004                OC7M2:       equ $04   ; %00000100 Output Compare 7 Mask bit 2
00849D 7F849D -> $0002                OC7M1:       equ $02   ; %00000010 Output Compare 7 Mask bit 1
00849D 7F849D -> $0001                OC7M0:       equ $01   ; %00000001 Output Compare 7 Mask bit 0
00849D 7F849D -> $0043                ECT_OC7D:    equ $0043 ; Output Compare 7 Data Register (pg 537)
00849D 7F849D -> $0080                OC7D7:       equ $80   ; %10000000 Output Compare 7 Data bit 7
00849D 7F849D -> $0040                OC7D6:       equ $40   ; %01000000 Output Compare 7 Data bit 6
00849D 7F849D -> $0020                OC7D5:       equ $20   ; %00100000 Output Compare 7 Data bit 5
00849D 7F849D -> $0010                OC7D4:       equ $10   ; %00010000 Output Compare 7 Data bit 4
00849D 7F849D -> $0008                OC7D3:       equ $08   ; %00001000 Output Compare 7 Data bit 3
00849D 7F849D -> $0004                OC7D2:       equ $04   ; %00000100 Output Compare 7 Data bit 2
00849D 7F849D -> $0002                OC7D1:       equ $02   ; %00000010 Output Compare 7 Data bit 1
00849D 7F849D -> $0001                OC7D0:       equ $01   ; %00000001 Output Compare 7 Data bit 0
00849D 7F849D -> $0044                ECT_TCNTH:   equ $0044 ; Timer Count Register High (pg 537)
00849D 7F849D -> $0080                TCNT15:      equ $80   ; %10000000 Timer Count Data bit 15
00849D 7F849D -> $0040                TCNT14:      equ $40   ; %01000000 Timer Count Data bit 14
00849D 7F849D -> $0020                TCNT13:      equ $20   ; %00100000 Timer Count Data bit 13
00849D 7F849D -> $0010                TCNT12:      equ $10   ; %00010000 Timer Count Data bit 12
00849D 7F849D -> $0008                TCNT11:      equ $08   ; %00001000 Timer Count Data bit 11
00849D 7F849D -> $0004                TCNT10:      equ $04   ; %00000100 Timer Count Data bit 10
00849D 7F849D -> $0002                TCNT9:       equ $02   ; %00000010 Timer Count Data bit 9
00849D 7F849D -> $0001                TCNT8:       equ $01   ; %00000001 Timer Count Data bit 8
00849D 7F849D -> $0045                ECT_TCNTL:   equ $0045 ; Timer Count Register Low (pg 537)
00849D 7F849D -> $0080                TCNT7:       equ $80   ; %10000000 Timer Count Data bit 7
00849D 7F849D -> $0040                TCNT6:       equ $40   ; %01000000 Timer Count Data bit 6
00849D 7F849D -> $0020                TCNT5:       equ $20   ; %00100000 Timer Count Data bit 5
00849D 7F849D -> $0010                TCNT4:       equ $10   ; %00010000 Timer Count Data bit 4
00849D 7F849D -> $0008                TCNT3:       equ $08   ; %00001000 Timer Count Data bit 3
00849D 7F849D -> $0004                TCNT2:       equ $04   ; %00000100 Timer Count Data bit 2
00849D 7F849D -> $0002                TCNT1:       equ $02   ; %00000010 Timer Count Data bit 1
00849D 7F849D -> $0001                TCNT0:       equ $01   ; %00000001 Timer Count Data bit 0
00849D 7F849D -> $0046                ECT_TSCR1:   equ $0046 ; Timer System Control Register 1 (pg 538)
00849D 7F849D -> $0080                TEN:         equ $80   ; %10000000 Timer Enable bit 7
00849D 7F849D -> $0040                TSWAI:       equ $40   ; %01000000 Timer Module Stops While In Wait bit 6
00849D 7F849D -> $0020                TSFRZ:       equ $20   ; %00100000 Timer and Modulus Counter Stop While In Wait bit 5
00849D 7F849D -> $0010                TFFCA:       equ $10   ; %00010000 Timer Fast Flag Clear All bit 4
00849D 7F849D -> $0008                PRNT:        equ $08   ; %00001000 Precision Timer bit 3
00849D 7F849D -> $0047                ECT_TTOV:    equ $0047 ; Timer Toggle On Overflow Register 1 (pg 539)
00849D 7F849D -> $0080                TOV7:        equ $80   ; %10000000 Toggle on Overflow bit 7
00849D 7F849D -> $0040                TOV6:        equ $40   ; %01000000 Toggle on Overflow bit 6
00849D 7F849D -> $0020                TOV5:        equ $20   ; %00100000 Toggle on Overflow bit 5
00849D 7F849D -> $0010                TOV4:        equ $10   ; %00100000 Toggle on Overflow bit 4
00849D 7F849D -> $0008                TOV3:        equ $08   ; %00001000 Toggle on Overflow bit 3
00849D 7F849D -> $0004                TOV2:        equ $04   ; %00000100 Toggle on Overflow bit 2
00849D 7F849D -> $0002                TOV1:        equ $02   ; %00000010 Toggle on Overflow bit 1
00849D 7F849D -> $0001                TOV0:        equ $01   ; %00000001 Toggle on Overflow bit 0
00849D 7F849D -> $0048                ECT_TCTL1:   equ $0048 ; Timer Control Register 1 (pg 540)
00849D 7F849D -> $0080                OM7:         equ $80   ; %10000000 Output Mode 7 bit 7
00849D 7F849D -> $0040                OL7:         equ $40   ; %01000000 Output Level 7 bit 6
00849D 7F849D -> $0020                OM6:         equ $20   ; %00100000 Output Mode 6 bit 5
00849D 7F849D -> $0010                OL6:         equ $10   ; %0010000Output Level 6 bit 4
00849D 7F849D -> $0008                OM5:         equ $08   ; %00001000 Output Mode 5 bit 3
00849D 7F849D -> $0004                OL5:         equ $04   ; %00000100 Output Level 5 bit 2
00849D 7F849D -> $0002                OM4:         equ $02   ; %00000010 Output Mode 4 bit 1
00849D 7F849D -> $0001                OL4:         equ $01   ; %00000001 Output Level 4 bit 0
00849D 7F849D -> $0049                ECT_TCTL2:   equ $0049 ; Timer Control Register 2 (pg 540)
00849D 7F849D -> $0080                OM3:         equ $80   ; %10000000 Output Mode 3 bit 7
00849D 7F849D -> $0040                OL3:         equ $40   ; %01000000 Output Level 3 bit 6
00849D 7F849D -> $0020                OM2:         equ $20   ; %00100000 Output Mode 2 bit 5
00849D 7F849D -> $0010                OL2:         equ $10   ; %0010000Output Level 2 bit 4
00849D 7F849D -> $0008                OM1:         equ $08   ; %00001000 Output Mode 1 bit 3
00849D 7F849D -> $0004                OL1:         equ $04   ; %00000100 Output Level 1 bit 2
00849D 7F849D -> $0002                OM0:         equ $02   ; %00000010 Output Mode 0 bit 1
00849D 7F849D -> $0001                OL0:         equ $01   ; %00000001 Output Level 0 bit 0
00849D 7F849D -> $004A                ECT_TCTL3:   equ $004A ; Timer Control Register 3 (pg 541)
00849D 7F849D -> $0080                EDG7B:       equ $80   ; %10000000 Input Capture Edge Control 7B bit 7
00849D 7F849D -> $0040                EDG7A:       equ $40   ; %01000000 Input Capture Edge Control 7A bit 6
00849D 7F849D -> $0020                EDG6B:       equ $20   ; %00100000 Input Capture Edge Control 6B bit 5
00849D 7F849D -> $0010                EDG6A:       equ $10   ; %00010000 Input Capture Edge Control 6A bit 4
00849D 7F849D -> $0008                EDG5B:       equ $08   ; %00001000 Input Capture Edge Control 5B bit 3
00849D 7F849D -> $0004                EDG5A:       equ $04   ; %00000100 Input Capture Edge Control 5A bit 2
00849D 7F849D -> $0002                EDG4B:       equ $02   ; %00000010 Input Capture Edge Control 4B bit 1
00849D 7F849D -> $0001                EDG4A:       equ $01   ; %00000001 Input Capture Edge Control 4A bit 0
00849D 7F849D -> $004B                ECT_TCTL4:   equ $004B ; Timer Control Register 4 (pg 541)
00849D 7F849D -> $0080                EDG3B:       equ $80   ; %10000000 Input Capture Edge Control 3B bit 7
00849D 7F849D -> $0040                EDG3A:       equ $40   ; %01000000 Input Capture Edge Control 3A bit 6
00849D 7F849D -> $0020                EDG2B:       equ $20   ; %00100000 Input Capture Edge Control 2B bit 5
00849D 7F849D -> $0010                EDG2A:       equ $10   ; %00010000 Input Capture Edge Control 2A bit 4
00849D 7F849D -> $0008                EDG1B:       equ $08   ; %00001000 Input Capture Edge Control 1B bit 3
00849D 7F849D -> $0004                EDG1A:       equ $04   ; %00000100 Input Capture Edge Control 1A bit 2
00849D 7F849D -> $0002                EDG0B:       equ $02   ; %00000010 Input Capture Edge Control 0B bit 1
00849D 7F849D -> $0001                EDG0A:       equ $01   ; %00000001 Input Capture Edge Control 0A bit 0
00849D 7F849D -> $004C                ECT_TIE:     equ $004C ; Timer Interrupt Enable Register (pg 542)
                                                             ; 0 = interrupt disabled, 1 = interrupts enabled
00849D 7F849D -> $0080                C7I:         equ $80   ; %10000000 IC/OC "X" Interrupt Enable bit 7
00849D 7F849D -> $0040                C6I:         equ $40   ; %01000000 IC/OC "X" Interrupt Enable bit 6
00849D 7F849D -> $0020                C5I:         equ $20   ; %00100000 IC/OC "X" Interrupt Enable bit 5
00849D 7F849D -> $0010                C4I:         equ $10   ; %00010000 IC/OC "X" Interrupt Enable bit 4
00849D 7F849D -> $0008                C3I:         equ $08   ; %00001000 IC/OC "X" Interrupt Enable bit 3
00849D 7F849D -> $0004                C2I:         equ $04   ; %00000100 IC/OC "X" Interrupt Enable bit 2
00849D 7F849D -> $0002                C1I:         equ $02   ; %00000010 IC/OC "X" Interrupt Enable bit 1
00849D 7F849D -> $0001                C0I:         equ $01   ; %00000001 IC/OC "X" Interrupt Enable bit 0
00849D 7F849D -> $004D                ECT_TSCR2:   equ $004D ; Timer System Control Register 2 (pg 543)
00849D 7F849D -> $0080                TOI:         equ $80   ; %10000000 Timer Overflow Interrupt Enable bit 7
00849D 7F849D -> $0008                TCRE:        equ $08   ; %00001000 Timer Counter Register Enable bit 3
00849D 7F849D -> $0004                PR2:         equ $04   ; %00000100 Timer Prescaler Select bit 2
00849D 7F849D -> $0002                PR1:         equ $02   ; %00000010 Timer Prescaler Select bit 1
00849D 7F849D -> $0001                PR0:         equ $01   ; %00000001 Timer Prescaler Select bit 0
00849D 7F849D -> $004E                ECT_TFLG1:   equ $004E ; Main Timer Interrupt Flag 1 (pg 545)
00849D 7F849D -> $0080                C7F:         equ $80   ; %10000000 IC/OC Channel "x" Flag bit 7
00849D 7F849D -> $0040                C6F:         equ $40   ; %10000000 IC/OC Channel "x" Flag bit 6
00849D 7F849D -> $0020                C5F:         equ $20   ; %10000000 IC/OC Channel "x" Flag bit 5
00849D 7F849D -> $0010                C4F:         equ $10   ; %10000000 IC/OC Channel "x" Flag bit 4
00849D 7F849D -> $0008                C3F:         equ $08   ; %10000000 IC/OC Channel "x" Flag bit 3
00849D 7F849D -> $0004                C2F:         equ $04   ; %10000000 IC/OC Channel "x" Flag bit 2
00849D 7F849D -> $0002                C1F:         equ $02   ; %10000000 IC/OC Channel "x" Flag bit 1
00849D 7F849D -> $0001                C0F:         equ $01   ; %10000000 IC/OC Channel "x" Flag bit 0
00849D 7F849D -> $004F                ECT_TFLG2:   equ $004F ; Main Timer Interrupt Flag 2 (pg 545)
00849D 7F849D -> $0080                TOF:         equ $80   ; %10000000 Timer Overflow Flag
00849D 7F849D -> $0050                ECT_TC0H:    equ $0050 ; Timer IC/OC Register0 Hi (pg 546)
00849D 7F849D -> $0080                Bit15:       equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit14:       equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit13:       equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit12:       equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit11:       equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit10:       equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit9:        equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit8:        equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $0051                ECT_TC0L:    equ $0051 ; Timer IC/OC Register0 Lo (pg 546)
00849D 7F849D -> $0080                Bit7:        equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit6:        equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit5:        equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit4:        equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit3:        equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit2:        equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit1:        equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit0:        equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $0052                ECT_TC1H:    equ $0052 ; Timer IC/OC Register1 Hi (pg 546)
00849D 7F849D -> $0080                Bit15:       equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit14:       equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit13:       equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit12:       equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit11:       equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit10:       equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit9:        equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit8:        equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $0053                ECT_TC1L:    equ $0053 ; Timer IC/OC Register1 Lo (pg 547)
00849D 7F849D -> $0080                Bit7:        equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit6:        equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit5:        equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit4:        equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit3:        equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit2:        equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit1:        equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit0:        equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $0054                ECT_TC2H:    equ $0054 ; Timer IC/OC Register2 Hi (pg 547)
00849D 7F849D -> $0080                Bit15:       equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit14:       equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit13:       equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit12:       equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit11:       equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit10:       equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit9:        equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit8:        equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $0055                ECT_TC2L:    equ $0055 ; Timer IC/OC Register2 Lo (pg 547)
00849D 7F849D -> $0080                Bit7:        equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit6:        equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit5:        equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit4:        equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit3:        equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit2:        equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit1:        equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit0:        equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $0056                ECT_TC3H:    equ $0056 ; Timer IC/OC Register3 Hi (pg 547)
00849D 7F849D -> $0080                Bit15:       equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit14:       equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit13:       equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit12:       equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit11:       equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit10:       equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit9:        equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit8:        equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $0057                ECT_TC3L:    equ $0057 ; Timer IC/OC Register3 Lo (pg 547)
00849D 7F849D -> $0080                Bit7:        equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit6:        equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit5:        equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit4:        equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit3:        equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit2:        equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit1:        equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit0:        equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $0058                ECT_TC4H:    equ $0058 ; Timer IC/OC Register4 Hi (pg 547)
00849D 7F849D -> $0080                Bit15:       equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit14:       equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit13:       equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit12:       equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit11:       equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit10:       equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit9:        equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit8:        equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $0059                ECT_TC4L:    equ $0059 ; Timer IC/OC Register4 Lo (pg 548)
00849D 7F849D -> $0080                Bit7:        equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit6:        equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit5:        equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit4:        equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit3:        equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit2:        equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit1:        equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit0:        equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $005A                ECT_TC5H:    equ $005A ; Timer IC/OC Register5 Hi (pg 548)
00849D 7F849D -> $0080                Bit15:       equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit14:       equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit13:       equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit12:       equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit11:       equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit10:       equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit9:        equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit8:        equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $005B                ECT_TC5L:    equ $005B ; Timer IC/OC Register5 Lo (pg 548)
00849D 7F849D -> $0080                Bit7:        equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit6:        equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit5:        equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit4:        equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit3:        equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit2:        equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit1:        equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit0:        equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $005C                ECT_TC6H:    equ $005C ; Timer IC/OC Register6 Hi (pg 548)
00849D 7F849D -> $0080                Bit15:       equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit14:       equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit13:       equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit12:       equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit11:       equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit10:       equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit9:        equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit8:        equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $005D                ECT_TC6L:    equ $005D ; Timer IC/OC Register6 Lo (pg 548)
00849D 7F849D -> $0080                Bit7:        equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit6:        equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit5:        equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit4:        equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit3:        equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit2:        equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit1:        equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit0:        equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $005E                ECT_TC7H:    equ $005E ; Timer IC/OC Register7 Hi (pg 548)
00849D 7F849D -> $0080                Bit15:       equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit14:       equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit13:       equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit12:       equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit11:       equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit10:       equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit9:        equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit8:        equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $005F                ECT_TC7L:    equ $005F ; Timer IC/OC Register7 Lo (pg 549)
00849D 7F849D -> $0080                Bit7:        equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit6:        equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit5:        equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit4:        equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit3:        equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit2:        equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit1:        equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit0:        equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $0060                ECT_PACTL:    equ $0060 ; 16-Bit Pulse Accumulator Control Register (pg 549)
00849D 7F849D -> $0040                PAEN:         equ $40   ; %01000000 Pulse Accumulator System Enable(bit 6)
00849D 7F849D -> $0020                PAMOD:        equ $20   ; %00100000 Pulse Accumulator Mode(bit 5)
00849D 7F849D -> $0010                PEDGE:        equ $10   ; %00010000 Pulse Accumulator Edge Control(bit 4)
00849D 7F849D -> $0008                CLK1:         equ $08   ; %00001000 Clock Select(bit 3)
00849D 7F849D -> $0004                CLK0:         equ $04   ; %00000100 Clock Select(bit 2)
00849D 7F849D -> $0002                PAOV1:        equ $02   ; %00000010 Pulse Accumulator Overflow Interrupt Enable(bit 1)
00849D 7F849D -> $0001                PAI:          equ $01   ; %00000001 Pulse Accumulator Input Interrupt Enable(bit 0)
00849D 7F849D -> $0061                ECT_PAFLG:    equ $0061 ; Pulse Accumulator Flag Register (pg 551)
00849D 7F849D -> $0002                PAOVF:        equ $02   ; %00000010 Pulse Accumulator Overflow Flag(bit 1)
00849D 7F849D -> $0001                PAIF:         equ $01   ; %00000001 Pulse Accumulator input edge Flag(bit 0)
00849D 7F849D -> $0062                ECT_PACN3:   equ $0062 ; Pulse Accumulator Count Register 3 (pg 551)
00849D 7F849D -> $0080                PACNT15:     equ $80   ; %10000000 Pulse Accumulator Count Data bit 15
00849D 7F849D -> $0040                PACNT14:     equ $40   ; %01000000 Pulse Accumulator Count Data bit 14
00849D 7F849D -> $0020                PACNT13:     equ $20   ; %00100000 Pulse Accumulator Count Data bit 13
00849D 7F849D -> $0010                PACNT12:     equ $10   ; %00010000 Pulse Accumulator Count Data bit 12
00849D 7F849D -> $0008                PACNT11:     equ $08   ; %00001000 Pulse Accumulator Count Data bit 11
00849D 7F849D -> $0004                PACNT10:     equ $04   ; %00000100 Pulse Accumulator Count Data bit 10
00849D 7F849D -> $0002                PACNT9:      equ $02   ; %00000010 Pulse Accumulator Count Data bit 9
00849D 7F849D -> $0001                PACNT8:      equ $01   ; %00000001 Pulse Accumulator Count Data bit 8
00849D 7F849D -> $0063                ECT_PACN2:   equ $0063 ; Pulse Accumulator Count Register 2 (pg 552)
00849D 7F849D -> $0080                PACNT7:      equ $80   ; %10000000 Pulse Accumulator Count Data bit 15
00849D 7F849D -> $0040                PACNT6:      equ $40   ; %01000000 Pulse Accumulator Count Data bit 14
00849D 7F849D -> $0020                PACNT5:      equ $20   ; %00100000 Pulse Accumulator Count Data bit 13
00849D 7F849D -> $0010                PACNT4:      equ $10   ; %00010000 Pulse Accumulator Count Data bit 12
00849D 7F849D -> $0008                PACNT3:      equ $08   ; %00001000 Pulse Accumulator Count Data bit 11
00849D 7F849D -> $0004                PACNT2:      equ $04   ; %00000100 Pulse Accumulator Count Data bit 10
00849D 7F849D -> $0002                PACNT1:      equ $02   ; %00000010 Pulse Accumulator Count Data bit 9
00849D 7F849D -> $0001                PACNT`:      equ $01   ; %00000001 Pulse Accumulator Count Data bit 8
00849D 7F849D -> $0064                ECT_PACN1:   equ $0064 ; Pulse Accumulator Count Register 1 (pg 552)
00849D 7F849D -> $0080                PACNT15:     equ $80   ; %10000000 Pulse Accumulator Count Data bit 15
00849D 7F849D -> $0040                PACNT14:     equ $40   ; %01000000 Pulse Accumulator Count Data bit 14
00849D 7F849D -> $0020                PACNT13:     equ $20   ; %00100000 Pulse Accumulator Count Data bit 13
00849D 7F849D -> $0010                PACNT12:     equ $10   ; %00010000 Pulse Accumulator Count Data bit 12
00849D 7F849D -> $0008                PACNT11:     equ $08   ; %00001000 Pulse Accumulator Count Data bit 11
00849D 7F849D -> $0004                PACNT10:     equ $04   ; %00000100 Pulse Accumulator Count Data bit 10
00849D 7F849D -> $0002                PACNT9:      equ $02   ; %00000010 Pulse Accumulator Count Data bit 9
00849D 7F849D -> $0001                PACNT8:      equ $01   ; %00000001 Pulse Accumulator Count Data bit 8
00849D 7F849D -> $0065                ECT_PACN20:   equ $0065 ; Pulse Accumulator Count Register 0 (pg 552)
00849D 7F849D -> $0080                PACNT7:      equ $80   ; %10000000 Pulse Accumulator Count Data bit 15
00849D 7F849D -> $0040                PACNT6:      equ $40   ; %01000000 Pulse Accumulator Count Data bit 14
00849D 7F849D -> $0020                PACNT5:      equ $20   ; %00100000 Pulse Accumulator Count Data bit 13
00849D 7F849D -> $0010                PACNT4:      equ $10   ; %00010000 Pulse Accumulator Count Data bit 12
00849D 7F849D -> $0008                PACNT3:      equ $08   ; %00001000 Pulse Accumulator Count Data bit 11
00849D 7F849D -> $0004                PACNT2:      equ $04   ; %00000100 Pulse Accumulator Count Data bit 10
00849D 7F849D -> $0002                PACNT1:      equ $02   ; %00000010 Pulse Accumulator Count Data bit 9
00849D 7F849D -> $0001                PACNT`:      equ $01   ; %00000001 Pulse Accumulator Count Data bit 8
00849D 7F849D -> $006C                ECT_OCPD:     equ $006C ; Output Compare Pin Disconnect Register (pg 559)
00849D 7F849D -> $0080                OCPD7:        equ $80   ; %10000000 Output Compare Pin Disconnect bit 7
00849D 7F849D -> $0040                OCPD6:        equ $40   ; %01000000 Output Compare Pin Disconnect bit 6
00849D 7F849D -> $0020                OCPD5:        equ $20   ; %00100000 Output Compare Pin Disconnect bit 5
00849D 7F849D -> $0010                OCPD4:        equ $10   ; %00010000 Output Compare Pin Disconnect bit 4
00849D 7F849D -> $0008                OCPD3:        equ $08   ; %00001000 Output Compare Pin Disconnect bit 3
00849D 7F849D -> $0004                OCPD2:        equ $04   ; %00000100 Output Compare Pin Disconnect bit 2
00849D 7F849D -> $0002                OCPD1:        equ $02   ; %00000010 Output Compare Pin Disconnect bit 1
00849D 7F849D -> $0001                OCPD0:        equ $01   ; %00000001 Output Compare Pin Disconnect bit 0
00849D 7F849D -> $006E                ECT_PTPSR:   equ $006E ; Precision Timer Prescaler Select Register (pg 559)
00849D 7F849D -> $0080                PTPS7:       equ $80   ; %10000000 Precision Timer Prescaler Select bit 7
00849D 7F849D -> $0040                PTPS6:       equ $40   ; %01000000 Precision Timer Prescaler Select bit 6
00849D 7F849D -> $0020                PTPS5:       equ $20   ; %00100000 Precision Timer Prescaler Select bit 5
00849D 7F849D -> $0010                PTPS4:       equ $10   ; %00010000 Precision Timer Prescaler Select bit 4
00849D 7F849D -> $0008                PTPS3:       equ $08   ; %00001000 Precision Timer Prescaler Select bit 3
00849D 7F849D -> $0004                PTPS2:       equ $04   ; %00000100 Precision Timer Prescaler Select bit 2
00849D 7F849D -> $0002                PTPS1:       equ $02   ; %00000010 Precision Timer Prescaler Select bit 1
00849D 7F849D -> $0001                PTPS0:       equ $01   ; %00000001 Precision Timer Prescaler Select bit 0
                                      ;*****************************************************************************************
                                      ; - 1024KB Flash Module (S12XFTM1024K5V2)
                                      ;*****************************************************************************************
00849D 7F849D -> $0100                FCLKDIV:     equ $0100 ; Flash Clock Divider Register (pg 1152)
00849D 7F849D -> $0080                FDIVLD:      equ $80   ; %10000000 Clock Divider Loaded bit 7
00849D 7F849D -> $0040                FDIV6:       equ $40   ; %01000000 Clock Divider Bits bit 6
00849D 7F849D -> $0020                FDIV5:       equ $20   ; %00100000 Clock Divider Bits bit 5
00849D 7F849D -> $0010                FDIV4:       equ $10   ; %00010000 Clock Divider Bits bit 4
00849D 7F849D -> $0008                FDIV3:       equ $08   ; %00001000 Clock Divider Bits bit 3
00849D 7F849D -> $0004                FDIV2:       equ $04   ; %00000100 Clock Divider Bits bit 2
00849D 7F849D -> $0002                FDIV1:       equ $02   ; %00000010 Clock Divider Bits bit 1
00849D 7F849D -> $0001                FDIV0:       equ $01   ; %00000001 Clock Divider Bits bit 0
00849D 7F849D -> $0102                FCCOBIX:     equ $0102 ; Flash CCOB Index Register ( pg 1155)
00849D 7F849D -> $0004                CCOBIX2:     equ $04   ; %00000100 Common Command Register Index bit 2
00849D 7F849D -> $0002                CCOBIX1:     equ $02   ; %00000010 Common Command Register Index bit 1
00849D 7F849D -> $0001                CCOBIX0:     equ $01   ; %00000001 Common Command Register Index bit 0
00849D 7F849D -> $0106                FSTAT:       equ $0106 ; Flash Status Register (pg 1158)
00849D 7F849D -> $0080                CCIF:        equ $80   ; %10000000 Command Complete Interrupt Flag bit 7
00849D 7F849D -> $0020                ACCERR:      equ $20   ; %00100000 Flash Access Error Flag bit 5
00849D 7F849D -> $0010                FPVIOL:      equ $10   ; %00010000 Flash Protection Violation Flag bit 4
00849D 7F849D -> $0008                MGBUSY:      equ $08   ; %00001000 Memory Controller Busy Flag bit 3
00849D 7F849D -> $0004                RSVD:        equ $04   ; %00000100 Reserved Bit bit 2
00849D 7F849D -> $0002                MGSTAT1:     equ $02   ; %00000010 Memory Controller Command Completion Status Flag bit 1
00849D 7F849D -> $0001                MGSTAT0:     equ $01   ; %00000001 Memory Controller Command Completion Status Flag bit 0
00849D 7F849D -> $0107                FERSTAT:     equ $0107 ; Flash Error Status Register (pg 1159)
00849D 7F849D -> $0080                ERSERIF:     equ $80   ; %10000000 EEE Erase Error Interrupt Flag bit 7
00849D 7F849D -> $0020                PGMERIF:     equ $20   ; %00100000 EEE Program Error Interrupt Flag bit 5
00849D 7F849D -> $0010                EPVIOLIF:    equ $10   ; %00010000 EEE Protection Violation Interrupt Flag bit 4
00849D 7F849D -> $0008                ERSVIF1:     equ $08   ; %00001000 EEE Error Interrupt 1 Flag bit 3
00849D 7F849D -> $0004                ERSVIF0:     equ $04   ; %00000100 EEE Error Interrupt 0 Flag bit 2
00849D 7F849D -> $0002                DFDIF:       equ $02   ; %00000010 Double Bit Fault Detect Interrupt Flag bit 1
00849D 7F849D -> $0001                SFDIF:       equ $01   ; %00000001 Single Bit Fault Detect Interrupt Flag bit 0
00849D 7F849D -> $010A                FCCOBHI:     equ $010A ; Flash Common Command Object High Register (pg 1166)
00849D 7F849D -> $010B                FCCOBLO:     equ $010B ; Flash Common Command Object Low Register (pg 1166)
00849D 7F849D -> $010C                ETAGHI:      equ $010C ; EEE Tag Counter Register High (pg 1167)
00849D 7F849D -> $010D                ETAGLO:      equ $010D ; EEE Tag Counter Register Low (pg 1167)
                                      ;*****************************************************************************************
                                      ; - Port Integration Module (S12XEPIMV1) Port T equates
                                      ;*****************************************************************************************
00849D 7F849D -> $0240                PTT:         equ $0240 ; Port T Data Register (pg 121)
00849D 7F849D -> $0080                PT7:         equ $80   ; %10000000 Port T general purpose I/O data bit 7 pin #18
00849D 7F849D -> $0040                PT6:         equ $40   ; %01000000 Port T general purpose I/O data bit 6 pin #17
00849D 7F849D -> $0020                PT5:         equ $20   ; %00100000 Port T general purpose I/O data bit 5 pin #16
00849D 7F849D -> $0010                PT4:         equ $10   ; %00010000 Port T general purpose I/O data bit 4 pin #15
00849D 7F849D -> $0008                PT3:         equ $08   ; %00001000 Port T general purpose I/O data bit 3 pin #12
00849D 7F849D -> $0004                PT2:         equ $04   ; %00000100 Port T general purpose I/O data bit 2 pin #11
00849D 7F849D -> $0002                PT1:         equ $02   ; %00000010 Port T general purpose I/O data bit 1 pin #10
00849D 7F849D -> $0001                PT0:         equ $01   ; %00000001 Port T general purpose I/O data bit 0 pin #9
00849D 7F849D -> $0242                DDRT:        equ $0242 ; Port T Data Direction Register (pg 122)
                                                             ; 1 = output, 0 = input
00849D 7F849D -> $0080                DDRT7:       equ $80   ; %10000000 Port T data direction bit 7 pin #18
00849D 7F849D -> $0040                DDRT6:       equ $40   ; %01000000 Port T data direction bit 6 pin #17
00849D 7F849D -> $0020                DDRT5:       equ $20   ; %00100000 Port T data direction bit 5 pin #16
00849D 7F849D -> $0010                DDRT4:       equ $10   ; %00010000 Port T data direction bit 4 pin #15
00849D 7F849D -> $0008                DDRT3:       equ $08   ; %00001000 Port T data direction bit 3 pin #12
00849D 7F849D -> $0004                DDRT2:       equ $04   ; %00000100 Port T data direction bit 2 pin #11
00849D 7F849D -> $0002                DDRT1:       equ $02   ; %00000010 Port T data direction bit 1 pin #10
00849D 7F849D -> $0001                DDRT0:       equ $01   ; %00000001 Port T data direction bit 0 pin #9
00849D 7F849D -> $0244                PERT:        equ $0244 ; Port T Pull Device Enable Register (pg 123)
00849D 7F849D -> $0080                PERT7:       equ $80   ; %10000000 Port T pull Device Enable Register bit 7
00849D 7F849D -> $0040                PERT6:       equ $40   ; %01000000 Port T pull Device Enable Register bit 6
00849D 7F849D -> $0020                PERT5:       equ $20   ; %00100000 Port T pull Device Enable Register bit 5
00849D 7F849D -> $0010                PERT4:       equ $10   ; %10010000 Port T pull Device Enable Register bit 4
00849D 7F849D -> $0008                PERT3:       equ $08   ; %00001000 Port T pull Device Enable Register bit 3
00849D 7F849D -> $0004                PERT2:       equ $04   ; %00000100 Port T pull Device Enable Register bit 2
00849D 7F849D -> $0002                PERT1:       equ $02   ; %00000010 Port T pull Device Enable Register bit 1
00849D 7F849D -> $0001                PERT0:       equ $01   ; %00000001 Port T pull Device Enable Register bit 0
                                      ;*****************************************************************************************
                                      ; - Port Integration Module (S12XEPIMV1) Port S equates
                                      ;*****************************************************************************************
00849D 7F849D -> $0248                PTS:         equ $0248 ; Port S Data Register (pg 125)
00849D 7F849D -> $0080                PS7:         equ $80   ; %10000000 Port S general purpose I/O data bit 7 pin #96
00849D 7F849D -> $0040                PS6:         equ $40   ; %01000000 Port S general purpose I/O data bit 6 pin #95
00849D 7F849D -> $0020                PS5:         equ $20   ; %00100000 Port S general purpose I/O data bit 5 pin #94
00849D 7F849D -> $0010                PS4:         equ $10   ; %00010000 Port S general purpose I/O data bit 4 pin #93
00849D 7F849D -> $0008                PS3:         equ $08   ; %00001000 Port S general purpose I/O data bit 3 pin #92
00849D 7F849D -> $0004                PS2:         equ $04   ; %00000100 Port S general purpose I/O data bit 2 pin #91
00849D 7F849D -> $0002                PS1:         equ $02   ; %00000010 Port S general purpose I/O data bit 1 pin #90
00849D 7F849D -> $0001                PS0:         equ $01   ; %00000001 Port S general purpose I/O data bit 0 pin #89
00849D 7F849D -> $024A                DDRS:        equ $024A ; Port S Data Direction Register (pg 126)
                                                             ; 1 = output, 0 = input
00849D 7F849D -> $0080                DDRS7:       equ $80   ; %10000000 Port S data direction bit 7 pin #96
00849D 7F849D -> $0040                DDRS6:       equ $40   ; %01000000 Port S data direction bit 6 pin #95
00849D 7F849D -> $0020                DDRS5:       equ $20   ; %00100000 Port S data direction bit 5 pin #94
00849D 7F849D -> $0010                DDRS4:       equ $10   ; %00010000 Port S data direction bit 4 pin #93
00849D 7F849D -> $0008                DDRS3:       equ $08   ; %00001000 Port S data direction bit 3 pin #92
00849D 7F849D -> $0004                DDRS2:       equ $04   ; %00000100 Port S data direction bit 2 pin #91
00849D 7F849D -> $0002                DDRS1:       equ $02   ; %00000010 Port S data direction bit 1 pin #90
00849D 7F849D -> $0001                DDRS0:       equ $01   ; %00000001 Port S data direction bit 0 pin #89
00849D 7F849D -> $024D                PPSS:        equ $024D ; Port S Polarity Select Register (pg 128)
                                                             ; 1 = pull down selected, 0 = pull up selected
00849D 7F849D -> $0080                PPSS7:       equ $80   ; Port S pull device select bit 7 pin #96
00849D 7F849D -> $0040                PPSS6:       equ $40   ; Port S pull device select bit 6 pin #95
00849D 7F849D -> $0020                PPSS5:       equ $20   ; Port S pull device select bit 5 pin #94
00849D 7F849D -> $0010                PPSS4:       equ $10   ; Port S pull device select bit 4 pin #93
00849D 7F849D -> $0008                PPSS3:       equ $08   ; Port S pull device select bit 3 pin #92
00849D 7F849D -> $0004                PPSS2:       equ $04   ; Port S pull device select bit 2 pin #91
00849D 7F849D -> $0002                PPSS1:       equ $02   ; Port S pull device select bit 1 pin #90
00849D 7F849D -> $0001                PPSS0:       equ $01   ; Port S pull device select bit 0 pin #89
00849D 7F849D -> $024C                PERS:        equ $024C ; Port S Pull Device Enable Register (pg 128)
                                      ;*****************************************************************************************
                                      ; - Port Integration Module (S12XEPIMV1) Port M equates
                                      ;*****************************************************************************************
00849D 7F849D -> $0250                PTM:          equ $0250 ; Port M Data Register (pg 131)
00849D 7F849D -> $0080                PM7:          equ $80   ; %10000000 Port M general purpose I/O data bit 7 pin #87
00849D 7F849D -> $0040                PM6:          equ $40   ; %01000000 Port M general purpose I/O data bit 6 pin #88
00849D 7F849D -> $0020                PM5:          equ $20   ; %00100000 Port M general purpose I/O data bit 5 pin #100
00849D 7F849D -> $0010                PM4:          equ $10   ; %00010000 Port M general purpose I/O data bit 4 pin #101
00849D 7F849D -> $0008                PM3:          equ $08   ; %00001000 Port M general purpose I/O data bit 3 pin #102
00849D 7F849D -> $0004                PM2:          equ $04   ; %00000100 Port M general purpose I/O data bit 2 pin #103
00849D 7F849D -> $0002                PM1:          equ $02   ; %00000010 Port M general purpose I/O data bit 1 pin #104
00849D 7F849D -> $0001                PM0:          equ $01   ; %00000001 Port M general purpose I/O data bit 0 pin #105
00849D 7F849D -> $0252                DDRM:         equ $0252 ; Port M Data Direction Register (pg 132)
                                                              ; 1 = output, 0 = input
00849D 7F849D -> $0080                DDRM7:        equ $80   ; %10000000 Port M data direction bit 7 pin # 87
00849D 7F849D -> $0040                DDRM6:        equ $40   ; %01000000 Port M data direction bit 6 pin # 88
00849D 7F849D -> $0020                DDRM5:        equ $20   ; %00100000 Port M data direction bit 5 pin # 100
00849D 7F849D -> $0010                DDRM4:        equ $10   ; %00010000 Port M data direction bit 4 pin # 101
00849D 7F849D -> $0008                DDRM3:        equ $08   ; %00001000 Port M data direction bit 3 pin # 102
00849D 7F849D -> $0004                DDRM2:        equ $04   ; %00000100 Port M data direction bit 2 pin # 103
00849D 7F849D -> $0002                DDRM1:        equ $02   ; %00000010 Port M data direction bit 1 pin # 104
00849D 7F849D -> $0001                DDRM0:        equ $01   ; %00000001 Port M data direction bit 0 pin # 105
00849D 7F849D -> $0254                PERM:         equ $0254 ; Port M Pull Device Enable Register pg 134
                                                              ; 1 = pull device enabled, 0 = pull device disabled
00849D 7F849D -> $0080                PERM7:        equ $80   ; %10000000  Port M pull device enable bit 7 pin #87
00849D 7F849D -> $0040                PERM6:        equ $40   ; %01000000  Port M pull device enable bit 6 pin #88
00849D 7F849D -> $0020                PERM5:        equ $20   ; %00100000  Port M pull device enable bit 5 pin #100
00849D 7F849D -> $0010                PERM4:        equ $10   ; %00010000  Port M pull device enable bit 4 pin #101
00849D 7F849D -> $0008                PERM3:        equ $08   ; %00001000  Port M pull device enable bit 3 pin #102
00849D 7F849D -> $0004                PERM2:        equ $04   ; %00000100  Port M pull device enable bit 2 pin #103
00849D 7F849D -> $0002                PERM1:        equ $02   ; %00000010  Port M pull device enable bit 1 pin #104
00849D 7F849D -> $0001                PERM0:        equ $01   ; %00000001  Port M pull device enable bit 0 pin #105
00849D 7F849D -> $0255                PPSM:         equ $0255 ; Port M Polarity Select Register pg 135
                                                              ; 1 = pull down device, 0 = pull up device
00849D 7F849D -> $0080                PPSM7:        equ $80   ; %10000000  Port M pull device select bit 7
00849D 7F849D -> $0040                PPSM6:        equ $40   ; %01000000  Port M pull device select bit 6
00849D 7F849D -> $0020                PPSM5:        equ $20   ; %00100000  Port M pull device select bit 5
00849D 7F849D -> $0010                PPSM4:        equ $10   ; %00010000  Port M pull device select bit 4
00849D 7F849D -> $0008                PPSM3:        equ $08   ; %00001000  Port M pull device select bit 3
00849D 7F849D -> $0004                PPSM2:        equ $04   ; %00000100  Port M pull device select bit 2
00849D 7F849D -> $0002                PPSM1:        equ $02   ; %00000010  Port M pull device select bit 1
00849D 7F849D -> $0001                PPSM0:        equ $01   ; %00000001  Port M pull device select bit 0
00849D 7F849D -> $0256                WOMM:         equ $0256 ; Port M Wired-Or Mode Register pg 135
                                                              ; 1 = open drain output, 0 = push pull output
00849D 7F849D -> $0080                WOMM7:        equ $80   ; %10000000  Port M wired or mode bit 7
00849D 7F849D -> $0040                WOMM6:        equ $40   ; %01000000  Port M wired or mode bit 6
00849D 7F849D -> $0020                WOMM5:        equ $20   ; %00100000  Port M wired or mode bit 5
00849D 7F849D -> $0010                WOMM4:        equ $10   ; %00010000  Port M wired or mode bit 4
00849D 7F849D -> $0008                WOMM3:        equ $08   ; %00001000  Port M wired or mode bit 3
00849D 7F849D -> $0004                WOMM2:        equ $04   ; %00000100  Port M wired or mode bit 2
00849D 7F849D -> $0002                WOMM1:        equ $02   ; %00000010  Port M wired or mode bit 1
00849D 7F849D -> $0001                WOMM0:        equ $01   ; %00000001  Port M wired or mode bit 0
                                      ;*****************************************************************************************
                                      ; - Port Integration Module (S12XEPIMV1) Module Routing Register for CAN0, CAN4, SPIO0,
                                      ;   SPIO1, SPIO2
                                      ;*****************************************************************************************
00849D 7F849D -> $0257                MODRR:        equ $0257 ; Module Routing Register pg 135 see table 2-40
00849D 7F849D -> $0040                MODRR6:       equ $40   ; %01000000  Module Routing Register bit 6
00849D 7F849D -> $0020                MODRR5:       equ $20   ; %00100000  Module Routing Register bit 5
00849D 7F849D -> $0010                MODRR4:       equ $10   ; %00010000  Module Routing Register bit 4
00849D 7F849D -> $0008                MODRR3:       equ $08   ; %00001000  Module Routing Register bit 3
00849D 7F849D -> $0004                MODRR2:       equ $04   ; %00000100  Module Routing Register bit 2
00849D 7F849D -> $0002                MODRR1:       equ $02   ; %00000010  Module Routing Register bit 1
00849D 7F849D -> $0001                MODRR0:       equ $01   ; %00000001  Module Routing Register bit 0
                                      ;*****************************************************************************************
                                      ; - Port Integration Module (S12XEPIMV1) Port P equates
                                      ;*****************************************************************************************
00849D 7F849D -> $0258                PTP:          equ $0258 ; Port P Data Register (pg 137)
00849D 7F849D -> $0080                PP7:          equ $80   ; %10000000 Port P general purpose I/O data bit 7 pin #109
00849D 7F849D -> $0040                PP6:          equ $40   ; %01000000 Port P general purpose I/O data bit 6 pin #110
00849D 7F849D -> $0020                PP5:          equ $20   ; %00100000 Port P general purpose I/O data bit 5 pin #111
00849D 7F849D -> $0010                PP4:          equ $10   ; %00010000 Port P general purpose I/O data bit 4 pin #112
00849D 7F849D -> $0008                PP3:          equ $08   ; %00001000 Port P general purpose I/O data bit 3 pin #1
00849D 7F849D -> $0004                PP2:          equ $04   ; %00000100 Port P general purpose I/O data bit 2 pin #2
00849D 7F849D -> $0002                PP1:          equ $02   ; %00000010 Port P general purpose I/O data bit 1 pin #3
00849D 7F849D -> $0001                PP0:          equ $01   ; %00000001 Port P general purpose I/O data bit 0 pin #4
00849D 7F849D -> $025A                DDRP:         equ $025A ; Port P Data Direction Register (DDRP) pg 139
                                                             ; 1 = output, 0 = input
00849D 7F849D -> $0080                DDRP7:        equ $80   ; %10000000 Port P data direction bit 7 pin #109
00849D 7F849D -> $0040                DDRP6:        equ $40   ; %01000000 Port P data direction bit 6 pin #110
00849D 7F849D -> $0020                DDRP5:        equ $20   ; %00100000 Port P data direction bit 5 pin #111
00849D 7F849D -> $0010                DDRP4:        equ $10   ; %00010000 Port P data direction bit 4 pin #112
00849D 7F849D -> $0008                DDRP3:        equ $08   ; %00001000 Port P data direction bit 3 pin #1
00849D 7F849D -> $0004                DDRP2:        equ $04   ; %00000100 Port P data direction bit 2 pin #2
00849D 7F849D -> $0002                DDRP1:        equ $02   ; %00000010 Port P data direction bit 1 pin #3
00849D 7F849D -> $0001                DDRP0:        equ $01   ; %00000001 Port P data direction bit 0 pin #4
                                      ;*****************************************************************************************
                                      ; - Port Integration Module (S12XEPIMV1) Port H equates
                                      ;*****************************************************************************************
00849D 7F849D -> $0260                PTH:          equ $0260 ; Port H Data Register (pg 142)
00849D 7F849D -> $0080                PH7:          equ $80   ; %10000000 Port H general purpose I/O data bit 7 pin #32
00849D 7F849D -> $0040                PH6:          equ $40   ; %01000000 Port H general purpose I/O data bit 6 pin #33
00849D 7F849D -> $0020                PH5:          equ $20   ; %00100000 Port H general purpose I/O data bit 5 pin #34
00849D 7F849D -> $0010                PH4:          equ $10   ; %00010000 Port H general purpose I/O data bit 4 pin #35
00849D 7F849D -> $0008                PH3:          equ $08   ; %00001000 Port H general purpose I/O data bit 3 pin #49
00849D 7F849D -> $0004                PH2:          equ $04   ; %00000100 Port H general purpose I/O data bit 2 pin #50
00849D 7F849D -> $0002                PH1:          equ $02   ; %00000010 Port H general purpose I/O data bit 1 pin #51
00849D 7F849D -> $0001                PH0:          equ $01   ; %00000001 Port H general purpose I/O data bit 0 pin #52
00849D 7F849D -> $0262                DDRH:         equ $0262 ;Port H Data Direction Register (pg 144)
                                                             ; 1 = output, 0 = input
00849D 7F849D -> $0080                DDRH7:        equ $80   ; %10000000 Port H Data Direction bit 7 pin #32
00849D 7F849D -> $0040                DDRH6:        equ $40   ; %01000000 Port H Data Direction bit 6 pin #33
00849D 7F849D -> $0020                DDRH5:        equ $20   ; %00100000 Port H Data Direction bit 5 pin #34
00849D 7F849D -> $0010                DDRH4:        equ $10   ; %00010000 Port H Data Direction bit 4 pin #35
00849D 7F849D -> $0008                DDRH3:        equ $08   ; %00001000 Port H Data Direction bit 3 pin #49
00849D 7F849D -> $0004                DDRH2:        equ $04   ; %00000100 Port H Data Direction bit 2 pin #50
00849D 7F849D -> $0002                DDRH1:        equ $02   ; %00000010 Port H Data Direction bit 1 pin #51
00849D 7F849D -> $0001                DDRH0:        equ $01   ; %00000001 Port H Data Direction bit 0 pin #52
00849D 7F849D -> $0264                PERH:         equ $0264 ; Port H Pull Device Enable Register (pg 147)
                                                             ; 1 = pull device enabled, 0 = pull device disabled
00849D 7F849D -> $0080                PERH7:        equ $80   ; %10000000 Port H pull device enable bit 7 pin #32
00849D 7F849D -> $0040                PERH6:        equ $40   ; %01000000 Port H pull device enable bit 6 pin #33
00849D 7F849D -> $0020                PERH5:        equ $20   ; %00100000 Port H pull device enable bit 5 pin #34
00849D 7F849D -> $0010                PERH4:        equ $10   ; %00010000 Port H pull device enable bit 4 pin #35
00849D 7F849D -> $0008                PERH3:        equ $08   ; %00001000 Port H pull device enable bit 3 pin #49
00849D 7F849D -> $0004                PERH2:        equ $04   ; %00000100 Port H pull device enable bit 2 pin #50
00849D 7F849D -> $0002                PERH1:        equ $02   ; %00000010 Port H pull device enable bit 1 pin #51
00849D 7F849D -> $0001                PERH0:        equ $01   ; %00000001 Port H pull device enable bit 0 pin #52
00849D 7F849D -> $0265                PPSH:         equ $0265 ; Port H Polarity Select Register (pg 147)
                                                             ; 1 = rising edge and pull down
                                                             ; 0 = falling edge and pull up
00849D 7F849D -> $0080                PPSH7:        equ $80   ; %10000000 Port H Pull Device Select bit 7 pin #32
00849D 7F849D -> $0040                PPSH6:        equ $40   ; %01000000 Port H Pull Device Select bit 6 pin #33
00849D 7F849D -> $0020                PPSH5:        equ $20   ; %00100000 Port H Pull Device Select bit 5 pin #34
00849D 7F849D -> $0010                PPSH4:        equ $10   ; %00010000 Port H Pull Device Select bit 4 pin #35
00849D 7F849D -> $0008                PPSH3:        equ $08   ; %00001000 Port H Pull Device Select bit 3 pin #49
00849D 7F849D -> $0004                PPSH2:        equ $04   ; %00000100 Port H Pull Device Select bit 2 pin #50
00849D 7F849D -> $0002                PPSH1:        equ $02   ; %00000010 Port H Pull Device Select bit 1 pin #51
00849D 7F849D -> $0001                PPSH0:        equ $01   ; %00000001 Port H Pull Device Select bit 0 pin #52
                                      ;*****************************************************************************************
                                      ; - Port Integration Module (S12XEPIMV1) Port J equates
                                      ;*****************************************************************************************
00849D 7F849D -> $0268                PTJ:          equ $0268 ; Port J Data Register (pg 149)
00849D 7F849D -> $0080                PJ7:          equ $80   ; %10000000 Port J general purpose I/O data bit 7 pin #98
00849D 7F849D -> $0040                PJ6:          equ $40   ; %01000000 Port J general purpose I/O data bit 6 pin #99
00849D 7F849D -> $0020                PJ5:          equ $20   ; N/C
00849D 7F849D -> $0010                PJ4:          equ $10   ; N/C
00849D 7F849D -> $0008                PJ3:          equ $08   ; N/C
00849D 7F849D -> $0004                PJ2:          equ $04   ; N/C
00849D 7F849D -> $0002                PJ1:          equ $02   ; %00000010 Port J general purpose I/O data bit 1 pin #21
00849D 7F849D -> $0001                PJ0:          equ $01   ; %00000001 Port J general purpose I/O data bit 0 pin #20
00849D 7F849D -> $026A                DDRJ:         equ $026A ; Port J Data Direction Register (pg 150)
                                                              ; 1 = output, 0 = input
00849D 7F849D -> $0080                DDRJ7:        equ $80   ; %10000000 Port J data direction bit 7 pin #98
00849D 7F849D -> $0040                DDRJ6:        equ $40   ; %01000000 Port J data direction bit 6 pin #99
00849D 7F849D -> $0020                DDRJ5:        equ $20   ; %00100000 Port J data direction bit 5
00849D 7F849D -> $0010                DDRJ4:        equ $10   ; %00010000 Port J data direction bit 4
00849D 7F849D -> $0008                DDRJ3:        equ $08   ; %00001000 Port J data direction bit 3
00849D 7F849D -> $0004                DDRJ2:        equ $04   ; %00000100 Port J data direction bit 2
00849D 7F849D -> $0002                DDRJ1:        equ $02   ; %00000010 Port J data direction bit 1 pin #21
00849D 7F849D -> $0001                DDRJ0:        equ $01   ; %00000001 Port J data direction bit 0 pin #20
00849D 7F849D -> $002C                PERJ:         equ $02C  ; Port J Pull Device Enable Register (pg 153)
                                      ;*****************************************************************************************
                                      ; - Port Integration Module (S12XEPIMV1) Port AD0 equates
                                      ;*****************************************************************************************
00849D 7F849D -> $0270                PT0AD0:       equ $0270 ; Port AD0 Data Register 0 (pg 155)
                                                              ; ATD0 analog inputs AN[15:8] on PAD[15:8]
00849D 7F849D -> $0080                PT0AD07:      equ $80   ; %10000000 Port AD0 general purpose input/output data bit 7 pin 82
00849D 7F849D -> $0040                PT0AD06:      equ $40   ; %01000000 Port AD0 general purpose input/output data bit 6 pin 80
00849D 7F849D -> $0020                PT0AD05:      equ $20   ; %00100000 Port AD0 general purpose input/output data bit 5 pin 78
00849D 7F849D -> $0010                PT0AD04:      equ $10   ; %00010000 Port AD0 general purpose input/output data bit 4 pin 76
00849D 7F849D -> $0008                PT0AD03:      equ $08   ; %00001000 Port AD0 general purpose input/output data bit 3 pin 74
00849D 7F849D -> $0004                PT0AD02:      equ $04   ; %00000100 Port AD0 general purpose input/output data bit 2 pin 72
00849D 7F849D -> $0002                PT0AD01:      equ $02   ; %00000010 Port AD0 general purpose input/output data bit 1 pin 70
00849D 7F849D -> $0001                PT0AD00:      equ $01   ; %00000001 Port AD0 general purpose input/output data bit 0 pin 68
00849D 7F849D -> $0271                PT1AD0:       equ $0271 ; Port AD0 Data Register 1 (pg 155)
                                                              ; ATD0 analog inputs AN[7:0] on PAD[7:0]
00849D 7F849D -> $0080                PT1AD07:      equ $80   ; %10000000 Port AD0 general purpose input/output data bit 7 pin 81
00849D 7F849D -> $0040                PT1AD06:      equ $40   ; %01000000 Port AD0 general purpose input/output data bit 6 pin 79
00849D 7F849D -> $0020                PT1AD05:      equ $20   ; %00100000 Port AD0 general purpose input/output data bit 5 pin 77
00849D 7F849D -> $0010                PT1AD04:      equ $10   ; %00010000 Port AD0 general purpose input/output data bit 4 pin 75
00849D 7F849D -> $0008                PT1AD03:      equ $08   ; %00001000 Port AD0 general purpose input/output data bit 3 pin 73
00849D 7F849D -> $0004                PT1AD02:      equ $04   ; %00000100 Port AD0 general purpose input/output data bit 2 pin 71
00849D 7F849D -> $0002                PT1AD01:      equ $02   ; %00000010 Port AD0 general purpose input/output data bit 1 pin 69
00849D 7F849D -> $0001                PT1AD00:      equ $01   ; %00000001 Port AD0 general purpose input/output data bit 0 pin 67
00849D 7F849D -> $0272                DDR0AD0:      equ $0272 ; Port AD0 Data Direcction Register 0 (pg 156)
                                                              ; Data direction pins 15 through 8. 1 = output, 0 = input
00849D 7F849D -> $0080                DDR0AD07:     equ $80   ; %10000000 Port AD0 data direction bit 7
00849D 7F849D -> $0040                DDR0AD06:     equ $40   ; %01000000 Port AD0 data direction bit 6
00849D 7F849D -> $0020                DDR0AD05:     equ $20   ; %00100000 Port AD0 data direction bit 5
00849D 7F849D -> $0010                DDR0AD04:     equ $10   ; %00010000 Port AD0 data direction bit 4
00849D 7F849D -> $0008                DDR0AD03:     equ $08   ; %00001000 Port AD0 data direction bit 3
00849D 7F849D -> $0004                DDR0AD02:     equ $04   ; %00000100 Port AD0 data direction bit 2
00849D 7F849D -> $0002                DDR0AD01:     equ $02   ; %00000010 Port AD0 data direction bit 1
00849D 7F849D -> $0001                DDR0AD00:     equ $01   ; %00000001 Port AD0 data direction bit 0
00849D 7F849D -> $0273                DDR1AD0:      equ $0273 ; Port AD0 Data Direcction Register 1 (pg 156)
                                                              ; Data direction pins 7 through 0. 1 = output, 0 = input
00849D 7F849D -> $0080                DDR1AD07:     equ $80   ; %10000000 Port AD0 data direction bit 7
00849D 7F849D -> $0040                DDR1AD06:     equ $40   ; %01000000 Port AD0 data direction bit 6
00849D 7F849D -> $0020                DDR1AD05:     equ $20   ; %00100000 Port AD0 data direction bit 5
00849D 7F849D -> $0010                DDR1AD04:     equ $10   ; %00010000 Port AD0 data direction bit 4
00849D 7F849D -> $0008                DDR1AD03:     equ $08   ; %00001000 Port AD0 data direction bit 3
00849D 7F849D -> $0004                DDR1AD02:     equ $04   ; %00000100 Port AD0 data direction bit 2
00849D 7F849D -> $0002                DDR1AD01:     equ $02   ; %00000010 Port AD0 data direction bit 1
00849D 7F849D -> $0001                DDR1AD00:     equ $01   ; %00000001 Port AD0 data direction bit 0
00849D 7F849D -> $0274                RDR0AD0:      equ $0274 ; Port AD0 Reduced Drive Register 0 (pg 157)
                                                              ; Drive strength for pins 15 through 8. 1 = reduced, 0 = full
00849D 7F849D -> $0080                RDR0AD07:     equ $80   ; %10000000 Port AD0 reduced drive bit 7
00849D 7F849D -> $0040                RDR0AD06:     equ $40   ; %01000000 Port AD0 reduced drive bit 6
00849D 7F849D -> $0020                RDR0AD05:     equ $20   ; %00100000 Port AD0 reduced drive bit 5
00849D 7F849D -> $0010                RDR0AD04:     equ $10   ; %00010000 Port AD0 reduced drive bit 4
00849D 7F849D -> $0008                RDR0AD03:     equ $08   ; %00001000 Port AD0 reduced drive bit 3
00849D 7F849D -> $0004                RDR0AD02:     equ $04   ; %00000100 Port AD0 reduced drive bit 2
00849D 7F849D -> $0002                RDR0AD01:     equ $02   ; %00000010 Port AD0 reduced drive bit 1
00849D 7F849D -> $0001                RDR0AD00:     equ $01   ; %00000001 Port AD0 reduced drive bit 0
00849D 7F849D -> $0275                RDR1AD0:      equ $0275 ; Port AD0 Reduced Drive Register 1 (pg 158)
                                                              ; Drive strength for pins 7 through 0. 1 = reduced, 0 = full
00849D 7F849D -> $0080                RDR1AD07:     equ $80   ; %10000000 Port AD0 reduced drive bit 7
00849D 7F849D -> $0040                RDR1AD06:     equ $40   ; %01000000 Port AD0 reduced drive bit 6
00849D 7F849D -> $0020                RDR1AD05:     equ $20   ; %00100000 Port AD0 reduced drive bit 5
00849D 7F849D -> $0010                RDR1AD04:     equ $10   ; %00010000 Port AD0 reduced drive bit 4
00849D 7F849D -> $0008                RDR1AD03:     equ $08   ; %00001000 Port AD0 reduced drive bit 3
00849D 7F849D -> $0004                RDR1AD02:     equ $04   ; %00000100 Port AD0 reduced drive bit 2
00849D 7F849D -> $0002                RDR1AD01:     equ $02   ; %00000010 Port AD0 reduced drive bit 1
00849D 7F849D -> $0001                RDR1AD00:     equ $01   ; %00000001 Port AD0 reduced drive bit 0
00849D 7F849D -> $0276                PER0AD0:      equ $0276 ; Port AD0 Pull Up Enable Register 0 (pg 158)
                                                              ; Pull device enable for pins 15 through 8. 1 = enabled, 0 = disabled
00849D 7F849D -> $0080                PER0AD07:     equ $80   ; %00000000 Port AD0 pull device enable bit 7
00849D 7F849D -> $0040                PER0AD06:     equ $40   ; %01000000 Port AD0 pull device enable bit 6
00849D 7F849D -> $0020                PER0AD05:     equ $20   ; %00100000 Port AD0 pull device enable bit 5
00849D 7F849D -> $0010                PER0AD04:     equ $10   ; %00010000 Port AD0 pull device enable bit 4
00849D 7F849D -> $0008                PER0AD03:     equ $08   ; %00001000 Port AD0 pull device enable bit 3
00849D 7F849D -> $0004                PER0AD02:     equ $04   ; %00000100 Port AD0 pull device enable bit 2
00849D 7F849D -> $0002                PER0AD01:     equ $02   ; %00000010 Port AD0 pull device enable bit 1
00849D 7F849D -> $0001                PER0AD00:     equ $01   ; %00000001 Port AD0 pull device enable bit 0
00849D 7F849D -> $0277                PER1AD0:      equ $0277 ; Port AD0 Pull Up Enable Register 1 (pg 159)
                                                              ; Pull device enable for pins 7 through 0. 1 = enabled, 0 = disabled
00849D 7F849D -> $0080                PER1AD07:     equ $80   ; %00000000 Port AD0 pull device enable bit 7
00849D 7F849D -> $0040                PER1AD06:     equ $40   ; %01000000 Port AD0 pull device enable bit 6
00849D 7F849D -> $0020                PER1AD05:     equ $20   ; %00100000 Port AD0 pull device enable bit 5
00849D 7F849D -> $0010                PER1AD04:     equ $10   ; %00010000 Port AD0 pull device enable bit 4
00849D 7F849D -> $0008                PER1AD03:     equ $08   ; %00001000 Port AD0 pull device enable bit 3
00849D 7F849D -> $0004                PER1AD02:     equ $04   ; %00000100 Port AD0 pull device enable bit 2
00849D 7F849D -> $0002                PER1AD01:     equ $02   ; %00000010 Port AD0 pull device enable bit 1
00849D 7F849D -> $0001                PER1AD00:     equ $01   ; %00000001 Port AD0 pull device enable bit 0
                                      ;*****************************************************************************************
                                      ; - S12XE Clocks and Reset Generator (S12XECRGV1) equates
                                      ;*****************************************************************************************
00849D 7F849D -> $0034                SYNR:        equ $0034 ; S12XECRG Synthesizer Register (pg 473)
00849D 7F849D -> $0080                VCOFRQ1:     equ $80   ; %10000000 VCO Frequency bit 7
00849D 7F849D -> $0040                VCOFRQ0:     equ $40   ; %01000000 VCO Frequency bit 6
00849D 7F849D -> $0020                SYNDIV5:     equ $20   ; %00100000 IPLL multification factor bit 5
00849D 7F849D -> $0010                SYNDIV4:     equ $10   ; %00010000 IPLL multification factor bit 5
00849D 7F849D -> $0008                SYNDIV3:     equ $08   ; %00001000 IPLL multification factor bit 5
00849D 7F849D -> $0004                SYNDIV2:     equ $04   ; %00000100 IPLL multification factor bit 5
00849D 7F849D -> $0002                SYNDIV1:     equ $02   ; %00000010 IPLL multification factor bit 5
00849D 7F849D -> $0001                SYNDIV0:     equ $01   ; %00000001 IPLL multification factor bit 5
00849D 7F849D -> $0035                REFDV:       equ $0035 ; S12XECRG Reference Divider Register (pg 474)
00849D 7F849D -> $0080                REFFRQ1:     equ $80   ; %10000000 Reference Frequency bit 7
00849D 7F849D -> $0040                REFFRQ0:     equ $40   ; %01000000 Reference Frequency bit 6
00849D 7F849D -> $0020                REFDIV5:     equ $20   ; %00100000 Reference Divider bit 5
00849D 7F849D -> $0010                REFDIV4:     equ $10   ; %00010000 Reference Divider bit 4
00849D 7F849D -> $0008                REFDIV3:     equ $08   ; %00001000 Reference Divider bit 3
00849D 7F849D -> $0004                REFDIV2:     equ $04   ; %00000100 Reference Divider bit 2
00849D 7F849D -> $0002                REFDIV1:     equ $02   ; %00000010 Reference Divider bit 1
00849D 7F849D -> $0001                REFDIV0:     equ $01   ; %00000001 Reference Divider bit 0
00849D 7F849D -> $0036                POSTDIV:     equ $0036 ; S12XECRG Post Divider Register (pg 474)
00849D 7F849D -> $0010                POSTDIV4:    equ $10   ; %00010000 Post Divider bit 4
00849D 7F849D -> $0008                POSTDIV3:    equ $08   ; %00010000 Post Divider bit 3
00849D 7F849D -> $0004                POSTDIV2:    equ $04   ; %00010000 Post Divider bit 2
00849D 7F849D -> $0002                POSTDIV1:    equ $02   ; %00010000 Post Divider bit 1
00849D 7F849D -> $0001                POSTDIV0:    equ $01   ; %00010000 Post Divider bit 0
00849D 7F849D -> $0037                CRGFLG:      equ $0037 ; S12XECRG Flags Register (pg 475)
00849D 7F849D -> $0080                RTIF:        equ $80   ; %10000000 Real Time Interrupt Flag Bit 7
00849D 7F849D -> $0040                PORF:        equ $40   ; %01000000 Power on Reset Flag Bit 6
00849D 7F849D -> $0020                LVRF:        equ $20   ; %00100000 Low Voltage Reset Flag Bit 5
00849D 7F849D -> $0010                LOCKIF:      equ $10   ; %00010000 PLL Lock Interrupt Flag Bit 4
00849D 7F849D -> $0008                LOCK:        equ $08   ; %00001000 Lock Status Bit 3
00849D 7F849D -> $0004                ILAF:        equ $04   ; %00000100 Illegal Address Reset Flag Bit 2
00849D 7F849D -> $0002                SCMIF:       equ $02   ; %00000010 Self Clock Mode Interrupt Flag Bit 1
00849D 7F849D -> $0001                SCM:         equ $01   ; %00000001 Self Clock Mode Status Bit 0
00849D 7F849D -> $0038                CRGINT:      equ $0038 ; S12XECRG Interrupt Enable Register (pg 476)
00849D 7F849D -> $0080                RTIE:        equ $80   ; %10000000 Real Time Interrupt Enable Bit 7
00849D 7F849D -> $0010                LOCKIE:      equ $10   ; %00010000 Lock Interrupt Enable Bit 4
00849D 7F849D -> $0002                SCMIE:       equ $02   ; %00000010 Self Clock Mode Interrupt Enable Bit1
00849D 7F849D -> $0039                CLKSEL:      equ $0039 ; S12XECRG Clock Select Register (pg 477)
00849D 7F849D -> $0080                PLLSEL:      equ $80   ; %10000000 PLL Select Bit 7
00849D 7F849D -> $0040                PSTP:        equ $40   ; %01000000 Pseudo Stop Bit 6
00849D 7F849D -> $0020                XCLKS:       equ $20   ; %00100000 Oscillator Configurtion Status bit 5
00849D 7F849D -> $0008                PLLWAI:      equ $08   ; %00001000 PLL Stops in Wait Mode Bit 3
00849D 7F849D -> $0002                RTIWAI:      equ $02   ; %00000010 RTI Stops in Wait Mode Bit 1
00849D 7F849D -> $0001                COPWAI:      equ $01   ; %00000001 COP Stops in Wait Mode Bit 0
00849D 7F849D -> $003A                PLLCTL:      equ $003A ; S12XECRG PLL Control Register (pg 478)
00849D 7F849D -> $0080                CME:         equ $80   ; %10000000 Clock Monitor Enable Bit 7
00849D 7F849D -> $0040                PLLON:       equ $40   ; %01000000 Phase Lock Loop On Bit 6
00849D 7F849D -> $0020                FM1:         equ $20   ; %00100000 IPLL Frequency Modulation Enable Bit 5
00849D 7F849D -> $0010                FM0:         equ $10   ; %00010000 IPLL Frequency Modulation Enable Bit 4
00849D 7F849D -> $0008                FSTWKP:      equ $08   ; %00001000 Fast Wake-up From Full Stop Bit 3
00849D 7F849D -> $0004                PRE:         equ $04   ; %00000100 RTI Enable During Pseudo Stop Bit 2
00849D 7F849D -> $0002                PCE:         equ $02   ; %00000010 COP Enable During Psuedo Stop Bit 1
00849D 7F849D -> $0001                SCME:        equ $01   ; %00000001 Self Clock Mode Enable Bit 0
00849D 7F849D -> $003B                RTICTL:      equ $003B ; S12XECRG RTI Control Register (pg 480)
00849D 7F849D -> $0080                RTDEC:       equ $80   ; %10000000 Decimal or Binary Divider Select Bit 7
00849D 7F849D -> $0040                RTR6:        equ $40   ; %01000000 Real Time Int Prscle Rate Select Bit 6
00849D 7F849D -> $0020                RTR5:        equ $20   ; %00100000 Real Time Int Prscle Rate Select Bit 5
00849D 7F849D -> $0010                RTR4:        equ $10   ; %00010000 Real Time Int Prscle Rate Select Bit 4
00849D 7F849D -> $0008                RTR3:        equ $08   ; %00001000 Real Time Int Mod Cntr Select Bit 3
00849D 7F849D -> $0004                RTR2:        equ $04   ; %00000100 Real Time Int Mod Cntr Select Bit 2
00849D 7F849D -> $0002                RTR1:        equ $02   ; %00000010 Real Time Int Mod Cntr Select Bit 1
00849D 7F849D -> $0001                RTR0:        equ $01   ; %00000001 Real Time Int Mod Cntr Select Bit 0
00849D 7F849D -> $003C                COPCTL:      equ $003C ; S12XSCRG COP Control Register (pg 482)
00849D 7F849D -> $0080                WCOP:        equ $80   ; Window COP Mode bit 7
00849D 7F849D -> $0040                RSBCK:       equ $40   ; COP and RTI Stop in Active BDM Mode bit 6
00849D 7F849D -> $0020                WRTMASK:     equ $20   ; Write Mask for WCOP and CR[2:0] bit 5
00849D 7F849D -> $0004                CR2:         equ $04   ; COP Watchdog Timer Rate Select bit 2
00849D 7F849D -> $0002                CR1:         equ $02   ; COP Watchdog Timer Rate Select bit 1
00849D 7F849D -> $0001                CR0:         equ $01   ; COP Watchdog Timer Rate Select bit 0
                                      ;*****************************************************************************************
                                      ; - Interrupt (S12XINTV2) equates
                                      ;*****************************************************************************************
00849D 7F849D -> $0121                IVBR:        equ $0121 ; Interrupt Vector Base Register (pg 267)
00849D 7F849D -> $0080                IVB_ADDR7:   equ $80   ; %10000000 Interrupt Vector Base Address Bit 7
00849D 7F849D -> $0040                IVB_ADDR6:   equ $40   ; %01000000 Interrupt Vector Base Address Bit 6
00849D 7F849D -> $0020                IVB_ADDR5:   equ $20   ; %00100000 Interrupt Vector Base Address Bit 5
00849D 7F849D -> $0010                IVB_ADDR4:   equ $10   ; %00010000 Interrupt Vector Base Address Bit 4
00849D 7F849D -> $0008                IVB_ADDR3:   equ $08   ; %00001000 Interrupt Vector Base Address Bit 3
00849D 7F849D -> $0004                IVB_ADDR2:   equ $04   ; %00000100 Interrupt Vector Base Address Bit 2
00849D 7F849D -> $0002                IVB_ADDR1:   equ $02   ; %00000010 Interrupt Vector Base Address Bit 1
00849D 7F849D -> $0001                IVB_ADDR0:   equ $01   ; %00000001 Interrupt Vector Base Address Bit 0
00849D 7F849D -> $0126                INT_XGPRIO:  equ $0126 ; XGATE Int Priority Config Register (pg 267)
00849D 7F849D -> $0004                XILVL2:      equ $04   ; %00000100 XGATE Int Priority Level Bit 2
00849D 7F849D -> $0002                XILVL1:      equ $02   ; %00000010 XGATE Int Priority Level Bit 1
00849D 7F849D -> $0001                XILVL0:      equ $01   ; %00000001 XGATE Int Priority Level Bit 0
00849D 7F849D -> $0127                INT_CFADDR:  equ $0127 ; Int Request Config Addr Register (pg 268)
00849D 7F849D -> $0080                INT_CFADDR7: equ $80   ; %10000000 Int Req Config Data Reg Sel Bit 7
00849D 7F849D -> $0040                INT_CFADDR6: equ $40   ; %01000000 Int Req Config Data Reg Sel Bit 6
00849D 7F849D -> $0020                INT_CFADDR5: equ $20   ; %00100000 Int Req Config Data Reg Sel Bit 5
00849D 7F849D -> $0010                INT_CFADDR4: equ $10   ; %00010000 Int Req Config Data Reg Sel Bit 4
00849D 7F849D -> $0128                INT_CFDATA0: equ $0128 ; Interrupt Req Config Data Reg 0 (pg 269)
00849D 7F849D -> $0129                INT_CFDATA1: equ $0129 ; Interrupt Req Config Data Reg 1 (pg 269)
00849D 7F849D -> $012A                INT_CFDATA2: equ $012A ; Interrupt Req Config Data Reg 2 (pg 269)
00849D 7F849D -> $012B                INT_CFDATA3: equ $012B ; Interrupt Req Config Data Reg 3 (pg 269)
00849D 7F849D -> $012C                INT_CFDATA4: equ $012C ; Interrupt Req Config Data Reg 4 (pg 270)
00849D 7F849D -> $012D                INT_CFDATA5: equ $012D ; Interrupt Req Config Data Reg 5 (pg 270)
00849D 7F849D -> $012E                INT_CFDATA6: equ $012E ; Interrupt Req Config Data Reg 6 (pg 270)
00849D 7F849D -> $012F                INT_CFDATA7: equ $012F ; Interrupt Req Config Data Reg 7 (pg 270)
00849D 7F849D -> $0080                RQST:        equ $80   ; %10000000 XGATE Request Enable Bit 7
00849D 7F849D -> $0004                PRIOLVL2:    equ $04   ; %00000100 Int Requ Priority Level Bit 2
00849D 7F849D -> $0002                PRIOLVL1:    equ $02   ; %00000010 Int Requ Priority Level Bit 1
00849D 7F849D -> $0001                PRIOLVL0:    equ $01   ; %00000001 Int Requ Priority Level Bit 0
                                      ;*****************************************************************************************
                                      ; - Memory Mapping Control (S12XMMCV4) equates
                                      ;*****************************************************************************************
00849D 7F849D -> $000B                MODE:        equ $000B ; Mode Register (pg 195)
00849D 7F849D -> $0080                MODC:        equ $80   ; External mode pin #23 (MODC/BKGD) bit 7
00849D 7F849D -> $0040                MODB:        equ $40   ; External mode pin #37 (MODB/PE6) bit 6
00849D 7F849D -> $0020                MODA:        equ $20   ; External mode pin #38 (MODA/PE5) bit 5
                                      ;*****************************************************************************************
                                      ; - Analog to Digital Converter (ADC12B16V1) equates
                                      ;*****************************************************************************************
00849D 7F849D -> $02C0                ATD0CTL0:  equ $02C0 ; ATD0 Control Register 0 (pg 508)
00849D 7F849D -> $0008                WRAP3:     equ $08   ; %00001000 Wrap Around Channel Select Bit 3
00849D 7F849D -> $0004                WRAP2:     equ $04   ; %00000100 Wrap Around Channel Select Bit 2
00849D 7F849D -> $0002                WRAP1:     equ $02   ; %00000010 Wrap Around Channel Select Bit 1
00849D 7F849D -> $0001                WRAP0:     equ $01   ; %00000001 Wrap Around Channel Select Bit 0
00849D 7F849D -> $02C1                ATD0CTL1:   equ $02C1 ; ATD0 Control Register 1 (pg 509)
00849D 7F849D -> $0080                ETRIGSEL:  equ $80   ; %10000000 External Trigger Source Select Bit 7
00849D 7F849D -> $0040                SRES1:     equ $40   ; %01000000 A/D Resolution Select bit 6
00849D 7F849D -> $0020                SRES0:     equ $20   ; %00100000 A/D Resolution Select bit 5
00849D 7F849D -> $0010                SMP_DIS:   equ $10   ; %00010000 Discharge Before Sampling bit 4
00849D 7F849D -> $0008                ETRIGCH3:  equ $08   ; %00001000 External Trigger Channel Select Bit 3
00849D 7F849D -> $0004                ETRIGCH2:  equ $04   ; %00000100 External Trigger Channel Select Bit 2
00849D 7F849D -> $0002                ETRIGCH1:  equ $02   ; %00000010 External Trigger Channel Select Bit 1
00849D 7F849D -> $0001                ETRIGCH0:  equ $01   ; %00000001 External Trigger Channel Select Bit 0
00849D 7F849D -> $02C2                ATD0CTL2:   equ $02C2 ; ATD0 Control Register 2 (pg 511)
00849D 7F849D -> $0040                AFFC:      equ $40   ; %01000000 ATD Fast Flag Clear All Bit 6
00849D 7F849D -> $0020                ICLKSTP:   equ $20   ; %00100000 Internal Clock in Stop Mode bit 5
00849D 7F849D -> $0010                ETRIGLE:   equ $10   ; %00010000 External Trigger Level/Edge Control Bit 4
00849D 7F849D -> $0008                ETRIGP:    equ $08   ; %00001000 External Trigger Polarity Bit 3
00849D 7F849D -> $0004                ETRIGE:    equ $04   ; %00000100 External Trigger Mode Enable Bit 2
00849D 7F849D -> $0002                ASCIE:     equ $02   ; %00000010 ATD Seq Complete Interrupt Enable Bit 1
00849D 7F849D -> $0001                ACMPIE:    equ $01   ; %00000001  ATD Compare Interrupt Enable bit 0
00849D 7F849D -> $02C3                ATD0CTL3:   equ $02C3 ; ATD0 Control Register 3 (pg 512)
00849D 7F849D -> $0080                DJM:       equ $80   ; %10000000 Result Register Data Justification bit 7
00849D 7F849D -> $0040                S8C:       equ $40   ; %01000000 Conversion Sequence Length bit 6
00849D 7F849D -> $0020                S4C:       equ $20   ; %00100000 Conversion Sequence Length bit 5
00849D 7F849D -> $0010                S2C:       equ $10   ; %00010000 Conversion Sequence Length bit 4
00849D 7F849D -> $0008                S1C:       equ $08   ; %00001000 Conversion Sequence Length bit 3
00849D 7F849D -> $0004                FIFO:      equ $04   ; %00000100 Result Register FIFO Mode bit 2
00849D 7F849D -> $0002                FRZ1:      equ $02   ; %00000010 Background Debug Freeze Enable bit 1
00849D 7F849D -> $0001                FRZ0:      equ $01   ; %00000001 Background Debug Freeze Enable bit 0
00849D 7F849D -> $02C4                ATD0CTL4:   equ $02C4 ; ATD0 Control Register 4 (pg 514)
00849D 7F849D -> $0080                SMP2:      equ $80   ; %10000000 Sample Time Select Bit 7
00849D 7F849D -> $0040                SMP1:      equ $40   ; %01000000 Sample Time Select Bit 6
00849D 7F849D -> $0020                SMP0:      equ $20   ; %00100000 Sample Time Select Bit 5
00849D 7F849D -> $0010                PRS4:      equ $10   ; %00010000 ATD Clock Prescaler Bit 4
00849D 7F849D -> $0008                PRS3:      equ $08   ; %00001000 ATD Clock Prescaler Bit 3
00849D 7F849D -> $0004                PRS2:      equ $04   ; %00000100 ATD Clock Prescaler Bit 2
00849D 7F849D -> $0002                PRS1:      equ $02   ; %00000010 ATD Clock Prescaler Bit 1
00849D 7F849D -> $0001                PRS0:      equ $01   ; %00000001 ATD Clock Prescaler Bit 0
00849D 7F849D -> $02C5                ATD0CTL5:   equ $02C5 ; ATD0 Control Register 5 (pg 515)
00849D 7F849D -> $0040                SC:        equ $40   ; %01000000 Special Channel Conversion bit 6
00849D 7F849D -> $0020                SCAN:      equ $20   ; %00100000 Continous Conversion Sequence Mode Bit 5
00849D 7F849D -> $0010                MULT:      equ $10   ; %00010000 Multi-Channel Sample Mode Bit 4
00849D 7F849D -> $0008                CD:        equ $08   ; %00001000 Analog Input Channel Select Code Bit 3
00849D 7F849D -> $0004                CC:        equ $04   ; %00000100 Analog Input Channel Select Code Bit 2
00849D 7F849D -> $0002                CB:        equ $02   ; %00000010 Analog Input Channel Select Code Bit 1
00849D 7F849D -> $0001                CA:        equ $01   ; %00000001 Analog Input Channel Select Code Bit 0
00849D 7F849D -> $02C6                ATD0STAT0:  equ $02C6 ; ATD0 Status Register 0 (pg 517)
00849D 7F849D -> $0080                SCF:       equ $80   ; %10000000 Sequence Complete Flag Bit 7
00849D 7F849D -> $0020                ETORF:     equ $20   ; %00100000 External Trigger Overrun Flag Bit 5
00849D 7F849D -> $0010                FIFOR:     equ $10   ; %00010000 Result Register Over Run Flag Bit 4
00849D 7F849D -> $0008                CC3:       equ $08   ; %00001000 Conversion Counter Bit 3
00849D 7F849D -> $0004                CC2:       equ $04   ; %00000100 Conversion Counter Bit 2
00849D 7F849D -> $0002                CC1:       equ $02   ; %00000010 Conversion Counter Bit 1
00849D 7F849D -> $0001                CC0:       equ $01   ; %00000001 Conversion Counter Bit 0
                                      ;$02C7 reserved
00849D 7F849D -> $02C8                ATD0CMPEH: equ $02C8 ; ATD0 Compare Enable Register Hi Byte (pg 518)
00849D 7F849D -> $0080                CMPE15:   equ $80   ; Compare Enable for Conversion Number n bit 15
00849D 7F849D -> $0040                CMPE14:   equ $40   ; Compare Enable for Conversion Number n bit 14
00849D 7F849D -> $0020                CMPE13:   equ $20   ; Compare Enable for Conversion Number n bit 13
00849D 7F849D -> $0010                CMPE12:   equ $10   ; Compare Enable for Conversion Number n bit 12
00849D 7F849D -> $0008                CMPE11:   equ $08   ; Compare Enable for Conversion Number n bit 11
00849D 7F849D -> $0004                CMPE10:   equ $04   ; Compare Enable for Conversion Number n bit 10
00849D 7F849D -> $0002                CMPE9:    equ $02   ; Compare Enable for Conversion Number n bit 9
00849D 7F849D -> $0001                CMPE8:    equ $01   ; Compare Enable for Conversion Number n bit 8
00849D 7F849D -> $02C9                ATD0CMPEL: equ $02C9 ; ATD0 Compare Enable Register Lo Byte (pg 518)
00849D 7F849D -> $0080                CMPE7:    equ $80   ; Compare Enable for Conversion Number n bit 7
00849D 7F849D -> $0040                CMPE6:    equ $40   ; Compare Enable for Conversion Number n bit 6
00849D 7F849D -> $0020                CMPE5:    equ $20   ; Compare Enable for Conversion Number n bit 5
00849D 7F849D -> $0010                CMPE4:    equ $10   ; Compare Enable for Conversion Number n bit 4
00849D 7F849D -> $0008                CMPE3:    equ $08   ; Compare Enable for Conversion Number n bit 3
00849D 7F849D -> $0004                CMPE2:    equ $04   ; Compare Enable for Conversion Number n bit 2
00849D 7F849D -> $0002                CMPE1:    equ $02   ; Compare Enable for Conversion Number n bit 1
00849D 7F849D -> $0001                CMPE0:    equ $01   ; Compare Enable for Conversion Number n bit 0
00849D 7F849D -> $02CA                ATD0STAT2H: equ $02CA ; ATD0 Status Register 2 Hi Byte (pg 520)
00849D 7F849D -> $0080                CCF15:    equ $80   ; Conversion Complete Flag n bit 15
00849D 7F849D -> $0040                CCF14:    equ $40   ; Conversion Complete Flag n bit 14
00849D 7F849D -> $0020                CCF13:    equ $20   ; Conversion Complete Flag n bit 13
00849D 7F849D -> $0010                CCF12:    equ $10   ; Conversion Complete Flag n bit 12
00849D 7F849D -> $0008                CCF11:    equ $08   ; Conversion Complete Flag n bit 11
00849D 7F849D -> $0004                CCF10:    equ $04   ; Conversion Complete Flag n bit 10
00849D 7F849D -> $0002                CCF9:     equ $02   ; Conversion Complete Flag n bit 9
00849D 7F849D -> $0001                CCF8:     equ $01   ; Conversion Complete Flag n bit 8
00849D 7F849D -> $02CB                ATD0STAT2L: equ $02CB ; ATD0 Status Register 2 Lo Byte (pg 520)
00849D 7F849D -> $0080                CCF7:     equ $80   ; Conversion Complete Flag n bit 7
00849D 7F849D -> $0040                CCF6:     equ $40   ; Conversion Complete Flag n bit 6
00849D 7F849D -> $0020                CCF5:     equ $20   ; Conversion Complete Flag n bit 5
00849D 7F849D -> $0010                CCF4:     equ $10   ; Conversion Complete Flag n bit 4
00849D 7F849D -> $0008                CCF3:     equ $08   ; Conversion Complete Flag n bit 3
00849D 7F849D -> $0004                CCF2:     equ $04   ; Conversion Complete Flag n bit 2
00849D 7F849D -> $0002                CCF1:     equ $02   ; Conversion Complete Flag n bit 1
00849D 7F849D -> $0001                CCF0:     equ $01   ; Conversion Complete Flag n bit 0
00849D 7F849D -> $02CC                ATD0DIENH: equ $02CC ; ATD0 Input Enable Register Hi Byte (pg 521)
                                                          ; 1 = enable digital input buffer, 0 = disable digital input buffer
00849D 7F849D -> $0080                IEN15:    equ $80   ; %10000000 ATD Digital Input Enable on Channel Bit 7
00849D 7F849D -> $0040                IEN14:    equ $40   ; %01000000 ATD Digital Input Enable on Channel Bit 6
00849D 7F849D -> $0020                IEN13:    equ $20   ; %00100000 ATD Digital Input Enable on Channel Bit 5
00849D 7F849D -> $0010                IEN12:    equ $10   ; %00010000 ATD Digital Input Enable on Channel Bit 4
00849D 7F849D -> $0008                IEN11:    equ $08   ; %00001000 ATD Digital Input Enable on Channel Bit 3
00849D 7F849D -> $0004                IEN10:    equ $04   ; %00000100 ATD Digital Input Enable on Channel Bit 2
00849D 7F849D -> $0002                IEN9:     equ $02   ; %00000010 ATD Digital Input Enable on Channel Bit 1
00849D 7F849D -> $0001                IEN8:     equ $01   ; %00000001 ATD Digital Input Enable on Channel Bit 0
00849D 7F849D -> $02CD                ATD0DIENL: equ $02CD ; ATD0 Input Enable Register Lo Byte (pg 521)
                                                          ; 1 = enable digital input buffer, 0 = disable digital input buffer
00849D 7F849D -> $0080                IEN7:     equ $80   ; %10000000 ATD Digital Input Enable on Channel Bit 7
00849D 7F849D -> $0040                IEN6:     equ $40   ; %01000000 ATD Digital Input Enable on Channel Bit 6
00849D 7F849D -> $0020                IEN5:     equ $20   ; %00100000 ATD Digital Input Enable on Channel Bit 5
00849D 7F849D -> $0010                IEN4:     equ $10   ; %00010000 ATD Digital Input Enable on Channel Bit 4
00849D 7F849D -> $0008                IEN3:     equ $08   ; %00001000 ATD Digital Input Enable on Channel Bit 3
00849D 7F849D -> $0004                IEN2:     equ $04   ; %00000100 ATD Digital Input Enable on Channel Bit 2
00849D 7F849D -> $0002                IEN1:     equ $02   ; %00000010 ATD Digital Input Enable on Channel Bit 1
00849D 7F849D -> $0001                IEN0:     equ $01   ; %00000001 ATD Digital Input Enable on Channel Bit 0
00849D 7F849D -> $02CE                ATD0CMPHTH: equ $02CE ; ATD0 Compare Higher Than Register Hi Byte (pg 521)
00849D 7F849D -> $0080                CMPHT15:  equ $80   ; Compare Operation Higher Than Enable for conversion number n bit 15
00849D 7F849D -> $0040                CMPHT14:  equ $40   ; Compare Operation Higher Than Enable for conversion number n bit 14
00849D 7F849D -> $0020                CMPHT13:  equ $20   ; Compare Operation Higher Than Enable for conversion number n bit 13
00849D 7F849D -> $0010                CMPHT12:  equ $10   ; Compare Operation Higher Than Enable for conversion number n bit 12
00849D 7F849D -> $0008                CMPHT11:  equ $08   ; Compare Operation Higher Than Enable for conversion number n bit 11
00849D 7F849D -> $0004                CMPHT10:  equ $04   ; Compare Operation Higher Than Enable for conversion number n bit 10
00849D 7F849D -> $0002                CMPHT9:   equ $02   ; Compare Operation Higher Than Enable for conversion number n bit 9
00849D 7F849D -> $0001                CMPHT8:   equ $01   ; Compare Operation Higher Than Enable for conversion number n bit 8
00849D 7F849D -> $02CF                ATD0CMPHTL: equ $02CF ; ATD0 Compare Higher Than Register Lo Byte (pg 521)
00849D 7F849D -> $0080                CMPHT7:   equ $80   ; Compare Operation Higher Than Enable for conversion number n bit 7
00849D 7F849D -> $0040                CMPHT6:   equ $40   ; Compare Operation Higher Than Enable for conversion number n bit 6
00849D 7F849D -> $0020                CMPHT5:   equ $20   ; Compare Operation Higher Than Enable for conversion number n bit 5
00849D 7F849D -> $0010                CMPHT4:   equ $10   ; Compare Operation Higher Than Enable for conversion number n bit 4
00849D 7F849D -> $0008                CMPHT3:   equ $08   ; Compare Operation Higher Than Enable for conversion number n bit 3
00849D 7F849D -> $0004                CMPHT2:   equ $04   ; Compare Operation Higher Than Enable for conversion number n bit 2
00849D 7F849D -> $0002                CMPHT1:   equ $02   ; Compare Operation Higher Than Enable for conversion number n bit 1
00849D 7F849D -> $0001                CMPHT0:   equ $01   ; Compare Operation Higher Than Enable for conversion number n bit 0
00849D 7F849D -> $02D0                ATD0DR0H:  equ $02D0 ; ATD0 Conversion Result Register 0 Hi Byte (pg 522)
00849D 7F849D -> $02D1                ATD0DR0L:  equ $02D1 ; ATD0 Conversion Result Register 0 Lo Byte (pg 522)
00849D 7F849D -> $02D2                ATD0DR1H:  equ $02D2 ; ATD0 Conversion Result Register 1 Hi Byte (pg 522)
00849D 7F849D -> $02D3                ATD0DR1L:  equ $02D3 ; ATD0 Conversion Result Register 1 Lo Byte (pg 522)
00849D 7F849D -> $02D4                ATD0DR2H:  equ $02D4 ; ATD0 Conversion Result Register 2 Hi Byte (pg 522)
00849D 7F849D -> $02D5                ATD0DR2L:  equ $02D5 ; ATD0 Conversion Result Register 2 Lo Byte (pg 522)
00849D 7F849D -> $02D6                ATD0DR3H:  equ $02D6 ; ATD0 Conversion Result Register 3 Hi Byte (pg 522)
00849D 7F849D -> $02D7                ATD0DR3L:  equ $02D7 ; ATD0 Conversion Result Register 3 Lo Byte (pg 522)
00849D 7F849D -> $02D8                ATD0DR4H:  equ $02D8 ; ATD0 Conversion Result Register 4 Hi Byte (pg 522)
00849D 7F849D -> $02D9                ATD0DR4L:  equ $02D9 ; ATD0 Conversion Result Register 4 Lo Byte (pg 522)
00849D 7F849D -> $02DA                ATD0DR5H:  equ $02DA ; ATD0 Conversion Result Register 5 Hi Byte (pg 522)
00849D 7F849D -> $02DB                ATD0DR5L:  equ $02DB ; ATD0 Conversion Result Register 5 Lo Byte (pg 522)
00849D 7F849D -> $02DC                ATD0DR6H:  equ $02DC ; ATD0 Conversion Result Register 6 Hi Byte (pg 522)
00849D 7F849D -> $02DD                ATD0DR6L:  equ $02DD ; ATD0 Conversion Result Register 6 Lo Byte (pg 522)
00849D 7F849D -> $02DE                ATD0DR7H:  equ $02DE ; ATD0 Conversion Result Register 7 Hi Byte (pg 522)
00849D 7F849D -> $02DF                ATD0DR7L:  equ $02DF ; ATD0 Conversion Result Register 7 Lo Byte (pg 522)
00849D 7F849D -> $02E0                ATD0DR8H:  equ $02E0 ; ATD0 Conversion Result Register 8 Hi Byte (pg 522)
00849D 7F849D -> $02E1                ATD0DR8L:  equ $02E1 ; ATD0 Conversion Result Register 8 Lo Byte (pg 522)
00849D 7F849D -> $02E2                ATD0DR9H:  equ $02E2 ; ATD0 Conversion Result Register 9 Hi Byte (pg 522)
00849D 7F849D -> $02E3                ATD0DR9L:  equ $02E3 ; ATD0 Conversion Result Register 9 Lo Byte (pg 522)
00849D 7F849D -> $02E4                ATD0DR10H:  equ $02E4 ; ATD0 Conversion Result Register 10 Hi Byte (pg 522)
00849D 7F849D -> $02E5                ATD0DR10L:  equ $02E5 ; ATD0 Conversion Result Register 10 Lo Byte (pg 522)
00849D 7F849D -> $02E6                ATD0DR11H:  equ $02E6 ; ATD0 Conversion Result Register 11 Hi Byte (pg 522)
00849D 7F849D -> $02E7                ATD0DR11L:  equ $02E7 ; ATD0 Conversion Result Register 11 Lo Byte (pg 522)
00849D 7F849D -> $02E8                ATD0DR12H:  equ $02E8 ; ATD0 Conversion Result Register 12 Hi Byte (pg 522)
00849D 7F849D -> $02E9                ATD0DR12L:  equ $02E9 ; ATD0 Conversion Result Register 12 Lo Byte (pg 522)
00849D 7F849D -> $02EA                ATD0DR13H:  equ $02EA ; ATD0 Conversion Result Register 13 Hi Byte (pg 522)
00849D 7F849D -> $02EB                ATD0DR13L:  equ $02EB ; ATD0 Conversion Result Register 13 Lo Byte (pg 522)
00849D 7F849D -> $02EC                ATD0DR14H:  equ $02EC ; ATD0 Conversion Result Register 14 Hi Byte (pg 522)
00849D 7F849D -> $02ED                ATD0DR14L:  equ $02ED ; ATD0 Conversion Result Register 14 Lo Byte (pg 522)
00849D 7F849D -> $02EE                ATD0DR15H:  equ $02EE ; ATD0 Conversion Result Register 15 Hi Byte (pg 522)
00849D 7F849D -> $02EF                ATD0DR15L:  equ $02EF ; ATD0 Conversion Result Register 15 Lo Byte (pg 522)
                                      ;*****************************************************************************************
                                      ; - Serial Communications Interface (S12SCIV5) equates
                                      ;*****************************************************************************************
00849D 7F849D -> $00C8                SCI0BDH:   equ $00C8 ; SCI0 Baud Rate Register Hi Byte (pg 728)
00849D 7F849D -> $0080                IREN:      equ $80   ; %10000000 Infrared Enable Bit 7
00849D 7F849D -> $0040                TNP1:      equ $40   ; %01000000 Transmitter Narrow Pulse Bit 6
00849D 7F849D -> $0020                TNP0:      equ $20   ; %00100000 Transmitter Narrow Pulse Bit 5
00849D 7F849D -> $0010                SBR12:     equ $10   ; %00010000 SCI Baud Rate Bit 4
00849D 7F849D -> $0008                SBR11:     equ $08   ; %00001000 SCI Baud Rate Bit 3
00849D 7F849D -> $0004                SBR10:     equ $04   ; %00000100 SCI Baud Rate Bit 2
00849D 7F849D -> $0002                SBR9:      equ $02   ; %00000010 SCI Baud Rate Bit 1
00849D 7F849D -> $0001                SBR8:      equ $01   ; %00000001 SCI Baud Rate Bit 0
00849D 7F849D -> $00C9                SCI0BDL:   equ $00C9 ; SCI0 Baud Rate Register Lo Byte (pg 728
00849D 7F849D -> $0080                SBR7:      equ $80   ; %10000000 SCI Baud Rate Bit 7
00849D 7F849D -> $0040                SBR6:      equ $40   ; %01000000 SCI Baud Rate Bit 6
00849D 7F849D -> $0020                SBR5:      equ $20   ; %00100000 SCI Baud Rate Bit 5
00849D 7F849D -> $0010                SBR4:      equ $10   ; %00010000 SCI Baud Rate Bit 4
00849D 7F849D -> $0008                SBR3:      equ $08   ; %00001000 SCI Baud Rate Bit 3
00849D 7F849D -> $0004                SBR2:      equ $04   ; %00000100 SCI Baud Rate Bit 2
00849D 7F849D -> $0002                SBR1:      equ $02   ; %00000010 SCI Baud Rate Bit 1
00849D 7F849D -> $0001                SBR0:      equ $01   ; %00000001 SCI Baud Rate Bit 0
00849D 7F849D -> $00CA                SCI0CR1:   equ $00CA ; SCI0 Control Register 1 (pg 729)
00849D 7F849D -> $0080                LOOPS:     equ $80   ; %10000000 Loop Select Bit 7
00849D 7F849D -> $0040                SCISWAI:   equ $40   ; %01000000 SCI Stop in Wait Mode Bit 6
00849D 7F849D -> $0020                RSRC:      equ $20   ; %00100000 Receiver Source Bit 5
00849D 7F849D -> $0010                M:         equ $10   ; %00010000 Data Format Mode Bit 4
00849D 7F849D -> $0008                WAKE:      equ $08   ; %00001000 Wakeup Condition Bit 3
00849D 7F849D -> $0004                ILT:       equ $04   ; %00000100 Idle Line Type Bit 2
00849D 7F849D -> $0002                PE:        equ $02   ; %00000010 Parity Enable Bit 1
00849D 7F849D -> $0001                PT:        equ $01   ; %00000001 Parity Type Bit 0
00849D 7F849D -> $00CB                SCI0CR2:   equ $00CB ; SCI0 Control Register 2 (pg 734)
00849D 7F849D -> $0080                TXIE:      equ $80   ; %10000000 Transmitter Interrupt Enable Bit 7
00849D 7F849D -> $0040                TCIE:      equ $40   ; %01000000 Transmission Complete Int En Bit 6
00849D 7F849D -> $0020                RIE:       equ $20   ; %00100000 Receiver Full Interrupt Enable Bit 5
00849D 7F849D -> $0010                ILIE:      equ $10   ; %00010000 Idle Line Interrupt Enable Bit 4
00849D 7F849D -> $0008                TE:        equ $08   ; %00001000 Transmitter Enable Bit 3
00849D 7F849D -> $0004                RE:        equ $04   ; %00000100 Receiver Enable Bit 2
00849D 7F849D -> $0002                RWU:       equ $02   ; %00000010 Receiver Wakeup Bit 1
00849D 7F849D -> $0001                SBK:       equ $01   ; %00000001 Send Break Bit 0
00849D 7F849D -> $00CC                SCI0SR1:   equ $00CC ; SCI0 Status Register 1 (pg 735)
00849D 7F849D -> $0080                TDRE:      equ $80   ; %10000000 Transmit Data Register Empty Flag Bit 7
00849D 7F849D -> $0040                TC:        equ $40   ; %01000000 Transmit Complete Bit 6
00849D 7F849D -> $0020                RDRF:      equ $20   ; %00100000 Receive Data Register Full Flag Bit 5
00849D 7F849D -> $0010                IDLE:      equ $10   ; %00010000 Idle Line Flag Bit 4
00849D 7F849D -> $0008                OR:        equ $08   ; %00001000 Overrun Flag Bit 3
00849D 7F849D -> $0004                NF:        equ $04   ; %00000100 Noise Flag Bit 2
00849D 7F849D -> $0002                FE:        equ $02   ; %00000010 Framing Error Flag Bit 1
00849D 7F849D -> $0001                PF:        equ $01   ; %00000001 Parity Error Flag Bit 0
00849D 7F849D -> $00CE                SCI0DRH:   equ $00CE ; SCI0 Data Register Hi byte (pg 738)
00849D 7F849D -> $0080                R8:        equ $80   ; %10000000 bit 7
00849D 7F849D -> $0040                T8:        equ $40   ; 010000000 bit 6
00849D 7F849D -> $00CF                SCI0DRL:   equ $00CF ; SCI0 Data Register Lo Byte (pg 738)
00849D 7F849D -> $0080                R7:        equ $80   ; %10000000 Receive Bit 7
00849D 7F849D -> $0040                R6:        equ $40   ; %01000000 Receive Bit 6
00849D 7F849D -> $0020                R5:        equ $20   ; %00100000 Receive Bit 5
00849D 7F849D -> $0010                R4:        equ $10   ; %00010000 Receive Bit 4
00849D 7F849D -> $0008                R3:        equ $08   ; %00001000 Receive Bit 3
00849D 7F849D -> $0004                R2:        equ $04   ; %00000100 Receive Bit 2
00849D 7F849D -> $0002                R1:        equ $02   ; %00000010 Receive Bit 1
00849D 7F849D -> $0001                R0:        equ $01   ; %00000001 Receive Bit 0
00849D 7F849D -> $0080                T7:        equ $80   ; %10000000 Transmit Bit 7
00849D 7F849D -> $0040                T6:        equ $40   ; %01000000 Transmit Bit 6
00849D 7F849D -> $0020                T5:        equ $20   ; %00100000 Transmit Bit 5
00849D 7F849D -> $0010                T4:        equ $10   ; %00010000 Transmit Bit 4
00849D 7F849D -> $0008                T3:        equ $08   ; %00001000 Transmit Bit 3
00849D 7F849D -> $0004                T2:        equ $04   ; %00000100 Transmit Bit 2
00849D 7F849D -> $0002                T1:        equ $02   ; %00000010 Transmit Bit 1
00849D 7F849D -> $0001                T0:        equ $01   ; %00000001 Transmit Bit 0
00849D 7F849D -> $00D0                SCI1BDH:   equ $00D0 ; SCI1 Baud Rate Register Hi Byte (pg 728)
00849D 7F849D -> $0080                IREN:      equ $80   ; %10000000 Infrared Enable Bit 7
00849D 7F849D -> $0040                TNP1:      equ $40   ; %01000000 Transmitter Narrow Pulse Bit 6
00849D 7F849D -> $0020                TNP0:      equ $20   ; %00100000 Transmitter Narrow Pulse Bit 5
00849D 7F849D -> $0010                SBR12:     equ $10   ; %00010000 SCI Baud Rate Bit 4
00849D 7F849D -> $0008                SBR11:     equ $08   ; %00001000 SCI Baud Rate Bit 3
00849D 7F849D -> $0004                SBR10:     equ $04   ; %00000100 SCI Baud Rate Bit 2
00849D 7F849D -> $0002                SBR9:      equ $02   ; %00000010 SCI Baud Rate Bit 1
00849D 7F849D -> $0001                SBR8:      equ $01   ; %00000001 SCI Baud Rate Bit 0
00849D 7F849D -> $00D1                SCI1BDL:   equ $00D1 ; SCI1 Baud Rate Register Lo Byte (pg 728
00849D 7F849D -> $0080                SBR7:      equ $80   ; %10000000 SCI Baud Rate Bit 7
00849D 7F849D -> $0040                SBR6:      equ $40   ; %01000000 SCI Baud Rate Bit 6
00849D 7F849D -> $0020                SBR5:      equ $20   ; %00100000 SCI Baud Rate Bit 5
00849D 7F849D -> $0010                SBR4:      equ $10   ; %00010000 SCI Baud Rate Bit 4
00849D 7F849D -> $0008                SBR3:      equ $08   ; %00001000 SCI Baud Rate Bit 3
00849D 7F849D -> $0004                SBR2:      equ $04   ; %00000100 SCI Baud Rate Bit 2
00849D 7F849D -> $0002                SBR1:      equ $02   ; %00000010 SCI Baud Rate Bit 1
00849D 7F849D -> $0001                SBR0:      equ $01   ; %00000001 SCI Baud Rate Bit 0
00849D 7F849D -> $00D2                SCI1CR1:   equ $00D2 ; SCI1 Control Register 1 (pg 729)
00849D 7F849D -> $0080                LOOPS:     equ $80   ; %10000000 Loop Select Bit 7
00849D 7F849D -> $0040                SCISWAI:   equ $40   ; %01000000 SCI Stop in Wait Mode Bit 6
00849D 7F849D -> $0020                RSRC:      equ $20   ; %00100000 Receiver Source Bit 5
00849D 7F849D -> $0010                M:         equ $10   ; %00010000 Data Format Mode Bit 4
00849D 7F849D -> $0008                WAKE:      equ $08   ; %00001000 Wakeup Condition Bit 3
00849D 7F849D -> $0004                ILT:       equ $04   ; %00000100 Idle Line Type Bit 2
00849D 7F849D -> $0002                PE:        equ $02   ; %00000010 Parity Enable Bit 1
00849D 7F849D -> $0001                PT:        equ $01   ; %00000001 Parity Type Bit 0
00849D 7F849D -> $00D3                SCI1CR2:   equ $00D3 ; SCI1 Control Register 2 (pg 734)
00849D 7F849D -> $0080                TXIE:      equ $80   ; %10000000 Transmitter Interrupt Enable Bit 7
00849D 7F849D -> $0040                TCIE:      equ $40   ; %01000000 Transmission Complete Int En Bit 6
00849D 7F849D -> $0020                RIE:       equ $20   ; %00100000 Receiver Full Interrupt Enable Bit 5
00849D 7F849D -> $0010                ILIE:      equ $10   ; %00010000 Idle Line Interrupt Enable Bit 4
00849D 7F849D -> $0008                TE:        equ $08   ; %00001000 Transmitter Enable Bit 3
00849D 7F849D -> $0004                RE:        equ $04   ; %00000100 Receiver Enable Bit 2
00849D 7F849D -> $0002                RWU:       equ $02   ; %00000010 Receiver Wakeup Bit 1
00849D 7F849D -> $0001                SBK:       equ $01   ; %00000001 Send Break Bit 0
00849D 7F849D -> $00D4                SCI1SR1:   equ $00D4 ; SCI1 Status Register 1 (pg 735)
00849D 7F849D -> $0080                TDRE:      equ $80   ; %10000000 Transmit Data Register Empty Flag Bit 7
00849D 7F849D -> $0040                TC:        equ $40   ; %01000000 Transmit Complete Bit 6
00849D 7F849D -> $0020                RDRF:      equ $20   ; %00100000 Receive Data Register Full Flag Bit 5
00849D 7F849D -> $0010                IDLE:      equ $10   ; %00010000 Idle Line Flag Bit 4
00849D 7F849D -> $0008                OR:        equ $08   ; %00001000 Overrun Flag Bit 3
00849D 7F849D -> $0004                NF:        equ $04   ; %00000100 Noise Flag Bit 2
00849D 7F849D -> $0002                FE:        equ $02   ; %00000010 Framing Error Flag Bit 1
00849D 7F849D -> $0001                PF:        equ $01   ; %00000001 Parity Error Flag Bit 0
00849D 7F849D -> $00D6                SCI1DRH:   equ $00D6 ; SCI1 Data Register Hi byte (pg 738)
00849D 7F849D -> $0080                R8:        equ $80   ; %10000000 bit 7
00849D 7F849D -> $0040                T8:        equ $40   ; 010000000 bit 6
00849D 7F849D -> $00D7                SCI1DRL:   equ $00D7 ; SCI1 Data Register Lo Byte (pg 738)
00849D 7F849D -> $0080                R7:        equ $80   ; %10000000 Receive Bit 7
00849D 7F849D -> $0040                R6:        equ $40   ; %01000000 Receive Bit 6
00849D 7F849D -> $0020                R5:        equ $20   ; %00100000 Receive Bit 5
00849D 7F849D -> $0010                R4:        equ $10   ; %00010000 Receive Bit 4
00849D 7F849D -> $0008                R3:        equ $08   ; %00001000 Receive Bit 3
00849D 7F849D -> $0004                R2:        equ $04   ; %00000100 Receive Bit 2
00849D 7F849D -> $0002                R1:        equ $02   ; %00000010 Receive Bit 1
00849D 7F849D -> $0001                R0:        equ $01   ; %00000001 Receive Bit 0
00849D 7F849D -> $0080                T7:        equ $80   ; %10000000 Transmit Bit 7
00849D 7F849D -> $0040                T6:        equ $40   ; %01000000 Transmit Bit 6
00849D 7F849D -> $0020                T5:        equ $20   ; %00100000 Transmit Bit 5
00849D 7F849D -> $0010                T4:        equ $10   ; %00010000 Transmit Bit 4
00849D 7F849D -> $0008                T3:        equ $08   ; %00001000 Transmit Bit 3
00849D 7F849D -> $0004                T2:        equ $04   ; %00000100 Transmit Bit 2
00849D 7F849D -> $0002                T1:        equ $02   ; %00000010 Transmit Bit 1
00849D 7F849D -> $0001                T0:        equ $01   ; %00000001 Transmit Bit 0
                                      ;*****************************************************************************************
                                      ; - Serial Peripherial Interface (S12SPIV5) equates
                                      ;*****************************************************************************************
00849D 7F849D -> $00D8                SPI0CR1:   equ $00D8 ; SPI0 Control Register (page 765)
00849D 7F849D -> $0080                SPIE:      equ $80   ; %10000000 SPI Interrupt Enable Bit 7
00849D 7F849D -> $0040                SPE:       equ $40   ; %01000000 SPI System Enable Bit 6
00849D 7F849D -> $0020                SPTIE:     equ $20   ; %00100000 SPI Tansmit Interrupt Enable Bit 5
00849D 7F849D -> $0010                MSTR:      equ $10   ; %00010000 SPI Master/Slave Mode Select Bit 4
00849D 7F849D -> $0008                CPOL:      equ $08   ; %00001000 SPI Clock Polarity  Bit 3
00849D 7F849D -> $0004                CPHA:      equ $04   ; %00000100 SPI Clock Phase Bit 2
00849D 7F849D -> $0002                SSOE:      equ $02   ; %00000010 Slave Select Output Enable Bit 1
00849D 7F849D -> $0001                LSBFE:     equ $01   ; %00000001 LSB-First Enable Bit 0
00849D 7F849D -> $00D9                SPI0CR2:  equ $00D9  ; SPI0 Control Register 2 (page 766)
                                      ;U/I:     equ $80    ; %10000000 Unimplemented Bit 7
00849D 7F849D -> $0040                XFRW:     equ $40    ; %01000000 Transfer Width Bit 6
                                      ;U/I:     equ $20    ; %00100000 Unimplemented Bit 5
00849D 7F849D -> $0010                MODFN:    equ $10    ; %00010000 Mode Fault Enable Bit 4
00849D 7F849D -> $0008                BIDIROE:  equ $08    ; %00001000 Output Enable in the Bidirectionsal Mode of Opersation  Bit 3
                                      ;U/I:     equ $04    ; %00000100 Unimplemented Bit 2
00849D 7F849D -> $0002                SPISWAI:  equ $02    ; %00000010 SPI Stop in Wait Mode Bit 1
00849D 7F849D -> $0001                SPCO:     equ $01    ; %00000001 Serial Pin Control Bit 0
00849D 7F849D -> $00DA                SPI0BR:   equ $00DA  ; SPI0 Baud Rate Register (page 768)
                                      ;U/I:     equ $80    ; %10000000 Unimplemented Bit 7
00849D 7F849D -> $0040                SPPR2:    equ $40    ; %01000000 SPI Baud Rate Preselection Bit 6
00849D 7F849D -> $0020                SPPR1:    equ $20    ; %00100000 SPI Baud Rate Preselection Bit 5
00849D 7F849D -> $0010                SPPR0:    equ $10    ; %00010000 SPI Baud Rate Preselection Bit 4
                                      ;U/I:     equ $08    ; %00001000 Unimplemented  Bit 3
00849D 7F849D -> $0004                SPR2:     equ $04    ; %00000100 SPI Baud Rate Selection Bit 2
00849D 7F849D -> $0002                SPR1:     equ $02    ; %00000010 SPI Baud Rate Selection Bit 1
00849D 7F849D -> $0001                SPR0:     equ $01    ; %00000001 SPI Baud Rate Selection Bit 0
00849D 7F849D -> $00DB                SPI0SR:   equ $00DB  ; SPI0 Status Register (page 770)
00849D 7F849D -> $0080                SPIF:     equ $80    ; %10000000 SPIF Interrupt Flag Bit 7
                                      ;U/I:     equ $40    ; %01000000 Unimplemented Bit 6
00849D 7F849D -> $0020                SPTEF:    equ $20    ; %00100000 SPI Transmit Empty Interrupt Flag Bit 5
00849D 7F849D -> $0010                MODF:     equ $10    ; %00010000 Mode Fault Flag Bit 4
                                      ;U/I:     equ $08    ; %00001000 Unimplemented  Bit 3
                                      ;U/I:     equ $04    ; %00000100 Unimplemented Bit 2
                                      ;U/I:     equ $02    ; %00000010 Unimplemented Bit 1
                                      ;U/I:     equ $01    ; %00000001 Unimplemented Bit 0
00849D 7F849D -> $00DC                SPI0DRH:  equ $00DC  ; SPI0 Data Register Hi Byte(page 772)
                                      ;R15:     equ $80    ; %10000000 SPI Data Bit 15
                                      ;R14:     equ $40    ; %01000000 SPI Data Bit 14
                                      ;R13:     equ $20    ; %00100000 SPI Data Bit 13
                                      ;R12:     equ $10    ; %00010000 SPI Data Bit 12
                                      ;R11:     equ $08    ; %00001000 SPI Data Bit 11
                                      ;R10:     equ $04    ; %00000100 SPI Data Bit 10
                                      ;R9:      equ $02    ; %00000010 SPI Data Bit 9
                                      ;R8:      equ $01    ; %00000001 SPI Data Bit 8
00849D 7F849D -> $00DD                SPI0DRL:  equ $00DD  ; SPI0 Data Register Hi Byte(page 772)
                                      ;R7:      equ $80    ; %10000000 SPI Data Bit 7
                                      ;R6:      equ $40    ; %01000000 SPI Data Bit 6
                                      ;R5:      equ $20    ; %00100000 SPI Data Bit 5
                                      ;R4:      equ $10    ; %00010000 SPI Data Bit 4
                                      ;R3:      equ $08    ; %00001000 SPI Data Bit 3
                                      ;R2:      equ $04    ; %00000100 SPI Data Bit 2
                                      ;R1:      equ $02    ; %00000010 SPI Data Bit 1
                                      ;R0:      equ $01    ; %00000001 SPI Data Bit 0
00849D 7F849D -> $00F0                SPI1CR1:   equ $00F0 ; SPI1 Control Register (page 765)
00849D 7F849D -> $0080                SPIE:      equ $80   ; %10000000 SPI Interrupt Enable Bit 7
00849D 7F849D -> $0040                SPE:       equ $40   ; %01000000 SPI System Enable Bit 6
00849D 7F849D -> $0020                SPTIE:     equ $20   ; %00100000 SPI Tansmit Interrupt Enable Bit 5
00849D 7F849D -> $0010                MSTR:      equ $10   ; %00010000 SPI Master/Slave Mode Select Bit 4
00849D 7F849D -> $0008                CPOL:      equ $08   ; %00001000 SPI Clock Polarity  Bit 3
00849D 7F849D -> $0004                CPHA:      equ $04   ; %00000100 SPI Clock Phase Bit 2
00849D 7F849D -> $0002                SSOE:      equ $02   ; %00000010 Slave Select Output Enable Bit 1
00849D 7F849D -> $0001                LSBFE:     equ $01   ; %00000001 LSB-First Enable Bit 0
00849D 7F849D -> $00F1                SPI1CR2:  equ $00F1  ; SPI1 Control Register 2 (page 766)
                                      ;U/I:     equ $80    ; %10000000 Unimplemented Bit 7
00849D 7F849D -> $0040                XFRW:     equ $40    ; %01000000 Transfer Width Bit 6
                                      ;U/I:     equ $20    ; %00100000 Unimplemented Bit 5
00849D 7F849D -> $0010                MODFN:    equ $10    ; %00010000 Mode Fault Enable Bit 4
00849D 7F849D -> $0008                BIDIROE:  equ $08    ; %00001000 Output Enable in the Bidirectionsal Mode of Opersation  Bit 3
                                      ;U/I:     equ $04    ; %00000100 Unimplemented Bit 2
00849D 7F849D -> $0002                SPISWAI:  equ $02    ; %00000010 SPI Stop in Wait Mode Bit 1
00849D 7F849D -> $0001                SPCO:     equ $01    ; %00000001 Serial Pin Control Bit 0
00849D 7F849D -> $00F2                SPI1BR:   equ $00F2  ; SPI1 Baud Rate Register (page 768)
                                      ;U/I:     equ $80    ; %10000000 Unimplemented Bit 7
00849D 7F849D -> $0040                SPPR2:    equ $40    ; %01000000 SPI Baud Rate Preselection Bit 6
00849D 7F849D -> $0020                SPPR1:    equ $20    ; %00100000 SPI Baud Rate Preselection Bit 5
00849D 7F849D -> $0010                SPPR0:    equ $10    ; %00010000 SPI Baud Rate Preselection Bit 4
                                      ;U/I:     equ $08    ; %00001000 Unimplemented  Bit 3
00849D 7F849D -> $0004                SPR2:     equ $04    ; %00000100 SPI Baud Rate Selection Bit 2
00849D 7F849D -> $0002                SPR1:     equ $02    ; %00000010 SPI Baud Rate Selection Bit 1
00849D 7F849D -> $0001                SPR0:     equ $01    ; %00000001 SPI Baud Rate Selection Bit 0
00849D 7F849D -> $00F3                SPI1SR:   equ $00F3  ; SPI1 Status Register (page 770)
00849D 7F849D -> $0080                SPIF:     equ $80    ; %10000000 SPIF Interrupt Flag Bit 7
                                      ;U/I:     equ $40    ; %01000000 Unimplemented Bit 6
00849D 7F849D -> $0020                SPTEF:    equ $20    ; %00100000 SPI Transmit Empty Interrupt Flag Bit 5
00849D 7F849D -> $0010                MODF:     equ $10    ; %00010000 Mode Fault Flag Bit 4
                                      ;U/I:     equ $08    ; %00001000 Unimplemented  Bit 3
                                      ;U/I:     equ $04    ; %00000100 Unimplemented Bit 2
                                      ;U/I:     equ $02    ; %00000010 Unimplemented Bit 1
                                      ;U/I:     equ $01    ; %00000001 Unimplemented Bit 0
00849D 7F849D -> $00F4                SPI1DRH:  equ $00F4  ; SPI1 Data Register Hi Byte(page 772)
                                      ;R15:     equ $80    ; %10000000 SPI Data Bit 15
                                      ;R14:     equ $40    ; %01000000 SPI Data Bit 14
                                      ;R13:     equ $20    ; %00100000 SPI Data Bit 13
                                      ;R12:     equ $10    ; %00010000 SPI Data Bit 12
                                      ;R11:     equ $08    ; %00001000 SPI Data Bit 11
                                      ;R10:     equ $04    ; %00000100 SPI Data Bit 10
                                      ;R9:      equ $02    ; %00000010 SPI Data Bit 9
                                      ;R8:      equ $01    ; %00000001 SPI Data Bit 8
00849D 7F849D -> $00F5                SPI1DRL:  equ $00F5  ; SPI1 Data Register Hi Byte(page 772)
                                      ;R7:      equ $80    ; %10000000 SPI Data Bit 7
                                      ;R6:      equ $40    ; %01000000 SPI Data Bit 6
                                      ;R5:      equ $20    ; %00100000 SPI Data Bit 5
                                      ;R4:      equ $10    ; %00010000 SPI Data Bit 4
                                      ;R3:      equ $08    ; %00001000 SPI Data Bit 3
                                      ;R2:      equ $04    ; %00000100 SPI Data Bit 2
                                      ;R1:      equ $02    ; %00000010 SPI Data Bit 1
                                      ;R0:      equ $01    ; %00000001 SPI Data Bit 0
00849D 7F849D -> $00F8                SPI2CR1:   equ $00F8 ; SPI2 Control Register (page 765)
00849D 7F849D -> $0080                SPIE:      equ $80   ; %10000000 SPI Interrupt Enable Bit 7
00849D 7F849D -> $0040                SPE:       equ $40   ; %01000000 SPI System Enable Bit 6
00849D 7F849D -> $0020                SPTIE:     equ $20   ; %00100000 SPI Tansmit Interrupt Enable Bit 5
00849D 7F849D -> $0010                MSTR:      equ $10   ; %00010000 SPI Master/Slave Mode Select Bit 4
00849D 7F849D -> $0008                CPOL:      equ $08   ; %00001000 SPI Clock Polarity  Bit 3
00849D 7F849D -> $0004                CPHA:      equ $04   ; %00000100 SPI Clock Phase Bit 2
00849D 7F849D -> $0002                SSOE:      equ $02   ; %00000010 Slave Select Output Enable Bit 1
00849D 7F849D -> $0001                LSBFE:     equ $01   ; %00000001 LSB-First Enable Bit 0
00849D 7F849D -> $00F9                SPI2CR2:  equ $00F9  ; SPI2 Control Register 2 (page 766)
                                      ;U/I:     equ $80    ; %10000000 Unimplemented Bit 7
00849D 7F849D -> $0040                XFRW:     equ $40    ; %01000000 Transfer Width Bit 6
                                      ;U/I:     equ $20    ; %00100000 Unimplemented Bit 5
00849D 7F849D -> $0010                MODFN:    equ $10    ; %00010000 Mode Fault Enable Bit 4
00849D 7F849D -> $0008                BIDIROE:  equ $08    ; %00001000 Output Enable in the Bidirectionsal Mode of Opersation  Bit 3
                                      ;U/I:     equ $04    ; %00000100 Unimplemented Bit 2
00849D 7F849D -> $0002                SPISWAI:  equ $02    ; %00000010 SPI Stop in Wait Mode Bit 1
00849D 7F849D -> $0001                SPCO:     equ $01    ; %00000001 Serial Pin Control Bit 0
00849D 7F849D -> $00FA                SPI2BR:   equ $00FA  ; SPI2 Baud Rate Register (page 768)
                                      ;U/I:     equ $80    ; %10000000 Unimplemented Bit 7
00849D 7F849D -> $0040                SPPR2:    equ $40    ; %01000000 SPI Baud Rate Preselection Bit 6
00849D 7F849D -> $0020                SPPR1:    equ $20    ; %00100000 SPI Baud Rate Preselection Bit 5
00849D 7F849D -> $0010                SPPR0:    equ $10    ; %00010000 SPI Baud Rate Preselection Bit 4
                                      ;U/I:     equ $08    ; %00001000 Unimplemented  Bit 3
00849D 7F849D -> $0004                SPR2:     equ $04    ; %00000100 SPI Baud Rate Selection Bit 2
00849D 7F849D -> $0002                SPR1:     equ $02    ; %00000010 SPI Baud Rate Selection Bit 1
00849D 7F849D -> $0001                SPR0:     equ $01    ; %00000001 SPI Baud Rate Selection Bit 0
00849D 7F849D -> $00FB                SPI2SR:   equ $00FB  ; SPI1 Status Register (page 770)
00849D 7F849D -> $0080                SPIF:     equ $80    ; %10000000 SPIF Interrupt Flag Bit 7
                                      ;U/I:     equ $40    ; %01000000 Unimplemented Bit 6
00849D 7F849D -> $0020                SPTEF:    equ $20    ; %00100000 SPI Transmit Empty Interrupt Flag Bit 5
00849D 7F849D -> $0010                MODF:     equ $10    ; %00010000 Mode Fault Flag Bit 4
                                      ;U/I:     equ $08    ; %00001000 Unimplemented  Bit 3
                                      ;U/I:     equ $04    ; %00000100 Unimplemented Bit 2
                                      ;U/I:     equ $02    ; %00000010 Unimplemented Bit 1
                                      ;U/I:     equ $01    ; %00000001 Unimplemented Bit 0
00849D 7F849D -> $00FC                SPI2DRH:  equ $00FC  ; SPI1 Data Register Hi Byte(page 772)
                                      ;R15:     equ $80    ; %10000000 SPI Data Bit 15
                                      ;R14:     equ $40    ; %01000000 SPI Data Bit 14
                                      ;R13:     equ $20    ; %00100000 SPI Data Bit 13
                                      ;R12:     equ $10    ; %00010000 SPI Data Bit 12
                                      ;R11:     equ $08    ; %00001000 SPI Data Bit 11
                                      ;R10:     equ $04    ; %00000100 SPI Data Bit 10
                                      ;R9:      equ $02    ; %00000010 SPI Data Bit 9
                                      ;R8:      equ $01    ; %00000001 SPI Data Bit 8
00849D 7F849D -> $00FD                SPI2DRL:  equ $00FD  ; SPI1 Data Register Hi Byte(page 772)
                                      ;R7:      equ $80    ; %10000000 SPI Data Bit 7
                                      ;R6:      equ $40    ; %01000000 SPI Data Bit 6
                                      ;R5:      equ $20    ; %00100000 SPI Data Bit 5
                                      ;R4:      equ $10    ; %00010000 SPI Data Bit 4
                                      ;R3:      equ $08    ; %00001000 SPI Data Bit 3
                                      ;R2:      equ $04    ; %00000100 SPI Data Bit 2
                                      ;R1:      equ $02    ; %00000010 SPI Data Bit 1
                                      ;R0:      equ $01    ; %00000001 SPI Data Bit 0
00849D 7F849D -> $036F                PTRRR:    equ $036F   ;Port R Routing Register (page 167)
00849D 7F849D -> $0080                PTRRR7:   equ $80     ; %10000000 Port R routing bit 7
00849D 7F849D -> $0040                PTRRR6:   equ $40     ; %01000000 Port R routing bit 6
00849D 7F849D -> $0020                PTRRR5:   equ $20     ; %00100000 Port R routing bit 5
00849D 7F849D -> $0010                PTRRR4:   equ $10     ; %00010000 Port R routing bit 4
00849D 7F849D -> $0008                PTRRR3:   equ $08     ; %00001000 Port R routing bit 3
00849D 7F849D -> $0004                PTRRR2:   equ $04     ; %00000100 Port R routing bit 2
00849D 7F849D -> $0002                PTRRR1:   equ $02     ; %00000010 Port R routing bit 1
00849D 7F849D -> $0001                PTRRR0:   equ $01     ; %00000001 Port R routing bit 0
                                      ;*****************************************************************************************
                                      ; - XGATE (S12XGATEV3) equates
                                      ;*****************************************************************************************
00849D 7F849D -> $0380                XGMCTL:     equ $0380 ; XGATE Control Register (pg 359)
00849D 7F849D -> $8000                XGEM:       equ $8000 ; XGE Mask bit 15
00849D 7F849D -> $4000                XGFRZM:     equ $4000 ; XGFRZ Mask bit 14
00849D 7F849D -> $2000                XGDBGM:     equ $2000 ; XGDBG Mask bit 13
00849D 7F849D -> $1000                XGSSM:      equ $1000 ; XGSS Mask bit 12
00849D 7F849D -> $0800                XGFACTM:    equ $0800 ; XGFACT Mask bit 11
00849D 7F849D -> $0200                XGSWEFM:    equ $0200 ; XGSWEF Mask bit 10
00849D 7F849D -> $0100                XGIEM:      equ $0100 ; XGIE Mask bit 9
00849D 7F849D -> $0080                XGE:        equ $0080 ; XGATE Module Enable (Request Enable) bit 7
00849D 7F849D -> $0040                XGFRZ:      equ $0040 ; Halt XGATE in Freeze Mode bit 6
00849D 7F849D -> $0020                XGDBG:      equ $0020 ; XGATE Debug Mode bit 5
00849D 7F849D -> $0010                XGSS:       equ $0010 ; XGATE Single Step bit 4
00849D 7F849D -> $0008                XGFACT:     equ $0008 ; Fake XGATE Activity bit 3
00849D 7F849D -> $0002                XGSWEF:     equ $0002 ; XGATE Software Error Flag bit 1
00849D 7F849D -> $0001                XGIE:       equ $0001 ; XGATE interrupt Enable bit 0
00849D 7F849D -> $0382                XGCHID:     equ $0382 ; XGATE Channel ID Register (pg 361)
00849D 7F849D -> $0383                XGCHPL:     equ $0383 ; XGATE Channel Priority Level (pg 362)
00849D 7F849D -> $0385                XGISPSEL:   equ $0385 ; XGATE Initial Stack Pointer Select Register (pg 362)
00849D 7F849D -> $0386                XGVBR:      equ $0386 ; XGATE Vector Base Address Register (pg 364)
00849D 7F849D -> $0388                XGIF_7F_78: equ $0388 ; XGATE Channel Interrupt Flag Vector Ch7F to Ch78 (pg 365)
00849D 7F849D -> $0080                XGIF_7F:    equ $80   ; Ch7F interrupt Flag bit 7 (not used)
00849D 7F849D -> $0040                XGIF_7E:    equ $40   ; Ch7E interrupt Flag bit 6 (not used)
00849D 7F849D -> $0020                XGIF_7D:    equ $20   ; Ch7D interrupt Flag bit 5 (not used)
00849D 7F849D -> $0010                XGIF_7C:    equ $10   ; Ch7C interrupt Flag bit 4 (not used)
00849D 7F849D -> $0008                XGIF_7B:    equ $08   ; Ch7B interrupt Flag bit 3 (not used)
00849D 7F849D -> $0004                XGIF_7A:    equ $04   ; Ch7A interrupt Flag bit 2 (not used)
00849D 7F849D -> $0002                XGIF_79:    equ $02   ; Ch79 interrupt Flag bit 1 (not used)
00849D 7F849D -> $0001                XGIF_78:    equ $01   ; Ch78 interrupt Flag bit 0
00849D 7F849D -> $0389                XGIF_77_70: equ $0389 ; XGATE Channel Interrupt Flag Vector Ch77 to Ch70 (pg 365)
00849D 7F849D -> $0080                XGIF_77:    equ $80   ; Ch77 interrupt Flag bit 7
00849D 7F849D -> $0040                XGIF_76:    equ $40   ; Ch76 interrupt Flag bit 6
00849D 7F849D -> $0020                XGIF_75:    equ $20   ; Ch75 interrupt Flag bit 5
00849D 7F849D -> $0010                XGIF_74:    equ $10   ; Ch74 interrupt Flag bit 4
00849D 7F849D -> $0008                XGIF_73:    equ $08   ; Ch73 interrupt Flag bit 3
00849D 7F849D -> $0004                XGIF_72:    equ $04   ; Ch72 interrupt Flag bit 2
00849D 7F849D -> $0002                XGIF_71:    equ $02   ; Ch71 interrupt Flag bit 1
00849D 7F849D -> $0001                XGIF_70:    equ $01   ; Ch70 interrupt Flag bit 0
00849D 7F849D -> $038A                XGIF_6F_68: equ $038A ; XGATE Channel Interrupt Flag Vector Ch6F to Ch68 (pg 365)
00849D 7F849D -> $0080                XGIF_6F:    equ $80   ; Ch6F interrupt Flag bit 7
00849D 7F849D -> $0040                XGIF_6E:    equ $40   ; Ch6E interrupt Flag bit 6
00849D 7F849D -> $0020                XGIF_6D:    equ $20   ; Ch6D interrupt Flag bit 5
00849D 7F849D -> $0010                XGIF_6C:    equ $10   ; Ch6C interrupt Flag bit 4
00849D 7F849D -> $0008                XGIF_6B:    equ $08   ; Ch6B interrupt Flag bit 3
00849D 7F849D -> $0004                XGIF_6A:    equ $04   ; Ch6A interrupt Flag bit 2
00849D 7F849D -> $0002                XGIF_69:    equ $02   ; Ch69 interrupt Flag bit 1
00849D 7F849D -> $0001                XGIF_68:    equ $01   ; Ch68 interrupt Flag bit 0
00849D 7F849D -> $038B                XGIF_67_60: equ $038B ; XGATE Channel Interrupt Flag Vector Ch67 to Ch60 (pg 365)
00849D 7F849D -> $0080                XGIF_67:    equ $80   ; Ch67 interrupt Flag bit 7
00849D 7F849D -> $0040                XGIF_66:    equ $40   ; Ch66 interrupt Flag bit 6
00849D 7F849D -> $0020                XGIF_65:    equ $20   ; Ch65 interrupt Flag bit 5
00849D 7F849D -> $0010                XGIF_64:    equ $10   ; Ch64 interrupt Flag bit 4
00849D 7F849D -> $0008                XGIF_63:    equ $08   ; Ch63 interrupt Flag bit 3
00849D 7F849D -> $0004                XGIF_62:    equ $04   ; Ch62 interrupt Flag bit 2
00849D 7F849D -> $0002                XGIF_61:    equ $02   ; Ch61 interrupt Flag bit 1
00849D 7F849D -> $0001                XGIF_60:    equ $01   ; Ch60 interrupt Flag bit 0
00849D 7F849D -> $038C                XGIF_5F_58: equ $038C ; XGATE Channel Interrupt Flag Vector Ch5F to Ch58 (pg 365)
00849D 7F849D -> $0080                XGIF_5F:    equ $80   ; Ch5F interrupt Flag bit 7
00849D 7F849D -> $0040                XGIF_5E:    equ $40   ; Ch5E interrupt Flag bit 6
00849D 7F849D -> $0020                XGIF_5D:    equ $20   ; Ch5D interrupt Flag bit 5
00849D 7F849D -> $0010                XGIF_5C:    equ $10   ; Ch5C interrupt Flag bit 4
00849D 7F849D -> $0008                XGIF_5B:    equ $08   ; Ch5B interrupt Flag bit 3
00849D 7F849D -> $0004                XGIF_5A:    equ $04   ; Ch5A interrupt Flag bit 2
00849D 7F849D -> $0002                XGIF_59:    equ $02   ; Ch59 interrupt Flag bit 1
00849D 7F849D -> $0001                XGIF_58:    equ $01   ; Ch58 interrupt Flag bit 0
00849D 7F849D -> $038D                XGIF_57_50: equ $038D ; XGATE Channel Interrupt Flag Vector Ch57 to Ch50 (pg 365)
00849D 7F849D -> $0080                XGIF_57:    equ $80   ; Ch57 interrupt Flag bit 7
00849D 7F849D -> $0040                XGIF_56:    equ $40   ; Ch56 interrupt Flag bit 6
00849D 7F849D -> $0020                XGIF_55:    equ $20   ; Ch55 interrupt Flag bit 5
00849D 7F849D -> $0010                XGIF_54:    equ $10   ; Ch54 interrupt Flag bit 4
00849D 7F849D -> $0008                XGIF_53:    equ $08   ; Ch53 interrupt Flag bit 3
00849D 7F849D -> $0004                XGIF_52:    equ $04   ; Ch52 interrupt Flag bit 2
00849D 7F849D -> $0002                XGIF_51:    equ $02   ; Ch51 interrupt Flag bit 1
00849D 7F849D -> $0001                XGIF_50:    equ $01   ; Ch50 interrupt Flag bit 0
00849D 7F849D -> $038E                XGIF_4F_48: equ $038E ; XGATE Channel Interrupt Flag Vector Ch4F to Ch48 (pg 365)
00849D 7F849D -> $0080                XGIF_4F:    equ $80   ; Ch4F interrupt Flag bit 7
00849D 7F849D -> $0040                XGIF_4E:    equ $40   ; Ch4E interrupt Flag bit 6
00849D 7F849D -> $0020                XGIF_4D:    equ $20   ; Ch4D interrupt Flag bit 5
00849D 7F849D -> $0010                XGIF_4C:    equ $10   ; Ch4C interrupt Flag bit 4
00849D 7F849D -> $0008                XGIF_4B:    equ $08   ; Ch4B interrupt Flag bit 3
00849D 7F849D -> $0004                XGIF_4A:    equ $04   ; Ch4A interrupt Flag bit 2
00849D 7F849D -> $0002                XGIF_49:    equ $02   ; Ch49 interrupt Flag bit 1
00849D 7F849D -> $0001                XGIF_48:    equ $01   ; Ch48 interrupt Flag bit 0
00849D 7F849D -> $038F                XGIF_47_40: equ $038F ; XGATE Channel Interrupt Flag Vector Ch47 to Ch40 (pg 365)
00849D 7F849D -> $0080                XGIF_47:    equ $80   ; Ch47 interrupt Flag bit 7
00849D 7F849D -> $0040                XGIF_46:    equ $40   ; Ch46 interrupt Flag bit 6
00849D 7F849D -> $0020                XGIF_45:    equ $20   ; Ch45 interrupt Flag bit 5
00849D 7F849D -> $0010                XGIF_44:    equ $10   ; Ch44 interrupt Flag bit 4
00849D 7F849D -> $0008                XGIF_43:    equ $08   ; Ch43 interrupt Flag bit 3
00849D 7F849D -> $0004                XGIF_42:    equ $04   ; Ch42 interrupt Flag bit 2
00849D 7F849D -> $0002                XGIF_41:    equ $02   ; Ch41 interrupt Flag bit 1
00849D 7F849D -> $0001                XGIF_40:    equ $01   ; Ch40 interrupt Flag bit 0
00849D 7F849D -> $0390                XGIF_3F_38: equ $0390 ; XGATE Channel Interrupt Flag Vector Ch3F to Ch38 (pg 366)
00849D 7F849D -> $0080                XGIF_3F:    equ $80   ; Ch3F interrupt Flag bit 7
00849D 7F849D -> $0040                XGIF_3E:    equ $40   ; Ch3E interrupt Flag bit 6
00849D 7F849D -> $0020                XGIF_3D:    equ $20   ; Ch3D interrupt Flag bit 5
00849D 7F849D -> $0010                XGIF_3C:    equ $10   ; Ch3C interrupt Flag bit 4
00849D 7F849D -> $0008                XGIF_3B:    equ $08   ; Ch3B interrupt Flag bit 3
00849D 7F849D -> $0004                XGIF_3A:    equ $04   ; Ch3A interrupt Flag bit 2
00849D 7F849D -> $0002                XGIF_39:    equ $02   ; Ch39 interrupt Flag bit 1
00849D 7F849D -> $0001                XGIF_38:    equ $01   ; Ch38 interrupt Flag bit 0
00849D 7F849D -> $0391                XGIF_37_30: equ $0391 ; XGATE Channel Interrupt Flag Vector Ch37 to Ch30 (pg 366)
00849D 7F849D -> $0080                XGIF_37:    equ $80   ; Ch37 interrupt Flag bit 7
00849D 7F849D -> $0040                XGIF_36:    equ $40   ; Ch36 interrupt Flag bit 6
00849D 7F849D -> $0020                XGIF_35:    equ $20   ; Ch35 interrupt Flag bit 5
00849D 7F849D -> $0010                XGIF_34:    equ $10   ; Ch34 interrupt Flag bit 4
00849D 7F849D -> $0008                XGIF_33:    equ $08   ; Ch33 interrupt Flag bit 3
00849D 7F849D -> $0004                XGIF_32:    equ $04   ; Ch32 interrupt Flag bit 2
00849D 7F849D -> $0002                XGIF_31:    equ $02   ; Ch31 interrupt Flag bit 1
00849D 7F849D -> $0001                XGIF_30:    equ $01   ; Ch30 interrupt Flag bit 0
00849D 7F849D -> $0392                XGIF_2F_28: equ $0392 ; XGATE Channel Interrupt Flag Vector Ch2F to Ch28 (pg 366)
00849D 7F849D -> $0080                XGIF_2F:    equ $80   ; Ch2F interrupt Flag bit 7
00849D 7F849D -> $0040                XGIF_2E:    equ $40   ; Ch2E interrupt Flag bit 6
00849D 7F849D -> $0020                XGIF_2D:    equ $20   ; Ch2D interrupt Flag bit 5
00849D 7F849D -> $0010                XGIF_2C:    equ $10   ; Ch2C interrupt Flag bit 4
00849D 7F849D -> $0008                XGIF_2B:    equ $08   ; Ch2B interrupt Flag bit 3
00849D 7F849D -> $0004                XGIF_2A:    equ $04   ; Ch2A interrupt Flag bit 2
00849D 7F849D -> $0002                XGIF_29:    equ $02   ; Ch29 interrupt Flag bit 1
00849D 7F849D -> $0001                XGIF_28:    equ $01   ; Ch28 interrupt Flag bit 0
00849D 7F849D -> $0393                XGIF_27_20: equ $0393 ; XGATE Channel Interrupt Flag Vector Ch27 to Ch20 (pg 366)
00849D 7F849D -> $0080                XGIF_27:    equ $80   ; Ch27 interrupt Flag bit 7
00849D 7F849D -> $0040                XGIF_26:    equ $40   ; Ch26 interrupt Flag bit 6
00849D 7F849D -> $0020                XGIF_25:    equ $20   ; Ch25 interrupt Flag bit 5
00849D 7F849D -> $0010                XGIF_24:    equ $10   ; Ch24 interrupt Flag bit 4
00849D 7F849D -> $0008                XGIF_23:    equ $08   ; Ch23 interrupt Flag bit 3
00849D 7F849D -> $0004                XGIF_22:    equ $04   ; Ch22 interrupt Flag bit 2
00849D 7F849D -> $0002                XGIF_21:    equ $02   ; Ch21 interrupt Flag bit 1
00849D 7F849D -> $0001                XGIF_20:    equ $01   ; Ch20 interrupt Flag bit 0
00849D 7F849D -> $0394                XGIF_1F_18: equ $0394 ; XGATE Channel Interrupt Flag Vector Ch1F to Ch18 (pg 366)
00849D 7F849D -> $0080                XGIF_1F:    equ $80   ; Ch1F interrupt Flag bit 7
00849D 7F849D -> $0040                XGIF_1E:    equ $40   ; Ch1E interrupt Flag bit 6
00849D 7F849D -> $0020                XGIF_1D:    equ $20   ; Ch1D interrupt Flag bit 5
00849D 7F849D -> $0010                XGIF_1C:    equ $10   ; Ch1C interrupt Flag bit 4
00849D 7F849D -> $0008                XGIF_1B:    equ $08   ; Ch1B interrupt Flag bit 3
00849D 7F849D -> $0004                XGIF_1A:    equ $04   ; Ch1A interrupt Flag bit 2
00849D 7F849D -> $0002                XGIF_19:    equ $02   ; Ch19 interrupt Flag bit 1
00849D 7F849D -> $0001                XGIF_18:    equ $01   ; Ch18 interrupt Flag bit 0
00849D 7F849D -> $0395                XGIF_17_10: equ $0395 ; XGATE Channel Interrupt Flag Vector Ch17 to Ch10 (pg 366)
00849D 7F849D -> $0080                XGIF_17:    equ $80   ; Ch17 interrupt Flag bit 7
00849D 7F849D -> $0040                XGIF_16:    equ $40   ; Ch16 interrupt Flag bit 6
00849D 7F849D -> $0020                XGIF_15:    equ $20   ; Ch15 interrupt Flag bit 5
00849D 7F849D -> $0010                XGIF_14:    equ $10   ; Ch14 interrupt Flag bit 4
00849D 7F849D -> $0008                XGIF_13:    equ $08   ; Ch13 interrupt Flag bit 3
00849D 7F849D -> $0004                XGIF_12:    equ $04   ; Ch12 interrupt Flag bit 2
00849D 7F849D -> $0002                XGIF_11:    equ $02   ; Ch11 interrupt Flag bit 1
00849D 7F849D -> $0001                XGIF_10:    equ $01   ; Ch10 interrupt Flag bit 0
00849D 7F849D -> $0396                XGIF_0F_08: equ $0396 ; XGATE Channel Interrupt Flag Vector Ch0F to Ch08 (pg 366)
00849D 7F849D -> $0080                XGIF_0F:    equ $80   ; Ch0F interrupt Flag bit 7
00849D 7F849D -> $0040                XGIF_0E:    equ $40   ; Ch0E interrupt Flag bit 6
00849D 7F849D -> $0020                XGIF_0D:    equ $20   ; Ch0D interrupt Flag bit 5
00849D 7F849D -> $0010                XGIF_0C:    equ $10   ; Ch0C interrupt Flag bit 4 (not used)
00849D 7F849D -> $0008                XGIF_0B:    equ $08   ; Ch0B interrupt Flag bit 3 (not used)
00849D 7F849D -> $0004                XGIF_0A:    equ $04   ; Ch0A interrupt Flag bit 2 (not used)
00849D 7F849D -> $0002                XGIF_09:    equ $02   ; Ch09 interrupt Flag bit 1 (not used)
00849D 7F849D -> $0001                XGIF_08:    equ $01   ; Ch08 interrupt Flag bit 0 (not used)
00849D 7F849D -> $0397                XGIF_07_00: equ $0397 ; XGATE Channel Interrupt Flag Vector Ch07 to Ch00 (pg 366)
00849D 7F849D -> $0080                XGIF_07:    equ $80   ; Ch07 interrupt Flag bit 7 (not used)
00849D 7F849D -> $0040                XGIF_06:    equ $40   ; Ch06 interrupt Flag bit 6 (not used)
00849D 7F849D -> $0020                XGIF_05:    equ $20   ; Ch05 interrupt Flag bit 5 (not used)
00849D 7F849D -> $0010                XGIF_04:    equ $10   ; Ch04 interrupt Flag bit 4 (not used)
00849D 7F849D -> $0008                XGIF_03:    equ $08   ; Ch03 interrupt Flag bit 3 (not used)
00849D 7F849D -> $0004                XGIF_02:    equ $04   ; Ch02 interrupt Flag bit 2 (not used)
00849D 7F849D -> $0002                XGIF_01:    equ $02   ; Ch01 interrupt Flag bit 1 (not used)
00849D 7F849D -> $0001                XGIF_00:    equ $01   ; Ch00 interrupt Flag bit 0 (not used)
00849D 7F849D -> $0398                XGSWT:      equ $0398 ; XGATE Software Trigger Register (pg 367)
00849D 7F849D -> $039A                XGSEM:      equ $039A ;XGATE Semaphore Register (pg 368)
                                      ; $039C reserved
00849D 7F849D -> $039D                XGCCR:      equ $039D ; XGATE Condition Code Register (pg 369)
00849D 7F849D -> $0008                XGN:        equ $08   ; Sign flag bit 3
00849D 7F849D -> $0004                XGZ:        equ $04   ; Zero flag bit 2
00849D 7F849D -> $0002                XGV:        equ $02   ; Overflow flag bit 1
00849D 7F849D -> $0001                XGC:        equ $01   ; Carry flag bit 0
00849D 7F849D -> $039E                XGPC        equ $039E ; XGATE Program Counter Register (pg 370)
                                      ; $03A0 to $03A1 reserved
00849D 7F849D -> $03A2                XGR1:       equ $03A2 ; XGATE Register 1 (pg 370)
00849D 7F849D -> $03A4                XGR2:       equ $03A4 ; XGATE Register 2 (pg 371)
00849D 7F849D -> $03A6                XGR3:       equ $03A6 ; XGATE Register 3 (pg 371)
00849D 7F849D -> $03A8                XGR4:       equ $03A8 ; XGATE Register 4 (pg 372)
00849D 7F849D -> $03AA                XGR5:       equ $03AA ; XGATE Register 5 (pg 372)
00849D 7F849D -> $03AC                XGR6:       equ $03AC ; XGATE Register 6 (pg 373)
00849D 7F849D -> $03AE                XGR7:       equ $03AE ; XGATE Register 7 (pg 373)
                                      ;*****************************************************************************************
                                      ; - Timer module (TIM16B8CV3) equates
                                      ;*****************************************************************************************
00849D 7F849D -> $03D0                TIM_TIOS:    equ $03D0 ; Timer Input Capture/Output Compare Select Register (pg 794)
                                                             ; 1 = input capture, 0 = output compare
00849D 7F849D -> $0080                IOS7:        equ $80   ; %10000000 Input Capture or Output Compare Channel Config bit 7
00849D 7F849D -> $0040                IOS6:        equ $40   ; %01000000 Input Capture or Output Compare Channel Config bit 6
00849D 7F849D -> $0020                IOS5:        equ $20   ; %00100000 Input Capture or Output Compare Channel Config bit 5
00849D 7F849D -> $0010                IOS4:        equ $10   ; %00010000 Input Capture or Output Compare Channel Config bit 4
00849D 7F849D -> $0008                IOS3:        equ $08   ; %00001000 Input Capture or Output Compare Channel Config bit 3
00849D 7F849D -> $0004                IOS2:        equ $04   ; %00000100 Input Capture or Output Compare Channel Config bit 2
00849D 7F849D -> $0002                IOS1:        equ $02   ; %00000010 Input Capture or Output Compare Channel Config bit 1
00849D 7F849D -> $0001                IOS0:        equ $01   ; %00000001 Input Capture or Output Compare Channel Config bit 0
00849D 7F849D -> $03D1                TIM_CFORC:   equ $03D1 ; Timer Compare Force Register (pg 794)
00849D 7F849D -> $0080                FOC7:        equ $80   ; %10000000 Force output Compare Action for Channel bit 7
00849D 7F849D -> $0040                FOC6:        equ $40   ; %01000000 Force output Compare Action for Channel bit 6
00849D 7F849D -> $0020                FOC5:        equ $20   ; %00100000 Force output Compare Action for Channel bit 5
00849D 7F849D -> $0010                FOC4:        equ $10   ; %00010000 Force output Compare Action for Channel bit 4
00849D 7F849D -> $0008                FOC3:        equ $08   ; %00001000 Force output Compare Action for Channel bit 3
00849D 7F849D -> $0004                FOC2:        equ $04   ; %00000100 Force output Compare Action for Channel bit 2
00849D 7F849D -> $0002                FOC1:        equ $02   ; %00000010 Force output Compare Action for Channel bit 1
00849D 7F849D -> $0001                FOC0:        equ $01   ; %00000001 Force output Compare Action for Channel bit 0
00849D 7F849D -> $03D2                TIM_OC7M:    equ $03D2 ; Output Compare 7 Mask Register (pg 795)
00849D 7F849D -> $0080                OC7M7:       equ $80   ; %10000000 Output Compare 7 Mask bit 7
00849D 7F849D -> $0040                OC7M6:       equ $40   ; %01000000 Output Compare 7 Mask bit 6
00849D 7F849D -> $0020                OC7M5:       equ $20   ; %00100000 Output Compare 7 Mask bit 5
00849D 7F849D -> $0010                OC7M4:       equ $10   ; %00010000 Output Compare 7 Mask bit 4
00849D 7F849D -> $0008                OC7M3:       equ $08   ; %00001000 Output Compare 7 Mask bit 3
00849D 7F849D -> $0004                OC7M2:       equ $04   ; %00000100 Output Compare 7 Mask bit 2
00849D 7F849D -> $0002                OC7M1:       equ $02   ; %00000010 Output Compare 7 Mask bit 1
00849D 7F849D -> $0001                OC7M0:       equ $01   ; %00000001 Output Compare 7 Mask bit 0
00849D 7F849D -> $03D3                TIM_OC7D:    equ $03D3 ; Output Compare 7 Data Register (pg 796)
00849D 7F849D -> $0080                OC7D7:       equ $80   ; %10000000 Output Compare 7 Data bit 7
00849D 7F849D -> $0040                OC7D6:       equ $40   ; %01000000 Output Compare 7 Data bit 6
00849D 7F849D -> $0020                OC7D5:       equ $20   ; %00100000 Output Compare 7 Data bit 5
00849D 7F849D -> $0010                OC7D4:       equ $10   ; %00010000 Output Compare 7 Data bit 4
00849D 7F849D -> $0008                OC7D3:       equ $08   ; %00001000 Output Compare 7 Data bit 3
00849D 7F849D -> $0004                OC7D2:       equ $04   ; %00000100 Output Compare 7 Data bit 2
00849D 7F849D -> $0002                OC7D1:       equ $02   ; %00000010 Output Compare 7 Data bit 1
00849D 7F849D -> $0001                OC7D0:       equ $01   ; %00000001 Output Compare 7 Data bit 0
00849D 7F849D -> $03D4                TIM_TCNTH:    equ $03D4 ; Timer Count Register High (pg 796)
00849D 7F849D -> $0080                TCNT15:       equ $80   ; %10000000 Timer Count Data bit 15
00849D 7F849D -> $0040                TCNT14:       equ $40   ; %01000000 Timer Count Data bit 14
00849D 7F849D -> $0020                TCNT13:       equ $20   ; %00100000 Timer Count Data bit 13
00849D 7F849D -> $0010                TCNT12:       equ $10   ; %00010000 Timer Count Data bit 12
00849D 7F849D -> $0008                TCNT11:       equ $08   ; %00001000 Timer Count Data bit 11
00849D 7F849D -> $0004                TCNT10:       equ $04   ; %00000100 Timer Count Data bit 10
00849D 7F849D -> $0002                TCNT9:        equ $02   ; %00000010 Timer Count Data bit 9
00849D 7F849D -> $0001                TCNT8:        equ $01   ; %00000001 Timer Count Data bit 8
00849D 7F849D -> $03D5                TIM_TCNTL:    equ $03D5 ; Timer Count Register Low (pg 796)
00849D 7F849D -> $0080                TCNT7:        equ $80   ; %10000000 Timer Count Data bit 7
00849D 7F849D -> $0040                TCNT6:        equ $40   ; %01000000 Timer Count Data bit 6
00849D 7F849D -> $0020                TCNT5:        equ $20   ; %00100000 Timer Count Data bit 5
00849D 7F849D -> $0010                TCNT4:        equ $10   ; %00010000 Timer Count Data bit 4
00849D 7F849D -> $0008                TCNT3:        equ $08   ; %00001000 Timer Count Data bit 3
00849D 7F849D -> $0004                TCNT2:        equ $04   ; %00000100 Timer Count Data bit 2
00849D 7F849D -> $0002                TCNT1:        equ $02   ; %00000010 Timer Count Data bit 1
00849D 7F849D -> $0001                TCNT0:        equ $01   ; %00000001 Timer Count Data bit 0
00849D 7F849D -> $03D6                TIM_TSCR1:    equ $03D6 ; Timer System Control Register 1 (pg 797)
00849D 7F849D -> $0080                TEN:          equ $80   ; %10000000 Timer Enable bit 7
00849D 7F849D -> $0040                TSWAI:        equ $40   ; %01000000 Timer Module Stops While In Wait bit 6
00849D 7F849D -> $0020                TSFRZ:        equ $20   ; %00100000 Timer and Modulus Counter Stop While In Wait bit 5
00849D 7F849D -> $0010                TFFCA:        equ $10   ; %00010000 Timer Fast Flag Clear All bit 4
00849D 7F849D -> $0008                PRNT:         equ $08   ; %00001000 Precision Timer bit 3
00849D 7F849D -> $03D7                TIM_TTOV:     equ $03D7 ; Timer Toggle On Overflow Register 1 (pg 798)
00849D 7F849D -> $0080                TOV7:         equ $80   ; %10000000 Toggle on Overflow bit 7
00849D 7F849D -> $0040                TOV6:         equ $40   ; %01000000 Toggle on Overflow bit 6
00849D 7F849D -> $0020                TOV5:         equ $20   ; %00100000 Toggle on Overflow bit 5
00849D 7F849D -> $0010                TOV4:         equ $10   ; %00100000 Toggle on Overflow bit 4
00849D 7F849D -> $0008                TOV3:         equ $08   ; %00001000 Toggle on Overflow bit 3
00849D 7F849D -> $0004                TOV2:         equ $04   ; %00000100 Toggle on Overflow bit 2
00849D 7F849D -> $0002                TOV1:         equ $02   ; %00000010 Toggle on Overflow bit 1
00849D 7F849D -> $0001                TOV0:         equ $01   ; %00000001 Toggle on Overflow bit 0
00849D 7F849D -> $03D8                TIM_TCTL1:    equ $03D8 ; Timer Control Register 1 (pg 799)
00849D 7F849D -> $0080                OM7:          equ $80   ; %10000000 Output Mode 7 bit 7
00849D 7F849D -> $0040                OL7:          equ $40   ; %01000000 Output Level 7 bit 6
00849D 7F849D -> $0020                OM6:          equ $20   ; %00100000 Output Mode 6 bit 5
00849D 7F849D -> $0010                OL6:          equ $10   ; %0010000Output Level 6 bit 4
00849D 7F849D -> $0008                OM5:          equ $08   ; %00001000 Output Mode 5 bit 3
00849D 7F849D -> $0004                OL5:          equ $04   ; %00000100 Output Level 5 bit 2
00849D 7F849D -> $0002                OM4:          equ $02   ; %00000010 Output Mode 4 bit 1
00849D 7F849D -> $0001                OL4:          equ $01   ; %00000001 Output Level 4 bit 0
00849D 7F849D -> $03D9                TIM_TCTL2:    equ $03D9 ; Timer Control Register 2 (pg 799)
00849D 7F849D -> $0080                OM3:          equ $80   ; %10000000 Output Mode 3 bit 7
00849D 7F849D -> $0040                OL3:          equ $40   ; %01000000 Output Level 3 bit 6
00849D 7F849D -> $0020                OM2:          equ $20   ; %00100000 Output Mode 2 bit 5
00849D 7F849D -> $0010                OL2:          equ $10   ; %0010000Output Level 2 bit 4
00849D 7F849D -> $0008                OM1:          equ $08   ; %00001000 Output Mode 1 bit 3
00849D 7F849D -> $0004                OL1:          equ $04   ; %00000100 Output Level 1 bit 2
00849D 7F849D -> $0002                OM0:          equ $02   ; %00000010 Output Mode 0 bit 1
00849D 7F849D -> $0001                OL0:          equ $01   ; %00000001 Output Level 0 bit 0
00849D 7F849D -> $03DA                TIM_TCTL3:    equ $03DA ; Timer Control Register 3 (pg 800)
00849D 7F849D -> $0080                EDG7B:        equ $80   ; %10000000 Input Capture Edge Control 7B bit 7
00849D 7F849D -> $0040                EDG7A:        equ $40   ; %01000000 Input Capture Edge Control 7A bit 6
00849D 7F849D -> $0020                EDG6B:        equ $20   ; %00100000 Input Capture Edge Control 6B bit 5
00849D 7F849D -> $0010                EDG6A:        equ $10   ; %00010000 Input Capture Edge Control 6A bit 4
00849D 7F849D -> $0008                EDG5B:        equ $08   ; %00001000 Input Capture Edge Control 5B bit 3
00849D 7F849D -> $0004                EDG5A:        equ $04   ; %00000100 Input Capture Edge Control 5A bit 2
00849D 7F849D -> $0002                EDG4B:        equ $02   ; %00000010 Input Capture Edge Control 4B bit 1
00849D 7F849D -> $0001                EDG4A:        equ $01   ; %00000001 Input Capture Edge Control 4A bit 0
00849D 7F849D -> $03DB                TIM_TCTL4:    equ $03DB ; Timer Control Register 4 (pg 800)
00849D 7F849D -> $0080                EDG3B:        equ $80   ; %10000000 Input Capture Edge Control 3B bit 7
00849D 7F849D -> $0040                EDG3A:        equ $40   ; %01000000 Input Capture Edge Control 3A bit 6
00849D 7F849D -> $0020                EDG2B:        equ $20   ; %00100000 Input Capture Edge Control 2B bit 5
00849D 7F849D -> $0010                EDG2A:        equ $10   ; %00010000 Input Capture Edge Control 2A bit 4
00849D 7F849D -> $0008                EDG1B:        equ $08   ; %00001000 Input Capture Edge Control 1B bit 3
00849D 7F849D -> $0004                EDG1A:        equ $04   ; %00000100 Input Capture Edge Control 1A bit 2
00849D 7F849D -> $0002                EDG0B:        equ $02   ; %00000010 Input Capture Edge Control 0B bit 1
00849D 7F849D -> $0001                EDG0A:        equ $01   ; %00000001 Input Capture Edge Control 0A bit 0
00849D 7F849D -> $03DC                TIM_TIE:      equ $03DC ; Timer Interrupt Enable Register (pg 801)
                                                             ; 0 = interrupt disabled, 1 = interrupts enabled
00849D 7F849D -> $0080                C7I:          equ $80   ; %10000000 IC/OC "X" Interrupt Enable bit 7
00849D 7F849D -> $0040                C6I:          equ $40   ; %01000000 IC/OC "X" Interrupt Enable bit 6
00849D 7F849D -> $0020                C5I:          equ $20   ; %00100000 IC/OC "X" Interrupt Enable bit 5
00849D 7F849D -> $0010                C4I:          equ $10   ; %00010000 IC/OC "X" Interrupt Enable bit 4
00849D 7F849D -> $0008                C3I:          equ $08   ; %00001000 IC/OC "X" Interrupt Enable bit 3
00849D 7F849D -> $0004                C2I:          equ $04   ; %00000100 IC/OC "X" Interrupt Enable bit 2
00849D 7F849D -> $0002                C1I:          equ $02   ; %00000010 IC/OC "X" Interrupt Enable bit 1
00849D 7F849D -> $0001                C0I:          equ $01   ; %00000001 IC/OC "X" Interrupt Enable bit 0
00849D 7F849D -> $03DD                TIM_TSCR2:    equ $03DD ; Timer System Control Register 2 (pg 802)
00849D 7F849D -> $0080                TOI:          equ $80   ; %10000000 Timer Overflow Interrupt Enable bit 7
00849D 7F849D -> $0008                TCRE:         equ $08   ; %00001000 Timer Counter Register Enable bit 3
00849D 7F849D -> $0004                PR2:          equ $04   ; %00000100 Timer Prescaler Select bit 2
00849D 7F849D -> $0002                PR1:          equ $02   ; %00000010 Timer Prescaler Select bit 1
00849D 7F849D -> $0001                PR0:          equ $01   ; %00000001 Timer Prescaler Select bit 0
00849D 7F849D -> $03DE                TIM_TFLG1:    equ $03DE ; Main Timer Interrupt Flag 1 (pg 803)
00849D 7F849D -> $0080                C7F:          equ $80   ; %10000000 IC/OC Channel "x" Flag bit 7
00849D 7F849D -> $0040                C6F:          equ $40   ; %10000000 IC/OC Channel "x" Flag bit 6
00849D 7F849D -> $0020                C5F:          equ $20   ; %10000000 IC/OC Channel "x" Flag bit 5
00849D 7F849D -> $0010                C4F:          equ $10   ; %10000000 IC/OC Channel "x" Flag bit 4
00849D 7F849D -> $0008                C3F:          equ $08   ; %10000000 IC/OC Channel "x" Flag bit 3
00849D 7F849D -> $0004                C2F:          equ $04   ; %10000000 IC/OC Channel "x" Flag bit 2
00849D 7F849D -> $0002                C1F:          equ $02   ; %10000000 IC/OC Channel "x" Flag bit 1
00849D 7F849D -> $0001                C0F:          equ $01   ; %10000000 IC/OC Channel "x" Flag bit 0
00849D 7F849D -> $03DF                TIM_TFLG2:    equ $03DF ; Main Timer Interrupt Flag 2 (pg 803)
00849D 7F849D -> $0080                TOF:          equ $80   ; %10000000 Timer Overflow Flag
00849D 7F849D -> $03E0                TIM_TC0H:     equ $03E0 ; Timer IC/OC Register0 Hi (pg 804)
00849D 7F849D -> $0080                Bit15:        equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit14:        equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit13:        equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit12:        equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit11:        equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit10:        equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit9:         equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit8:         equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $03E1                TIM_TC0L:     equ $03E1 ; Timer IC/OC Register0 Lo (pg 804)
00849D 7F849D -> $0080                Bit7:         equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit6:         equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit5:         equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit4:         equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit3:         equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit2:         equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit1:         equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit0:         equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $03E2                TIM_TC1H:     equ $03E2 ; Timer IC/OC Register1 Hi (pg 804)
00849D 7F849D -> $0080                Bit15:        equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit14:        equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit13:        equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit12:        equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit11:        equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit10:        equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit9:         equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit8:         equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $03E3                TIM_TC1L:     equ $03E3 ; Timer IC/OC Register1 Lo (pg 804)
00849D 7F849D -> $0080                Bit7:         equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit6:         equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit5:         equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit4:         equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit3:         equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit2:         equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit1:         equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit0:         equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $03E4                TIM_TC2H:     equ $03E4 ; Timer IC/OC Register2 Hi (pg 804)
00849D 7F849D -> $0080                Bit15:        equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit14:        equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit13:        equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit12:        equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit11:        equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit10:        equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit9:         equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit8:         equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $03E5                TIM_TC2L:     equ $03E5 ; Timer IC/OC Register2 Lo (pg 804)
00849D 7F849D -> $0080                Bit7:         equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit6:         equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit5:         equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit4:         equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit3:         equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit2:         equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit1:         equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit0:         equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $03E6                TIM_TC3H:     equ $03E6 ; Timer IC/OC Register3 Hi (pg 804)
00849D 7F849D -> $0080                Bit15:        equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit14:        equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit13:        equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit12:        equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit11:        equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit10:        equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit9:         equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit8:         equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $03E7                TIM_TC3L:     equ $03E7 ; Timer IC/OC Register3 Lo (pg 804)
00849D 7F849D -> $0080                Bit7:         equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit6:         equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit5:         equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit4:         equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit3:         equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit2:         equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit1:         equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit0:         equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $03E8                TIM_TC4H:     equ $03E8 ; Timer IC/OC Register4 Hi (pg 804)
00849D 7F849D -> $0080                Bit15:        equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit14:        equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit13:        equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit12:        equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit11:        equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit10:        equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit9:         equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit8:         equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $03E9                TIM_TC4L:     equ $03E9 ; Timer IC/OC Register4 Lo (pg 804)
00849D 7F849D -> $0080                Bit7:         equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit6:         equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit5:         equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit4:         equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit3:         equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit2:         equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit1:         equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit0:         equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $03EA                TIM_TC5H:     equ $03EA ; Timer IC/OC Register5 Hi (pg 804)
00849D 7F849D -> $0080                Bit15:        equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit14:        equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit13:        equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit12:        equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit11:        equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit10:        equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit9:         equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit8:         equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $03EB                TIM_TC5L:     equ $03EB ; Timer IC/OC Register5 Lo (pg 804)
00849D 7F849D -> $0080                Bit7:         equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit6:         equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit5:         equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit4:         equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit3:         equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit2:         equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit1:         equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit0:         equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $03EC                TIM_TC6H:     equ $03EC ; Timer IC/OC Register6 Hi (pg 804)
00849D 7F849D -> $0080                Bit15:        equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit14:        equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit13:        equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit12:        equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit11:        equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit10:        equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit9:         equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit8:         equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $03ED                TIM_TC6L:     equ $03ED ; Timer IC/OC Register6 Lo (pg 804)
00849D 7F849D -> $0080                Bit7:         equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit6:         equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit5:         equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit4:         equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit3:         equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit2:         equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit1:         equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit0:         equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $03EE                TIM_TC7H:     equ $03EE ; Timer IC/OC Register6 Lo (pg 804)
00849D 7F849D -> $0080                Bit15:        equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit14:        equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit13:        equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit12:        equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit11:        equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit10:        equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit9:         equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit8:         equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $03EF                TIM_TC7L:     equ $03EF ; Timer IC/OC Register7 Lo (pg 804)
00849D 7F849D -> $0080                Bit7:         equ $80   ; %10000000 (bit 7)
00849D 7F849D -> $0040                Bit6:         equ $40   ; %01000000 (bit 6)
00849D 7F849D -> $0020                Bit5:         equ $20   ; %00100000 (bit 5)
00849D 7F849D -> $0010                Bit4:         equ $10   ; %00010000 (bit 4)
00849D 7F849D -> $0008                Bit3:         equ $08   ; %00001000 (bit 3)
00849D 7F849D -> $0004                Bit2:         equ $04   ; %00000100 (bit 2)
00849D 7F849D -> $0002                Bit1:         equ $02   ; %00000010 (bit 1)
00849D 7F849D -> $0001                Bit0:         equ $01   ; %00000001 (bit 0)
00849D 7F849D -> $03F0                TIM_PACTL:    equ $03F0 ; 16-Bit Pulse Accumulator Control Register (pg 805)
00849D 7F849D -> $0040                PAEN:         equ $40   ; %01000000 Pulse Accumulator System Enable(bit 6)
00849D 7F849D -> $0020                PAMOD:        equ $20   ; %00100000 Pulse Accumulator Mode(bit 5)
00849D 7F849D -> $0010                PEDGE:        equ $10   ; %00010000 Pulse Accumulator Edge Control(bit 4)
00849D 7F849D -> $0008                CLK1:         equ $08   ; %00001000 Clock Select(bit 3)
00849D 7F849D -> $0004                CLK0:         equ $04   ; %00000100 Clock Select(bit 2)
00849D 7F849D -> $0002                PAOV1:        equ $02   ; %00000010 Pulse Accumulator Overflow Interrupt Enable(bit 1)
00849D 7F849D -> $0001                PAI:          equ $01   ; %00000001 Pulse Accumulator Input Interrupt Enable(bit 0)
00849D 7F849D -> $03F1                TIM_PAFLG:    equ $03F1 ; Pulse Accumulator Flag Register (pg 806)
00849D 7F849D -> $0002                PAOVF:        equ $02   ; %00000010 Pulse Accumulator Overflow Flag(bit 1)
00849D 7F849D -> $0001                PAIF:         equ $01   ; %00000001 Pulse Accumulator input edge Flag(bit 0)
00849D 7F849D -> $03F2                TIM_PACNTH:   equ $03F2 ; Pulse Accumulator Count Register High (pg 807)
00849D 7F849D -> $0080                PACN15:       equ $80   ; %10000000 Pulse Accumulator Count Data bit 15
00849D 7F849D -> $0040                PACN14:       equ $40   ; %01000000 Pulse Accumulator Count Data bit 14
00849D 7F849D -> $0020                PACN13:       equ $20   ; %00100000 Pulse Accumulator Count Data bit 13
00849D 7F849D -> $0010                PACN12:       equ $10   ; %00010000 Pulse Accumulator Count Data bit 12
00849D 7F849D -> $0008                PACN11:       equ $08   ; %00001000 Pulse Accumulator Count Data bit 11
00849D 7F849D -> $0004                PACN10:       equ $04   ; %00000100 Pulse Accumulator Count Data bit 10
00849D 7F849D -> $0002                PACN9:        equ $02   ; %00000010 Pulse Accumulator Count Data bit 9
00849D 7F849D -> $0001                PACN8:        equ $01   ; %00000001 Pulse Accumulator Count Data bit 8
00849D 7F849D -> $03F3                TIM_PACNTL:   equ $03F3 ; Pulse Accumulators Count Register Low (pg 807)
00849D 7F849D -> $0080                PACN7:        equ $80   ; %10000000 Pulse Accumulator Count Data bit 7
00849D 7F849D -> $0040                PACN6:        equ $40   ; %01000000 Pulse Accumulator Count Data bit 6
00849D 7F849D -> $0020                PACN5:        equ $20   ; %00100000 Pulse Accumulator Count Data bit 5
00849D 7F849D -> $0010                PACN4:        equ $10   ; %00010000 Pulse Accumulator Count Data bit 4
00849D 7F849D -> $0008                PACN3:        equ $08   ; %00001000 Pulse Accumulator Count Data bit 3
00849D 7F849D -> $0004                PACN2:        equ $04   ; %00000100 Pulse Accumulator Count Data bit 2
00849D 7F849D -> $0002                PACN1:        equ $02   ; %00000010 Pulse Accumulator Count Data bit 1
00849D 7F849D -> $0001                PACN0:        equ $01   ; %00000001 Pulse Accumulator Count Data bit 0
                                      ;$03F4 to $03FB reserved
00849D 7F849D -> $03FC                TIM_OCPD:     equ $03FC ; Output Compare Pin Disconnect Register (pg 808)
00849D 7F849D -> $0080                OCPD7:        equ $80   ; %10000000 Output Compare Pin Disconnect bit 7
00849D 7F849D -> $0040                OCPD6:        equ $40   ; %01000000 Output Compare Pin Disconnect bit 6
00849D 7F849D -> $0020                OCPD5:        equ $20   ; %00100000 Output Compare Pin Disconnect bit 5
00849D 7F849D -> $0010                OCPD4:        equ $10   ; %00010000 Output Compare Pin Disconnect bit 4
00849D 7F849D -> $0008                OCPD3:        equ $08   ; %00001000 Output Compare Pin Disconnect bit 3
00849D 7F849D -> $0004                OCPD2:        equ $04   ; %00000100 Output Compare Pin Disconnect bit 2
00849D 7F849D -> $0002                OCPD1:        equ $02   ; %00000010 Output Compare Pin Disconnect bit 1
00849D 7F849D -> $0001                OCPD0:        equ $01   ; %00000001 Output Compare Pin Disconnect bit 0
                                      ;$03FD reserved
00849D 7F849D -> $03FE                TIM_PTPSR:    equ $03FE ; Precision Timer Prescaler Select Register (pg 808)
00849D 7F849D -> $0080                PTPS7:        equ $80   ; %10000000 Precision Timer Prescaler Select bit 7
00849D 7F849D -> $0040                PTPS6:        equ $40   ; %01000000 Precision Timer Prescaler Select bit 6
00849D 7F849D -> $0020                PTPS5:        equ $20   ; %00100000 Precision Timer Prescaler Select bit 5
00849D 7F849D -> $0010                PTPS4:        equ $10   ; %00010000 Precision Timer Prescaler Select bit 4
00849D 7F849D -> $0008                PTPS3:        equ $08   ; %00001000 Precision Timer Prescaler Select bit 3
00849D 7F849D -> $0004                PTPS2:        equ $04   ; %00000100 Precision Timer Prescaler Select bit 2
00849D 7F849D -> $0002                PTPS1:        equ $02   ; %00000010 Precision Timer Prescaler Select bit 1
00849D 7F849D -> $0001                PTPS0:        equ $01   ; %00000001 Precision Timer Prescaler Select bit 0
                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (vectabs_BPEM488.s)                                                        *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BPEM488 Engine Controller for the Dodge 488CID (8.0L) V10 engine  *
                                      ;*    by Robert Hiebert.                                                                 *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teaching    *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*    CPU vector tables for 9S12XEP100                                                   *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project                          *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map                                       *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project(This module)  *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map                                         *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features                     *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler              *
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications                  *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)                                     *
                                      ;*   gpio_BPEM488.s       - Initialization all ports                                     *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros                         *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing                              *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths                       *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors                   *
                                      ;*****************************************************************************************
                                      ;* Version History:                                                                      *
                                      ;*    May 25 2020                                                                        *
                                      ;*    - BPEM488 dedicated hardware version begins (work in progress)                     *
                                      ;*    - Update December 10 2020                                                          *
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
00849D 7F849D S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ;*****************************************************************************************
                                      ;* - Constants -                                                                         *
                                      ;*****************************************************************************************
                                      ; - "ResetFlgs" bit field variable equates -
00849D 7F849D -> $0001                uiISR      equ $01  ; Unimplimented ISR %00000001 (set bit 0)
00849D 7F849D -> $0002                PoLvExrst  equ $02  ; Power on, Lo Volt, Ext reset  %00000010 (set bit 1)
00849D 7F849D -> $0004                Cmrst      equ $04  ; Clock Monitor reset  %00000100 (set bit 2)
00849D 7F849D -> $0008                Coprst     equ $08  ; COP reset  %00001000 (set bit 3)
                                      ;*****************************************************************************************
                                      ;* - Variables -                                                                         *
                                      ;*****************************************************************************************
001000 0FD000                                     ORG     VECTAB_VARS_START, VECTAB_VARS_START_LIN
001000 0FD000 -> $FD000               VECTAB_VARS_START_LIN   EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
001000 0FD000                         ResetFlgs:  ds 1 ; Reset Flags bit field variable
001001 0FD001                         VecDebug:   ds 1 ; Vector Table de-bug address holder
001002 0FD002 -> $1002                VECTAB_VARS_END         EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
001002 0FD002 -> $FD002               VECTAB_VARS_END_LIN     EQU     @     ; @ Represents the current value of the linear
                                      ;*****************************************************************************************
                                      ;* - Code -                                                                              *
                                      ;*****************************************************************************************
00533D 7F533D                                                 ORG     VECTAB_CODE_START, VECTAB_CODE_START_LIN
00533D 7F533D -> $7F533D              VECTAB_CODE_START_LIN   EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ; - Unimpimented ISRs -
                                      ;   Each ISR loads the last byte of the vector address into the variable "VecDebug"
                                      ;   and stops the code there. Use D-Bug12 to read "VecDebug" to determine which is the
                                      ;   offending vector. Then try to figure out why it happended.
                                      ;*****************************************************************************************
00533D 7F533D                         SPURIOUS_ISR:
00533D 7F533D 18 0B 10 10 01              movb #$10,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005342 7F5342 20 F9                       bra  SPURIOUS_ISR    ; Keep looping here
005344 7F5344                         SYS_ISR:
005344 7F5344 18 0B 12 10 01              movb #$12,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005349 7F5349 20 F9                       bra  SYS_ISR         ; Keep looping here
00534B 7F534B                         MPU_ISR:
00534B 7F534B 18 0B 14 10 01              movb #$14,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005350 7F5350 20 F9                       bra  MPU_ISR         ; Keep looping here
005352 7F5352                         XGSWE_ISR:
005352 7F5352 18 0B 16 10 01              movb #$16,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005357 7F5357 20 F9                       bra  XGSWE_ISR       ; Keep looping here
005359 7F5359                         RES18_ISR
005359 7F5359 18 0B 18 10 01              movb #$18,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00535E 7F535E 20 F9                       bra  RES18_ISR       ; Keep looping here
005360 7F5360                         RES1A_ISR:
005360 7F5360 18 0B 1A 10 01              movb #$1A,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005365 7F5365 20 F9                       bra  RES1A_ISR       ; Keep looping here
005367 7F5367                         RES1C_ISR:
005367 7F5367 18 0B 1C 10 01              movb #$1C,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00536C 7F536C 20 F9                       bra  RES1C_ISR       ; Keep looping here
00536E 7F536E                         RES1E_ISR:
00536E 7F536E 18 0B 1E 10 01              movb #$1E,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005373 7F5373 20 F9                       bra  RES1E_ISR       ; Keep looping here
005375 7F5375                         RES20_ISR:
005375 7F5375 18 0B 20 10 01              movb #$20,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00537A 7F537A 20 F9                       bra  RES20_ISR       ; Keep looping here
00537C 7F537C                         RES22_ISR:
00537C 7F537C 18 0B 22 10 01              movb #$22,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005381 7F5381 20 F9                       bra  RES22_ISR       ; Keep looping here
005383 7F5383                         RES24_ISR:
005383 7F5383 18 0B 24 10 01              movb #$24,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005388 7F5388 20 F9                       bra  RES24_ISR       ; Keep looping here
00538A 7F538A                         RES26_ISR:
00538A 7F538A 18 0B 26 10 01              movb #$26,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00538F 7F538F 20 F9                       bra  RES26_ISR       ; Keep looping here
005391 7F5391                         RES28_ISR:
005391 7F5391 18 0B 28 10 01              movb #$28,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005396 7F5396 20 F9                       bra  RES28_ISR       ; Keep looping here
005398 7F5398                         RES2A_ISR:
005398 7F5398 18 0B 2A 10 01              movb #$2A,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00539D 7F539D 20 F9                       bra  RES2A_ISR       ; Keep looping here
00539F 7F539F                         RES2C_ISR:
00539F 7F539F 18 0B 2C 10 01              movb #$2C,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0053A4 7F53A4 20 F9                       bra  RES2C_ISR       ; Keep looping here
0053A6 7F53A6                         RES2E_ISR:
0053A6 7F53A6 18 0B 2E 10 01              movb #$2E,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0053AB 7F53AB 20 F9                       bra  RES2E_ISR       ; Keep looping here
0053AD 7F53AD                         RES30_ISR:
0053AD 7F53AD 18 0B 30 10 01              movb #$30,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0053B2 7F53B2 20 F9                       bra  RES30_ISR       ; Keep looping here
0053B4 7F53B4                         RES32_ISR:
0053B4 7F53B4 18 0B 32 10 01              movb #$32,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0053B9 7F53B9 20 F9                       bra  RES32_ISR       ; Keep looping here
0053BB 7F53BB                         RES34_ISR:
0053BB 7F53BB 18 0B 34 10 01              movb #$34,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0053C0 7F53C0 20 F9                       bra  RES34_ISR       ; Keep looping here
0053C2 7F53C2                         RES36_ISR:
0053C2 7F53C2 18 0B 36 10 01              movb #$36,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0053C7 7F53C7 20 F9                       bra  RES36_ISR       ; Keep looping here
0053C9 7F53C9                         RES38_ISR:
0053C9 7F53C9 18 0B 38 10 01              movb #$38,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0053CE 7F53CE 20 F9                       bra  RES38_ISR       ; Keep looping here
0053D0 7F53D0                         RES3A_ISR:
0053D0 7F53D0 18 0B 3A 10 01              movb #$3A,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0053D5 7F53D5 20 F9                       bra  RES3A_ISR       ; Keep looping here
0053D7 7F53D7                         ATD1COMP_ISR:
0053D7 7F53D7 18 0B 3C 10 01              movb #$3C,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0053DC 7F53DC 20 F9                       bra  ATD1COMP_ISR    ; Keep looping here
0053DE 7F53DE                         ATD0COMP_ISR:
0053DE 7F53DE 18 0B 3E 10 01              movb #$3E,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0053E3 7F53E3 20 F9                       bra  ATD0COMP_ISR    ; Keep looping here
0053E5 7F53E5                         TIM_PAIE_ISR:
0053E5 7F53E5 18 0B 40 10 01              movb #$40,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0053EA 7F53EA 20 F9                       bra  TIM_PAIE_ISR    ; Keep looping here
0053EC 7F53EC                         TIM_PAOV_ISR:
0053EC 7F53EC 18 0B 42 10 01              movb #$42,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0053F1 7F53F1 20 F9                       bra  TIM_PAOV_ISR    ; Keep looping here
0053F3 7F53F3                         TIM_TOV_ISR:
0053F3 7F53F3 18 0B 44 10 01              movb #$44,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0053F8 7F53F8 20 F9                       bra  TIM_TOV_ISR     ; Keep looping here
0053FA 7F53FA                         TIM_TC7_ISR:
0053FA 7F53FA 18 0B 46 10 01              movb #$46,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0053FF 7F53FF 20 F9                       bra  TIM_TC7_ISR     ; Keep looping here
005401 7F5401                         TIM_TC6_ISR:
005401 7F5401 18 0B 48 10 01              movb #$48,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005406 7F5406 20 F9                       bra  TIM_TC6_ISR     ; Keep looping here
005408 7F5408                         TIM_TC5_ISR:
005408 7F5408 18 0B 4A 10 01              movb #$4A,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00540D 7F540D 20 F9                       bra  TIM_TC5_ISR     ; Keep looping here
                                      ;*TIM_TC4_ISR:
                                      ;*    movb #$4C,VecDebug   ; Load "VecDebug" with the last byte of the vector address   ; TIM ch4 (PP4 Inj5 (7&2)), ENABLED, CPU level 1
                                      ;*    bra  TIM_TC4_ISR     ; Keep looping here
                                      ;*TIM_TC3_ISR:
                                      ;*    movb #$4E,VecDebug   ; Load "VecDebug" with the last byte of the vector address  ; TIM ch3 (PP3 Inj4 (5&8)), ENABLED, CPU level 1
                                      ;*    bra  TIM_TC3_ISR     ; Keep looping here
                                      ;*TIM_TC2_ISR:
                                      ;*    movb #$50,VecDebug   ; Load "VecDebug" with the last byte of the vector address ; TIM ch2 (PP2Inj3 (3&6)), ENABLED, CPU level 1
                                      ;*    bra  TIM_TC2_ISR     ; Keep looping here
                                      ;*TIM_TC1_ISR:
                                      ;*    movb #$52,VecDebug   ; Load "VecDebug" with the last byte of the vector address   ; TIM ch1 (PP1 Inj2 (9&4)), ENABLED, CPU level 1
                                      ;*    bra  TIM_TC1_ISR     ; Keep looping here
                                      ;*TIM_TC0_ISR:
                                      ;*    movb #$54,VecDebug   ; Load "VecDebug" with the last byte of the vector address  ; TIM ch0 (PP0 Inj1 (1&10)), ENABLED, CPU level 1
                                      ;*    bra  TIM_TC0_ISR     ; Keep looping here
00540F 7F540F                         SCI7_ISR:
00540F 7F540F 18 0B 56 10 01              movb #$56,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005414 7F5414 20 F9                       bra  SCI7_ISR        ; Keep looping here
005416 7F5416                         PITCH7_ISR:
005416 7F5416 18 0B 58 10 01              movb #$58,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00541B 7F541B 20 F9                       bra  PITCH7_ISR      ; Keep looping here
00541D 7F541D                         PITCH6_ISR:
00541D 7F541D 18 0B 5A 10 01              movb #$5A,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005422 7F5422 20 F9                       bra  PITCH6_ISR      ; Keep looping here
005424 7F5424                         PITCH5_ISR:
005424 7F5424 18 0B 5C 10 01              movb #$5C,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005429 7F5429 20 F9                       bra  PITCH5_ISR      ; Keep looping here
00542B 7F542B                         PITCH4_ISR:
00542B 7F542B 18 0B 5E 10 01              movb #$5E,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005430 7F5430 20 F9                       bra  PITCH4_ISR      ; Keep looping here
005432 7F5432                         RES60_ISR:
005432 7F5432 18 0B 60 10 01              movb #$60,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005437 7F5437 20 F9                       bra  RES60_ISR       ; Keep looping here
005439 7F5439                         RES62_ISR:
005439 7F5439 18 0B 62 10 01              movb #$62,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00543E 7F543E 20 F9                       bra  RES62_ISR       ; Keep looping here
005440 7F5440                         XGSWT7_ISR:
005440 7F5440 18 0B 64 10 01              movb #$64,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005445 7F5445 20 F9                       bra  XGSWT7_ISR      ; Keep looping here
005447 7F5447                         XGSWT6_ISR:
005447 7F5447 18 0B 66 10 01              movb #$66,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00544C 7F544C 20 F9                       bra  XGSWT6_ISR      ; Keep looping here
00544E 7F544E                         XGSWT5_ISR:
00544E 7F544E 18 0B 68 10 01              movb #$68,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005453 7F5453 20 F9                       bra  XGSWT5_ISR      ; Keep looping here
005455 7F5455                         XGSWT4_ISR:
005455 7F5455 18 0B 6A 10 01              movb #$6A,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00545A 7F545A 20 F9                       bra  XGSWT4_ISR      ; Keep looping here
00545C 7F545C                         XGSWT3_ISR:
00545C 7F545C 18 0B 6C 10 01              movb #$6C,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005461 7F5461 20 F9                       bra  XGSWT3_ISR      ; Keep looping here
005463 7F5463                         XGSWT2_ISR:
005463 7F5463 18 0B 6E 10 01              movb #$6E,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005468 7F5468 20 F9                       bra  XGSWT2_ISR      ; Keep looping here
00546A 7F546A                         XGSWT1_ISR:
00546A 7F546A 18 0B 70 10 01              movb #$70,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00546F 7F546F 20 F9                       bra  XGSWT1_ISR      ; Keep looping here
005471 7F5471                         XGSWT0_ISR:
005471 7F5471 18 0B 72 10 01              movb #$72,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005476 7F5476 20 F9                       bra  XGSWT0_ISR      ; Keep looping here
005478 7F5478                         PITCH3_ISR:
005478 7F5478 18 0B 74 10 01              movb #$74,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00547D 7F547D 20 F9                       bra  PITCH3_ISR      ; Keep looping here
00547F 7F547F                         PITCH2_ISR:
00547F 7F547F 18 0B 76 10 01              movb #$76,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005484 7F5484 20 F9                       bra  PITCH2_ISR      ; Keep looping here
005486 7F5486                         PITCH1_ISR:
005486 7F5486 18 0B 78 10 01              movb #$78,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00548B 7F548B 20 F9                       bra  PITCH1_ISR      ; Keep looping here
00548D 7F548D                         PITCH0_ISR:
00548D 7F548D 18 0B 7A 10 01              movb #$7A,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005492 7F5492 20 F9                       bra  PITCH0_ISR      ; Keep looping here
005494 7F5494                         HT_ISR:
005494 7F5494 18 0B 7C 10 01              movb #$7C,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005499 7F5499 20 F9                       bra  HT_ISR          ; Keep looping here
00549B 7F549B                         API_ISR:
00549B 7F549B 18 0B 7E 10 01              movb #$7E,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0054A0 7F54A0 20 F9                       bra  API_ISR         ; Keep looping here
0054A2 7F54A2                         LVI_ISR:
0054A2 7F54A2 18 0B 80 10 01              movb #$80,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0054A7 7F54A7 20 F9                       bra  LVI_ISR         ; Keep looping here
0054A9 7F54A9                         IIC1_ISR:
0054A9 7F54A9 18 0B 82 10 01              movb #$82,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0054AE 7F54AE 20 F9                       bra  IIC1_ISR        ; Keep looping here
0054B0 7F54B0                         SCI5_ISR:
0054B0 7F54B0 18 0B 84 10 01              movb #$84,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0054B5 7F54B5 20 F9                       bra  SCI5_ISR        ; Keep looping here
0054B7 7F54B7                         SCI4_ISR:
0054B7 7F54B7 18 0B 86 10 01              movb #$86,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0054BC 7F54BC 20 F9                       bra  SCI4_ISR        ; Keep looping here
0054BE 7F54BE                         SCI3_ISR:
0054BE 7F54BE 18 0B 88 10 01              movb #$88,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0054C3 7F54C3 20 F9                       bra  SCI3_ISR        ; Keep looping here
0054C5 7F54C5                         SCI2_ISR:
0054C5 7F54C5 18 0B 8A 10 01              movb #$8A,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0054CA 7F54CA 20 F9                       bra  SCI2_ISR        ; Keep looping here
0054CC 7F54CC                         PWMSDN_ISR:
0054CC 7F54CC 18 0B 8C 10 01              movb #$8C,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0054D1 7F54D1 20 F9                       bra  PWMSDN_ISR      ; Keep looping here
0054D3 7F54D3                         PORTP_ISR:
0054D3 7F54D3 18 0B 8E 10 01              movb #$8E,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0054D8 7F54D8 20 F9                       bra  PORTP_ISR       ; Keep looping here
0054DA 7F54DA                         CAN4TX_ISR:
0054DA 7F54DA 18 0B 90 10 01              movb #$90,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0054DF 7F54DF 20 F9                       bra  CAN4TX_ISR      ; Keep looping here
0054E1 7F54E1                         CAN4RX_ISR:
0054E1 7F54E1 18 0B 92 10 01              movb #$92,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0054E6 7F54E6 20 F9                       bra  CAN4RX_ISR      ; Keep looping here
0054E8 7F54E8                         CAN4ERR_ISR:
0054E8 7F54E8 18 0B 94 10 01              movb #$94,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0054ED 7F54ED 20 F9                       bra  CAN4ERR_ISR     ; Keep looping here
0054EF 7F54EF                         CAN4WUP_ISR:
0054EF 7F54EF 18 0B 96 10 01              movb #$96,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0054F4 7F54F4 20 F9                       bra  CAN4WUP_ISR     ; Keep looping here
0054F6 7F54F6                         CAN3TX_ISR:
0054F6 7F54F6 18 0B 98 10 01              movb #$98,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0054FB 7F54FB 20 F9                       bra  CAN3TX_ISR      ; Keep looping here
0054FD 7F54FD                         CAN3RX_ISR:
0054FD 7F54FD 18 0B 9A 10 01              movb #$9A,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005502 7F5502 20 F9                       bra  CAN3RX_ISR      ; Keep looping here
005504 7F5504                         CAN3ERR_ISR:
005504 7F5504 18 0B 9C 10 01              movb #$9C,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005509 7F5509 20 F9                       bra  CAN3ERR_ISR     ; Keep looping here
00550B 7F550B                         CAN3WUP_ISR:
00550B 7F550B 18 0B 9E 10 01              movb #$9E,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005510 7F5510 20 F9                       bra  CAN3WUP_ISR     ; Keep looping here
005512 7F5512                         CAN2TX_ISR:
005512 7F5512 18 0B A0 10 01              movb #$A0,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005517 7F5517 20 F9                       bra  CAN2TX_ISR      ; Keep looping here
005519 7F5519                         CAN2RX_ISR:
005519 7F5519 18 0B A2 10 01              movb #$A2,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00551E 7F551E 20 F9                       bra  CAN2RX_ISR      ; Keep looping here
005520 7F5520                         CAN2ERR_ISR:
005520 7F5520 18 0B A4 10 01              movb #$A4,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005525 7F5525 20 F9                       bra  CAN2ERR_ISR     ; Keep looping here
005527 7F5527                         CAN2WUP_ISR:
005527 7F5527 18 0B A6 10 01              movb #$A6,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00552C 7F552C 20 F9                       bra  CAN2WUP_ISR     ; Keep looping here
00552E 7F552E                         CAN1TX_ISR:
00552E 7F552E 18 0B A8 10 01              movb #$A8,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005533 7F5533 20 F9                       bra  CAN1TX_ISR      ; Keep looping here
005535 7F5535                         CAN1RX_ISR:
005535 7F5535 18 0B AA 10 01              movb #$AA,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00553A 7F553A 20 F9                       bra  CAN1RX_ISR      ; Keep looping here
00553C 7F553C                         CAN1ERR_ISR:
00553C 7F553C 18 0B AC 10 01              movb #$AC,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005541 7F5541 20 F9                       bra  CAN1ERR_ISR     ; Keep looping here
005543 7F5543                         CAN1WUP_ISR:
005543 7F5543 18 0B AE 10 01              movb #$AE,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005548 7F5548 20 F9                       bra  CAN1WUP_ISR     ; Keep looping here
00554A 7F554A                         CAN0TX_ISR:
00554A 7F554A 18 0B B0 10 01              movb #$B0,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00554F 7F554F 20 F9                       bra  CAN0TX_ISR      ; Keep looping here
005551 7F5551                         CAN0RX_ISR:
005551 7F5551 18 0B B2 10 01              movb #$B2,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005556 7F5556 20 F9                       bra  CAN0RX_ISR      ; Keep looping here
005558 7F5558                         CAN0ERR_ISR:
005558 7F5558 18 0B B4 10 01              movb #$B4,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00555D 7F555D 20 F9                       bra  CAN0ERR_ISR     ; Keep looping here
00555F 7F555F                         CAN0WUP_ISR:
00555F 7F555F 18 0B B6 10 01              movb #$B6,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005564 7F5564 20 F9                       bra  CAN0WUP_ISR     ; Keep looping here
005566 7F5566                         FLASH_ISR:
005566 7F5566 18 0B B8 10 01              movb #$B8,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00556B 7F556B 20 F9                       bra  FLASH_ISR       ; Keep looping here
00556D 7F556D                         FLASHFLT_ISR:
00556D 7F556D 18 0B BA 10 01              movb #$BA,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005572 7F5572 20 F9                       bra  FLASHFLT_ISR    ; Keep looping here
005574 7F5574                         SPI2_ISR:
005574 7F5574 18 0B BC 10 01              movb #$BC,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005579 7F5579 20 F9                       bra  SPI2_ISR        ; Keep looping here
00557B 7F557B                         SPI1_ISR:
00557B 7F557B 18 0B BE 10 01              movb #$BE,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005580 7F5580 20 F9                       bra  SPI1_ISR        ; Keep looping here
005582 7F5582                         IIC0_ISR:
005582 7F5582 18 0B C0 10 01              movb #$C0,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005587 7F5587 20 F9                       bra  IIC0_ISR        ; Keep looping here
005589 7F5589                         SCI6_ISR:
005589 7F5589 18 0B C2 10 01              movb #$C2,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00558E 7F558E 20 F9                       bra  SCI6_ISR        ; Keep looping here
005590 7F5590                         SCM_ISR:
005590 7F5590 18 0B C4 10 01              movb #$C4,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005595 7F5595 20 F9                       bra  SCM_ISR         ; Keep looping here
005597 7F5597                         PLLLOCK_ISR:
005597 7F5597 18 0B C6 10 01              movb #$C6,VecDebug   ; Load "VecDebug" with the last byte of the vector address
00559C 7F559C 20 F9                       bra  PLLLOCK_ISR     ; Keep looping here
00559E 7F559E                         ECT_PBOV_ISR:
00559E 7F559E 18 0B C8 10 01              movb #$C8,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0055A3 7F55A3 20 F9                       bra  ECT_PBOV_ISR    ; Keep looping here
0055A5 7F55A5                         ECT_MODCNT_ISR:
0055A5 7F55A5 18 0B CA 10 01              movb #$CA,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0055AA 7F55AA 20 F9                       bra  ECT_MODCNT_ISR  ; Keep looping here
0055AC 7F55AC                         PORTH_ISR:
0055AC 7F55AC 18 0B CC 10 01              movb #$CC,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0055B1 7F55B1 20 F9                       bra  PORTH_ISR       ; Keep looping here
0055B3 7F55B3                         PORTJ_ISR:
0055B3 7F55B3 18 0B CE 10 01              movb #$CE,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0055B8 7F55B8 20 F9                       bra  PORTJ_ISR       ; Keep looping here
0055BA 7F55BA                         ATD1_ISR:
0055BA 7F55BA 18 0B D0 10 01              movb #$D0,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0055BF 7F55BF 20 F9                       bra  ATD1_ISR        ; Keep looping here
0055C1 7F55C1                         ATD0_ISR:
0055C1 7F55C1 18 0B D2 10 01              movb #$D2,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0055C6 7F55C6 20 F9                       bra  ATD0_ISR        ; Keep looping here
0055C8 7F55C8                         SCI1_ISR:
0055C8 7F55C8 18 0B D4 10 01              movb #$D4,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0055CD 7F55CD 20 F9                       bra  SCI1_ISR        ; Keep looping here
                                      ;*SCI0_ISR:
                                      ;*    movb #$D6,VecDebug   ; Load "VecDebug" with the last byte of the vector address        ; SCI0 ENABLED, CPU, level 1
                                      ;*    bra  SCI1_ISR        ; Keep looping here
0055CF 7F55CF                         SPI0_ISR
0055CF 7F55CF 18 0B D8 10 01              movb #$D8,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0055D4 7F55D4 20 F9                       bra  SPI0_ISR        ; Keep looping here
0055D6 7F55D6                         ECT_PAIE_ISR:
0055D6 7F55D6 18 0B DA 10 01              movb #$DA,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0055DB 7F55DB 20 F9                       bra  ECT_PAIE_ISR    ; Keep looping here
0055DD 7F55DD                         ECT_PAOV_ISR:
0055DD 7F55DD 18 0B DC 10 01              movb #$DC,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0055E2 7F55E2 20 F9                       bra  ECT_PAOV_ISR    ; Keep looping here
0055E4 7F55E4                         ECT_TOV_ISR:
0055E4 7F55E4 18 0B DE 10 01              movb #$DE,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0055E9 7F55E9 20 F9                       bra  ECT_TOV_ISR     ; Keep looping here
                                      ;*ECT_TC7_ISR:
                                      ;*    movb #$E0,VecDebug   ; Load "VecDebug" with the last byte of the vector address       ; ECT ch7 (PT7 Ign5 (3&2)) ENABLED, CPU, level 1
                                      ;*    bra  ECT_TC7_ISR     ; Keep looping here
                                      ;*ECT_TC6_ISR:
                                      ;*    movb #$E2,VecDebug   ; Load "VecDebug" with the last byte of the vector address      ; ECT ch6 (PT6 Ign4 (4&7)) ENABLED, CPU, level 1
                                      ;*    bra  ECT_TC3_ISR     ; Keep looping here
                                      ;*ECT_TC5_ISR:
                                      ;*    movb #$E4,VecDebug   ; Load "VecDebug" with the last byte of the vector address      ; ECT ch5 (PT5 Ign3 (9&8)) ENABLED, CPU level 1
                                      ;*    bra  ECT_TC5_ISR     ; Keep looping here
                                      ;*ECT_TC4_ISR:
                                      ;*    movb #$E6,VecDebug   ; Load "VecDebug" with the last byte of the vector address      ; ECT ch4 (PT4 Ign2 (10&5)) ENABLED, CPU level 1
                                      ;*    bra  ECT_TC3_ISR     ; Keep looping here
                                      ;*ECT_TC3_ISR:
                                      ;*    movb #$E8,VecDebug   ; Load "VecDebug" with the last byte of the vector address      ; ECT ch3 (PT3 Ign1 (1&6)) ENABLED, CPU level 1
                                      ;*    bra  ECT_TC3_ISR     ; Keep looping here
                                      ;*ECT_TC2_ISR:
                                      ;*    movb #$EA,VecDebug   ; Load "VecDebug" with the last byte of the vector address      ; ECT ch2 (PT2 Vspd), ENABLED, CPU level 1
                                      ;*    bra  ECT_TC2_ISR     ; Keep looping here
                                      ;*ECT_TC1_ISR:
                                      ;*    movb #$EC,VecDebug   ; Load "VecDebug" with the last byte of the vector address      ; ECT ch1 (CKP), ENABLED, CPU level 7
                                      ;*    bra  ECT_TC1_ISR     ; Keep looping here
                                      ;*ECT_TC0_ISR:
                                      ;*    movb #$EE,VecDebug   ; Load "VecDebug" with the last byte of the vector address      ; ECT ch0 (CMP), ENABLED, CPU level 7
                                      ;*    bra  ECT_TC0_ISR     ; Keep looping here
                                      ;*RTI_ISR
                                      ;*    movb #$F0,VecDebug   ; Load "VecDebug" with the last byte of the vector address        ; RTI ENABLED, CPU, level 1
                                      ;*    bra  RTI_ISR         ; Keep looping here
0055EB 7F55EB                         IRQ_ISR:
0055EB 7F55EB 18 0B F2 10 01              movb #$F2,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0055F0 7F55F0 20 F9                       bra  IRQ_ISR         ; Keep looping here
0055F2 7F55F2                         XIRQ_ISR:
0055F2 7F55F2 18 0B F4 10 01              movb #$F4,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0055F7 7F55F7 20 F9                       bra  XIRQ_ISR        ; Keep looping here
0055F9 7F55F9                         SWI_ISR:
0055F9 7F55F9 18 0B F6 10 01              movb #$F6,VecDebug   ; Load "VecDebug" with the last byte of the vector address
0055FE 7F55FE 20 F9                       bra  SWI_ISR         ; Keep looping here
005600 7F5600                         TRAP_ISR:
005600 7F5600 18 0B F8 10 01              movb #$F8,VecDebug   ; Load "VecDebug" with the last byte of the vector address
005605 7F5605 20 F9                       bra  TRAP_ISR        ; Keep looping here
                                      ;*****************************************************************************************
                                      ; - Reset entry points -
                                      ;*****************************************************************************************
                                      ; - Power-on, Low voltage and External reset -
005607 7F5607                         RESET_EXT_ENTRY:
005607 7F5607 18 0B 02 10 00              movb  #PoLvExrst,ResetFlgs  ; Load "ResetFlgs" with %00000010 (set bit 1)
00560C 7F560C 06 40 00                    job   BPEM488_CODE_START    ; Jump or Branch to BPEM488_CODE_START: (Start of BPEM488.s)
                                      ; - Clock Monitor reset -
00560F 7F560F                         RESET_CM_ENTRY:
00560F 7F560F 18 0B 04 10 00              movb  #Cmrst,ResetFlgs      ; Load "ResetFlgs" with %00000100 (set bit 2)
005614 7F5614 06 40 00                    job   BPEM488_CODE_START    ; Jump or Branch to BPEM488_CODE_START: (Start of BPEM488.s)
                                      ; - COP and user reset -
005617 7F5617                         RESET_COP_ENTRY:
005617 7F5617 18 0B 08 10 00              movb  #Coprst,ResetFlgs     ; Load "ResetFlgs" with %00001000 (set bit 3)
00561C 7F561C 06 40 00                    job   BPEM488_CODE_START    ; Jump or Branch to BPEM488_CODE_START: (Start of BPEM488.s)
00561F 7F561F -> $561F                VECTAB_CODE_END         EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
00561F 7F561F -> $7F561F              VECTAB_CODE_END_LIN     EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ;* - Tables -                                                                            *
                                      ;*****************************************************************************************
007B53 7F7B53                                                 ORG     VECTAB_TABS_START, VECTAB_TABS_START_LIN
007B53 7F7B53 -> $7F7B53              VECTAB_TABS_START_LIN   EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ; - Interrupt service routines -
007B53 7F7B53 -> $533D                ISR_SPURIOUS    EQU SPURIOUS_ISR                ;vector base + $10
007B53 7F7B53 -> $5344                ISR_SYS                 EQU SYS_ISR                             ;vector base + $12
007B53 7F7B53 -> $534B                ISR_MPU                 EQU MPU_ISR                             ;vector base + $14
007B53 7F7B53 -> $5352                ISR_XGSWE       EQU XGSWE_ISR                   ;vector base + $16
007B53 7F7B53 -> $5359                ISR_RES18               EQU RES18_ISR                   ;vector base + $18
007B53 7F7B53 -> $5360                ISR_RES1A               EQU RES1A_ISR                   ;vector base + $1A
007B53 7F7B53 -> $5367                ISR_RES1C               EQU RES1C_ISR                   ;vector base + $1C
007B53 7F7B53 -> $536E                ISR_RES1E               EQU RES1E_ISR                   ;vector base + $1E
007B53 7F7B53 -> $5375                ISR_RES20               EQU RES20_ISR                   ;vector base + $20
007B53 7F7B53 -> $537C                ISR_RES22               EQU RES22_ISR                   ;vector base + $22
007B53 7F7B53 -> $5383                ISR_RES24               EQU RES24_ISR                   ;vector base + $24
007B53 7F7B53 -> $538A                ISR_RES26               EQU RES26_ISR                   ;vector base + $26
007B53 7F7B53 -> $5391                ISR_RES28               EQU RES28_ISR                   ;vector base + $28
007B53 7F7B53 -> $5398                ISR_RES2A               EQU RES2A_ISR                   ;vector base + $2A
007B53 7F7B53 -> $539F                ISR_RES2C               EQU RES2C_ISR                   ;vector base + $2C
007B53 7F7B53 -> $53A6                ISR_RES2E               EQU RES2E_ISR                   ;vector base + $2E
007B53 7F7B53 -> $53AD                ISR_RES30               EQU RES30_ISR                   ;vector base + $30
007B53 7F7B53 -> $53B4                ISR_RES32               EQU RES32_ISR                   ;vector base + $32
007B53 7F7B53 -> $53BB                ISR_RES34               EQU RES34_ISR                   ;vector base + $34
007B53 7F7B53 -> $53C2                ISR_RES36               EQU RES36_ISR                   ;vector base + $36
007B53 7F7B53 -> $53C9                ISR_RES38               EQU RES38_ISR                   ;vector base + $38
007B53 7F7B53 -> $53D0                ISR_RES3A               EQU RES3A_ISR                   ;vector base + $3A
007B53 7F7B53 -> $53D7                ISR_ATD1COMP    EQU ATD1COMP_ISR                ;vector base + $3C
007B53 7F7B53 -> $53DE                ISR_ATD0COMP    EQU ATD0COMP_ISR                ;vector base + $3E
007B53 7F7B53 -> $53E5                ISR_TIM_PAIE    EQU TIM_PAIE_ISR                ;vector base + $40
007B53 7F7B53 -> $53EC                ISR_TIM_PAOV    EQU TIM_PAOV_ISR                ;vector base + $42
007B53 7F7B53 -> $53F3                ISR_TIM_TOV     EQU TIM_TOV_ISR                 ;vector base + $44
007B53 7F7B53 -> $53FA                ISR_TIM_TC7     EQU TIM_TC7_ISR                 ;vector base + $46    ; TIM CH 7 ((D7)(87to112)(Inj5)(7&2)) enabled
007B53 7F7B53 -> $5401                ISR_TIM_TC6     EQU TIM_TC6_ISR                 ;vector base + $48    ; TIM Ch 6 ((D1)(87to112)(Inj4)(5&8)) enabled
007B53 7F7B53 -> $5408                ISR_TIM_TC5     EQU TIM_TC5_ISR                 ;vector base + $4A    ; TIM Ch 5 ((D6)(87to112)(Inj3)(3&6)) enabled
007B53 7F7B53 -> $5A38                ISR_TIM_TC4     EQU TIM_TC4_ISR                 ;vector base + $4C    ; TIM Ch 4 ((D3)(87to112)(Inj2)(9&4)) enabled
007B53 7F7B53 -> $5A26                ISR_TIM_TC3     EQU TIM_TC3_ISR                 ;vector base + $4E    ; TIM Ch 3 ((D1)(1to28)(Inj1)(1&10)) enabled
007B53 7F7B53 -> $5A14                ISR_TIM_TC2     EQU TIM_TC2_ISR                 ;vector base + $50    ; TIM Ch 2 ((D24)(1to28)(Ign5)(3&2)) enabled
007B53 7F7B53 -> $5A02                ISR_TIM_TC1     EQU TIM_TC1_ISR                 ;vector base + $52    ; TIM Ch 1 ((D5)(1to28)(Ign4)(4&7)) enabled
007B53 7F7B53 -> $59F0                ISR_TIM_TC0     EQU TIM_TC0_ISR                 ;vector base + $54    ; TIM Ch 0 ((D21)(1to28)(Ign3)(9&8))enabled
007B53 7F7B53 -> $540F                ISR_SCI7        EQU SCI7_ISR                    ;vector base + $56
007B53 7F7B53 -> $5416                ISR_PITCH7      EQU PITCH7_ISR                  ;vector base + $58
007B53 7F7B53 -> $541D                ISR_PITCH6      EQU PITCH6_ISR                  ;vector base + $5A
007B53 7F7B53 -> $5424                ISR_PITCH5      EQU PITCH5_ISR                  ;vector base + $5C
007B53 7F7B53 -> $542B                ISR_PITCH4      EQU PITCH4_ISR                  ;vector base + $5E
007B53 7F7B53 -> $5432                ISR_RES60               EQU RES60_ISR                   ;vector base + $60
007B53 7F7B53 -> $5439                ISR_RES62               EQU RES62_ISR                   ;vector base + $62
007B53 7F7B53 -> $5440                ISR_XGSWT7              EQU XGSWT7_ISR                  ;vector base + $64
007B53 7F7B53 -> $5447                ISR_XGSWT6              EQU XGSWT6_ISR                  ;vector base + $66
007B53 7F7B53 -> $544E                ISR_XGSWT5              EQU XGSWT5_ISR                  ;vector base + $68
007B53 7F7B53 -> $5455                ISR_XGSWT4              EQU XGSWT4_ISR                  ;vector base + $6A
007B53 7F7B53 -> $545C                ISR_XGSWT3              EQU XGSWT3_ISR                  ;vector base + $6C
007B53 7F7B53 -> $5463                ISR_XGSWT2              EQU XGSWT2_ISR                  ;vector base + $6E
007B53 7F7B53 -> $546A                ISR_XGSWT1              EQU XGSWT1_ISR                  ;vector base + $70
007B53 7F7B53 -> $5471                ISR_XGSWT0              EQU XGSWT0_ISR                  ;vector base + $72     ; XGATE SW Trig 0 (RTI) DISABLED, XGATE, level 1 (used to clear RTI variables)
007B53 7F7B53 -> $5478                ISR_PITCH3              EQU PITCH3_ISR                  ;vector base + $74
007B53 7F7B53 -> $547F                ISR_PITCH2              EQU PITCH2_ISR                  ;vector base + $76
007B53 7F7B53 -> $5486                ISR_PITCH1              EQU PITCH1_ISR                  ;vector base + $78
007B53 7F7B53 -> $548D                ISR_PITCH0              EQU PITCH0_ISR                  ;vector base + $7A
007B53 7F7B53 -> $5494                ISR_HT                  EQU HT_ISR                              ;vector base + $7C
007B53 7F7B53 -> $549B                ISR_API                 EQU API_ISR                             ;vector base + $7E
007B53 7F7B53 -> $54A2                ISR_LVI                 EQU LVI_ISR                             ;vector base + $80
007B53 7F7B53 -> $54A9                ISR_IIC1                EQU IIC1_ISR                    ;vector base + $82
007B53 7F7B53 -> $54B0                ISR_SCI5                EQU SCI5_ISR                    ;vector base + $84
007B53 7F7B53 -> $54B7                ISR_SCI4                EQU SCI4_ISR                    ;vector base + $86
007B53 7F7B53 -> $54BE                ISR_SCI3                EQU SCI3_ISR                    ;vector base + $88
007B53 7F7B53 -> $54C5                ISR_SCI2                EQU SCI2_ISR                    ;vector base + $8A
007B53 7F7B53 -> $54CC                ISR_PWMSDN              EQU PWMSDN_ISR                  ;vector base + $8C
007B53 7F7B53 -> $54D3                ISR_PORTP               EQU PORTP_ISR                   ;vector base + $8E
007B53 7F7B53 -> $54DA                ISR_CAN4TX              EQU CAN4TX_ISR                  ;vector base + $90
007B53 7F7B53 -> $54E1                ISR_CAN4RX              EQU CAN4RX_ISR                  ;vector base + $92
007B53 7F7B53 -> $54E8                ISR_CAN4ERR             EQU CAN4ERR_ISR                 ;vector base + $94
007B53 7F7B53 -> $54EF                ISR_CAN4WUP             EQU CAN4WUP_ISR                 ;vector base + $96
007B53 7F7B53 -> $54F6                ISR_CAN3TX              EQU CAN3TX_ISR                  ;vector base + $98
007B53 7F7B53 -> $54FD                ISR_CAN3RX              EQU CAN3RX_ISR                  ;vector base + $9A
007B53 7F7B53 -> $5504                ISR_CAN3ERR             EQU CAN3ERR_ISR                 ;vector base + $9C
007B53 7F7B53 -> $550B                ISR_CAN3WUP             EQU CAN3WUP_ISR                 ;vector base + $9E
007B53 7F7B53 -> $5512                ISR_CAN2TX              EQU CAN2TX_ISR                  ;vector base + $A0
007B53 7F7B53 -> $5519                ISR_CAN2RX              EQU CAN2RX_ISR                  ;vector base + $A2
007B53 7F7B53 -> $5520                ISR_CAN2ERR             EQU CAN2ERR_ISR                 ;vector base + $A4
007B53 7F7B53 -> $5527                ISR_CAN2WUP             EQU CAN2WUP_ISR                 ;vector base + $A6
007B53 7F7B53 -> $552E                ISR_CAN1TX      EQU CAN1TX_ISR                  ;vector base + $A8
007B53 7F7B53 -> $5535                ISR_CAN1RX      EQU CAN1RX_ISR                  ;vector base + $AA
007B53 7F7B53 -> $553C                ISR_CAN1ERR     EQU CAN1ERR_ISR                 ;vector base + $AC
007B53 7F7B53 -> $5543                ISR_CAN1WUP     EQU CAN1WUP_ISR                 ;vector base + $AE
007B53 7F7B53 -> $554A                ISR_CAN0TX      EQU CAN0TX_ISR                  ;vector base + $B0
007B53 7F7B53 -> $5551                ISR_CAN0RX      EQU CAN0RX_ISR                  ;vector base + $B2
007B53 7F7B53 -> $5558                ISR_CAN0ERR     EQU CAN0ERR_ISR                 ;vector base + $B4
007B53 7F7B53 -> $555F                ISR_CAN0WUP     EQU CAN0WUP_ISR                 ;vector base + $B6
007B53 7F7B53 -> $5566                ISR_FLASH       EQU FLASH_ISR                   ;vector base + $B8
007B53 7F7B53 -> $556D                ISR_FLASHFLT    EQU FLASHFLT_ISR                ;vector base + $BA
007B53 7F7B53 -> $5574                ISR_SPI2        EQU SPI2_ISR                    ;vector base + $BC
007B53 7F7B53 -> $557B                ISR_SPI1        EQU SPI1_ISR                    ;vector base + $BE
007B53 7F7B53 -> $5582                ISR_IIC0        EQU IIC0_ISR                    ;vector base + $C0
007B53 7F7B53 -> $5589                ISR_SCI6        EQU SCI6_ISR                    ;vector base + $C2
007B53 7F7B53 -> $5590                ISR_SCM                 EQU SCM_ISR                             ;vector base + $C4
007B53 7F7B53 -> $5597                ISR_PLLLOCK             EQU PLLLOCK_ISR                 ;vector base + $C6
007B53 7F7B53 -> $559E                ISR_ECT_PBOV    EQU ECT_PBOV_ISR                ;vector base + $C8
007B53 7F7B53 -> $55A5                ISR_ECT_MODCNT  EQU ECT_MODCNT_ISR              ;vector base + $CA
007B53 7F7B53 -> $55AC                ISR_PORTH               EQU PORTH_ISR                   ;vector base + $CC
007B53 7F7B53 -> $55B3                ISR_PORTJ               EQU PORTJ_ISR                   ;vector base + $CE
007B53 7F7B53 -> $55BA                ISR_ATD1                EQU ATD1_ISR                    ;vector base + $D0
007B53 7F7B53 -> $55C1                ISR_ATD0                EQU     ATD0_ISR                ;vector base + $D2
007B53 7F7B53 -> $55C8                ISR_SCI1                EQU SCI1_ISR                    ;vector base + $D4
007B53 7F7B53 -> $5681                ISR_SCI0        EQU SCI0_ISR            ;vector base + $D6   ; SCI0 ENABLED, CPU, level 1
007B53 7F7B53 -> $55CF                ISR_SPI0                EQU SPI0_ISR                    ;vector base + $D8
007B53 7F7B53 -> $55D6                ISR_ECT_PAIE    EQU ECT_PAIE_ISR                ;vector base + $DA
007B53 7F7B53 -> $55DD                ISR_ECT_PAOV    EQU ECT_PAOV_ISR                ;vector base + $DC
007B53 7F7B53 -> $55E4                ISR_ECT_TOV             EQU ECT_TOV_ISR                 ;vector base + $DE
007B53 7F7B53 -> $59E2                ISR_ECT_TC7             EQU ECT_TC7_ISR                 ;vector base + $E0   ; ECT Ch 7 (Crank) ENABLED, CPU, level 7 (Highest)
007B53 7F7B53 -> $59D4                ISR_ECT_TC6     EQU ECT_TC6_ISR         ;vector base + $E2   ; ECT Ch 6 (VSS) ENABLED, CPU, level 1
007B53 7F7B53 -> $59C6                ISR_ECT_TC5             EQU ECT_TC5_ISR                 ;vector base + $E4   ; ECT Ch 5 (Cam) ENABLED, CPU level 6
007B53 7F7B53 -> $59B8                ISR_ECT_TC4     EQU ECT_TC4_ISR         ;vector base + $E6
007B53 7F7B53 -> $59AA                ISR_ECT_TC3             EQU ECT_TC3_ISR                 ;vector base + $E8
007B53 7F7B53 -> $5989                ISR_ECT_TC2             EQU ECT_TC2_ISR                 ;vector base + $EA   ; ECT Ch 2 ((D8)(1to28)(Ign2)(10&5)) ENABLED
007B53 7F7B53 -> $5A5B                ISR_ECT_TC1             EQU ECT_TC1_ISR                 ;vector base + $EC
007B53 7F7B53 -> $5A4A                ISR_ECT_TC0             EQU ECT_TC0_ISR                 ;vector base + $EE   ; ECT Ch 0 ((D7)(1to28)(Ign1)(1&6)), ENABLED,
007B53 7F7B53 -> $561F                ISR_RTI         EQU RTI_ISR             ;vector base + $F0   ; RTI ENABLED, CPU, level 1
007B53 7F7B53 -> $55EB                ISR_IRQ                 EQU IRQ_ISR                             ;vector base + $F2
007B53 7F7B53 -> $55F2                ISR_XIRQ                EQU XIRQ_ISR                    ;vector base + $F4
007B53 7F7B53 -> $55F9                ISR_SWI                 EQU SWI_ISR                             ;vector base + $F6
007B53 7F7B53 -> $5600                ISR_TRAP                EQU TRAP_ISR                    ;vector base + $F8
007B53 7F7B53 -> $7B53                VECTAB_TABS_END         EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
007B53 7F7B53 -> $7F7B53              VECTAB_TABS_END_LIN     EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ; - 9S12XEP100 Reset Vectors. Vector base is set by Interrupt Vector
                                      ;   Base Register (IVBR). Reset sets IVBR to $FF. (Pgs 80..84)
                                      ;*****************************************************************************************
00FF10 7FFF10                                                 ORG     VECTAB_START, VECTAB_START_LIN  ; $FF10,$7FFF10
00FF10 7FFF10 53 3D                   VEC_SPURIOUS    DW      ISR_SPURIOUS        ;vector base + $10
00FF12 7FFF12 53 44                   VEC_SYS         DW      ISR_SYS             ;vector base + $12
00FF14 7FFF14 53 4B                   VEC_MPU         DW      ISR_MPU             ;vector base + $14
00FF16 7FFF16 53 52                   VEC_XGSWE       DW      ISR_XGSWE           ;vector base + $16
00FF18 7FFF18 53 59                   VEC_RES18               DW      ISR_RES18                   ;vector base + $18
00FF1A 7FFF1A 53 60                   VEC_RES1A               DW      ISR_RES1A                   ;vector base + $1A
00FF1C 7FFF1C 53 67                   VEC_RES1C               DW      ISR_RES1C                   ;vector base + $1C
00FF1E 7FFF1E 53 6E                   VEC_RES1E               DW      ISR_RES1E                   ;vector base + $1E
00FF20 7FFF20 53 75                   VEC_RES20               DW      ISR_RES20                   ;vector base + $20
00FF22 7FFF22 53 7C                   VEC_RES22               DW      ISR_RES22                   ;vector base + $22
00FF24 7FFF24 53 83                   VEC_RES24               DW      ISR_RES24                   ;vector base + $24
00FF26 7FFF26 53 8A                   VEC_RES26               DW      ISR_RES26                   ;vector base + $26
00FF28 7FFF28 53 91                   VEC_RES28               DW      ISR_RES28                   ;vector base + $28
00FF2A 7FFF2A 53 98                   VEC_RES2A               DW      ISR_RES2A                   ;vector base + $2A
00FF2C 7FFF2C 53 9F                   VEC_RES2C               DW      ISR_RES2C                   ;vector base + $2C
00FF2E 7FFF2E 53 A6                   VEC_RES2E               DW      ISR_RES2E                   ;vector base + $2E
00FF30 7FFF30 53 AD                   VEC_RES30               DW      ISR_RES30                   ;vector base + $30
00FF32 7FFF32 53 B4                   VEC_RES32               DW      ISR_RES32                   ;vector base + $32
00FF34 7FFF34 53 BB                   VEC_RES34               DW      ISR_RES34                   ;vector base + $34
00FF36 7FFF36 53 C2                   VEC_RES36               DW      ISR_RES36                   ;vector base + $36
00FF38 7FFF38 53 C9                   VEC_RES38               DW      ISR_RES38                   ;vector base + $38
00FF3A 7FFF3A 53 D0                   VEC_RES3A               DW      ISR_RES3A                   ;vector base + $3A
00FF3C 7FFF3C 53 D7                   VEC_ATD1COMP    DW      ISR_ATD1COMP            ;vector base + $3C
00FF3E 7FFF3E 53 DE                   VEC_ATD0COMP    DW      ISR_ATD0COMP            ;vector base + $3E
00FF40 7FFF40 53 E5                   VEC_TIM_PAIE    DW      ISR_TIM_PAIE            ;vector base + $40
00FF42 7FFF42 53 EC                   VEC_TIM_PAOV    DW      ISR_TIM_PAOV            ;vector base + $42
00FF44 7FFF44 53 F3                   VEC_TIM_TOV     DW      ISR_TIM_TOV             ;vector base + $44
00FF46 7FFF46 53 FA                   VEC_TIM_TC7     DW      ISR_TIM_TC7             ;vector base + $46
00FF48 7FFF48 54 01                   VEC_TIM_TC6     DW      ISR_TIM_TC6             ;vector base + $48
00FF4A 7FFF4A 54 08                   VEC_TIM_TC5     DW      ISR_TIM_TC5             ;vector base + $4A
00FF4C 7FFF4C 5A 38                   VEC_TIM_TC4     DW      ISR_TIM_TC4             ;vector base + $4C
00FF4E 7FFF4E 5A 26                   VEC_TIM_TC3     DW      ISR_TIM_TC3             ;vector base + $4E
00FF50 7FFF50 5A 14                   VEC_TIM_TC2     DW      ISR_TIM_TC2             ;vector base + $50
00FF52 7FFF52 5A 02                   VEC_TIM_TC1     DW      ISR_TIM_TC1             ;vector base + $52
00FF54 7FFF54 59 F0                   VEC_TIM_TC0     DW      ISR_TIM_TC0             ;vector base + $54
00FF56 7FFF56 54 0F                   VEC_SCI7        DW      ISR_SCI7                ;vector base + $56
00FF58 7FFF58 54 16                   VEC_PITCH7      DW      ISR_PITCH7              ;vector base + $58
00FF5A 7FFF5A 54 1D                   VEC_PITCH6      DW      ISR_PITCH6              ;vector base + $5A
00FF5C 7FFF5C 54 24                   VEC_PITCH5      DW      ISR_PITCH5              ;vector base + $5C
00FF5E 7FFF5E 54 2B                   VEC_PITCH4      DW      ISR_PITCH4              ;vector base + $5E
00FF60 7FFF60 54 32                   VEC_RES60               DW      ISR_RES60                   ;vector base + $60
00FF62 7FFF62 54 39                   VEC_RES62               DW      ISR_RES62                   ;vector base + $62
00FF64 7FFF64 54 40                   VEC_XGSWT7              DW      ISR_XGSWT7                  ;vector base + $64
00FF66 7FFF66 54 47                   VEC_XGSWT6              DW      ISR_XGSWT6                  ;vector base + $66
00FF68 7FFF68 54 4E                   VEC_XGSWT5              DW      ISR_XGSWT5                  ;vector base + $68
00FF6A 7FFF6A 54 55                   VEC_XGSWT4              DW      ISR_XGSWT4                  ;vector base + $6A
00FF6C 7FFF6C 54 5C                   VEC_XGSWT3              DW      ISR_XGSWT3                  ;vector base + $6C
00FF6E 7FFF6E 54 63                   VEC_XGSWT2              DW      ISR_XGSWT2                  ;vector base + $6E
00FF70 7FFF70 54 6A                   VEC_XGSWT1              DW      ISR_XGSWT1                  ;vector base + $70
00FF72 7FFF72 54 71                   VEC_XGSWT0              DW      ISR_XGSWT0                  ;vector base + $72
00FF74 7FFF74 54 78                   VEC_PITCH3              DW      ISR_PITCH3                  ;vector base + $74
00FF76 7FFF76 54 7F                   VEC_PITCH2              DW      ISR_PITCH2                  ;vector base + $76
00FF78 7FFF78 54 86                   VEC_PITCH1              DW      ISR_PITCH1                  ;vector base + $78
00FF7A 7FFF7A 54 8D                   VEC_PITCH0              DW      ISR_PITCH0                  ;vector base + $7A
00FF7C 7FFF7C 54 94                   VEC_HT                  DW      ISR_HT                      ;vector base + $7C
00FF7E 7FFF7E 54 9B                   VEC_API                 DW      ISR_API                     ;vector base + $7E
00FF80 7FFF80 54 A2                   VEC_LVI                 DW      ISR_LVI                     ;vector base + $80
00FF82 7FFF82 54 A9                   VEC_IIC1                DW      ISR_IIC1                    ;vector base + $82
00FF84 7FFF84 54 B0                   VEC_SCI5                DW      ISR_SCI5                    ;vector base + $84
00FF86 7FFF86 54 B7                   VEC_SCI4                DW      ISR_SCI4                    ;vector base + $86
00FF88 7FFF88 54 BE                   VEC_SCI3                DW      ISR_SCI3                    ;vector base + $88
00FF8A 7FFF8A 54 C5                   VEC_SCI2                DW      ISR_SCI2                    ;vector base + $8A
00FF8C 7FFF8C 54 CC                   VEC_PWMSDN              DW      ISR_PWMSDN                  ;vector base + $8C
00FF8E 7FFF8E 54 D3                   VEC_PORTP               DW      ISR_PORTP                   ;vector base + $8E
00FF90 7FFF90 54 DA                   VEC_CAN4TX              DW      ISR_CAN4TX                  ;vector base + $90
00FF92 7FFF92 54 E1                   VEC_CAN4RX              DW      ISR_CAN4RX                  ;vector base + $92
00FF94 7FFF94 54 E8                   VEC_CAN4ERR             DW      ISR_CAN4ERR                 ;vector base + $94
00FF96 7FFF96 54 EF                   VEC_CAN4WUP             DW      ISR_CAN4WUP                 ;vector base + $96
00FF98 7FFF98 54 F6                   VEC_CAN3TX              DW      ISR_CAN3TX                  ;vector base + $98
00FF9A 7FFF9A 54 FD                   VEC_CAN3RX              DW      ISR_CAN3RX                  ;vector base + $9A
00FF9C 7FFF9C 55 04                   VEC_CAN3ERR             DW      ISR_CAN3ERR                 ;vector base + $9C
00FF9E 7FFF9E 55 0B                   VEC_CAN3WUP             DW      ISR_CAN3WUP                 ;vector base + $9E
00FFA0 7FFFA0 55 12                   VEC_CAN2TX              DW      ISR_CAN2TX                  ;vector base + $A0
00FFA2 7FFFA2 55 19                   VEC_CAN2RX              DW      ISR_CAN2RX                  ;vector base + $A2
00FFA4 7FFFA4 55 20                   VEC_CAN2ERR             DW      ISR_CAN2ERR                 ;vector base + $A4
00FFA6 7FFFA6 55 27                   VEC_CAN2WUP             DW      ISR_CAN2WUP                 ;vector base + $A6
00FFA8 7FFFA8 55 2E                   VEC_CAN1TX      DW      ISR_CAN1TX              ;vector base + $A8
00FFAA 7FFFAA 55 35                   VEC_CAN1RX      DW      ISR_CAN1RX              ;vector base + $AA
00FFAC 7FFFAC 55 3C                   VEC_CAN1ERR     DW      ISR_CAN1ERR             ;vector base + $AC
00FFAE 7FFFAE 55 43                   VEC_CAN1WUP     DW      ISR_CAN1WUP             ;vector base + $AE
00FFB0 7FFFB0 55 4A                   VEC_CAN0TX      DW      ISR_CAN0TX              ;vector base + $A0
00FFB2 7FFFB2 55 51                   VEC_CAN0RX      DW      ISR_CAN0RX              ;vector base + $B2
00FFB4 7FFFB4 55 58                   VEC_CAN0ERR     DW      ISR_CAN0ERR             ;vector base + $B4
00FFB6 7FFFB6 55 5F                   VEC_CAN0WUP     DW      ISR_CAN0WUP             ;vector base + $B6
00FFB8 7FFFB8 55 66                   VEC_FLASH       DW      ISR_FLASH               ;vector base + $B8
00FFBA 7FFFBA 55 6D                   VEC_FLASHFLT    DW      ISR_FLASHFLT            ;vector base + $BA
00FFBC 7FFFBC 55 74                   VEC_SPI2        DW      ISR_SPI2                ;vector base + $BC
00FFBE 7FFFBE 55 7B                   VEC_SPI1        DW      ISR_SPI1                ;vector base + $BE
00FFC0 7FFFC0 55 82                   VEC_IIC0        DW      ISR_IIC0                ;vector base + $C0
00FFC2 7FFFC2 55 89                   VEC_SCI6        DW      ISR_SCI6                ;vector base + $C2
00FFC4 7FFFC4 55 90                   VEC_SCM         DW      ISR_SCM             ;vector base + $C4
00FFC6 7FFFC6 55 97                   VEC_PLLLOCK     DW      ISR_PLLLOCK             ;vector base + $C6
00FFC8 7FFFC8 55 9E                   VEC_ECT_PBOV    DW      ISR_ECT_PBOV            ;vector base + $C8
00FFCA 7FFFCA 55 A5                   VEC_ECT_MODCNT  DW      ISR_ECT_MODCNT          ;vector base + $CA
00FFCC 7FFFCC 55 AC                   VEC_PORTH               DW      ISR_PORTH                   ;vector base + $CC
00FFCE 7FFFCE 55 B3                   VEC_PORTJ               DW      ISR_PORTJ                   ;vector base + $CE
00FFD0 7FFFD0 55 BA                   VEC_ATD1                DW      ISR_ATD1                    ;vector base + $D0
00FFD2 7FFFD2 55 C1                   VEC_ATD0                DW      ISR_ATD0                    ;vector base + $D2
00FFD4 7FFFD4 55 C8                   VEC_SCI1                DW      ISR_SCI1                    ;vector base + $D4
00FFD6 7FFFD6 56 81                   VEC_SCI0                DW      ISR_SCI0                    ;vector base + $D6
00FFD8 7FFFD8 55 CF                   VEC_SPI0                DW      ISR_SPI0                    ;vector base + $D8
00FFDA 7FFFDA 55 D6                   VEC_ECT_PAIE    DW      ISR_ECT_PAIE            ;vector base + $DA
00FFDC 7FFFDC 55 DD                   VEC_ECT_PAOV    DW      ISR_ECT_PAOV            ;vector base + $DC
00FFDE 7FFFDE 55 E4                   VEC_ECT_TOV             DW      ISR_ECT_TOV                 ;vector base + $DE
00FFE0 7FFFE0 59 E2                   VEC_ECT_TC7             DW      ISR_ECT_TC7                 ;vector base + $E0
00FFE2 7FFFE2 59 D4                   VEC_ECT_TC6             DW      ISR_ECT_TC6                 ;vector base + $E2
00FFE4 7FFFE4 59 C6                   VEC_ECT_TC5             DW      ISR_ECT_TC5                 ;vector base + $E4
00FFE6 7FFFE6 59 B8                   VEC_ECT_TC4             DW      ISR_ECT_TC4                 ;vector base + $E6
00FFE8 7FFFE8 59 AA                   VEC_ECT_TC3             DW      ISR_ECT_TC3                 ;vector base + $E8
00FFEA 7FFFEA 59 89                   VEC_ECT_TC2             DW      ISR_ECT_TC2                 ;vector base + $EA
00FFEC 7FFFEC 5A 5B                   VEC_ECT_TC1             DW      ISR_ECT_TC1                 ;vector base + $EC
00FFEE 7FFFEE 5A 4A                   VEC_ECT_TC0             DW      ISR_ECT_TC0                 ;vector base + $EE
00FFF0 7FFFF0 56 1F                   VEC_RTI                 DW      ISR_RTI                     ;vector base + $F0
00FFF2 7FFFF2 55 EB                   VEC_IRQ                 DW      ISR_IRQ                     ;vector base + $F2
00FFF4 7FFFF4 55 F2                   VEC_XIRQ                DW      ISR_XIRQ                    ;vector base + $F4
00FFF6 7FFFF6 55 F9                   VEC_SWI                 DW      ISR_SWI                     ;vector base + $F6
00FFF8 7FFFF8 56 00                   VEC_TRAP                DW      ISR_TRAP                    ;vector base + $F8
00FFFA 7FFFFA 56 17                   VEC_RESET_COP   DW      RESET_COP_ENTRY         ;vector base + $FA
00FFFC 7FFFFC 56 0F                   VEC_RESET_CM    DW      RESET_CM_ENTRY          ;vector base + $FC
00FFFE 7FFFFE 56 07                   VEC_RESET_EXT   DW      RESET_EXT_ENTRY         ;vector base + $FE
                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (mmap_BPEM488.s)                                                           *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BPEM488 Engine Controller for the Dodge 488CID (8.0L) V10 engine  *
                                      ;*    by Robert Hiebert.                                                                 *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teaching    *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*    This module performs all the necessary steps to initialize the device              *
                                      ;*    after each reset.                                                                  *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project                          *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map                                       *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project               *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map (This module)                           *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features                     *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler              *
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications                  *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)                                     *
                                      ;*   gpio_BPEM488.s       - Initialization all ports                                     *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros                         *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing                              *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths                       *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors                   *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
010000 800000 S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ;  Flash Memory Map:
                                      ;  -----------------
                                      ;                      S12X
                                      ;                +-------------+ $0000
                                      ;                |  Registers  |
                                      ;                +-------------+ $0800
                                      ;                |/////////////|
                                      ;         RAM->+ +-------------+ $1000
                                      ;              | |  Variables  |
                                      ;       Flash->+ +-------------+ $4000
                                      ;              | |/////////////|
                                      ;              | +-------------+ $C000
                                      ;              | |    Code     |
                                      ;              | +-------------+
                                      ;              | |   Tables    |
                                      ;              | +-------------+ $FF10
                                      ;              | |   Vectors   |
                                      ;              + +-------------+
                                      ;
                                      ;  RAM Memory Map:
                                      ;  ---------------
                                      ;                      S12X
                                      ;                +-------------+ $0000
                                      ;                |  Registers  |
                                      ;                +-------------+ $0800
                                      ;                |/////////////|
                                      ;         RAM->+ +-------------+ $1000
                                      ;              | |  Variables  |
                                      ;              | +-------------+
                                      ;              | |    Code     |
                                      ;              | +-------------+
                                      ;              | |   Tables    |
                                      ;              | +-------------+
                                      ;              | |/////////////|
                                      ;              | +-------------+ $3F10
                                      ;              | |   Vectors   |
                                      ;              + +-------------+ $4000
                                      ;                |/////////////|
                                      ;                +-------------+
                                      ;
                                      ;*****************************************************************************************
                                      ;* - Security and Protection -                                                           *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Manually add the correct global addresses to the ORG statements and allocate the full
                                      ;   8 byte NVM phrase.
                                      ;   Method A:
                                      ;   ORG $FF08, $7F_FF08
                                      ;   DW  $FFFF   ;$FF08
                                      ;   DW  $FFFF   ;$FF0A
                                      ;   DW  $FFFF   ;$FF0C
                                      ;   DW  $FFFE   ;$FF0F
                                      ;   or Method B below:
                                      ;*****************************************************************************************
00FF08 7FFF08                                 ORG  $FF08, $7F_FF08
00FF08 7FFF08 FF FF FF FF FF FF FF FF     FILL  $FF, 8               ; Allocate the full phrase
00FF0D 7FFF0D                                 ORG   $FF0D, $7F_FF0D  ; EEE Protection Register (unprotect)
00FF0D 7FFF0D FF                          DB    $FF                  ; %11111111 (Unprotected buffer RAM EEE partition areas
                                                                     ; enabled)
00FF0F 7FFF0F                                 ORG   $FF0F, $7F_FF0F  ; Flash Security Register (unsecure)
00FF0F 7FFF0F FE                          DB    $FE                  ; %11111110 (Backdoor Key Disabled, Flash Security
                                                                     ; unsecured)
                                      ;*****************************************************************************************
                                      ;* - Constants - (Memory locations)                                                      *
                                      ;*****************************************************************************************
                                      ; - Register space -
00FF10 7FFF10 -> $0000                MMAP_REG_START      EQU $0000
00FF10 7FFF10 -> $0000                MMAP_REG_START_LIN  EQU $00_0000
00FF10 7FFF10 -> $0800                MMAP_REG_END        EQU $0800
00FF10 7FFF10 -> $0800                MMAP_REG_END_LIN    EQU $0_0800
                                      ; - EEPROM -
00FF10 7FFF10 -> $0800                MMAP_EE_START         EQU $0800
00FF10 7FFF10 -> $13F800              MMAP_EE_START_LIN     EQU $13_F800
00FF10 7FFF10 -> $1000                MMAP_EE_END           EQU $1000
00FF10 7FFF10 -> $140000              MMAP_EE_END_LIN       EQU $14_0000
00FF10 7FFF10 -> $0800                MMAP_EE_WIN_START     EQU MMAP_EE_START    ; $0800
00FF10 7FFF10 -> $0C00                MMAP_EE_WIN_END       EQU $0C00
00FF10 7FFF10 -> $0C00                MMAP_EE_FF_START      EQU MMAP_EE_WIN_END  ; $0C00
00FF10 7FFF10 -> $13FC00              MMAP_EE_FF_START_LIN  EQU $13_FC00
00FF10 7FFF10 -> $1000                MMAP_EE_FF_END        EQU MMAP_EE_END      ; $1000
00FF10 7FFF10 -> $140000              MMAP_EE_FF_END_LIN    EQU MMAP_EE_END_LIN  ; $14_0000
                                      ; - RAM -
00FF10 7FFF10 -> $1000                MMAP_RAM_START           EQU $1000
00FF10 7FFF10 -> $FD000               MMAP_RAM_START_LIN       EQU $0F_D000
00FF10 7FFF10 -> $4000                MMAP_RAM_END             EQU $4000
00FF10 7FFF10 -> $100000              MMAP_RAM_END_LIN         EQU $10_0000
00FF10 7FFF10 -> $1000                MMAP_RAM_WIN_START       EQU MMAP_RAM_START    ; $1000
00FF10 7FFF10 -> $2000                MMAP_RAM_WIN_END         EQU $2000
00FF10 7FFF10 -> $2000                MMAP_RAM_FEFF_START      EQU MMAP_RAM_WIN_END  ; $2000
00FF10 7FFF10 -> $FE000               MMAP_RAM_FEFF_START_LIN  EQU $0F_E000
00FF10 7FFF10 -> $4000                MMAP_RAM_FEFF_END        EQU MMAP_RAM_END      ; $4000
00FF10 7FFF10 -> $100000              MMAP_RAM_FEFF_END_LIN    EQU MMAP_RAM_END_LIN  ; $10_0000
                                      ; - XGATE RAM -
00FF10 7FFF10 -> $8000                MMAP_XGATE_RAM_START_XG        EQU $8000
00FF10 7FFF10 -> $F8000               MMAP_XGATE_RAM_START_LIN       EQU $0F_8000
00FF10 7FFF10 -> $10000               MMAP_XGATE_RAM_END_XG          EQU $01_0000
00FF10 7FFF10 -> $100000              MMAP_XGATE_RAM_END_LIN         EQU $10_0000
                                      ; - Flash -
00FF10 7FFF10 -> $4000                MMAP_FLASH_START          EQU $4000
00FF10 7FFF10 -> $7F4000              MMAP_FLASH_START_LIN      EQU $7F_4000
00FF10 7FFF10 -> $10000               MMAP_FLASH_END            EQU $10000
00FF10 7FFF10 -> $800000              MMAP_FLASH_END_LIN        EQU $80_0000
00FF10 7FFF10 -> $8000                MMAP_FLASH_WIN_START      EQU $8000
00FF10 7FFF10 -> $C000                MMAP_FLASH_WIN_END        EQU $C000
00FF10 7FFF10 -> $4000                MMAP_FLASH_FD_START       EQU $4000
00FF10 7FFF10 -> $7F4000              MMAP_FLASH_FD_START_LIN   EQU $7F_4000
00FF10 7FFF10 -> $8000                MMAP_FLASH_FD_END         EQU $8000
00FF10 7FFF10 -> $7F8000              MMAP_FLASH_FD_END_LIN     EQU $7F_8000
00FF10 7FFF10 -> $8000                MMAP_FLASH_FE_START       EQU $8000
00FF10 7FFF10 -> $7F8000              MMAP_FLASH_FE_START_LIN   EQU $7F_8000
00FF10 7FFF10 -> $C000                MMAP_FLASH_FE_END         EQU $C000
00FF10 7FFF10 -> $7FC000              MMAP_FLASH_FE_END_LIN     EQU $7F_C000
00FF10 7FFF10 -> $C000                MMAP_FLASH_FF_START       EQU $C000
00FF10 7FFF10 -> $7FC000              MMAP_FLASH_FF_START_LIN   EQU $7F_C000
00FF10 7FFF10 -> $10000               MMAP_FLASH_FF_END         EQU MMAP_FLASH_END      ; $10000
00FF10 7FFF10 -> $800000              MMAP_FLASH_FF_END_LIN     EQU MMAP_FLASH_END_LIN  ; $80_0000
                                      ; - XGATE Flash -
00FF10 7FFF10 -> $0800                MMAP_XG_FLASH_START_XG       EQU $0800
00FF10 7FFF10 -> $780800              MMAP_XG_FLASH_START_LIN      EQU $78_0800
00FF10 7FFF10 -> $8000                MMAP_XG_FLASH_END_XG         EQU $8000
00FF10 7FFF10 -> $788000              MMAP_XG_FLASH_END_LIN        EQU $78_8000
                                      ; - XGATE Vector table -
00FF10 7FFF10 -> $787E00              MMAP_XG_VECTAB_START_LIN     EQU MMAP_XG_FLASH_END_LIN-(4*128)  ; 4*128=512=$200 $78_8000-$200=$78_7E00
00FF10 7FFF10 -> $7E00                MMAP_XG_VECTAB_START_XG      EQU MMAP_XG_FLASH_END_XG-(4*128)   ; 4*128=512=$200 $8000-$200=$7E00
00FF10 7FFF10 -> $788000              MMAP_XG_VECTAB_END_LIN       EQU MMAP_XG_FLASH_END_LIN          ; $78_8000
00FF10 7FFF10 -> $8000                MMAP_XG_VECTAB_END_XG        EQU MMAP_XG_FLASH_END_XG           ; $8000
00FF10 7FFF10 -> $7E00                MMAP_XG_XGVBR_VALUE          EQU MMAP_XG_VECTAB_START_XG        ; $7E00
                                      ; - Vector table -
00FF10 7FFF10 -> $FF10                VECTAB_START       EQU $FF10
00FF10 7FFF10 -> $7FFF10              VECTAB_START_LIN   EQU $7F_FF10
                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (eeem_BPEM488.s)                                                           *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BPEM488 Engine Controller for the Dodge 488CID (8.0L) V10 engine  *
                                      ;*    by Robert Hiebert.                                                                 *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teaching    *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*   EE Emulation. D-Flash was partitioned using D-Bug 12 command:                       *
                                      ;*   "PARTDF 0 4096" to use all 32k bytes D-Flash and 4k bytes buffer RAM for            *
                                      ;*   EE Emulation. The "PARTDF" command by itself displays the partition configuration   *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project                          *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map                                       *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project               *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map                                         *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features                     *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler              *
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications                  *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)                                     *
                                      ;*   gpio_BPEM488.s       - Initialization all ports                                     *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros                         *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing                              *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths                       *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors                   *
                                      ;*****************************************************************************************
                                      ;* Version History:                                                                      *
                                      ;*    May 23 2020                                                                        *
                                      ;*    - BPEM488 dedicated hardware version begins (work in progress)                     *
                                      ;*    - Update December 10 2020                                                          *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
00FF10 7FFF10 S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ; - Oscillator frequency -
00FF10 7FFF10 -> $F42400              CLOCK_OSC_FREQ          EQU     16000000        ; 16 MHz
                                      ; - Prescaler value -
00FF10 7FFF10 -> $000F                EEEM_FDIV_VAL           EQU     (CLOCK_OSC_FREQ/1000000)-1
                                                          ; 16000000/1000000=16-1=15=$0F Ref manual pg 1151
                                      ;*****************************************************************************************
                                      ;* - Constants -                                                                         *
                                      ;*****************************************************************************************
00FF10 7FFF10 -> $FF0800              BUF_RAM_P1_START    EQU  $FF0800   ; Buffer RAM page 1 pointer(actual address 13FC00)
00FF10 7FFF10 -> $FE0800              BUF_RAM_P2_START    EQU  $FE0800   ; Buffer RAM page 2 pointer(actual address 13F800)
00FF10 7FFF10 -> $FD0800              BUF_RAM_P3_START    EQU  $FD0800   ; Buffer RAM page 3 pointer(actual address 13F400)
00FF10 7FFF10 -> $FC0800              BUF_RAM_P4_START    EQU  $FC0800   ; Buffer RAM page 4 pointer(actual address 13F000)
                                      ;*****************************************************************************************
                                      ; - Page 1 VE table, ranges and other configurable constants
                                      ;  (Copied from EE Emulation D-Flash to Buffer RAM on start up,
                                      ;  all pages 1024 bytes)
                                      ;*****************************************************************************************
FF0800 0F4800                                      ORG   BUF_RAM_P1_START ; $FF0800 (Buffer Ram page 1 pointer)
                                                                          ;(actual address 13FC00)
FF0800 0F4800                         veBins_E:          rmb $288 ; 648 bytes for VE Table (% x 10)
FF0A88 0F4A88                         verpmBins_E:       rmb $24  ; 36 bytes for VE Table RPM Bins (RPM)
FF0AAC 0F4AAC                         vemapBins_E:       rmb $24  ; 36 bytes for VE Table MAP Bins (KpA x 10)
FF0AD0 0F4AD0                         barCorVals_E:      rmb $12  ; 18 bytes for barometric correction values (KpA x 10)
FF0AE2 0F4AE2                         barCorDelta_E:     rmb $12  ; 18 bytes for barometric correction  (% x 10)
FF0AF4 0F4AF4                         dwellvolts_E:      rmb $0C  ; 12 bytes for dwell battery correction (volts x 10)
FF0B00 0F4B00                         dwellcorr_E:       rmb $0C  ; 12 bytes for dwell battery correction (% x 10)
FF0B0C 0F4B0C                         tempTable1_E:      rmb $14  ; 20 bytes for table common temperature values (degrees C or F x 10)
FF0B20 0F4B20                         tempTable2_E:      rmb $14  ; 20 bytes for table common temperature values (degrees C or F x 10)
FF0B34 0F4B34                         matCorrTemps2_E:   rmb $12  ; 18 bytes for MAT correction temperature (degrees C or F x 10)
FF0B46 0F4B46                         matCorrDelta2_E:   rmb $12  ; 18 bytes for MAT correction (% x 10)
FF0B58 0F4B58                         primePWTable_E:    rmb $14  ; 20 bytes for priming pulse width (msec x 10)
FF0B6C 0F4B6C                         crankPctTable_E:   rmb $14  ; 20 bytes for cranking pulsewidth adder (% x 10 of reqFuel)
FF0B80 0F4B80                         asePctTable_E:     rmb $14  ; 20 bytes for after start enrichment adder (% x 10)
FF0B94 0F4B94                         aseRevTable_E:     rmb $14  ; 20 bytes for after start enrichment time (engine revolutions)
FF0BA8 0F4BA8                         wueBins_E:         rmb $14  ; 20 bytes for after warm up enrichment adder (% x 10)
FF0BBC 0F4BBC                         TOEbins_E:         rmb $08  ; 8 bytes for TPS acceleration adder (%)
FF0BC4 0F4BC4                         TOErates_E:        rmb $08  ; 8 bytes for TPS acceleration rate (%/Sec x 10)
FF0BCC 0F4BCC                         DdBndBase_E:       rmb $02  ; 2 bytes for injector deadband at 13.2V (mSec * 100)
FF0BCE 0F4BCE                         DdBndCor_E:        rmb $02  ; 2 bytes for injector deadband voltage correction (mSec/V x 100)
FF0BD0 0F4BD0                         tpsThresh_E:       rmb $02  ; 2 bytes for Throttle Opening Enrichment threshold (TpsPctx10/100mS)
FF0BD2 0F4BD2                         TOEtime_E:         rmb $02  ; 2 bytes for Throttle Opening Enrich time in 100mS increments(mSx10)
FF0BD4 0F4BD4                         ColdAdd_E:         rmb $02  ; 2 bytes for Throttle Opening Enrichment cold temperature adder at -40F (%)
FF0BD6 0F4BD6                         ColdMul_E:         rmb $02  ; 2 bytes for Throttle Opening Enrichment multiplyer at -40F (%)
FF0BD8 0F4BD8                         InjDelDegx10_E:    rmb $02  ; 2 bytes for Injection delay from trigger to start of injection (deg x 10)
FF0BDA 0F4BDA                         OFCtps_E:          rmb $02  ; 2 bytes for Overrun Fuel Cut min TpS%x10
FF0BDC 0F4BDC                         OFCrpm_E:          rmb $02  ; 2 bytes for Overrun Fuel Cut min RPM
FF0BDE 0F4BDE                         OFCmap_E:          rmb $02  ; 2 bytes for Overrun Fuel Cut maximum manifold pressure permissive (KPAx10)
FF0BE0 0F4BE0                         OFCdel_E:          rmb $02  ; 2 bytes for Overrun Fuel Cut delay time (Sec x 10)
FF0BE2 0F4BE2                         crankingRPM_E:     rmb $02  ; 2 bytes for crank/run transition (RPM)
FF0BE4 0F4BE4                         floodClear_E:      rmb $02  ; 2 bytes for TPS position for flood clear (% x 10)
FF0BE6 0F4BE6                         Stallcnt_E:        rmb $02  ; 2 bytes for no crank or stall condition counter (1mS increments)
FF0BE8 0F4BE8                         tpsMin_E:          rmb $02  ; 2 bytes for TPS calibration closed throttle ADC
FF0BEA 0F4BEA                         tpsMax_E:          rmb $02  ; 2 bytes for TPS calibration wide open throttle ADC(
FF0BEC 0F4BEC                         reqFuel_E:         rmb $02  ; 2 bytes for Pulse width for 14.7 AFR @ 100% VE (mS x 10)
FF0BEE 0F4BEE                         enginesize_E:      rmb $02  ; 2 bytes for displacement of two engine cylinders (for TS reqFuel calcs only)(cc)
FF0BF0 0F4BF0                         InjPrFlo_E:        rmb $02  ; 2 bytes for Pair of injectors flow rate (L/hr x 100)
FF0BF2 0F4BF2                         staged_pri_size_E: rmb $01  ; 1 byte for flow rate of 1 injector (for TS reqFuel calcs only)(cc)
FF0BF3 0F4BF3                         alternate_E:       rmb $01  ; 1 byte for injector staging bit field (for TS reqFuel calcs only)
FF0BF4 0F4BF4                         nCylinders_E:      rmb $01  ; 1 byte for number of engine cylinders bit field (for TS reqFuel calcs only)
FF0BF5 0F4BF5                         nInjectors_E:      rmb $01  ; 1 byte for number of injectors bit field (for TS reqFuel calcs only)
FF0BF6 0F4BF6                         divider_E:         rmb $01  ; 1 byte for squirts per cycle bit field (for TS reqFuel calcs only)
                                      ;*****************************************************************************************
                                      ; - Page 2 ST table, ranges and other configurable constants
                                      ;  (Copied from EE Emulation D-Flash to Buffer RAM on start up,
                                      ;  all pages 1024 bytes)
                                      ;*****************************************************************************************
FE0800 0F4800                                      ORG   BUF_RAM_P2_START ; $FE0800 (Buffer Ram page 2 pointer)
                                                                          ;(actual address 13F800)
FE0800 0F4800                         stBins_E:     rmb $288 ; 648 bytes for ST Table
FE0A88 0F4A88                         strpmBins_E:  rmb $24  ; 36 bytes for ST Table RPM Bins
FE0AAC 0F4AAC                         stmapBins_E:  rmb $24  ; 36 bytes for ST Table MAP Bins
FE0AD0 0F4AD0                         heton_E:      rmb $02  ; 2 bytes for High engine temperature alarm on set point (degF*10)
FE0AD2 0F4AD2                         hetoff_E:     rmb $02  ; 2 bytes for High engine temperature alarm off set point (degF*10)
FE0AD4 0F4AD4                         hoton_E:      rmb $02  ; 2 bytes for High oil temperature alarm on set point (degF*10)
FE0AD6 0F4AD6                         hotoff_E:     rmb $02  ; 2 bytes for High oil temperature alarm off set point (degF*10)
FE0AD8 0F4AD8                         hfton_E:      rmb $02  ; 2 bytes for High fuel temperature alarm on set point (degF*10)
FE0ADA 0F4ADA                         hftoff_E:     rmb $02  ; 2 bytes for High fuel temperature alarm off set point (degF*10)
FE0ADC 0F4ADC                         hegton_E:     rmb $02  ; 2 bytes for High exhaust gas temperature alarm on set point (degF*10)
FE0ADE 0F4ADE                         hegtoff_E:    rmb $02  ; 2 bytes for High exhaust gas temperature alarm off set point (degF*10)
FE0AE0 0F4AE0                         lopon_E:      rmb $02  ; 2 bytes for Low engine oil pressure alarm on set point (psi*10)
FE0AE2 0F4AE2                         lopoff_E:     rmb $02  ; 2 bytes for Low oil engine pressure alarm off set point (psi*10)
FE0AE4 0F4AE4                         hfpon_E:      rmb $02  ; 2 bytes for High fuel pressure alarm on set point (psi*10)
FE0AE6 0F4AE6                         hfpoff_E:     rmb $02  ; 2 bytes for High fuel pressure alarm off set point (psi*10)
FE0AE8 0F4AE8                         lfpon_E:      rmb $02  ; 2 bytes for Low fuel pressure alarm on set point (psi*10)
FE0AEA 0F4AEA                         lfpoff_E:     rmb $02  ; 2 bytes for Low fuel pressure alarm off set point (psi*10)
FE0AEC 0F4AEC                         Dwell_E:      rmb $02  ; 2 bytes for run mode dwell time (mSec*10)
FE0AEE 0F4AEE                         CrnkDwell_E:  rmb $02  ; 2 bytes for crank mode dwell time (mSec*10)
FE0AF0 0F4AF0                         CrnkAdv_E:    rmb $02  ; 2 bytes for crank mode ignition advance (Deg*10)
                                       ;*****************************************************************************************
                                      ; - Page 3 AFR table, ranges and other configurable constants
                                      ;  (Copied from EE Emulation D-Flash to Buffer RAM on start up,
                                      ;  all pages 1024 bytes)
                                      ;*****************************************************************************************
FD0800 0F4800                                      ORG   BUF_RAM_P3_START ; $FD0800 (Buffer Ram page 3 pointer)
                                                                          ;(actual address 13F400)
FD0800 0F4800                         afrBins_E:    rmb $288 ; 648 bytes for AFR Table (0)
FD0A88 0F4A88                         afrrpmBins_E: rmb $24  ; 36 bytes for AFR Table RPM Bins (648)
FD0AAC 0F4AAC                         afrmapBins_E: rmb $24  ; 36 bytes for AFR Table MAP Bins (684)
                                      ;*****************************************************************************************
                                      ;* - Variables -                                                                         *
                                      ;*****************************************************************************************
001002 0FD002                                     ORG     EEEM_VARS_START, EEEM_VARS_START_LIN
001002 0FD002 -> $FD002               EEEM_VARS_START_LIN     EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ; --------------------------- No variables for the module --------------------------------
001002 0FD002 -> $1002                EEEM_VARS_END           EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
001002 0FD002 -> $FD002               EEEM_VARS_END_LIN       EQU     @     ; @ Represents the current value of the linear
                                                               ; of Flash Status Register is set
                                                               ;(Flash command has completed)
                                      ; - Step (5) optional!: Check for errors -
                                      ; - Error conditions: -
                                      ; "Load Data Field" command active (is not going to happen)
                                      ; D-flash not partitioned for EEE operation
                                      ; (could be checked once in your init sequence)
                                      ;    brset      FSTAT, #ACCERR, \1 ; If Flash Access Error flag is set,
                                                                     ; branch to address of error handler
                                      ;*****************************************************************************************
                                      ;* - Code -                                                                              *
                                      ;*****************************************************************************************
00561F 7F561F                                                 ORG     EEEM_CODE_START, EEEM_CODE_START_LIN
00561F 7F561F -> $7F561F              EEEM_CODE_START_LIN     EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ; ---------------------------- No code for this module -----------------------------------
00561F 7F561F -> $561F                EEEM_CODE_END           EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
00561F 7F561F -> $7F561F              EEEM_CODE_END_LIN       EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ;* - Tables -                                                                            *
                                      ;*****************************************************************************************
007B53 7F7B53                                                 ORG     EEEM_TABS_START, EEEM_TABS_START_LIN
007B53 7F7B53 -> $7F7B53              EEEM_TABS_START_LIN     EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ; ---------------------------- No tables for this module ---------------------------------
007B53 7F7B53 -> $7B53                EEEM_TABS_END           EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
007B53 7F7B53 -> $7F7B53              EEEM_TABS_END_LIN       EQU     @     ; @ Represents the current value of the linear
                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (clock_BPEM488.s                                                           *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BPEM488 Engine Controller for the Dodge 488CID (8.0L) V10 engine  *
                                      ;*    by Robert Hiebert.                                                                 *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teaching    *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*    This module does S12XEP100 PLL,clock related features and RTI initialization       *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project                          *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map                                       *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project               *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map                                         *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features (This module)       *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler              *
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications                  *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)                                     *
                                      ;*   gpio_BPEM488.s       - Initialization all ports                                     *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros                         *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing                              *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths                       *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors                   *
                                      ;*****************************************************************************************
                                      ;* Version History:                                                                      *
                                      ;*    May 25 2020                                                                        *
                                      ;*    - BPEM488 dedicated hardware version begins (work in progress)                     *
                                      ;*    - Update December 10 2020                                                          *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
007B53 7F7B53 S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ;*****************************************************************************************
                                      ;* - Variables -                                                                         *
                                      ;*****************************************************************************************
001002 0FD002                                     ORG     CLOCK_VARS_START, CLOCK_VARS_START_LIN
001002 0FD002 -> $FD002               CLOCK_VARS_START_LIN    EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ; ----------------------------- No variables for this module ----------------------------
001002 0FD002 -> $1002                CLOCK_VARS_END          EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
001002 0FD002 -> $FD002               CLOCK_VARS_END_LIN      EQU     @     ; @ Represents the current value of the linear
                                      ;*****************************************************************************************
                                      ;* - Code -                                                                              *
                                      ;*****************************************************************************************
00561F 7F561F                                                 ORG     CLOCK_CODE_START, CLOCK_CODE_START_LIN
00561F 7F561F -> $7F561F              CLOCK_CODE_START_LIN    EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ; ------------------------------- No code for this module -------------------------------
00561F 7F561F -> $561F                CLOCK_CODE_END          EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
00561F 7F561F -> $7F561F              CLOCK_CODE_END_LIN      EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ;* - Tables -                                                                            *
                                      ;*****************************************************************************************
007B53 7F7B53                                                 ORG     CLOCK_TABS_START, CLOCK_TABS_START_LIN
007B53 7F7B53 -> $7F7B53              CLOCK_TABS_START_LIN    EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ; ------------------------------- No tables for this module ------------------------------
007B53 7F7B53 -> $7B53                CLOCK_TABS_END          EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
007B53 7F7B53 -> $7F7B53              CLOCK_TABS_END_LIN      EQU     @     ; @ Represents the current value of the linear
                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (rti_BPEM488.s)                                                            *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BPEM Engine Controller by Robert Hiebert.                         *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teachoing   *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*    Real Time Interrupt time rate generator handler                                    *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project                          *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map                                       *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project               *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map                                         *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features                     *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler (This module)*
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications                  *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)                                     *
                                      ;*   gpio_BPEM488.s       - Initialization all ports                                     *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros                         *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing                              *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths                       *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors                   *
                                      ;*****************************************************************************************
                                      ;* Version History:                                                                      *
                                      ;*    May 18 2020                                                                        *
                                      ;*    - BPEM488 dedicated hardware version begins (work in progress)                     *
                                      ;*    - Update December 10 2020                                                          *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
007B53 7F7B53 S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ;*****************************************************************************************
                                      ;* - Variables -                                                                         *
                                      ;*****************************************************************************************
001002 0FD002                                                 ORG     RTI_VARS_START, RTI_VARS_START_LIN
001002 0FD002 -> $FD002               RTI_VARS_START_LIN      EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ; - RS232 Real Time variables ordered list for Tuner Studio  (declared in BPEM488.s)
                                      ;*****************************************************************************************
                                      ;SecH:       ds 1 ; RTI seconds count Hi byte
                                      ;SecL:       ds 1 ; RTI seconds count Lo byte
                                      ;RPM:        ds 2 ; Crankshaft Revolutions Per Minute
                                      ;TpsPctx10:  ds 2 ; Throttle Position Sensor % of travel(%x10)(update every 100mSec)
                                      ;FDsec:      ds 2 ; Fuel delivery pulse width total over 1 second (mS)
                                      ;CASprd512:  ds 2 ; Crankshaft Angle Sensor period (5.12uS time base
                                      ;CASprd256:  ds 2 ; Crankshaft Angle Sensor period (2.56uS time base
                                      ;LoopTime:   ds 2 ; Program main loop time (loops/Sec)
                                      ;engine:     ds 1 ; Engine status bit field
                                      ;engine2:    ds 1  ; Engine2 status bit field
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - "engine" equates
                                      ;*****************************************************************************************
                                      ;OFCdelon     equ  $01 ; %00000001, bit 0, In Crank Delay Mode
                                      ;crank        equ  $02 ; %00000010, bit 1, In Crank Mode
                                      ;run          equ  $04 ; %00000100, bit 2, In Run Mode
                                      ;ASEon        equ  $08 ; %00001000, bit 3, In ASE Mode
                                      ;WUEon        equ  $10 ; %00010000, bit 4, In WUE Mode
                                      ;TOEon        equ  $20 ; %00100000, bit 5, In Throttle Opening Enrichment Mode
                                      ;OFCon        equ  $40 ; %01000000, bit 6, In Overrun Fuel Cut Mode
                                      ;FldClr       equ  $80 ; %10000000, bit 7, In Flood Clear Mode
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; "engine2" equates
                                      ;*****************************************************************************************
                                      ;base512        equ $01 ; %00000001, bit 0, In Timer Base 512 mode
                                      ;base256        equ $02 ; %00000010, bit 1, In Timer Base 256 Mode
                                      ;AudAlrm        equ $04 ; %00000100, bit 2, In Audible Alarm Mode
                                      ;TOEduron       equ $08 ; %00001000, bit 3, In Throttle Opening Enrichment Duration Mode
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Non RS232 Real Time variables (declared in BPEM488.s)
                                      ;*****************************************************************************************
                                      ;LoopCntr:   ds 2 ; Counter for "LoopTime" (incremented every Main Loop pass)
                                      ;*****************************************************************************************
                                      ; - Non RS232 Real Time variables (declared in injcalcs_BPEM488.s)
                                      ;*****************************************************************************************
                                      ;AIOTcnt:       ds 1 ; Counter for AIOT totalizer pulse width
                                      ;OFCdel         ds 1 ; Overrun Fuel Cut delay duration (decremented every 100 mS)
                                      ;TOEtim:        ds 1 ; Throttle Opening Enrichment duration (decremented every 100 mS)
                                      ;TpsPctx10last: ds 2 ; Throttle Position Sensor percent last (%x10)(updated every 100Msec)
                                      ;FDt:           ds 2 ; Fuel Delivery pulse width total(mS) (for FDsec calcs)
                                      ;*****************************************************************************************
                                      ; - Non RS232 Real Time variables (declared in state_BPEM488.s)
                                      ;*****************************************************************************************
                                      ;Stallcnt:     ds 2 ; No crank or stall condition counter
                                      ;State:        ds 1  ; Cam-Crank state machine current state
                                      ;StateStatus:  ds 1  ; State status bit field
                                      ;ICflgs:       ds 1  ; Input Capture flags bit field
                                      ;*****************************************************************************************
                                      ; - "StateStatus" equates
                                      ;*****************************************************************************************
                                      ;Synch            equ    $01  ; %00000001, bit 0, Crank Position Synchronized
                                      ;SynchLost        equ    $02  ; %00000010, bit 1, Crank Position Synchronize Lost
                                      ;StateNew         equ    $04  ; %00000100, bit 2, New Crank Position
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - "ICflgs" equates
                                      ;*****************************************************************************************
                                      ;RPMcalc:    equ $01   ; %00000001 (Bit 0) (Do RPM calculations flag)
                                      ;KpHcalc:    equ $02   ; %00000010 (Bit 1) (Do VSS calculations flag)
                                      ;Ch1_2nd:    equ $04   ; %00000100 (Bit 2) (Ch1 2nd edge flag)
                                      ;Ch2alt:     equ $08   ; %00001000 (Bit 3) (Ch2 alt flag)
                                      ;Ch1_3d:     equ $10   ; %00010000 (Bit 4) (Ch1 3d edge flag)
                                      ;RevMarker:  equ $20   ; %00100000 (Bit 5) (Crank revolution marker flag)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Real Time Interrupt variables - (declared in this module)
                                      ;*****************************************************************************************
001002 0FD002                         uSx125:     ds 1 ; 125 microsecond counter
001003 0FD003                         mS:         ds 1 ; 1 millisecond counter
001004 0FD004                         mSx250:     ds 1 ; 250 millisecond counter
001005 0FD005                         clock:      ds 1 ; Time rate flag marker bit field
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - "clock" equates
                                      ;*****************************************************************************************
001006 0FD006 -> $0010                ms1000:     equ $10   ; %00010000 (Bit 4) (seconds marker)
001006 0FD006 -> $0008                ms500:      equ $08   ; %00001000 (Bit 3) (500mS marker)
001006 0FD006 -> $0004                ms250:      equ $04   ; %00000100 (Bit 2) (250mS marker)
001006 0FD006 -> $0002                ms100:      equ $02   ; %00000010 (Bit 1) (100mS marker)
001006 0FD006 -> $0001                ms1:        equ $01   ; %00000001 (Bit 0) (1mS marker)
001006 0FD006 -> $1006                RTI_VARS_END            EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
001006 0FD006 -> $FD006               RTI_VARS_END_LIN        EQU     @     ; @ Represents the current value of the linear
                                      ;*****************************************************************************************
                                      ;* - Code -                                                                              *
                                      ;*****************************************************************************************
00561F 7F561F                                                 ORG     RTI_CODE_START, RTI_CODE_START_LIN
                                      ;*****************************************************************************************
                                      ; - RTI_ISR Interrupt Service Routine (125 uS clock tick)
                                      ; - Generate time rates:
                                      ;   125 Microseconds
                                      ;   1 Millisecond
                                      ;   100 Milliseconds
                                      ;   250 Millisecnds
                                      ;   500 Milliseconds
                                      ;   Seconds
                                      ;*****************************************************************************************
00561F 7F561F                         RTI_ISR:
                                      ;*****************************************************************************************
                                      ; ------------------------------ 125 Microsecond section ---------------------------------
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Increment 125 microsecond counter and check to see if it's time to do the
                                      ; Millisecond section
                                      ;*****************************************************************************************
00561F 7F561F                         Inc125uS:
00561F 7F561F 72 10 02                    inc  uSx125        ; Increment 125 Microsecond counter
005622 7F5622 B6 10 02                    ldaa uSx125        ; Load accu A with value in 125 uS counter
005625 7F5625 81 08                       cmpa #$08          ; Compare it with decimal 8
005627 7F5627 26 54                       bne  RTI_ISR_DONE  ; If not equal, branch to RTI_ISR_DONE:
                                      ;*****************************************************************************************
                                      ; --------------------------------- Millisecond section ----------------------------------
                                      ;*****************************************************************************************
005629 7F5629                         DomS:
005629 7F5629 1C 10 05 01                 bset clock,ms1     ; Set "ms1" bit of "clock"
                                      ;*****************************************************************************************
                                      ; - Clear the 125 microsecond counter. Increment millisecond counter and check to see
                                      ;   if it's time to do the 100 Millisecond or 250 Millisecond section.
                                      ;*****************************************************************************************
00562D 7F562D 79 10 02                    clr  uSx125        ; Clear 125 Microsecond counter
005630 7F5630 72 10 03                    inc  mS            ; Increment Millisecond counter
005633 7F5633 B6 10 03                    ldaa mS            ; Load accu A with value in mS counter
005636 7F5636 81 64                       cmpa #$64          ; Compare it with decimal 100
005638 7F5638 27 0A                       beq  Do100mS       ; IF Z bit of CCR is set, branch to Do100mS: (mS=100)
00563A 7F563A 81 C8                       cmpa #$C8          ; Compare it with decimal 200
00563C 7F563C 27 06                       beq  Do100mS       ; IF Z bit of CCR is set, branch to Do100mS: (mS=200)
00563E 7F563E 81 FA                       cmpa #$FA          ; Compare it with decimal 250
005640 7F5640 27 08                       beq  Do250mS       ; IF Z bit of CCR is set, branch to Do250mS: (mS=250)
005642 7F5642 26 39                       bne  RTI_ISR_DONE  ; If not equal branch to RTI_ISR_DONE:
                                      ;*****************************************************************************************
                                      ; ------------------------------- 100 Millisecond section --------------------------------
                                      ;*****************************************************************************************
005644 7F5644                         Do100mS:
005644 7F5644 1C 10 05 02                bset clock,ms100    ; Set "ms100" bit of "clock" bit field
005648 7F5648 20 33                      bra  RTI_ISR_DONE   ; Branch to RTI_ISR_DONE:
                                      ;*****************************************************************************************
                                      ; ----------------------------- 250 Millisecond section ----------------------------------
                                      ;*****************************************************************************************
00564A 7F564A                         Do250mS:
00564A 7F564A 1C 10 05 04                 bset clock,ms250   ; Set "ms250" bit of "clock"
                                      ;*****************************************************************************************
                                      ; - Clear the millisecond counter. Increment 250 Millisecond counter  and check to see
                                      ;   if it's time to do the "500mS" section.
                                      ;*****************************************************************************************
00564E 7F564E 79 10 03                    clr  mS            ; Clear Millisecond counter
005651 7F5651 72 10 04                    inc  mSx250        ; Increment 250 Millisecond counter
005654 7F5654 B6 10 04                    ldaa mSx250        ; Load accu A with value in 250 mSec counter
005657 7F5657 81 02                       cmpa #$02          ; Compare with decimal 2
005659 7F5659 27 06                       beq  Do500mS       ; If the Z bit of CCR is set, branch to Do500mS:
00565B 7F565B 81 04                       cmpa #$04          ; Compare with decimal 4
00565D 7F565D 27 02                       beq  Do500mS       ; If the Z bit of CCR is set,branch to Do500mS:
00565F 7F565F 20 1C                       bra  RTI_ISR_DONE  ; Branch to RTI_ISR_DONE:
                                      ;*****************************************************************************************
                                      ; ----------------------------- 500 Millisecond section ----------------------------------
                                      ;*****************************************************************************************
005661 7F5661                         Do500mS:
005661 7F5661 1C 10 05 08                 bset clock,ms500   ; Set "ms500" bit of "clock"
                                      ;*****************************************************************************************
                                      ; - Check to see if it's time to do the "Seconds" section
                                      ;*****************************************************************************************
005665 7F5665 B6 10 04                    ldaa mSx250        ; Load accu A with value in 250 mSec counter
005668 7F5668 81 04                       cmpa #$04          ; Compare with decimal 4
00566A 7F566A 27 02                       beq  DoSec         ; If the Z bit of CCR is set, branch to DoSec:
00566C 7F566C 20 0F                       bra  RTI_ISR_DONE  ; Branch to RTI_ISR_DONE:
                                      ;*****************************************************************************************
                                      ; ---------------------------------- Seconds section -------------------------------------
                                      ;*****************************************************************************************
00566E 7F566E                         DoSec:
00566E 7F566E 1C 10 05 10                 bset clock,ms1000     ; Set "ms1000" bit of "clock"
                                      ;*****************************************************************************************
                                      ; - Clear the 250 millisecond counter. Increment "secL". Increment "secH" on roll over
                                      ;*****************************************************************************************
005672 7F5672                         IncSec:
005672 7F5672 79 10 04                    clr  mSx250        ; Clear 250 mSec counter
005675 7F5675 72 10 65                    inc  secL          ; Increment "Seconds" Lo byte
005678 7F5678 26 03                       bne  RTI_ISR_DONE  ; If the Z bit of CCR is clear, branch to RTI_ISR_DONE:
00567A 7F567A 72 10 64                    inc  secH          ; Increment "Seconds" Hi byte
00567D 7F567D                         RTI_ISR_DONE:
00567D 7F567D 4C 37 80                    bset CRGFLG,RTIF   ; Set "RTIF" bit of "CRGFLG" to clear flag
005680 7F5680 0B                          rti                ; Return from interrupt
                                      ;*****************************************************************************************
005681 7F5681 -> $5681                RTI_CODE_END            EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
005681 7F5681 -> $7F5681              RTI_CODE_END_LIN        EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ;* - Tables -                                                                            *
                                      ;*****************************************************************************************
007B53 7F7B53                                                 ORG     RTI_TABS_START, RTI_TABS_START_LIN
007B53 7F7B53 -> $7F7B53              RTI_TABS_START_LIN      EQU     @ ; @ Represents the current value of the linear
                                                                ; program counter
                                      ; ------------------------------- No tables for this module ------------------------------
007B53 7F7B53 -> $7B53                RTI_TABS_END            EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
007B53 7F7B53 -> $7F7B53              RTI_TABS_END_LIN        EQU     @     ; @ Represents the current value of the linear
                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (sci0_BPEM488.s)                                                           *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BPEM488 Engine Controller for the Dodge 488CID (8.0L) V10 engine  *
                                      ;*    by Robert Hiebert.                                                                 *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teaching    *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*    Interrupt handler for SCI0, (Communications with Tuner Studio)                     *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project                          *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map                                       *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project               *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map                                         *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features                     *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler              *
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications (This module)    *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)                                     *
                                      ;*   gpio_BPEM488.s       - Initialization all ports                                     *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros                         *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing                              *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths                       *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors                   *
                                      ;*****************************************************************************************
                                      ;* Version History:                                                                      *
                                      ;*    May 25 2020                                                                        *
                                      ;*    - BPEM488 dedicated hardware version begins (work in progress)                     *
                                      ;*    - Update December 10 2020                                                          *
                                      ;*    - Update January 6 2021 Revnum                                                     *
                                      ;*    - Update March 19 2021 Revnum                                                      *
                                      ;*    - Update April 11 2021 Revnum                                                      *
                                      ;*    - Update April 20 2021 Revnum                                                      *
                                      ;*    - Update April 28 2021 Revnum                                                      *
                                      ;*    - Update May 4 2021 Revnum                                                         *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
007B53 7F7B53 S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ;*****************************************************************************************
                                      ;* - Variables -                                                                         *
                                      ;*****************************************************************************************
001006 0FD006                                     ORG     SCI0_VARS_START, SCI0_VARS_START_LIN
001006 0FD006 -> $FD006               SCI0_VARS_START_LIN     EQU     @ ; @ Represents the current value of the linear
                                                                ; program counter
                                      ;*****************************************************************************************
                                      ; - Serial Communications Interface variables
                                      ;*****************************************************************************************
001006 0FD006                         txgoalMSB:    ds 1 ; SCI number of bytes to send/rcv Hi byte
001007 0FD007                         txgoalLSB:    ds 1 ; SCI number of bytes to send/rcv Lo byte
001008 0FD008                         txcnt:        ds 2 ; SCI count of bytes sent/rcvd
00100A 0FD00A                         rxoffsetMSB:  ds 1 ; SCI offset from start of page Hi byte
00100B 0FD00B                         rxoffsetLSB:  ds 1 ; SCI offset from start of page lo byte
00100C 0FD00C                         rxmode:       ds 1 ; SCI receive mode selector
00100D 0FD00D                         txmode:       ds 1 ; SCI transmit mode selector
00100E 0FD00E                         pageID:       ds 1 ; SCI page identifier
00100F 0FD00F                         txcmnd:       ds 1 ; SCI command character identifier
001010 0FD010                         dataMSB:      ds 1 ; SCI data Most Significant Byte received
001011 0FD011                         dataLSB:      ds 1 ; SCI data Least Significant Byte received
001012 0FD012 -> $1012                SCI0_VARS_END           EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
001012 0FD012 -> $FD012               SCI0_VARS_END_LIN       EQU     @     ; @ Represents the current value of the linear
                                                              ; interrpts disabled. RIE interrupts enabled.IDLE interrupts
                                                              ; disabled. Transmitter disabled, Receiver enabled, Normal
                                                              ; operation, No break characters)
                                                              ; (Transmitter and interrupt get enabled in SCI0_ISR)
                                      ;*****************************************************************************************
                                      ;* - Code -                                                                              *
                                      ;*****************************************************************************************
005681 7F5681                                                 ORG     SCI0_CODE_START, SCI0_CODE_START_LIN
005681 7F5681 -> $7F5681              SCI0_CODE_START_LIN     EQU     @ ; @ Represents the current value of the linear
                                                                ; program counter
                                      ;*****************************************************************************************
                                      ; ------------------------------ SCI Communication ---------------------------------------
                                      ;*****************************************************************************************
                                      ;
                                      ; Communication is established when the Tuner Studio sends
                                      ; a command character. The particular character sets the mode:
                                      ;
                                      ; "Q" = This is the first command that Tuner Studio sends to request the
                                      ;       format of the data. It must receive the signature "MS2Extra comms342h2"
                                      ;       in order to communicate with both Tuner Studio and Shadow Dash. originally I
                                      ;       used 'MShift 5.001' because the TS.ini file used with this code was
                                      ;       built from the base Megashift .ini. (QueryCommand)(1st)
                                      ; "S" = This command requests the version information and TS displays it in the title
                                      ;       block (2nd)
                                      ; "C" = This command requests the constants. (pageReadCommand)(3d)
                                      ;       It is sent after communication with TS has been established and
                                      ;       loads TS with all the the constant pages in RAM. It is also sent
                                      ;       when editing a particular page.
                                      ; "O" = This command requests the real time variables (ochGetCommand)(4th)
                                      ;       It is sent to update the real time variables at a selectable time rate
                                      ; "W" = This command sends an updated constant value from TS to the controller
                                      ;       (pageValueWrite). It is sent when editing configurable constants
                                      ;       one at a time. If editing only one, it is sent after the change
                                      ;       has been made and entered. If editing more than one it is sent
                                      ;       when the next constant to be changed is selected. The number of
                                      ;       bytes is either 1 for a byte value or 2 for a word value
                                      ; "B" = This command jumps to the flash burner routine (burnCommand)
                                      ;       It is sent either after pressing the "Burn" button or closing TS.
                                      ;
                                      ; NOTE! I am not using the burnCommand because I use EEEmulation to store
                                      ;       the configurable constants in buffer RAM.
                                      ;
                                      ; The commands sent to the GPIO(Megashift)are formatted "command\CAN_ID\table_ID"
                                      ;    %2i is the id/table number - 2 bytes
                                      ;    %2o is the table offset - 2 bytes
                                      ;    %2c is the number of bytes to be read/written
                                      ;    %v is the byte to be written
                                      ;
                                      ; Example: from TS comm log
                                      ; Time: 0:33.314: SENT, 7 bytes
                                      ; x72 x01 x07 x00 x38 x00 x08
                                      ; 'r',  can_id=1, table=7 (outpc), offset 38h (56 decimal), send 8 bytes
                                      ;
                                      ; NOTE! I am not using the CAN_ID
                                      ;
                                      ; The settings in the TS .ini file are:
                                      ;   queryCommand        = "H"
                                      ;   signature           = "MShift 5.001"
                                      ;   endianness          = big
                                      ;   nPages              = 3
                                      ;   pageSize            = 1024,            1024,            1024
                                      ;   pageIdentifier      = "\x01\x01",     "\x01\x02",     "\x01\x03"
                                      ;   burnCommand         = "B%2i",         "B%2i",         "B%2i"
                                      ;   pageReadCommand     = "C%2i%2o%2c",   "C%2i%2o%2c",   "C%2i%2o%2c"
                                      ;   pageValueWrite      = "W%2i%2o%2c%v", "W%2i%2o%2c%v", "W%2i%2o%2c%v"
                                      ;   pageChunkWrite      = "W%2i%2o%2c%v", "W%2i%2o%2c%v", "W%2i%2o%2c%v"
                                      ;   ochGetCommand       = "O"
                                      ;   ochBlockSize        = 58 ; This number will change as code expands
                                      ;   pageActivationDelay =  50 ; Milliseconds delay after burn command.
                                      ;   blockReadTimeout    = 200 ; Milliseconds total timeout for reading page.
                                      ;   writeBlocks         = on
                                      ;   interWriteDelay     = 10
                                      ;
                                      ; There are eight variables used in the communications code, "txgoalMSB", "txgoalLSB"
                                      ; "txcnt", "rxoffsetMSB", "rxoffsetLSB, "rxmode", "txmode", "pageID", "txcmnd", "dataMSB"
                                      ; and "dataLSB".
                                      ;
                                      ; "txgoalMSB" is the number of bytes to be sent Hi byte(8 bit)
                                      ; "txgoalLSB" is the number of bytes to be sent Lo byte(8 bit)
                                      ; "rxoffsetMSB" is the offset from start of page to a particuar value Hi byte(8 bit)
                                      ; "rxoffsetLSB" is the offset from start of page to a particuar value Lo byte(8 bit)
                                      ; "txcnt" is the running count of the number of bytes sent (16 bit)
                                      ; "rxmode" is the current receive mode (8 bit)
                                      ; "txmode" is the current transmit mode (8 bit)
                                      ; "pageID" is the page identifier (8 bit)
                                      ; "txcmnd" is the command character ID (8 bit)
                                      ; "dataMSB" is the Most Significant byte value sent from TS when
                                      ;           sending two bytes(8 bit)
                                      ; "dataLSB" is the Most Significant byte value sent from TS when
                                      ;           sending two bytes or a single byte(8 bit)
                                      ;
                                      ;
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - SCI0 Interrupt Service Routine
                                      ;   The interrupts are common to both receive and transmit. First
                                      ;   check the flags to determine which one initiated the interrupt
                                      ;   and branch accordingly.
                                      ;*****************************************************************************************
005681 7F5681                         SCI0_ISR:
005681 7F5681 4E CC 20 0A                 brset SCI0SR1,RDRF,RcvSCI    ; If Receive Data Register Full flag is set, branch to
                                                                       ; "RcvSCI:" (receive section)
005685 7F5685 4E CC 80 03                 brset SCI0SR1,TDRE,TxSCI_LB  ; If Transmit Data Register Empty flag is set, branch to
                                                                       ; "TxSCI_trmp:" (transmit section)
005689 7F5689 96 CC                       ldaa  SCI0SR1                ; Read SCI0CR1 to clear flags
00568B 7F568B 0B                          rti                          ; Return from interrupt (sanity check)
00568C 7F568C                         TxSCI_LB:
00568C 7F568C 06 59 0B                    job   TxSCI                  ; Jump or branch to TxSCI: (long branch)
                                      ;*****************************************************************************************
                                      ; - Receive section
                                      ;*****************************************************************************************
00568F 7F568F                         RcvSCI:
00568F 7F568F 96 CC                       ldaa  SCI0SR1  ; Load accu A with value in SCI0SR1(Read SCI0SR1 to clear "RDRF" flag)
                                      ;*****************************************************************************************
                                      ; - Check the value of "rxmode" to see if we are in the middle of
                                      ;   receiveing a CAN ID, Page ID, offset, byte count or value.
                                      ;          $01 = Receiving CAN ID
                                      ;          $02 = Receiving Page ID
                                      ;          $03 = Receiving offset msb
                                      ;          $04 = Receiving offset lsb
                                      ;          $05 = Receiving data count msb
                                      ;          $06 = Receiving data count lsb
                                      ;          $07 = Receiving data
                                      ;          $08 = Receiving data lsb
                                      ;
                                      ;*****************************************************************************************
005691 7F5691 B6 10 0C                    ldaa    rxmode       ; Load accumulator with value in "rxmode"
005694 7F5694 81 01                       cmpa    #$01         ; Compare with decimal 1 (receiving CAN ID )
005696 7F5696 27 1F                       beq     RcvCanID     ; If the Z bit of CCR is set, branch to RcvCanID:
005698 7F5698 81 02                       cmpa    #$02         ; Compare with decimal 2 (receiving page ID )
00569A 7F569A 27 21                       beq     RcvPageID    ; If the Z bit of CCR is set, branch to RcvPageID:
00569C 7F569C 81 03                       cmpa    #$03         ; Compare with decimal 3 (receiving offset MSB )
00569E 7F569E 27 2F                       beq     RcvOSmsb     ; If the Z bit of CCR is set, branch to RcvOSmsb:
0056A0 7F56A0 81 04                       cmpa    #$04         ; Compare with decimal 4 (receiving offset LSB )
0056A2 7F56A2 27 34                       beq     RcvOSlsb     ; If the Z bit of CCR is set, branch to RcvOSlsb:
0056A4 7F56A4 81 05                       cmpa    #$05         ; Compare with decimal 5 (receiving byte count MSB )
0056A6 7F56A6 27 39                       beq     RcvCntmsb    ; If the Z bit of CCR is set, branch to RcvCntmsb:
0056A8 7F56A8 81 06                       cmpa    #$06         ; Compare with decimal 6 (receiving byte count LSB )
0056AA 7F56AA 27 3E                       beq     RcvCntlsb    ; If the Z bit of CCR is set, branch to RcvCntlsb:
0056AC 7F56AC 81 07                       cmpa    #$07         ; Compare with decimal 7 (receiving data byte )
0056AE 7F56AE 27 4C                       beq     RcvData      ; If the Z bit of CCR is set, branch to RcvData:
0056B0 7F56B0 81 08                       cmpa    #$08         ; Compare with decimal 7 (receiving data byte )
0056B2 7F56B2 27 5E                       beq     RcvDataLSB   ; If the Z bit of CCR is set, branch to RcvDataLSB:
0056B4 7F56B4 06 58 03                    jmp     CheckTxCmnd  ; jump to CheckTxCmnd: (rxmode must be 0 or invalid)
0056B7 7F56B7                         RcvCanID:                ; "rxmode" = 1
0056B7 7F56B7 96 CF                       ldaa  SCI0DRL        ; Load Accu A with value in "SCI0DRL"
                                                               ; (CAN ID) not used, so just read it and get
                                                               ; ready for next byte
0056B9 7F56B9 72 10 0C                    inc   rxmode         ; Increment "rxmode"(continue to next mode)
0056BC 7F56BC 0B                          rti                  ; Return from interrupt
0056BD 7F56BD                         RcvPageID:               ; "rxmode" = 2
0056BD 7F56BD 96 CF                       ldaa  SCI0DRL        ; Load Accu A with value in "SCI0DRL"
0056BF 7F56BF 7A 10 0E                    staa  pageID         ; Copy to "pageID"
0056C2 7F56C2 B6 10 0F                    ldaa  txcmnd         ; Load Accu A with value in "txcmnd"
0056C5 7F56C5 81 03                       cmpa  #$03           ; Compare with decimal 3 ("B")
0056C7 7F56C7 18 27 01 E9                 beq   ModeB2         ; If the Z bit of CCR is set, branch to ModeB2:
0056CB 7F56CB 72 10 0C                    inc   rxmode         ; Increment "rxmode"(continue to next mode)
0056CE 7F56CE 0B                          rti                  ; Return from interrupt
0056CF 7F56CF                         RcvOSmsb:                ; "rxmode" = 3
0056CF 7F56CF 96 CF                       ldaa  SCI0DRL        ; Load Accu A with value in "SCI0DRL" (Offset MSB)
0056D1 7F56D1 7A 10 0A                    staa  rxoffsetMSB    ; Copy to "rxoffsetMSB"
0056D4 7F56D4 72 10 0C                    inc   rxmode         ; Increment "rxmode"(continue to next mode)
0056D7 7F56D7 0B                          rti                  ; Return from interrupt
0056D8 7F56D8                         RcvOSlsb:                ; "rxmode" = 4
0056D8 7F56D8 96 CF                       ldaa  SCI0DRL        ; Load Accu A with value in "SCI0DRL" (Offset LSB)
0056DA 7F56DA 7A 10 0B                    staa  rxoffsetLSB    ; Copy to "rxoffsetLSB"
0056DD 7F56DD 72 10 0C                    inc   rxmode         ; Increment "rxmode"(continue to next mode)
0056E0 7F56E0 0B                          rti                  ; Return from interrupt
0056E1 7F56E1                         RcvCntmsb:               ; "rxmode" = 5
0056E1 7F56E1 96 CF                       ldaa  SCI0DRL        ; Load Accu A with value in "SCI0DRL" (Byte count MSB)
0056E3 7F56E3 7A 10 06                    staa  txgoalMSB      ; Copy to "txgoalMSB"
0056E6 7F56E6 72 10 0C                    inc   rxmode         ; Increment "rxmode"(continue to next mode)
0056E9 7F56E9 0B                          rti                  ; Return from interrupt
0056EA 7F56EA                         RcvCntlsb:               ; "rxmode" = 6
0056EA 7F56EA 96 CF                       ldaa  SCI0DRL        ; Load Accu A with value in "SCI0DRL" (Byte count LSB)
0056EC 7F56EC 7A 10 07                    staa  txgoalLSB      ; Copy to "txgoalLSB"
0056EF 7F56EF B6 10 0F                    ldaa  txcmnd         ; Load Accu A with value in "txcmnd"
0056F2 7F56F2 81 01                       cmpa  #$01           ; Compare with decimal 1 ("C")
0056F4 7F56F4 18 27 01 3C                 beq   ModeC2         ; If the Z bit of CCR is set, branch to ModeC2:
0056F8 7F56F8 72 10 0C                    inc   rxmode         ; Increment "rxmode"(continue to next mode)
0056FB 7F56FB 0B                          rti                  ; Return from interrupt (ready to receive next byte)
0056FC 7F56FC                         RcvData:                 ; "rxmode" = 7
                                      ;*****************************************************************************************
                                      ; - If we are here we must be in "W" mode and receiving either one or
                                      ;   two bytes, depending on the byte count.
                                      ;*****************************************************************************************
0056FC 7F56FC FC 10 06                    ldd  txgoalMSB      ; Load double accumulator with value in
                                                              ; "txgoalMSB:txgoalLSB"
0056FF 7F56FF 8C 00 02                    cpd  #$0002         ; Compare with decimal 2
005702 7F5702 27 05                       beq  RcvDataMSB     ; If equal branch to RcvDataMSB:
005704 7F5704 8C 00 01                    cpd  #$0001         ; Compare with decimal 1
005707 7F5707 27 09                       beq  RcvDataLSB     ; If equal branch to RcvDataLSB:
005709 7F5709                         RcvDataMSB:
005709 7F5709 96 CF                       ldaa  SCI0DRL       ; Load Accu A with value in "SCI0DRL"(data byte)
00570B 7F570B 7A 10 10                    staa  dataMSB       ; Copy to "dataMSB"
00570E 7F570E 72 10 0C                    inc   rxmode        ; Increment "rxmode"(continue to next mode)
005711 7F5711 0B                          rti                 ; Return from subroutine
005712 7F5712                         RcvDataLSB:             ; "rxmode" = 8
005712 7F5712 D6 CF                       ldab  SCI0DRL       ; Load Accu B with value in "SCI0DRL"(data byte)
005714 7F5714 7B 10 11                    stab  dataLSB       ; Copy to "dataLSB"
005717 7F5717 B6 10 0E                    ldaa  pageID        ; Load accu A with value in "pageID"
00571A 7F571A 81 01                       cmpa  #$01          ; Compare with decimal 1 (send page 1)
00571C 7F571C 27 0A                       beq   StorePg1      ; If the Z bit of CCR is set, branch to StorePg1:
00571E 7F571E 81 02                       cmpa  #$02          ; Compare with decimal 2 (send page 2)
005720 7F5720 27 4B                       beq   StorePg2      ; If the Z bit of CCR is set, branch to StorePg2:
005722 7F5722 81 03                       cmpa  #$03          ; Compare with decimal 3 (send page 3)
005724 7F5724 18 27 00 86                 beq   StorePg3      ; If the Z bit of CCR is set, branch to StorePg3:
005728 7F5728                         StorePg1:
005728 7F5728 MACRO                         EEEM_ENABLE   ; Enable EEPROM Emulation Macro
                                                                          ; with $0F (FCLK=1MHz)                       (EEEM_ENABLE)
                                      ; - Enable EE Emulation -                                                        (EEEM_ENABLE)
                                      ; args:   1: branch address of error handler (optional)                          (EEEM_ENABLE)
                                      ; result: none                                                                   (EEEM_ENABLE)
                                      ; SSTACK: none                                                                   (EEEM_ENABLE)
                                      ;         X, Y, and D are preserved                                              (EEEM_ENABLE)
                                      ; - Step (1): Set FCCOBIX -                                                      (EEEM_ENABLE)
005728 7F5728 79 01 02                    clr    FCCOBIX    ; Clear Flash CCOB Index Register                          (EEEM_ENABLE)
                                      ; - Step (2): Enter parameters into FCCOB -                                      (EEEM_ENABLE)
00572B 7F572B 18 0B 13 01 0A              movb   #$13, FCCOBHI  ; Move %00010011 into Flash Common Command Register    (EEEM_ENABLE)
                                                                ; Hi byte (Flash command enable EEEPROM Emulation)     (EEEM_ENABLE)
                                      ;     movb   #$13, FCCOBLO                                                       (EEEM_ENABLE)
                                      ; - Step (3): Launch command -                                                   (EEEM_ENABLE)
005730 7F5730 18 0B B0 01 06              movb #(CCIF|ACCERR|FPVIOL), FSTAT ; Move $B0 (%10110000) into Flash Status Register (EEEM_ENABLE)
                                                                            ;( Write 1s to Command Complete Interrupt  (EEEM_ENABLE)
                                                                            ; flag, Flash Access Error Flag and Flash  (EEEM_ENABLE)
                                                                            ; Protection Violation Flag to clear flags) (EEEM_ENABLE)
                                      ; - Step (4): Wait until command is executed -                                   (EEEM_ENABLE)
005735 7F5735 1F 01 06 80 FB              brclr       FSTAT, #CCIF, *  ; Loop until Command Complete Interrupt         (EEEM_ENABLE)
00573A 7F573A FC 10 06                    ldd  txgoalMSB      ; Load double accumulator with value in
                                                              ; "txgoalMSB:txgoalLSB"
00573D 7F573D 8C 00 02                    cpd  #$0002         ; Compare with decimal 2
005740 7F5740 27 05                       beq  StorePg1Wd     ; If equal branch to StorePg1Wd:
005742 7F5742 8C 00 01                    cpd  #$0001         ; Compare with decimal 1
005745 7F5745 27 13                       beq  StorePg1Bt     ; If equal branch to StorePg1Bt:
005747 7F5747                         StorePg1Wd:
005747 7F5747 FE 10 0A                    ldx   rxoffsetMSB  ; Load index register X with value in "rxoffsetMSB:rxoffsetLSB"
00574A 7F574A FC 10 10                    ldd   dataMSB      ; Load double accu D with value in "dataMSB:dataLSB"
00574D 7F574D 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE
005752 7F5752 6C E2 08 00                 std   veBins_E,x     ; Copy "W" data word to "veBins_E" offset in index register X
005756 7F5756 18 20 00 93                 bra   StoreDone    ; Branch to StoreDone:
00575A 7F575A                         StorePg1Bt:
00575A 7F575A FE 10 0A                    ldx   rxoffsetMSB  ; Load index register X with value in "rxoffsetMSB:rxoffsetLSB"
00575D 7F575D B6 10 11                    ldaa  dataLSB      ; Load accu A with value in "dataLSB"
005760 7F5760 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE
005765 7F5765 6A E2 08 00                 staa  veBins_E,x     ; Copy "W" data byte to "veBins_E" offset in index register X
005769 7F5769 18 20 00 80                 bra   StoreDone    ; Branch to StoreDone:
00576D 7F576D                         StorePg2:
00576D 7F576D MACRO                         EEEM_ENABLE   ; Enable EEPROM Emulation Macro
                                                                          ; with $0F (FCLK=1MHz)                       (EEEM_ENABLE)
                                      ; - Enable EE Emulation -                                                        (EEEM_ENABLE)
                                      ; args:   1: branch address of error handler (optional)                          (EEEM_ENABLE)
                                      ; result: none                                                                   (EEEM_ENABLE)
                                      ; SSTACK: none                                                                   (EEEM_ENABLE)
                                      ;         X, Y, and D are preserved                                              (EEEM_ENABLE)
                                      ; - Step (1): Set FCCOBIX -                                                      (EEEM_ENABLE)
00576D 7F576D 79 01 02                    clr    FCCOBIX    ; Clear Flash CCOB Index Register                          (EEEM_ENABLE)
                                      ; - Step (2): Enter parameters into FCCOB -                                      (EEEM_ENABLE)
005770 7F5770 18 0B 13 01 0A              movb   #$13, FCCOBHI  ; Move %00010011 into Flash Common Command Register    (EEEM_ENABLE)
                                                                ; Hi byte (Flash command enable EEEPROM Emulation)     (EEEM_ENABLE)
                                      ;     movb   #$13, FCCOBLO                                                       (EEEM_ENABLE)
                                      ; - Step (3): Launch command -                                                   (EEEM_ENABLE)
005775 7F5775 18 0B B0 01 06              movb #(CCIF|ACCERR|FPVIOL), FSTAT ; Move $B0 (%10110000) into Flash Status Register (EEEM_ENABLE)
                                                                            ;( Write 1s to Command Complete Interrupt  (EEEM_ENABLE)
                                                                            ; flag, Flash Access Error Flag and Flash  (EEEM_ENABLE)
                                                                            ; Protection Violation Flag to clear flags) (EEEM_ENABLE)
                                      ; - Step (4): Wait until command is executed -                                   (EEEM_ENABLE)
00577A 7F577A 1F 01 06 80 FB              brclr       FSTAT, #CCIF, *  ; Loop until Command Complete Interrupt         (EEEM_ENABLE)
00577F 7F577F FC 10 06                    ldd  txgoalMSB     ; Load double accumulator with value in "txgoalMSB:txgoalLSB"
005782 7F5782 8C 00 02                    cpd  #$0002        ; Compare with decimal 2
005785 7F5785 27 05                       beq  StorePg2Wd    ; If equal branch to StorePg2Wd:
005787 7F5787 8C 00 01                    cpd  #$0001        ; Compare with decimal 1
00578A 7F578A 27 11                       beq  StorePg2Bt    ; If equal branch to StorePg2Bt:
00578C 7F578C                         StorePg2Wd:
00578C 7F578C FE 10 0A                    ldx   rxoffsetMSB  ; Load index register X with value in "rxoffsetMSB:rxoffsetLSB"
00578F 7F578F FC 10 10                    ldd   dataMSB      ; Load double accu D with value in "dataMSB:dataLSB"
005792 7F5792 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE
005797 7F5797 6C E2 08 00                 std   stBins_E,x     ; Copy "W" data word to "stBins_E" offset in index register X
00579B 7F579B 20 50                       bra   StoreDone    ; Branch to StoreDone:
00579D 7F579D                         StorePg2Bt:
00579D 7F579D FE 10 0A                    ldx   rxoffsetMSB  ; Load index register X with value in "rxoffsetMSB:rxoffsetLSB"
0057A0 7F57A0 B6 10 11                    ldaa  dataLSB      ; Load accu A with value in "dataLSB"
0057A3 7F57A3 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE
0057A8 7F57A8 6A E2 08 00                 staa  stBins_E,x     ; Copy "W" data byte to "stBins_E" offset in index register X
0057AC 7F57AC 20 3F                       bra   StoreDone    ; Branch to StoreDone:
0057AE 7F57AE                         StorePg3:
0057AE 7F57AE MACRO                         EEEM_ENABLE   ; Enable EEPROM Emulation Macro
                                                                          ; with $0F (FCLK=1MHz)                       (EEEM_ENABLE)
                                      ; - Enable EE Emulation -                                                        (EEEM_ENABLE)
                                      ; args:   1: branch address of error handler (optional)                          (EEEM_ENABLE)
                                      ; result: none                                                                   (EEEM_ENABLE)
                                      ; SSTACK: none                                                                   (EEEM_ENABLE)
                                      ;         X, Y, and D are preserved                                              (EEEM_ENABLE)
                                      ; - Step (1): Set FCCOBIX -                                                      (EEEM_ENABLE)
0057AE 7F57AE 79 01 02                    clr    FCCOBIX    ; Clear Flash CCOB Index Register                          (EEEM_ENABLE)
                                      ; - Step (2): Enter parameters into FCCOB -                                      (EEEM_ENABLE)
0057B1 7F57B1 18 0B 13 01 0A              movb   #$13, FCCOBHI  ; Move %00010011 into Flash Common Command Register    (EEEM_ENABLE)
                                                                ; Hi byte (Flash command enable EEEPROM Emulation)     (EEEM_ENABLE)
                                      ;     movb   #$13, FCCOBLO                                                       (EEEM_ENABLE)
                                      ; - Step (3): Launch command -                                                   (EEEM_ENABLE)
0057B6 7F57B6 18 0B B0 01 06              movb #(CCIF|ACCERR|FPVIOL), FSTAT ; Move $B0 (%10110000) into Flash Status Register (EEEM_ENABLE)
                                                                            ;( Write 1s to Command Complete Interrupt  (EEEM_ENABLE)
                                                                            ; flag, Flash Access Error Flag and Flash  (EEEM_ENABLE)
                                                                            ; Protection Violation Flag to clear flags) (EEEM_ENABLE)
                                      ; - Step (4): Wait until command is executed -                                   (EEEM_ENABLE)
0057BB 7F57BB 1F 01 06 80 FB              brclr       FSTAT, #CCIF, *  ; Loop until Command Complete Interrupt         (EEEM_ENABLE)
0057C0 7F57C0 FC 10 06                    ldd  txgoalMSB     ; Load double accumulator with value in "txgoalMSB:txgoalLSB"
0057C3 7F57C3 8C 00 02                    cpd  #$0002        ; Compare with decimal 2
0057C6 7F57C6 27 05                       beq  StorePg3Wd    ; If equal branch to StorePg3Wd:
0057C8 7F57C8 8C 00 01                    cpd  #$0001        ; Compare with decimal 1
0057CB 7F57CB 27 11                       beq  StorePg3Bt    ; If equal branch to StorePg3Bt:
0057CD 7F57CD                         StorePg3Wd:
0057CD 7F57CD FE 10 0A                    ldx   rxoffsetMSB  ; Load index register X with value in "rxoffsetMSB:rxoffsetLSB"
0057D0 7F57D0 FC 10 10                    ldd   dataMSB      ; Load double accu D with value in "dataMSB:dataLSB"
0057D3 7F57D3 18 0B FD 00 17              movb  #(BUF_RAM_P3_START>>16),EPAGE  ; Move $FD into EPAGE
0057D8 7F57D8 6C E2 08 00                 std   afrBins_E,x    ; Copy "W" data word to "afrBins_E" offset in index register X
0057DC 7F57DC 20 0F                       bra   StoreDone    ; Branch to StoreDone:
0057DE 7F57DE                         StorePg3Bt:
0057DE 7F57DE FE 10 0A                    ldx   rxoffsetMSB  ; Load index register X with value in "rxoffsetMSB:rxoffsetLSB"
0057E1 7F57E1 B6 10 11                    ldaa  dataLSB      ; Load accu A with value in "dataLSB"
0057E4 7F57E4 18 0B FD 00 17              movb  #(BUF_RAM_P3_START>>16),EPAGE  ; Move $FD into EPAGE
0057E9 7F57E9 6A E2 08 00                 staa  afrBins_E,x    ; Copy "W" data byte to "afrBins_E" offset in index register X
0057ED 7F57ED                         StoreDone:
0057ED 7F57ED 79 10 0C                    clr   rxmode       ; Clear "rxmode"
0057F0 7F57F0 79 10 0F                    clr   txcmnd       ; Clear "txcmnd"
0057F3 7F57F3 79 10 0E                    clr   pageID       ; Clear "pageID"
0057F6 7F57F6 18 79 10 10                 clrw  dataMSB      ; Clear "dataMSB:dataLSB"
0057FA 7F57FA 18 79 10 0A                 clrw  rxoffsetMSB  ; Clear "rxoffsetMSB:rxoffsetLSB"
0057FE 7F57FE 18 79 10 06                 clrw  txgoalMSB    ; Clear "txgoalMSB:txgoalLSB"
005802 7F5802 0B                          rti                ; Return from interrupt
                                      ;*****************************************************************************************
                                      ; - "txcmnd" is the command character identifier
                                      ;    $01 = "C"
                                      ;    $02 = "W"
                                      ;    $03 = "B"
                                      ;*****************************************************************************************
005803 7F5803                         CheckTxCmnd:
005803 7F5803 96 CF                       ldaa  SCI0DRL    ; Load accu A with value in SCI0DRL(get the command byte)
005805 7F5805 81 51                       cmpa  #$51       ; Compare with ASCII "Q"
005807 7F5807 18 27 00 B3                 beq   ModeQ      ; If equal branch to "ModeQ:"(QueryCommand) Return "Signature"
00580B 7F580B 81 53                       cmpa  #$53       ; Compare with ASCII "S"
00580D 7F580D 18 27 00 C5                 beq   ModeS      ; If equal branch to "ModeS:"(version info Command) Return "RevNum"
005811 7F5811 81 4F                       cmpa  #$4F       ; Compare with ASCII "O"
005813 7F5813 18 27 00 D7                 beq   ModeO      ; If equal branch to "ModeO:"(ochGetCommand)
005817 7F5817 81 43                       cmpa  #$43       ; Compare with ASCII "C"
005819 7F5819 27 0E                       beq   ModeC1     ; If equal branch to "ModeC1:"(pageReadCommand)
00581B 7F581B 81 57                       cmpa  #$57       ; Compare it with decimal 87 = ASCII "W"
00581D 7F581D 27 7F                       beq   ModeW1     ; If the Z bit of CCR is set, branch to Mode_W1:
                                                           ;(receive new VE or constant byte value and store in offset location)
                                                           ;(pageValueWrite or pageChunkWrite)
00581F 7F581F 81 42                       cmpa  #$42       ; Compare it with decimal 66 = ASCII "B"
005821 7F5821 18 27 00 84                 beq   ModeB1     ; If the Z bit of CCR is set, branch to ModeB1:(jump to flash burner
                                                           ; routine and burn VE, ST, AFR/constant values in RAM into flash)
005825 7F5825 18 20 00 E1                 bra   RcvSCIDone ; Branch to "RcvSCIDone:"
005829 7F5829                         ModeC1:
                                      ;*****************************************************************************************
                                      ; - Load "rxmode" and "txcmnd" with appropriate values to get ready
                                      ;   to receive additional command information
                                      ;*****************************************************************************************
005829 7F5829 18 0B 01 10 0C              movb  #$01,rxmode   ; Load "rxmode" with "Receiving CAN ID mode"
00582E 7F582E 18 0B 01 10 0F              movb  #$01,txcmnd   ; Load "txcmnd" with "Command character "C" ID"
005833 7F5833 0B                          rti                 ; Return from interrupt
005834 7F5834                         ModeC2:
005834 7F5834 79 10 0C                    clr   rxmode        ; Clear "rxmode"
005837 7F5837 79 10 0F                    clr   txcmnd        ; Clear "txcmnd"
00583A 7F583A B6 10 0E                    ldaa  pageID        ; Load accu A with value in "pageID"
00583D 7F583D 81 01                       cmpa  #$01          ; Compare with decimal 1 (send page 1)
00583F 7F583F 27 08                       beq   StartPg1      ; If the Z bit of CCR is set, branch to StartPg1:
005841 7F5841 81 02                       cmpa  #$02          ; Compare with decimal 2 (send page 2)
005843 7F5843 27 21                       beq   StartPg2      ; If the Z bit of CCR is set, branch to StartPg2:
005845 7F5845 81 03                       cmpa  #$03          ; Compare with decimal 3 (send page 3)
005847 7F5847 27 3A                       beq   StartPg3      ; If the Z bit of CCR is set, branch to StartPg3:
005849 7F5849                         StartPg1:
005849 7F5849 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE
00584E 7F584E FE 10 0A                    ldx   rxoffsetMSB   ; Load index register X with value in "rxoffsetMSB:rxoffsetLSB"
                                                              ;(Page 1 offset)
005851 7F5851 A6 E2 08 00                 ldaa  veBins_E,X      ; Load Accu "A" with value in "veBins, offset in "rxoffsetMSB:rxoffsetLSB"
                                      ;*    ldaa  veBins        ; Load accu A with first value at "veBins_E"
005855 7F5855 5A CF                       staa  SCI0DRL       ; Copy to SCI0DRL (first byte to send)
005857 7F5857 18 03 00 00 10 08           movw  #$0000,txcnt  ; Clear "txcnt"
00585D 7F585D 18 0B 03 10 0D              movb  #$03,txmode   ; Load "txmode" with decimal 3
005862 7F5862 18 20 00 9E                 bra   DoTx          ; Branch to "DoTx:" (start transmission)
005866 7F5866                         StartPg2:
005866 7F5866 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE
00586B 7F586B FE 10 0A                    ldx   rxoffsetMSB   ; Load index register X with value in "rxoffsetMSB:rxoffsetLSB"
                                                              ;(Page 2 offset)
00586E 7F586E A6 E2 08 00                 ldaa  stBins_E,X      ; Load Accu "A" with value in "stBins_E, offset in "rxoffsetMSB:rxoffsetLSB"
                                      ;*    ldaa  stBins        ; Load accu A with first value at "stBins"
005872 7F5872 5A CF                       staa  SCI0DRL       ; Copy to SCI0DRL (first byte to send)
005874 7F5874 18 03 00 00 10 08           movw  #$0000,txcnt  ; Clear "txcnt"
00587A 7F587A 18 0B 04 10 0D              movb  #$04,txmode   ; Load "txmode" with decimal 4
00587F 7F587F 18 20 00 81                 bra   DoTx          ; Branch to "DoTx:" (start transmission)
005883 7F5883                         StartPg3:
005883 7F5883 18 0B FD 00 17              movb  #(BUF_RAM_P3_START>>16),EPAGE  ; Move $FD into EPAGE
005888 7F5888 FE 10 0A                    ldx   rxoffsetMSB   ; Load index register X with value in "rxoffsetMSB:rxoffsetLSB"
                                                              ;(Page 3 offset)
00588B 7F588B A6 E2 08 00                 ldaa  afrBins_E,X     ; Load Accu "A" with value in "afrBins_E, offset in "rxoffsetMSB:rxoffsetLSB"
                                      ;*    ldaa  afrBins       ; Load accu A with first value at "afrBins"
00588F 7F588F 5A CF                       staa  SCI0DRL       ; Copy to SCI0DRL (first byte to send)
005891 7F5891 18 03 00 00 10 08           movw  #$0000,txcnt  ; Clear "txcnt"
005897 7F5897 18 0B 05 10 0D              movb  #$05,txmode   ; Load "txmode" with decimal 5
00589C 7F589C 20 66                       bra   DoTx          ; Branch to "DoTx:" (start transmission)
00589E 7F589E                         ModeW1:
                                      ;*****************************************************************************************
                                      ; - Load "rxmode" and "txcmnd" with appropriate values to get ready
                                      ;   to receive additional command information
                                      ;*****************************************************************************************
00589E 7F589E 18 0B 01 10 0C              movb  #$01,rxmode   ; Load "rxmode" with "Receiving CAN ID mode"
0058A3 7F58A3 18 0B 02 10 0F              movb  #$02,txcmnd   ; Load "txcmnd" with "Command character "W" ID"
0058A8 7F58A8 0B                          rti                 ; Return from interrupt
0058A9 7F58A9                         ModeB1:
                                      ;*****************************************************************************************
                                      ; - Load "rxmode" and "txcmnd" with appropriate values to get ready
                                      ;   to receive additional command information
                                      ;*****************************************************************************************
0058A9 7F58A9 18 0B 01 10 0C              movb  #$01,rxmode   ; Load "rxmode" with "Receiving CAN ID mode"
0058AE 7F58AE 18 0B 03 10 0F              movb  #$03,txcmnd   ; Load "txcmnd" with "Command character "B" ID"
0058B3 7F58B3 0B                          rti                 ; Return from interrupt
0058B4 7F58B4                         ModeB2
0058B4 7F58B4 79 10 0E                    clr   pageID        ; Clear "pageID"
0058B7 7F58B7 79 10 0C                    clr   rxmode        ; Clear "rxmode"
0058BA 7F58BA 79 10 0F                    clr   txcmnd        ; Clear "txcmnd"
                                      ; No code for this yet
0058BD 7F58BD 0B                          rti                 ; Return from interrupt
0058BE 7F58BE                         ModeQ:
0058BE 7F58BE B6 7B 53                    ldaa  Signature        ; Load accu A with value at "Signature"
0058C1 7F58C1 5A CF                       staa  SCI0DRL          ; Copy to SCI0DRL (first byte to send)
0058C3 7F58C3 18 03 00 00 10 08           movw  #$0000,txcnt     ; Clear "txcnt"
0058C9 7F58C9 18 03 00 13 10 06           movw  #$0013,txgoalMSB ; Load "txgoalMSB:txgoaLSB" with decimal 19(number of bytes to send)
0058CF 7F58CF 18 0B 01 10 0D              movb  #$01,txmode      ; Load "txmode" with decimal 1
0058D4 7F58D4 20 2E                       bra   DoTx             ; Branch to "DoTx:" (start transmission)
0058D6 7F58D6                         ModeS:
0058D6 7F58D6 B6 7B 66                    ldaa  RevNum           ; Load accu A with value at "RevNum"
0058D9 7F58D9 5A CF                       staa  SCI0DRL          ; Copy to SCI0DRL (first byte to send)
0058DB 7F58DB 18 03 00 00 10 08           movw  #$0000,txcnt     ; Clear "txcnt"
0058E1 7F58E1 18 03 00 39 10 06           movw  #$0039,txgoalMSB ; Load "txgoalMSB:txgoaLSB" with decimal 57(number of bytes to send)
0058E7 7F58E7 18 0B 01 10 0D              movb  #$01,txmode      ; Load "txmode" with decimal 1
0058EC 7F58EC 20 16                       bra   DoTx             ; Branch to "DoTx:" (start transmission)
0058EE 7F58EE                         ModeO:
0058EE 7F58EE B6 10 64                    ldaa  secH             ; Load accu A with value at "secH"
0058F1 7F58F1 5A CF                       staa  SCI0DRL          ; Copy to SCI0DRL (first byte to send)
0058F3 7F58F3 18 03 00 00 10 08           movw  #$0000,txcnt     ; Clear "txcnt"
0058F9 7F58F9 18 03 00 8B 10 06           movw  #$008B,txgoalMSB ; Load "txgoalMSB:txgoalLSB" with decimal 139(number of bytes to send)                    REAL TIME VARIABLES HERE!!!!!!!!
0058FF 7F58FF 18 0B 02 10 0D              movb  #$02,txmode      ; Load "txmode" with decimal 2
005904 7F5904                         DoTx:
005904 7F5904 4C CB 80                    bset  SCI0CR2,TXIE  ; Set Transmitter Interrupt Enable bit,
005907 7F5907 4C CB 08                    bset  SCI0CR2,TE    ; Set Transmitter Enable bit
00590A 7F590A                         RcvSCIDone:
00590A 7F590A 0B                          rti                 ; Return from interrupt
                                      ;*****************************************************************************************
                                      ; - Transmit section
                                      ;*****************************************************************************************
00590B 7F590B                         TxSCI:
00590B 7F590B 96 CC                       ldaa  SCI0SR1  ; Load accu A with value in SCI0SR1(Read SCI0SR1 to clear "TDRE" flag)
00590D 7F590D FE 10 08                    ldx   txcnt    ; Load Index Register X with value in "txcnt"
005910 7F5910 08                          inx            ; Increment Index Register X
005911 7F5911 7E 10 08                    stx   txcnt    ; Copy new value to "txcnt"
005914 7F5914 B6 10 0D                    ldaa  txmode   ; Load accu A with value in "txmode"
005917 7F5917 27 57                       beq   TxDone   ; If "txmode" = 0 branch to "TxDone:" (sanity check)
                                      ;*****************************************************************************************
                                      ; - Check the value of "txmode" to see if we are in the middle of
                                      ;   sending value bytes.
                                      ;          $01 = Sending Signature bytes
                                      ;          $02 = Sending real time variables
                                      ;          $03 = Sending constants page 1
                                      ;          $04 = Sending constants page 2
                                      ;          $05 = Sending constants page 3
                                      ;
                                      ;*****************************************************************************************
005919 7F5919 81 01                       cmpa  #$01         ; Compare with $01
00591B 7F591B 27 12                       beq   SendSig      ; If equal branch to "SendSig:"
00591D 7F591D 81 02                       cmpa  #$02         ; Compare with $02
00591F 7F591F 27 14                       beq   SendVars     ; If equal branch to "SendVars:"
005921 7F5921 81 03                       cmpa  #$03         ; Compare with $03
005923 7F5923 27 16                       beq   SendPg1      ; If equal branch to "SendPg1:"
005925 7F5925 81 04                       cmpa  #$04         ; Compare with $04
005927 7F5927 27 21                       beq   SendPg2      ; If equal branch to "SendPg2:"
005929 7F5929 81 05                       cmpa  #$05         ; Compare with $05
00592B 7F592B 27 2C                       beq   SendPg3      ; If equal branch to "SendPg3"
00592D 7F592D 20 41                       bra   TxDone       ; Branch to "TxDone:" (sanity check)
00592F 7F592F                         SendSig:               ; "txmode" = 1
00592F 7F592F A6 E2 7B 53                 ldaa  Signature,X  ; Load accu A with value at "Signature:", offset in "X" register
005933 7F5933 20 31                       bra   ContTx       ; Branch to "ContTx:"(continue TX process)
005935 7F5935                         SendVars:              ; "txmode" = 2
005935 7F5935 A6 E2 10 64                 ldaa  secH,X       ; Load accu A with value at "secH:" offset in "X" register.
005939 7F5939 20 2B                       bra   ContTx       ; Branch to "ContTX:" (continue TX process)
00593B 7F593B                         SendPg1:               ; "txmode" = 3
00593B 7F593B 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE
                                      ;*    ldaa  veBins,X     ; Load accu A with value at "veBins:", offset in "X" register
005940 7F5940 CC 08 00                    ldd   #veBins_E      ; Load double accumulator D with address of "veBins_E"
005943 7F5943 F3 10 0A                    addd  rxoffsetMSB  ; (A:B)+(M:M+1)->A:B Add the address of "veBins_E" with the offset
                                                             ; value to get the effective address of the byte to be sent
005946 7F5946 A6 E6                       ldaa  D,X          ; Load Accu A with value in the effective address
005948 7F5948 20 1C                       bra   ContTx       ; Branch to "ContTx:" (continue TX process)
00594A 7F594A                         SendPg2:               ; "txmode" = 4
00594A 7F594A 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE
                                      ;*    ldaa  stBins,X     ; Load accu A with value at "stBins:", offset in "X" register
00594F 7F594F CC 08 00                    ldd   #stBins_E      ; Load double accumulator D with address of "stBins_E"
005952 7F5952 F3 10 0A                    addd  rxoffsetMSB  ; (A:B)+(M:M+1)->A:B Add the address of "stBins_E" with the offset
                                                             ; value to get the effective address of the byte to be sent
005955 7F5955 A6 E6                       ldaa  D,X          ; Load Accu A with value in the effective address
005957 7F5957 20 0D                       bra   ContTx       ; Branch to "ContTx:" (continue TX process)
005959 7F5959                         SendPg3:               ; "txmode" = 5
005959 7F5959 18 0B FD 00 17              movb  #(BUF_RAM_P3_START>>16),EPAGE  ; Move $FD into EPAGE
                                      ;*    ldaa  afrBins,X    ; Load accu A with value at "afrBins:", offset in "X" register
00595E 7F595E CC 08 00                    ldd   #afrBins_E      ; Load double accumulator D with address of "afrBins_E"
005961 7F5961 F3 10 0A                    addd  rxoffsetMSB  ; (A:B)+(M:M+1)->A:B Add the address of "afrBins_E" with the offset
                                                             ; value to get the effective address of the byte to be sent
005964 7F5964 A6 E6                       ldaa  D,X          ; Load Accu A with value in the effective address
005966 7F5966                         ContTx:
005966 7F5966 5A CF                       staa  SCI0DRL      ; Copy value in accu A into SCI0DRL (next byte to send)
005968 7F5968 FD 10 08                    ldy   txcnt        ; Load Index Register Y with value in "txcnt"
00596B 7F596B BD 10 06                    cpy   txgoalMSB    ; Compare value to "txgoalMSB:txgoalLSB"
00596E 7F596E 26 18                       bne   ByteDone     ; If the Z bit of CCR is not set, branch to "ByteDone:"
                                                             ;(not finished yet)
005970 7F5970                         TxDone:
005970 7F5970 18 03 00 00 10 08           movw  #$0000,txcnt     ; Clear "txcnt"
005976 7F5976 18 03 00 00 10 06           movw  #$0000,txgoalMSB ; Clear "txgoalMSB:txgoalLSB"
00597C 7F597C 79 10 0D                    clr   txmode           ; Clear "txmode"
00597F 7F597F 79 10 0E                    clr   pageID           ; Clear "pageID"
005982 7F5982 4D CB 80                    bclr  SCI0CR2,TXIE     ; Clear Transmitter Interrupt Enable bit
                                                                 ;(disable TDRE interrupt)
005985 7F5985 4D CB 08                    bclr  SCI0CR2,TE       ; Clear Transmitter Enable bit (disable transmitter)
005988 7F5988                         ByteDone:
005988 7F5988 0B                          rti                    ; Return from interrupt
                                      ;*****************************************************************************************
005989 7F5989 -> $5989                SCI0_CODE_END           EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
005989 7F5989 -> $7F5989              SCI0_CODE_END_LIN       EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ;* - Tables -                                                                            *
                                      ;*****************************************************************************************
007B53 7F7B53                                                 ORG     SCI0_TABS_START, SCI0_TABS_START_LIN
007B53 7F7B53 -> $7F7B53              SCI0_TABS_START_LIN     EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
007B53 7F7B53                         Signature:
007B53 7F7B53 4D 53 32 45 78 74 72 61     fcc 'MS2Extra comms342h2'
              20 63 6F 6D 6D 73 33 34 
              32 68 32                
                                      ;        1234567890123456789   ; 19 bytes
                                      ;                              ; This must remain the same in order for both TS and SD
                                                                     ; to communicate
007B66 7F7B66                         RevNum:
007B66 7F7B66 42 50 45 4D 34 38 38 20      fcc 'BPEM488 05 04 2021                                       '
              30 35 20 30 34 20 32 30 
              32 31 20 20 20 20 20 20 
              20 20 20 20 20 20 20 20 
              20 20 20 20 20 20 20 20 
              20 20 20 20 20 20 20 20 
              20 20 20 20 20 20 20 20 
              20                      
                                      ;         123456789012345678901234567890123456789012345678901234567  ; 57 bytes
                                      ;                              ; This should be changed with each code revision but
                                                                     ; string length must stay the same
007B9F 7F7B9F -> $7B9F                SCI0_TABS_END           EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
007B9F 7F7B9F -> $7F7B9F              SCI0_TABS_END_LIN       EQU     @     ; @ Represents the current value of the linear
                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (adc0_BPEM488EM488.s)                                                      *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BPEM488 Engine Controller for the Dodge 488CID (8.0L) V10 engine  *
                                      ;*    by Robert Hiebert.                                                                 *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teaching    *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*    ADC0 interrupt handler                                                             *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project                          *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map                                       *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project               *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map                                         *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features                     *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler              *
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications                  *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)(This module)                        *
                                      ;*   gpio_BPEM488.s       - Initialization all ports                                     *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros                         *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing                              *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths                       *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors                   *
                                      ;*****************************************************************************************
                                      ;* Version History:                                                                      *
                                      ;*    May 17 2020                                                                        *
                                      ;*    - BPEM488 dedicated hardware version begins (work in progress)                     *
                                      ;*    - Update December 12 2020                                                          *
                                      ;*    - Update December 13 2020                                                          *
                                      ;*    - Update December 15 2020                                                          *
                                      ;*    - Update December 28 2020 Itrim and Ftrim enable changed from brclr to brset       *
                                      ;*    - Update January 6 2021 Corrected init macro                                       *
                                      ;*    April 28 2021                                                                      *
                                      ;*    - Add baroADC averaging code code                                                  *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
007B9F 7F7B9F S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ;*****************************************************************************************
                                      ;* - Variables -                                                                         *
                                      ;*****************************************************************************************
001012 0FD012                                     ORG     ADC0_VARS_START, ADC0_VARS_START_LIN
001012 0FD012 -> $FD012               ADC0_VARS_START_LIN     EQU   @ ; @ Represents the current value of the linear
                                                                  ; program counter
                                      ;*****************************************************************************************
                                      ; - RS232 Real Time Variables - (declared in BPEM488.s)
                                      ;*****************************************************************************************
                                      ;batAdc:       ds 2 ; Battery Voltage 10 bit ADC AN00(offset=2)
                                      ;BatVx10:      ds 2 ; Battery Voltage (Volts x 10)(offset=4)
                                      ;cltAdc:       ds 2 ; 10 bit ADC AN01 Engine Coolant Temperature ADC(offset=6)
                                      ;Cltx10:       ds 2 ; Engine Coolant Temperature (Degrees F x 10)(offset=8)
                                      ;matAdc:       ds 2 ; 10 bit ADC AN02 Manifold Air Temperature ADC(offset=10)
                                      ;Matx10:       ds 2 ; Manifold Air Temperature (Degrees F x 10)(offset=12)
                                      ;PAD03inAdc:   ds 2 ; 10 bit ADC AN03 Spare Temperature ADC(offset=14)
                                      ;Place16:      ds 2 ; Place holder 16(offset=16)
                                      ;mapAdc:       ds 2 ; 10 bit ADC AN04 Manifold Absolute Pressure ADC(offset=18)
                                      ;Mapx10:       ds 2 ; Manifold Absolute Pressure (KPAx10)(offset=20)
                                      ;tpsADC:       ds 2 ; 10 bit ADC AN05 Throttle Position Sensor ADC (exact for TS)(offset=22)
                                      ;TpsPctx10:    ds 2 ; Throttle Position Sensor % of travel(%x10)(update every 100mSec)(offset=24)
                                      ;egoAdc1:      ds 2 ; 10 bit ADC AN06 Exhaust Gas Oxygen ADC Left bank odd cyls(offset=26)
                                      ;afr1x10:      ds 2 ; Air Fuel Ratio for gasoline Left bank odd cyls(AFR1x10)(exact for TS)(offset=28)
                                      ;baroAdc:      ds 2 ; 10 bit ADC AN07 Barometric Pressure ADC(offset=30)
                                      ;Barox10:      ds 2 ; Barometric Pressure (KPAx10)(offset=32)
                                      ;eopAdc:       ds 2 ; 10 bit ADC AN08 Engine Oil Pressure ADC(offset=34)
                                      ;Eopx10:       ds 2 ; Engine Oil Pressure (PSI x 10)(offset=36)
                                      ;efpAdc:       ds 2 ; 10 bit ADC AN09 Engine Fuel Pressure ADC(offset=38)
                                      ;Efpx10:       ds 2 ; Engine Fuel Pressure (PSI x 10)(offset=40)
                                      ;itrmAdc:      ds 2 ; 10 bit ADC AN10 Ignition Trim ADC(offset=42)
                                      ;Itrmx10:      ds 2 ; Ignition Trim (degrees x 10)+-20 degrees) (offset=44)
                                      ;ftrmAdc:      ds 2 ; 10 bit ADC AN11 Fuel Trim ADC(offset=46)
                                      ;Ftrmx10:      ds 2 ; Fuel Trim (% x 10)(+-20%)(offset=48)
                                      ;egoAdc2:      ds 2 ; 10 bit ADC AN12  Exhaust Gas Oxygen ADC Right bank even cyls(offset=50)
                                      ;afr2x10:      ds 2 ; Air Fuel Ratio for gasoline Right bank even cyls(AFR2x10)(exact for TS)offset=52)
                                      ;*****************************************************************************************
                                      ; - Port status variables
                                      ;*****************************************************************************************
                                      ;PortAbits:    ds 1  ; Port A status bit field(offset=118)
                                      ;PortBbits:    ds 1  ; Port B status bit field(offset=119)
                                      ;PortKbits:    ds 1  ; Port K status bit field(offset=120)
                                      ;*****************************************************************************************
                                      ; - Misc variables
                                      ;*****************************************************************************************
                                      ;engine2:      ds 1  ; Engine2 status bit field(offset=124)
                                      ;alarmbits:    ds 1  ; Alarm status bit field(offset=125)
                                      ;AAoffbits:    ds 1  ; Audio Alarm Off status bit field(offset=126)
                                      ;*****************************************************************************************
                                      ; "engine2" equates
                                      ;*****************************************************************************************
                                      ;base512        equ $01 ; %00000001, bit 0, In Timer Base 512 mode
                                      ;base256        equ $02 ; %00000010, bit 1, In Timer Base 256 Mode
                                      ;AudAlrm        equ $04 ; %00000100, bit 2, In Audible Alarm Mode
                                      ;TOEduron       equ $08 ; %00001000, bit 3, In Throttle Opening Enrichment Duration Mode
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; "alarmbits" equates
                                      ;*****************************************************************************************
                                      ;LOP        equ $01 ; %00000001, bit 0, Low Oil Pressure
                                      ;HOT        equ $02 ; %00000010, bit 1, High Oil Temperature
                                      ;HET        equ $04 ; %00000100, bit 2, High Engine Temperature
                                      ;HEGT       equ $08 ; %00001000, bit 3, High Exhaust Gas Temperature
                                      ;HFT        equ $10 ; %00010000, bit 4, High Fuel Temperature
                                      ;LFP        equ $20 ; %00100000, bit 5, Low Fuel Pressure
                                      ;HFP        equ $40 ; %01000000, bit 6, High Fuel Pressure
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; PortAbits: Port A status bit field (PORTA)
                                      ;*****************************************************************************************
                                      ;LoadEEEM        equ  $01 ;(PA0)%00000001, bit 0, Load EEEM Enable
                                      ;Itrimen         equ  $02 ;(PA1)%00000010, bit 1, Ignition Trim Enable
                                      ;Ftrimen         equ  $04 ;(PA2)%00000100, bit 2, Fuel Trim Enable
                                      ;AudAlrmSil      equ  $08 ;(PA3)%00001000, bit 3, Audible Alarm Silence
                                      ;OFCen           equ  $10 ;(PA4)%00010000, bit 4, Overrun Fuel Cut Enable
                                      ;OFCdis          equ  $20 ;(PA5)%00100000, bit 5, Overrun Fuel Cut Disable
                                      ;*****************************************************************************************
                                      ; PortBbits: Port B status bit field (PORTB)
                                      ;*****************************************************************************************
                                      ;FuelPump    equ  $01 ;(PB0)%00000001, bit 0, Fuel Pump State
                                      ;ASDRelay    equ  $02 ;(PB1)%00000010, bit 1, Automatic Shutdown Relay State
                                      ;EngAlarm    equ  $04 ;(PB2)%00000100, bit 2, Engine Alarm State
                                      ;AIOT        equ  $08 ;(PB3)%00001000, bit 3, AIOT Signal State
                                      ;PB4out      equ  $10 ;(PB4)%00010000, bit 4, PB4out State
                                      ;PB5out      equ  $20 ;(PB5)%00100000, bit 5, PB5out State
                                      ;PB6out      equ  $40 ;(PB6)%01000000, bit 6, PB6out State
                                      ;*****************************************************************************************
001012 0FD012 -> $1012                ADC0_VARS_END           EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
001012 0FD012 -> $FD012               ADC0_VARS_END_LIN       EQU     @     ; @ Represents the current value of the linear
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Code -                                                                              *
                                      ;*****************************************************************************************
005989 7F5989                                                 ORG     ADC0_CODE_START, ADC0_CODE_START_LIN
005989 7F5989 -> $7F5989              ADC0_CODE_START_LIN        EQU  @   ; @ Represents the current value of the linear
                                                                      ; program counter
                                      ;----------------------------- No code for this module ----------------------------------
005989 7F5989 -> $5989                ADC0_CODE_END           EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
005989 7F5989 -> $7F5989              ADC0_CODE_END_LIN       EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ;* - Tables -                                                                            *
                                      ;*****************************************************************************************
007B9F 7F7B9F                                                 ORG     ADC0_TABS_START, ADC0_TABS_START_LIN
007B9F 7F7B9F -> $7F7B9F              ADC0_TABS_START_LIN     EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ; ------------------------------- No tables for this module ------------------------------
007B9F 7F7B9F -> $7B9F                ADC0_TABS_END           EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
007B9F 7F7B9F -> $7F7B9F              ADC0_TABS_END_LIN       EQU     @     ; @ Represents the current value of the linear
                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (gpio_BPEM488.s                                                            *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BPEM488 Engine Controller for the Dodge 488CID (8.0L) V10 engine  *
                                      ;*    by Robert Hiebert.                                                                 *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teaching    *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*    This module Initializes all ports                                                  *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project                          *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map                                       *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project               *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map                                         *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features                     *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler              *
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications                  *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)                                     *
                                      ;*   gpio_BPEM488.s       - Initialization all ports (This module)                       *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros                         *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing                              *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths                       *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors                   *
                                      ;*****************************************************************************************
                                      ;* Version History:                                                                      *
                                      ;*    May 17 2020                                                                        *
                                      ;*    - BEPEM488 dedicated hardware version version begins (work in progress)            *
                                      ;*    - Update December 10 2020                                                          *
                                      ;*    - Removed faulty ADC init code January 6 2021                                      *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
007B9F 7F7B9F S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ;*****************************************************************************************
                                      ;* - Variables -                                                                         *
                                      ;*****************************************************************************************
001012 0FD012                                     ORG     GPIO_VARS_START, GPIO_VARS_START_LIN
001012 0FD012 -> $FD012               GPIO_VARS_START_LIN     EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ; ----------------------------- No variables for this module ----------------------------
001012 0FD012 -> $1012                GPIO_VARS_END           EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
001012 0FD012 -> $FD012               GPIO_VARS_END_LIN       EQU     @     ; @ Represents the current value of the linear
                                      ;*****************************************************************************************
                                      ;* - Code -                                                                              *
                                      ;*****************************************************************************************
005989 7F5989                                                 ORG     GPIO_CODE_START, GPIO_CODE_START_LIN
005989 7F5989 -> $7F5989              GPIO_CODE_START_LIN     EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ; ------------------------------- No code for this module -------------------------------
005989 7F5989 -> $5989                GPIO_CODE_END           EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
005989 7F5989 -> $7F5989              GPIO_CODE_END_LIN       EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ;* - Tables -                                                                            *
                                      ;*****************************************************************************************
007B9F 7F7B9F                                                 ORG     GPIO_TABS_START, GPIO_TABS_START_LIN
007B9F 7F7B9F -> $7F7B9F              GPIO_TABS_START_LIN     EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ; ------------------------------- No tables for this module ------------------------------
007B9F 7F7B9F -> $7B9F                GPIO_TABS_END           EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
007B9F 7F7B9F -> $7F7B9F              GPIO_TABS_END_LIN       EQU     @     ; @ Represents the current value of the linear
                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (ect_BPEM488.s)                                                            *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BPEM488 Engine Controller for the Dodge 488CID (8.0L) V10 engine  *
                                      ;*    by Robert Hiebert.                                                                 *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teaching    *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*    Enhanced Capture Timer on Port T interrupt handler.                                *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project                          *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map                                       *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project               *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map                                         *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features                     *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler              *
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications                  *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)                                     *
                                      ;*   gpio_BPEM488.s       - Initialization all ports                                     *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros                         *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing                              *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths                       *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors                   *
                                      ;*****************************************************************************************
                                      ;* Version History:                                                                      *
                                      ;*    May 17 2020                                                                        *
                                      ;*    - BPEM488 dedicated hardware version begins (work in progress)                     *
                                      ;*    - Update December 10 2020                                                          *
                                      ;*    March 22 2021                                                                      *
                                      ;*    - Add current gear code                                                            *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
007B9F 7F7B9F S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ;*****************************************************************************************
                                      ;* - Variables -                                                                         *
                                      ;*****************************************************************************************
001012 0FD012                                                 ORG     ECT_VARS_START, ECT_VARS_START_LIN
001012 0FD012 -> $FD012               ECT_VARS_START_LIN      EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ; - RS232 variables - (declared in BPEM488.s)
                                      ;*****************************************************************************************
                                      ;CASprd512:    ds 2 ; Crankshaft Angle Sensor period (5.12uS time base
                                      ;CASprd256:    ds 2 ; Crankshaft Angle Sensor period (2.56uS time base
                                      ;VSSprd:       ds 2 ; Vehicle Speed Sensor period
                                      ;RPM:          ds 2 ; Crankshaft Revolutions Per Minute
                                      ;KPH:          ds 2 ; Vehicle speed (KpH x 10)
                                      ;engine:       ds 1 ; Engine status bit field
                                      ;*****************************************************************************************
                                      ; - "engine" Engine status bit field
                                      ;*****************************************************************************************
                                      ;OFCdelon     equ  $01 ; %00000001, bit 0, 0 = OFC timer not counting down(Grn),
                                                                              ; 1 = OFC timer counting down(Red)
                                      ;crank        equ  $02 ; %00000010, bit 1, 0 = engine not cranking(Grn),
                                                                              ; 1 = engine cranking(Red)
                                      ;run          equ  $04 ; %00000100, bit 2, 0 = engine not running(Red),
                                                                              ; 1 = engine running(Grn)
                                      ;ASEon        equ  $08 ; %00001000, bit 3, 0 = not in start/warmup(Grn),
                                                                              ; 1 = in start/warmup(Red)
                                      ;WUEon        equ  $10 ; %00010000, bit 4, 0 = not in warmup(Grn),
                                                                              ; 1 = in warmup(Red)
                                      ;TOEon        equ  $20 ; %00100000, bit 5, 0 = not in TOE mode(Grn),
                                                                              ; 1 = TOE mode(Red)
                                      ;OFCon        equ  $40 ; %01000000, bit 6, 0 = not in OFC mode(Grn),
                                                                              ; 1 = in OFC mode(Red)
                                      ;FldClr       equ $80  ; %10000000, bit 7, 0 = not in flood clear mode(Grn),
                                                                              ; 1 = Flood clear mode(Red)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Non RS32 variables - (declared in state_BPEM488.s)
                                      ;*****************************************************************************************
                                      ;RevCntr:     ds 1  ; Counter for "Revmarker" flag
                                      ;ICflgs:      ds 1  ; Input Capture flags bit field
                                      ;*****************************************************************************************
                                      ; - "ICflgs" equates
                                      ;*****************************************************************************************
                                      ;RPMcalc:    equ $01   ; %00000001 (Bit 0) (Do RPM calculations flag)
                                      ;KpHcalc:    equ $02   ; %00000010 (Bit 1) (Do VSS calculations flag)
                                      ;Ch1_2nd:    equ $04   ; %00000100 (Bit 2) (Ch1 2nd edge flag)
                                      ;Ch2alt:     equ $08   ; %00001000 (Bit 3) (Ch2 alt flag)
                                      ;Ch1_3d:     equ $10   ; %00010000 (Bit 4) (Ch1 3d edge flag)
                                      ;RevMarker:  equ $20   ; %00100000 (Bit 5) (Crank revolution marker flag)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Non RS32 variables - (declared in igncalcs_BPEM488.s)
                                      ;*****************************************************************************************
                                      ;IgnOCadd1:      ds 2 ; First ignition output compare adder (5.12uS or 2.56uS res)
                                      ;IgnOCadd2:      ds 2 ; Second ignition output compare adder(5.12uS or 2.56uS res)
                                      ;*****************************************************************************************
                                      ; - Non RS32 variables - (declared in This module)
                                      ;*****************************************************************************************
001012 0FD012                         VSS1st:      ds 2  ; VSS input capture rising edge 1st time stamp (5.12uS or 2.56uS res)
                                      ;*****************************************************************************************
001014 0FD014 -> $1014                ECT_VARS_END            EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
001014 0FD014 -> $FD014               ECT_VARS_END_LIN        EQU     @     ; @ Represents the current value of the linear
                                                              ; (Will trigger an interrupt after the delay time)(LED off)
                                      ;*****************************************************************************************
                                      ;* - Code -                                                                              *
                                      ;*****************************************************************************************
005989 7F5989                                                 ORG     ECT_CODE_START, ECT_CODE_START_LIN
                                      ;*****************************************************************************************
                                      ; - NOTE! ECT_TC0_ISR (camshaft position sensor) is handled in state_BEEM488.s module)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - NOTE! ECT_TC1_ISR (crankshaft position sensor) is handled in state_BEEM488.s module)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - ECT ch2 Interrupt Service Routine (for VSS calculations)
                                      ;*****************************************************************************************
005989 7F5989                         ECT_TC2_ISR:
                                      ;*****************************************************************************************
                                      ; - Get two consecutive rising edge signals for vehicle speed and
                                      ;   calculate the period. KPH calculations are done in the main loop
                                      ;*****************************************************************************************
005989 7F5989 1E 10 24 08 0B              brset ICflgs,Ch2alt,VSS2 ; If "Ch2alt" bit of "ICflgs" is set, branch to "VSS2:"
00598E 7F598E DC 54                       ldd  ECT_TC2H            ; Load accu D with value in "ECT_TC2H"
005990 7F5990 7C 10 12                    std  VSS1st              ; Copy to "VSS1st"
005993 7F5993 1C 10 24 08                 bset ICflgs,Ch2alt       ; Set "Ch2alt" bit of "ICflgs"
005997 7F5997 20 10                       bra  ECT2_ISR_Done       ; Branch to "ECT2_ISR_Done:"
005999 7F5999                         VSS2:
005999 7F5999 DC 54                       ldd  ECT_TC2H       ; Load accu D with value in "ECT_TC2H"
00599B 7F599B B3 10 12                    subd VSS1st         ; Subtract (A:B)-(M:M+1)=>A:B "VSS1st" from value in "ECT_TC2H"
00599E 7F599E 7C 10 9E                    std  VSSprd         ; Copy result to "VSSprd"
0059A1 7F59A1 1D 10 24 08                 bclr ICflgs,Ch2alt  ; Clear "Ch2alt" bit of "ICflgs"
0059A5 7F59A5 1C 10 24 02                 bset ICflgs,KPHcalc ; Set "KPHcalc" bit of "ICflgs"
0059A9 7F59A9                         ECT2_ISR_Done:
0059A9 7F59A9 0B                          rti                ; Return from Interrupt
0059AA 7F59AA                         ECT_TC3_ISR:
                                      ;*****************************************************************************************
                                      ; - ECT ch3 Interrupt Service Routine for Ign1(1&6) control
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Set the output compare value for desired on time and disable the interrupt
                                      ;*****************************************************************************************
0059AA 7F59AA 4C 49 80                    bset ECT_TCTL2,Bit7    ; Clear Ch3 output line to zero on compare
0059AD 7F59AD 4D 49 40                    bclr ECT_TCTL2,Bit6    ; Clear Ch3 output line to zero on compare
0059B0 7F59B0 DC 44                       ldd  ECT_TCNTH         ; Contents of Timer Count Register-> Accu D
0059B2 7F59B2 F3 10 43                    addd IgnOCadd2         ; Add "IgnOCadd2" (dwell time)
0059B5 7F59B5 5C 56                       std  ECT_TC3H          ; Copy result to Timer IC/OC register 0 (Start OC operation)
                                                                 ; (coil on for dwell time)(LED on)
0059B7 7F59B7 0B                          rti                    ; Return from Interrupt
0059B8 7F59B8                         ECT_TC4_ISR:
                                      ;*****************************************************************************************
                                      ; - ECT ch4 Interrupt Service Routine for Ign2(10&5) control
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Set the output compare value for desired on time and disable the interrupt
                                      ;*****************************************************************************************
0059B8 7F59B8 4C 48 02                    bset ECT_TCTL1,Bit1    ; Clear Ch4 output line to zero on compare
0059BB 7F59BB 4D 48 01                    bclr ECT_TCTL1,Bit0    ; Clear Ch4 output line to zero on compare
0059BE 7F59BE DC 44                       ldd  ECT_TCNTH         ; Contents of Timer Count Register-> Accu D
0059C0 7F59C0 F3 10 43                    addd IgnOCadd2         ; Add "IgnOCadd2" (dwell time))
0059C3 7F59C3 5C 58                       std  ECT_TC4H          ; Copy result to Timer IC/OC register 2(Start OC operation)
                                                                 ; (coil on for dwell time)(LED on)
0059C5 7F59C5 0B                          rti                    ; Return from Interrupt
0059C6 7F59C6                         ECT_TC5_ISR:
                                      ;*****************************************************************************************
                                      ; - ECT ch5 Interrupt Service Routine for Ign3(9&8) control
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Set the output compare value for desired on time and disable the interrupt
                                      ;*****************************************************************************************
0059C6 7F59C6 4C 48 08                    bset ECT_TCTL1,Bit3    ; Clear Ch5 output line to zero on compare
0059C9 7F59C9 4D 48 04                    bclr ECT_TCTL1,Bit2    ; Clear Ch5 output line to zero on compare
0059CC 7F59CC DC 44                       ldd  ECT_TCNTH         ; Contents of Timer Count Register-> Accu D
0059CE 7F59CE F3 10 43                    addd IgnOCadd2         ; Add "IgnOCadd2" (dwell time))
0059D1 7F59D1 5C 5A                       std  ECT_TC5H          ; Copy result to Timer IC/OC register 2(Start OC operation)
                                                                 ; (coil on for dwell time)(LED on)
0059D3 7F59D3 0B                          rti                    ; Return from Interrupt
0059D4 7F59D4                         ECT_TC6_ISR:
                                      ;*****************************************************************************************
                                      ; - ECT ch6 Interrupt Service Routine for Ign4(4&7) control
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Set the output compare value for desired on time and disable the interrupt
                                      ;*****************************************************************************************
0059D4 7F59D4 4C 48 20                    bset ECT_TCTL1,Bit5    ; Clear Ch6 output line to zero on compare
0059D7 7F59D7 4D 48 10                    bclr ECT_TCTL1,Bit4    ; Clear Ch6 output line to zero on compare
0059DA 7F59DA DC 44                       ldd  ECT_TCNTH         ; Contents of Timer Count Register-> Accu D
0059DC 7F59DC F3 10 43                    addd IgnOCadd2         ; Add "IgnOCadd2" (dwell time))
0059DF 7F59DF 5C 5C                       std  ECT_TC6H          ; Copy result to Timer IC/OC register 2(Start OC operation)
                                                                 ; (coil on for dwell time)(LED on)
0059E1 7F59E1 0B                          rti                    ; Return from Interrupt
0059E2 7F59E2                         ECT_TC7_ISR:
                                      ;*****************************************************************************************
                                      ; - ECT ch7 Interrupt Service Routine for Ign5(3&2) control
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Set the output compare value for desired on time and disable the interrupt
                                      ;*****************************************************************************************
0059E2 7F59E2 4C 48 80                    bset ECT_TCTL1,Bit7    ; Clear Ch7 output line to zero on compare
0059E5 7F59E5 4D 48 40                    bclr ECT_TCTL1,Bit6    ; Clear Ch7 output line to zero on compare
0059E8 7F59E8 DC 44                       ldd  ECT_TCNTH         ; Contents of Timer Count Register-> Accu D
0059EA 7F59EA F3 10 43                    addd IgnOCadd2         ; Add "IgnOCadd2" (dwell time))
0059ED 7F59ED 5C 5E                       std  ECT_TC7H          ; Copy result to Timer IC/OC register 2(Start OC operation)
                                                                 ; (coil on for dwell time)(LED on)
0059EF 7F59EF 0B                          rti                    ; Return from Interrupt
0059F0 7F59F0 -> $59F0                ECT_CODE_END            EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
0059F0 7F59F0 -> $7F59F0              ECT_CODE_END_LIN        EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ;* - Tables -                                                                            *
                                      ;*****************************************************************************************
007B9F 7F7B9F                                                 ORG     ECT_TABS_START, ECT_TABS_START_LIN
007B9F 7F7B9F -> $7F7B9F              ECT_TABS_START_LIN      EQU     @ ; @ Represents the current value of the linear
                                                                ; program counter
                                      ; ------------------------------- No tables for this module ------------------------------
007B9F 7F7B9F -> $7B9F                ECT_TABS_END            EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
007B9F 7F7B9F -> $7F7B9F              ECT_TABS_END_LIN        EQU     @     ; @ Represents the current value of the linear
                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (tim_BPEM488.s                                                             *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BEEM488 Engine Controller for the Dodge 488CID (8.0L) V10 engine  *
                                      ;*    by Robert Hiebert.                                                                 *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teaching    *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*    Timer module for Ignition and injector control on Port P                           *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project                          *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map                                       *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project               *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map                                         *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features                     *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler              *
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications                  *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)                                     *
                                      ;*   gpio_BPEM488.s       - Initialization all ports                                     *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros                         *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing                              *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths                       *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors                   *
                                      ;*****************************************************************************************
                                      ;* Version History:                                                                      *
                                      ;*    May 17 2020                                                                        *
                                      ;*    - BPEM488 dedicated hardware version begins (work in progress)                     *
                                      ;*    - Update December 10 2020                                                          *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
007B9F 7F7B9F S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ;*****************************************************************************************
                                      ;* - Variables -                                                                         *
                                      ;*****************************************************************************************
001014 0FD014                                     ORG     TIM_VARS_START, TIM_VARS_START_LIN
001014 0FD014 -> $FD014               TIM_VARS_START_LIN      EQU     @ ; @ Represents the current value of the linear
                                                                ; program counter
                                      ;*****************************************************************************************
                                      ; - RS232 variables - (declared in BPEM488.s)
                                      ;*****************************************************************************************
                                      ;FD:           ds 2 ; Fuel Delivery pulse width (mS)
                                      ;*****************************************************************************************
                                      ; - Non RS232 variables - (declared in injcalcs_BPEM488.s)
                                      ;*****************************************************************************************
                                      ;InjOCadd1:     ds 2 ; First injector output compare adder (5.12uS res or 2.56uS res)
                                      ;InjOCadd2:     ds 2 ; Second injector output compare adder (5.12uS res or 2.56uS res)
                                      ;FDpw:          ds 2 ; Fuel Delivery pulse width (PW - Deadband) (mS x 10)
                                      ;FDt:           ds 2 ; Fuel Delivery pulse width total(mS) (for FDsec calcs)
                                      ;FDcnt:         ds 2 ; Fuel delivery pulse width total(ms)(for totalizer pulse on rollover)
                                      ;AIOTcnt:       ds 1 ; Counter for AIOT totalizer pulse width
                                      ;*****************************************************************************************
                                      ; - Non RS232 variables - (declared in igncalcs_BPEM488.s)
                                      ;*****************************************************************************************
                                      ;IgnOCadd1:      ds 2 ; First ignition output compare adder (5.12uS or 2.56uS res)
                                      ;IgnOCadd2:      ds 2 ; Second ignition output compare adder(5.12uS or 2.56uS res)
001014 0FD014 -> $1014                TIM_VARS_END            EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
001014 0FD014 -> $FD014               TIM_VARS_END_LIN        EQU     @     ; @ Represents the current value of the linear
                                                                  ; (Will trigger an interrupt after the delay time)(LED off)
                                      ;*****************************************************************************************
                                      ;* - Code -                                                                              *
                                      ;*****************************************************************************************
0059F0 7F59F0                                                 ORG     TIM_CODE_START, TIM_CODE_START_LIN
0059F0 7F59F0 -> $7F59F0              TIM_CODE_START_LIN      EQU     @ ; @ Represents the current value of the linear
                                                                ; program counter
                                      ;*****************************************************************************************
                                      ; - In the INIT_TIM macro, Port T PT0, PT2 and all Port P pins are set as outputs with
                                      ;   initial setting low. To control both the ignition and injector drivers two interrupts
                                      ;   are required for each ignition or injection event. At the appropriate crank angle and
                                      ;   cam phase an interrupt is triggered. In this ISR routine the channel output compare
                                      ;   register is loaded with the delay value from trigger time to the time desired to
                                      ;   energise the coil or injector and the channel interrupt is enabled. When the output
                                      ;   compare matches, the pin is commanded high and the timer channel interrupt is triggered.
                                      ;   The output compare register is then loaded with the value to keep the coil or injector
                                      ;   energised, and the channel interrupt is disabled. When the output compare matches, the
                                      ;   pin is commanded low to fire the coil or de-energise the injector.
                                      ;*****************************************************************************************
0059F0 7F59F0                         TIM_TC0_ISR:
                                      ;*****************************************************************************************
                                      ; - TIM ch0 Interrupt Service Routine for Inj1(1&10) control)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Set the output compare value for desired on time and disable the interrupt
                                      ;*****************************************************************************************
0059F0 7F59F0 1C 03 D9 02                 bset TIM_TCTL2,Bit1    ; Clear Ch0 output line to zero on compare
0059F4 7F59F4 1D 03 D9 01                 bclr TIM_TCTL2,Bit0    ; Clear Ch0 output line to zero on compare
0059F8 7F59F8 FC 03 D4                    ldd  TIM_TCNTH         ; Contents of Timer Count Register-> Accu D
0059FB 7F59FB F3 10 5F                    addd InjOCadd2         ; Add "InjOCadd2" (injector pulse width)
0059FE 7F59FE 7C 03 E0                    std  TIM_TC0H          ; Copy result to Timer IC/OC register 1 (Start OC operation)
                                                                 ; (coil on for dwell time)(LED on)
005A01 7F5A01 0B                          rti                    ; Return from Interrupt
005A02 7F5A02                         TIM_TC1_ISR:
                                      ;*****************************************************************************************
                                      ; - TIM ch1 Interrupt Service Routine for Inj2 (9&4) control)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Set the output compare value for desired on time and disable the interrupt
                                      ;*****************************************************************************************
005A02 7F5A02 1C 03 D9 08                 bset TIM_TCTL2,Bit3    ; Clear Ch1 output line to zero on compare
005A06 7F5A06 1D 03 D9 04                 bclr TIM_TCTL2,Bit2    ; Clear Ch1 output line to zero on compare
005A0A 7F5A0A FC 03 D4                    ldd  TIM_TCNTH         ; Contents of Timer Count Register-> Accu D
005A0D 7F5A0D F3 10 5F                    addd InjOCadd2         ; Add "InjOCadd2" (injector pulse width)
005A10 7F5A10 7C 03 E2                    std  TIM_TC1H          ; Copy result to Timer IC/OC register 1 (Start OC operation)
                                                                 ; (coil on for dwell time)(LED on)
005A13 7F5A13 0B                          rti                    ; Return from Interrupt
005A14 7F5A14                         TIM_TC2_ISR:
                                      ;*****************************************************************************************
                                      ; - TIM ch2 Interrupt Service Routine for Inj3 (3&6) control)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Set the output compare value for desired on time and disable the interrupt
                                      ;*****************************************************************************************
005A14 7F5A14 1C 03 D9 20                 bset TIM_TCTL2,Bit5    ; Clear Ch2 output line to zero on compare
005A18 7F5A18 1D 03 D9 10                 bclr TIM_TCTL2,Bit4    ; Clear Ch2 output line to zero on compare
005A1C 7F5A1C FC 03 D4                    ldd  TIM_TCNTH         ; Contents of Timer Count Register-> Accu D
005A1F 7F5A1F F3 10 5F                    addd InjOCadd2         ; Add "InjOCadd2" (injector pulse width)
005A22 7F5A22 7C 03 E4                    std  TIM_TC2H          ; Copy result to Timer IC/OC register 2 (Start OC operation)
                                                                 ; (coil on for dwell time)(LED on)
005A25 7F5A25 0B                          rti                    ; Return from Interrupt
005A26 7F5A26                         TIM_TC3_ISR:
                                      ;*****************************************************************************************
                                      ; - TIM ch3 Interrupt Service Routine for Inj4)(5&8) control)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Set the output compare value for desired on time and disable the interrupt
                                      ;*****************************************************************************************
005A26 7F5A26 1C 03 D9 80                 bset TIM_TCTL2,Bit7    ; Clear Ch3 output line to zero on compare
005A2A 7F5A2A 1D 03 D9 40                 bclr TIM_TCTL2,Bit6    ; Clear Ch3 output line to zero on compare
005A2E 7F5A2E FC 03 D4                    ldd  TIM_TCNTH         ; Contents of Timer Count Register-> Accu D
005A31 7F5A31 F3 10 5F                    addd InjOCadd2         ; Add "InjOCadd2" (injector pulse width)
005A34 7F5A34 7C 03 E6                    std  TIM_TC3H          ; Copy result to Timer IC/OC register 3 (Start OC operation)
                                                                 ; (Should result in LED on for ~3 to ~25 mS)
005A37 7F5A37 0B                          rti                    ; Return from Interrupt
005A38 7F5A38                         TIM_TC4_ISR:
                                      ;*****************************************************************************************
                                      ; - TIM ch4 Interrupt Service Routine for Inj5(7&2) control)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Set the output compare value for desired on time and disable the interrupt
                                      ;*****************************************************************************************
005A38 7F5A38 1C 03 D8 02                 bset TIM_TCTL1,Bit1    ; Clear Ch4 output line to zero on compare
005A3C 7F5A3C 1D 03 D8 01                 bclr TIM_TCTL1,Bit0    ; Clear Ch4 output line to zero on compare
005A40 7F5A40 FC 03 D4                    ldd  TIM_TCNTH         ; Contents of Timer Count Register-> Accu D
005A43 7F5A43 F3 10 5F                    addd InjOCadd2         ; Add "InjOCadd2" (injector pulse width)
005A46 7F5A46 7C 03 E8                    std  TIM_TC4H          ; Copy result to Timer IC/OC register 4(Start OC operation)
                                                                 ; (Should result in LED on for ~3 to ~25 mS)
005A49 7F5A49 0B                          rti                    ; Return from Interrupt
005A4A 7F5A4A -> $5A4A                TIM_CODE_END            EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
005A4A 7F5A4A -> $7F5A4A              TIM_CODE_END_LIN        EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ;* - Tables -                                                                            *
                                      ;*****************************************************************************************
007B9F 7F7B9F                                                 ORG     TIM_TABS_START, TIM_TABS_START_LIN
007B9F 7F7B9F -> $7F7B9F              TIM_TABS_START_LIN      EQU     @ ; @ Represents the current value of the linear
                                                                ; program counter
                                      ; ------------------------------- No tables for this module ------------------------------
007B9F 7F7B9F -> $7B9F                TIM_TABS_END            EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
007B9F 7F7B9F -> $7F7B9F              TIM_TABS_END_LIN        EQU     @     ; @ Represents the current value of the linear
                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (state_BPEM488.s)                                                          *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BPEM488 Engine Controller for the Dodge 488CID (8.0L) V10 engine  *
                                      ;*    by Robert Hiebert.                                                                 *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teaching    *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*    This module contains code for the state machine to determine crankshaft position   *
                                      ;*    and camshaft phase                                                                 *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project                          *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map                                       *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project               *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map                                         *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features                     *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler              *
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications                  *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)                                     *
                                      ;*   gpio_BPEM488.s       - Initialization all ports                                     *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros                         *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing                              *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths                       *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors                   *
                                      ;*****************************************************************************************
                                      ;* Version History:                                                                      *
                                      ;*    May 13 2020                                                                        *
                                      ;*    - BPEM488 version begins (work in progress)                                        *
                                      ;*    - Update December 10 2020                                                          *
                                      ;*    March 19 2021                                                                      *
                                      ;*    - Add code for PB4 Tach out                                                        *
                                      ;*    April 20 2021                                                                      *
                                      ;*    - Change RPM period code                                                           *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
007B9F 7F7B9F S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ;*****************************************************************************************
                                      ;* - Variables -                                                                         *
                                      ;*****************************************************************************************
001014 0FD014                                    ORG     STATE_VARS_START, STATE_VARS_START_LIN
001014 0FD014 -> $FD014               STATE_VARS_START_LIN    EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ; - RS232 variables - (declared in BPEM488.s)
                                      ;*****************************************************************************************
                                      ;CASprd512:   ds 2  ; Period between CAS2nd and CAS3d (5.12uS res)
                                      ;CASprd256:   ds 2  ; Period between CAS2nd and CAS3d (2.56uS res)
                                      ;engine:      ds 1  ; Engine status bit field
                                      ;engine2:      ds 1  ; Engine2 status bit field
                                      ;*****************************************************************************************
                                      ; - "engine" Engine status bit field
                                      ;*****************************************************************************************
                                      ;OFCdelon     equ  $01 ; %00000001, bit 0, 0 = OFC timer not counting down(Grn),
                                                                              ; 1 = OFC timer counting down(Red)
                                      ;crank        equ  $02 ; %00000010, bit 1, 0 = engine not cranking(Grn),
                                                                              ; 1 = engine cranking(Red)
                                      ;run          equ  $04 ; %00000100, bit 2, 0 = engine not running(Red),
                                                                              ; 1 = engine running(Grn)
                                      ;ASEon        equ  $08 ; %00001000, bit 3, 0 = not in start/warmup(Grn),
                                                                              ; 1 = in start/warmup(Red)
                                      ;WUEon        equ  $10 ; %00010000, bit 4, 0 = not in warmup(Grn),
                                                                              ; 1 = in warmup(Red)
                                      ;TOEon        equ  $20 ; %00100000, bit 5, 0 = not in TOE mode(Grn),
                                                                              ; 1 = TOE mode(Red)
                                      ;OFCon        equ  $40 ; %01000000, bit 6, 0 = not in OFC mode(Grn),
                                                                              ; 1 = in OFC mode(Red)
                                      ;FldClr       equ $80  ; %10000000, bit 7, 0 = not in flood clear mode(Grn),
                                                                              ; 1 = Flood clear mode(Red)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; "engine2" equates
                                      ;*****************************************************************************************
                                      ;base512        equ $01 ; %00000001, bit 0, 0 = 5.12uS time base off(White),
                                                                               ; 1 = 5.12uS time base on(Grn)
                                      ;base256        equ $02 ; %00000010, bit 1, 0 = 2.56uS time base off(White),
                                                                               ; 1 = 2.56uS time base on(Grn)
                                      ;eng2Bit2       equ $04 ; %00000100, bit 2, 0 = , 1 =
                                      ;eng2Bit3       equ $08 ; %00001000, bit 3, 0 = , 1 =
                                      ;eng2Bit4       equ $10 ; %00010000, bit 4, 0 = , 1 =
                                      ;eng2Bit5       equ $20 ; %00100000, bit 5, 0 = , 1 =
                                      ;eng2Bit6       equ $40 ; %01000000, bit 6, 0 = , 1 =
                                      ;eng2Bit7       equ $80 ; %10000000, bit 7, 0 = , 1 =
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - RS232 variables - (declared in injcalcs_BPEM488.s)
                                      ;*****************************************************************************************
                                      ;ASErev:        ds 2 ; Afterstart Enrichment Taper (revolutions)
                                      ;ASEcnt:        ds 2 ; Counter value for ASE taper
                                      ;StateStatus:   ds 1 ; State status bit field
                                      ;*****************************************************************************************
                                      ; - "StateStatus" equates
                                      ;*****************************************************************************************
                                      ;Synch            equ    $01  ; %00000001, bit 0,
                                                                   ; 0 = crank position not synchronized(Red),
                                                                                               ; 1 = crank position synchronized(Grn)
                                      ;SynchLost        equ    $02  ; %00000010, bit 1, 0 = synch not lost(Grn),
                                                                   ; 1 = synch lost(Red)
                                      ;StateNew         equ    $04  ; %00000100, bit 2, 0 = no new State value,
                                                                   ; 1 = New State value
                                      ;StateStatus3     equ    $08  ; %00001000, bit 3,
                                      ;StateStatus4     equ    $10  ; %00010000, bit 4
                                      ;StateStatus5     equ    $20  ; %00100000, bit 5
                                      ;StateStatus6     equ    $40  ; %01000000, bit 6
                                      ;StateStatus7     equ    $80  ; %10000000, bit 7
                                      ;*****************************************************************************************
                                      ; - State machine variables - (declared in this module)
                                      ;*****************************************************************************************
001014 0FD014                         State:        ds 1  ; Cam-Crank state machine current state
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Input capture variables - (declared in this module)
                                      ;*****************************************************************************************
001015 0FD015                         CAS1sttk:    ds 2  ; CAS input capture rising edge 1st time stamp ((5.12uS or 2.56uS res)
001017 0FD017                         CAS2ndtk:    ds 2  ; CAS input capture rising edge 2nd time stamp (5.12uS or 2.56uS res)
001019 0FD019                         CASprd1tk:   ds 2  ; Period between CAS1st and CAS2nd (5.12uS or 2.56uS res)
00101B 0FD01B                         CASprd2tk:   ds 2  ; Period between CAS2nd and CAS3d ((5.12uS or 2.56uS res)
00101D 0FD01D                         Degx10tk512: ds 2  ; Time to rotate crankshaft 1 degree in 5.12uS resolution x 10
00101F 0FD01F                         Degx10tk256: ds 2  ; Time to rotate crankshaft 1 degree in 2.56uS resolution x 10
001021 0FD021                         RevCntr:     ds 1  ; Counter for "Revmarker" flag
001022 0FD022                         Stallcnt:    ds 2  ; No crank or stall condition counter (1mS increments)
001024 0FD024                         ICflgs:      ds 1  ; Input Capture flags bit field
                                      ;*****************************************************************************************
                                      ; - "ICflgs" equates
                                      ;*****************************************************************************************
001025 0FD025 -> $0001                RPMcalc:    equ $01   ; %00000001 (Bit 0) (Do RPM calculations flag)
001025 0FD025 -> $0002                KpHcalc:    equ $02   ; %00000010 (Bit 1) (Do VSS calculations flag)
                                      ;Ch1_2nd:    equ $04   ; %00000100 (Bit 2) (Ch1 2nd edge flag)
001025 0FD025 -> $0004                Ch1_On:     equ $04   ; %00000100 (Bit 2) (Ch1 On and counting flag)
001025 0FD025 -> $0008                Ch2alt:     equ $08   ; %00001000 (Bit 3) (Ch2 alt flag)
001025 0FD025 -> $0010                Ch1_3d:     equ $10   ; %00010000 (Bit 4) (Ch1 3d edge flag)
001025 0FD025 -> $0020                RevMarker:  equ $20   ; %00100000 (Bit 5) (Crank revolution marker flag)
                                      ;*****************************************************************************************
001025 0FD025 -> $1025                STATE_VARS_END          EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
001025 0FD025 -> $FD025               STATE_VARS_END_LIN      EQU     @     ; @ Represents the current value of the linear
                                      ;*****************************************************************************************
                                      ;* - Code -                                                                              *
                                      ;*****************************************************************************************
005A4A 7F5A4A                                                 ORG     STATE_CODE_START, STATE_CODE_START_LIN
005A4A 7F5A4A -> $7F5A4A              STATE_CODE_START_LIN    EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ; - The camshaft position sensor and the crankshaft position sensor are both hall
                                      ;   effect gear tooth sensors. They read notched wheels on their repsective shafts.
                                      ;   When the sensor senses a notch its output pin goes to ground. The BPEM simulator
                                      ;   input from the sensor is the LED circuit of an opto isolator. When the LED in the
                                      ;   opto is powered it biases the output transistor on so the timer channel pin sees a
                                      ;   rising edge, which triggers an interrupt event. The state machine uses these events
                                      ;   to de-code the signals to determine crankshaft position and camshaft phase. Any
                                      ;   event that does not fall into the mechanical order of events triggers an error.
                                      ;   An error will disable ignition and fuel injection until a positive lock on crankshaft
                                      ;   position and camshaft phase is re-established.
                                      ;*****************************************************************************************
005A4A 7F5A4A                         ECT_TC0_ISR:
                                      ;*****************************************************************************************
                                      ; - ECT_TC0_ISR Interrupt Service Routine (Camshaft sensor notch)
                                      ;   Event = 0
                                      ;*****************************************************************************************
005A4A 7F5A4A DE 50                       ldx    ECT_TC0H         ; Read ECT_TC0H to clear the flag
005A4C 7F5A4C CE 7B 9F                    ldx    #StateLookup     ; Load index register X with the address of "TableLookup"
005A4F 7F5A4F F6 10 14                    ldab   State            ; Load Accu B with the contents of "State"
005A52 7F5A52 58                          aslb                    ; Shift Accu B 1 place to the left
005A53 7F5A53 CA 00                       orab   #$00             ; Bit wise inclusive OR Accu B with 0
005A55 7F5A55 A6 E5                       ldaa   B,X              ; Load Accu A with the contents of "TableLookup", offset in
                                                                  ; Accu B (9 bit constant offset indexed addressing)
005A57 7F5A57 7A 10 14                    staa   State            ; Copy to "State"
005A5A 7F5A5A 0B                          rti                     ; Return from interrupt
005A5B 7F5A5B                         ECT_TC1_ISR:
                                      ;*****************************************************************************************
                                      ; - ECT_TC1_ISR Interrupt Service Routine (Crankshaft sensor notch)
                                      ;   Event = 1
                                      ;*****************************************************************************************
005A5B 7F5A5B DE 52                       ldx    ECT_TC1H              ; Read ECT_TC1H to clear the flag
005A5D 7F5A5D CE 7B 9F                    ldx    #StateLookup     ; Load index register X with the address of "TableLookup"
005A60 7F5A60 F6 10 14                    ldab   State            ; Load Accu B with the contents of "State"
005A63 7F5A63 58                          aslb                    ; Shift Accu B 1 place to the left
005A64 7F5A64 CA 01                       orab   #$01             ; Bit wise inclusive OR Accu B with 1
005A66 7F5A66 A6 E5                       ldaa   B,X              ; Load Accu A with the contents of "TableLookup", offset in
                                                                  ; Accu B (9 bit constant offset indexed addressing)
005A68 7F5A68 7A 10 14                    staa   State            ; Copy to "State"
005A6B 7F5A6B 81 46                       cmpa    #$46            ; Compare with decimal 70 (Error)
005A6D 7F5A6D 27 06                       beq     State_Error     ; If "State" = $46, branch to State_Error:
005A6F 7F5A6F 81 67                       cmpa    #$67            ; Compare with decimal 103
005A71 7F5A71 2F 21                       ble     NoLock          ; If "State" =< $67, branch to NoLock:
005A73 7F5A73 2E 11                       bgt     SynchLock       ; If "State" is > $67, branch to Synchlock:
005A75 7F5A75                         State_Error:
                                      ;*****************************************************************************************
                                      ; - If we get here we have experienced an unexpected cam or crank input and have lost lock.
                                      ;   No more spark or injection events until lock has been re-established.
                                      ;*****************************************************************************************
005A75 7F5A75 79 10 14                    clr   State                     ; Clear "State"
005A78 7F5A78 1C 10 E5 02                 bset  StateStatus,SynchLost     ; Set "SynchLost" bit of "StateStatus" variable (bit1)
005A7C 7F5A7C 1D 10 E5 01                 bclr  StateStatus,Synch         ; Clear "Synch " bit of "StateStatus" variable (bit0)
005A80 7F5A80 1D 10 E5 04                 bclr  StateStatus,StateNew      ; Clear "StateNew " bit of "StateStatus" variable (bit2)
005A84 7F5A84 20 1A                       bra   STATE_STATUS_done         ; Branch to STATE_STATUS_done:
005A86 7F5A86                         SynchLock:
                                      ;*****************************************************************************************
                                      ; - If we get here we have either just reached one of the four possible lock points, or
                                      ;    we are already in the synch loop.
                                      ;*****************************************************************************************
005A86 7F5A86 1C 10 E5 01                 bset  StateStatus,Synch        ; Set "Synch " bit of "StateStatus" variable (bit0)
005A8A 7F5A8A 1C 10 E5 04                 bset  StateStatus,StateNew     ; Set "StateNew" bit of "StateStatus" variable (bit2)
005A8E 7F5A8E 1D 10 E5 02                 bclr  StateStatus,SynchLost    ; Clear "SynchLost" bit of "StateStatus" variable (bit1)
005A92 7F5A92 20 0C                       bra   STATE_STATUS_done        ; Branch to STATE_STATUS_done:
005A94 7F5A94                         NoLock:
                                      ;*****************************************************************************************
                                      ; - If we get here we have the state machine is still looking for a synch lock.
                                      ;*****************************************************************************************
005A94 7F5A94 1D 10 E5 01                 bclr  StateStatus,Synch        ; Clear "Synch" bit of "StateStatus" variable (bit0)
005A98 7F5A98 1D 10 E5 02                 bclr  StateStatus,SynchLost    ; Clear "SynchLost" bit of "StateStatus" variable (bit1)
005A9C 7F5A9C 1D 10 E5 04                 bclr  StateStatus,StateNew     ; Clear "StateNew" bit of "StateStatus" variable (bit 2)
005AA0 7F5AA0                         STATE_STATUS_done:
                                      ;*****************************************************************************************
                                      ; - Get three consecutive rising edge signals for engine RPM and
                                      ;   calculate the period. This period is for one fifth of a revolution (72 degrees).
                                      ;   RPM, Ignition and  Fuel calculations are done in the main loop.
                                      ;
                                      ; - Also, the tachometer in the instrument cluster of the '95 Dodge Ram with the 8.0L V10
                                      ;   is expecting a 12V square wave signal of 125Hz at 3000 engine RPM. In order to
                                      ;   generate the appropriate signal for this tachometer the following logic is applied:
                                      ;   3000 RPM/60 = 50 Hz
                                      ;   125/50 = 2.5 pulse per revolution, or 5 pulses per 2 revolution
                                      ;   Because we have ten notches on the crank tone ring, if we toggle an output every 3
                                      ;   notches we can create the desired frequency. Then it is just a matter of hardware
                                      ;   conditioning the circuit to create the desired 12V square wave signal
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Reload stall counter with compare value. Stall check is done in the main loop every
                                      ;   mSec. "Stallcnt" is decremented every mSec and reloaded at every crank signal.
                                      ;*****************************************************************************************
005AA0 7F5AA0 18 0B FF 00 17                  movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE
005AA5 7F5AA5 CD 08 00                    ldy   #veBins_E       ; Load index register Y with address of first configurable
                                                              ; constant on buffer RAM page 1 (vebins)
005AA8 7F5AA8 EC EA 03 E6                 ldd   $03E6,Y       ; Load Accu A with value in buffer RAM page 1 offset 998
                                                              ; "Stallcnt" (stall counter)(offset = 998)
005AAC 7F5AAC 7C 10 22                    std  Stallcnt       ; Copy to "Stallcnt" (no crank or stall condition counter)
                                                              ; (1mS increments)
005AAF 7F5AAF 1E 10 24 10 1A              brset ICflgs,Ch1_3d,CAS_3d   ; If "Ch1_3d" bit of "ICflgs" is set, branch to "CAS_3d:"
005AB4 7F5AB4 1E 10 24 04 0D              brset ICflgs,Ch1_On,CAS_2nd  ; If "Ch1_On" bit of "ICflgs" is set, branch to "CAS_2nd:"
005AB9 7F5AB9 DC 52                       ldd   ECT_TC1H               ; Load accu D with value in "ECT_TC1H"
005ABB 7F5ABB 7C 10 15                    std   CAS1sttk               ; Copy to "CAS1sttk"
005ABE 7F5ABE 1C 10 24 04                     bset  ICflgs,Ch1_On          ; Set "Ch1_On" bit of "ICflgs"
005AC2 7F5AC2 18 20 00 BA                 bra   CASDone                ; Branch to CASDone:
005AC6 7F5AC6                         CAS_2nd:
005AC6 7F5AC6 1C 10 24 10                 bset  ICflgs,Ch1_3d          ; Set "Ch1_3d" bit of "ICflgs"
005ACA 7F5ACA 18 20 00 B2                 bra   CASDone                ; Branch to CASDone:
005ACE 7F5ACE                         CAS_3d:
005ACE 7F5ACE DC 52                       ldd   ECT_TC1H          ; Load accu D with value in "ECT_TC1H"
005AD0 7F5AD0 7C 10 17                    std   CAS2ndtk          ; Copy to "CAS2ntk"
005AD3 7F5AD3 B3 10 15                    subd  CAS1sttk          ; Subtract (A:B)-(M:M+1)=>A:B "CAS1sttk" from value in "CAS2ntk"
                                                                      ; Result in Acu D will be stored as either "CASprd512" or "CASprd256"
                                                                                              ; depending on whether we are cranking or running
005AD6 7F5AD6 18 04 10 17 10 15               movw  CAS2ndtk,CAS1sttk  ; Copy value in "CAS2ndtk" to "CAS1sttk"
005ADC 7F5ADC 1D 10 24 10                 bclr  ICflgs,Ch1_3d     ; Clear "Ch1_3d" bit of "ICflgs"
                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; - Old Code  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                      ;    brset ICflgs,Ch1_2nd,CAS_2nd ; If "Ch1_2nd" bit of "ICflgs" is set, branch to "CAS_2nd:"
                                      ;    brset ICflgs,Ch1_3d,CAS_3d   ; If "Ch1_3d" bit of "ICflgs" is set, branch to "CAS_3d:"
                                      ;    ldd   ECT_TC1H               ; Load accu D with value in "ECT_TC1H"
                                      ;    std   CAS1sttk               ; Copy to "CAS1sttk"
                                      ;    bset  ICflgs,Ch1_2nd         ; Set "Ch1_2nd" bit of "ICflgs"
                                      ;    bra   CASDone                ; Branch to CASDone:
                                      ;CAS_2nd:
                                      ;    ldd   ECT_TC1H        ; Load accu D with value in "ECT_TC1H"
                                      ;    std   CAS2ndtk        ; Copy to "CAS2ndtk"
                                      ;    subd  CAS1sttk        ; Subtract (A:B)-(M:M+1)=>A:B "CAS1sttk" from value in "ECT_TC7H"
                                      ;    std   CASprd1tk       ; Copy result to "CASprd1tk"
                                      ;    bclr  ICflgs,Ch1_2nd  ; Clear "Ch1_2nd" bit of "ICflgs"
                                      ;    bset  ICflgs,Ch1_3d   ; Set "Ch1_3d" bit of "ICflgs"
                                      ;    bra   CASDone         ; Branch to CASDone:
                                      ;CAS_3d:
                                      ;    ldd   ECT_TC1H        ; Load accu D with value in "ECT_TC1H"
                                      ;    subd  CAS2ndtk        ; Subtract (A:B)-(M:M+1)=>A:B "CAS2ndtk" from value in "ECT_TC7H"
                                      ;    std   CASprd2tk       ; Copy result to "CASprd2tk"
                                      ;    addd  CASprd1tk       ; (A:B)+(M:M+1)_->A:B "CASprd2tk" + "CASprd1tk" = "CASprdtk"
                                      ;    bclr  ICflgs,Ch1_3d   ; Clear "Ch1_3d" bit of "ICflgs"
                                      ;
                                      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                      ;*****************************************************************************************
                                      ; - All calculations that use the Crank Angle Sensor period need to know what the
                                      ;   resolution is. The timers are initalized with a 5.12uS resoluion but switched to
                                      ;   2.56uS resolution when the engine tranistions from crank mode to run mode.
                                      ;*****************************************************************************************
005AE0 7F5AE0 1E 10 E1 04 17              brset engine,run,CAS256 ; If "run" bit of "engine" bit field is set branch to
                                                                    ; CAS256:
005AE5 7F5AE5 7C 10 9A                    std   CASprd512       ; Copy result to "CASprd512" (CAS period in 5.12uS resolution)
                                      ;******************************************************************************************
                                      ; - Convert Crank Angle Sensor period (5.12uS res)to degrees x 10 of rotation (for 1 tenth
                                      ;   of a degree resolution calculations).("Degx10tk512")
                                      ;******************************************************************************************
005AE8 7F5AE8 CE 00 48                    ldx   #$0048         ; Decimal 72 -> X
005AEB 7F5AEB 18 10                       idiv                 ; (D)/(X)->(X)rem(D) (CASprd512/72)
005AED 7F5AED B7 54                       tfr   X,D            ; Copy result in "X" to "D"
005AEF 7F5AEF CD 00 0A                        ldy   #$000A         ; Decimal 10 -> Accu Y
005AF2 7F5AF2 13                              emul                 ; (D)*(Y)->Y:D result * 10 = "Degx10tk512"
005AF3 7F5AF3 7C 10 1D                        std   Degx10tk512    ; Copy result to "Degx10tk512"
005AF6 7F5AF6 18 79 10 1F                     clrw  Degx10tk256    ; Clear "Degx10tk256"
005AFA 7F5AFA 20 15                           bra   CASprdDone     ; Branch to CASprdDone:
005AFC 7F5AFC                         CAS256:
005AFC 7F5AFC 7C 10 9C                    std   CASprd256      ; Copy result to "CASprd256" (CAS period in 2.56uS resolution)
                                      ;******************************************************************************************
                                      ; - Convert Crank Angle Sensor period (2.56uS res)to degrees x 10 of rotation (for 1 tenth
                                      ;   of a degree resolution calculations).("Degx10tk256")
                                      ;******************************************************************************************
005AFF 7F5AFF CE 00 48                    ldx   #$0048         ; Decimal 72 -> X
005B02 7F5B02 18 10                       idiv                 ; (D)/(X)->(X)rem(D) (CASprd256/72)
005B04 7F5B04 B7 54                       tfr   X,D            ; Copy result in "X" to "D"
005B06 7F5B06 CD 00 0A                        ldy   #$000A         ; Decimal 10 -> Accu Y
005B09 7F5B09 13                              emul                 ; (D)*(Y)->Y:D result * 10 = "Degx10tk256"
005B0A 7F5B0A 7C 10 1F                        std   Degx10tk256    ; Copy result to "Degx10tk256"
005B0D 7F5B0D 18 79 10 1D                 clrw  Degx10tk512    ; Clear "Degx10tk512"
005B11 7F5B11                         CASprdDone:
                                      ;*****************************************************************************************
                                      ; - Toggle PB4 (Tach out signal)
                                      ;*****************************************************************************************
005B11 7F5B11 96 01                       ldaa  PORTB        ; Load ACC A with value in Port B
005B13 7F5B13 88 10                       eora  #$10         ; Exclusive or with $00010000
005B15 7F5B15 5A 01                       staa   PORTB       ; Copy to Port B (toggle Bit4, Tach out)
                                      ;*****************************************************************************************
                                      ; - Determine if the engine is cranking or running. The timer is initialized with a
                                      ;   5.12uS time base and the engine status bit field "engine" is cleared on power up.
                                      ;   "Spantk" will roll over at ~85 RPM with a 5.12uS base and at ~169 RPM with a
                                      ;   2.56uS base. The time base is switched from 5.12uS to 2.56uS at ~300 RPM which should
                                      ;   be at a speed when the engine is running. Engine speed can drop to as low as ~169 RPM
                                      ;   before ignition calculations cannot be done. It is not likely that the engine will
                                      ;   continue to run at this speed and will stall. Stall detection is done in the main
                                      ;   loop if the period between crank sensor signals is greater than ~2 seconds.
                                      ;*****************************************************************************************
005B17 7F5B17 1E 10 E1 04 60              brset  engine,run,CASprdOK ; If "run" bit of "engine" bit field is set branch to
                                                                    ; CASDone:
                                      ;*****************************************************************************************
                                      ; - Look up the cranking RPM limit ("crankingRPM_F")
                                      ;*****************************************************************************************
005B1C 7F5B1C 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE
005B21 7F5B21 CD 08 00                    ldy   #veBins_E   ; Load index register Y with address of first configurable
                                                            ; constant on buffer RAM page 1 (veBins_E)
005B24 7F5B24 EE EA 03 E2                 ldx   $03E2,Y     ; Load Accu X with value in buffer RAM page 1 (offset 994)($03E2)
                                                            ; ("crankingRPM_F", cranking RPM limit)
                                      ;*****************************************************************************************
                                      ; - Convert to crank angle sensor period ticks in 5.12uS resolution
                                      ;*****************************************************************************************
005B28 7F5B28 CC C3 46                    ldd  #$C346           ; Load accu D with Lo word of  10 cyl RPMk (5.12uS clock tick)
005B2B 7F5B2B CD 00 23                    ldy  #$0023           ; Load accu Y with Hi word of 10 cyl RPMk (5.12uS clock tick)
005B2E 7F5B2E 11                          ediv                  ; Extended divide (Y:D)/(X)=>Y;Rem=>D "RPMk" / "crankingRPM_F"
                                                                ; = crank angle sensor period in 5.12uS resolution
                                      ;*****************************************************************************************
                                      ; - Compare the limit period with the current period
                                      ;*****************************************************************************************
005B2F 7F5B2F BD 10 9A                    cpy   CASprd512       ; Compare cranking RPM limit period to "CASprd512"
005B32 7F5B32 25 28                           blo   StillCranking   ; Period is greater than that for "crankingRPM_F" so engine is
                                                                    ; still cranking. Branch to StillCranking:
005B34 7F5B34 20 00                       bra   SwitchToRun     ; Branch to SwitchToRun:
005B36 7F5B36                         SwitchToRun:
005B36 7F5B36 18 0B 7F 00 6E              movb #$7F,ECT_PTPSR   ; Load ECT_PTPSR with %01111111
                                                                ; (prescale 128, 2.56us resolution,
                                                                ; max period 167.7696ms)
005B3B 7F5B3B 18 0B 7F 03 FE              movb #$7F,TIM_PTPSR   ; (TIM_PTPSR equ $03FE) Load TIM_PTPSR with %01111111
                                                                ; (prescale 128, 2.56us resolution,
                                                                ; max period 167.7696ms)
005B40 7F5B40 1C 10 E1 04                 bset  engine,run      ; Set "run" bit of "engine" variable
005B44 7F5B44 1D 10 E1 02                 bclr  engine,crank    ; Clear "crank" bit of "engine" variable
005B48 7F5B48 1D 10 E2 01                 bclr engine2,base512  ; Clear the "base512" bit of "engine" bit field
005B4C 7F5B4C 1C 10 E2 02                 bset engine2,base256  ; Set the "base256" bit of "engine" bit field
005B50 7F5B50 18 79 10 9A                 clrw  CASprd512       ; Clear "CASprd512"
005B54 7F5B54 MACRO                           FUEL_PUMP_AND_ASD_ON  ; Energise fuel pump and ASD Relay (macro in gpio_BEEM.s)
                                                            ; Register (pullups enabled BKGD, Port E and Port A        (FUEL_PUMP_AND_ASD_ON)
                                      ;***************************************************************************************** (FUEL_PUMP_AND_ASD_ON)
                                      ; - Energise the Fuel pump relay and the Emergency Shutdown relay on Port B Bit0 and Bit1 (FUEL_PUMP_AND_ASD_ON)
                                      ;***************************************************************************************** (FUEL_PUMP_AND_ASD_ON)
005B54 7F5B54 4C 01 01                    bset  PORTB,FuelPump  ; Set "FuelPump" pin on Port B(LED9 board 1 to 28)     (FUEL_PUMP_AND_ASD_ON)
005B57 7F5B57 4C 01 02                        bset  PORTB,ASDRelay  ; Set "ASDRelay" pin on Port B(LED23 board 1 to 28) (FUEL_PUMP_AND_ASD_ON)
005B5A 7F5B5A 20 20                           bra   CASprdOK        ; Branch to CASprdOK:
005B5C 7F5B5C                         StillCranking:
005B5C 7F5B5C 18 0B FF 00 6E              movb #$FF,ECT_PTPSR   ; Load ECT_PTPSR with %11111111
                                                                ; (prescale 256, 5.12us resolution,
                                                                ; max period 335.5ms)
005B61 7F5B61 18 0B FF 03 FE              movb #$FF,TIM_PTPSR   ; Load TIM_PTPSR with %11111111
                                                                ; (prescale 256, 5.12us resolution,
                                                                ; max period 335.5ms)
005B66 7F5B66 1D 10 E1 04                 bclr engine,run       ; Clear "run" bit of "engine" variable
005B6A 7F5B6A 1C 10 E1 02                 bset engine,crank     ; Set "crank" bit of "engine" variable
005B6E 7F5B6E 1C 10 E2 01                 bset engine2,base512  ; Set the "base512" bit of "engine" bit field
005B72 7F5B72 1D 10 E2 02                 bclr engine2,base256  ; Clear the "base256" bit of "engine" bit field
005B76 7F5B76 MACRO                           FUEL_PUMP_AND_ASD_ON  ; Energise fuel pump and ASD Relay (macro in gpio_BEEM.s)
                                                            ; Register (pullups enabled BKGD, Port E and Port A        (FUEL_PUMP_AND_ASD_ON)
                                      ;***************************************************************************************** (FUEL_PUMP_AND_ASD_ON)
                                      ; - Energise the Fuel pump relay and the Emergency Shutdown relay on Port B Bit0 and Bit1 (FUEL_PUMP_AND_ASD_ON)
                                      ;***************************************************************************************** (FUEL_PUMP_AND_ASD_ON)
005B76 7F5B76 4C 01 01                    bset  PORTB,FuelPump  ; Set "FuelPump" pin on Port B(LED9 board 1 to 28)     (FUEL_PUMP_AND_ASD_ON)
005B79 7F5B79 4C 01 02                        bset  PORTB,ASDRelay  ; Set "ASDRelay" pin on Port B(LED23 board 1 to 28) (FUEL_PUMP_AND_ASD_ON)
005B7C 7F5B7C                         CASprdOK:
005B7C 7F5B7C 1C 10 24 01                 bset  ICflgs,RPMcalc  ; Set "RPMcalc" bit of "ICflgs"
005B80 7F5B80                         CASDone:
                                      ;******************************************************************************************
                                      ; - Rev counter -
                                      ;   Used to decrement "ASErev" every revolution  (count down counter for ASE taper)
                                      ;******************************************************************************************
005B80 7F5B80                         DoRevCntr:
005B80 7F5B80 B6 10 21                    ldaa  RevCntr        ; Load Accu A with value in "RevCntr"
005B83 7F5B83 81 09                       cmpa  #$09           ; Compare with decimal 9
005B85 7F5B85 27 24                       beq   CAS1           ; If equal branch to CAS1: (First CAS signal)
005B87 7F5B87 81 08                       cmpa  #$08           ; Compare with decimal 8
005B89 7F5B89 27 30                       beq   CAS2           ; If equal branch to CAS2: (Second CAS signal)
005B8B 7F5B8B 81 07                       cmpa  #$07           ; Compare with decimal 7
005B8D 7F5B8D 27 31                       beq   CAS3           ; If equal branch to CAS3: (Third CAS signal)
005B8F 7F5B8F 81 06                       cmpa  #$06           ; Compare with decimal 6
005B91 7F5B91 27 32                       beq   CAS4           ; If equal branch to CAS4: (Forth CAS signal)
005B93 7F5B93 81 05                       cmpa  #$05           ; Compare with decimal 5
005B95 7F5B95 27 33                       beq   CAS5           ; If equal branch to CAS5: (Fifth CAS signal)
005B97 7F5B97 81 04                       cmpa  #$04           ; Compare with decimal 4
005B99 7F5B99 27 34                       beq   CAS6           ; If equal branch to CAS6: (Sixth CAS signal)
005B9B 7F5B9B 81 03                       cmpa  #$03           ; Compare with decimal 3
005B9D 7F5B9D 27 35                       beq   CAS7           ; If equal branch to CAS7: (Seventh CAS signal)
005B9F 7F5B9F 81 02                       cmpa  #$02           ; Compare with decimal 2
005BA1 7F5BA1 27 36                       beq   CAS8           ; If equal branch to CAS8: (Eighth CAS signal)
005BA3 7F5BA3 81 01                       cmpa  #$01           ; Compare with decimal 1
005BA5 7F5BA5 27 37                       beq   CAS9           ; If equal branch to CAS9: (Nineth CAS signal)
005BA7 7F5BA7 81 00                       cmpa  #$00           ; Compare with zero
005BA9 7F5BA9 27 38                       beq   CAS10          ; If equal branch to CAS10: (Tenth CAS signal)
005BAB 7F5BAB                         CAS1:
                                      ;*****************************************************************************************
                                      ; - if ASE is in progress, decrement the counter (ASEcnt)
                                      ;*****************************************************************************************
005BAB 7F5BAB 1E 10 E1 08 02              brset engine,ASEon,DecASECnt ; If "ASEon" bit of "engine" bit field is set, branch to
                                                                 ; DecASECnt:
005BB0 7F5BB0 20 04                       bra  NoDecASECnt       ; Branch to NoDecASECnt:
005BB2 7F5BB2                         DecASECnt:
005BB2 7F5BB2 18 73 10 A4                 decw   ASEcnt          ; Decrement "ASEcnt"(countdown value for ASE taper)
                                                                 ; (starts with the lookup value of "ASErev")
005BB6 7F5BB6                         NoDecASECnt:
005BB6 7F5BB6 73 10 21                    dec   RevCntr          ; Decrement "RevCntr"(now eight)
005BB9 7F5BB9 20 31                       bra   RevCntrDone      ; Branch to RevCntrDone:
005BBB 7F5BBB                         CAS2:
005BBB 7F5BBB 73 10 21                    dec   RevCntr          ; Decrement "RevCntr"(now seven)
005BBE 7F5BBE 20 2C                       bra   RevCntrDone      ; Branch to RevCntrDone:
005BC0 7F5BC0                         CAS3:
005BC0 7F5BC0 73 10 21                    dec   RevCntr          ; Decrement "RevCntr"(now six)
005BC3 7F5BC3 20 27                       bra   RevCntrDone      ; Branch to RevCntrDone:
005BC5 7F5BC5                         CAS4:
005BC5 7F5BC5 73 10 21                    dec   RevCntr          ; Decrement "RevCntr"(now five)
005BC8 7F5BC8 20 22                       bra   RevCntrDone      ; Branch to RevCntrDone:
005BCA 7F5BCA                         CAS5:
005BCA 7F5BCA 73 10 21                    dec   RevCntr          ; Decrement "RevCntr"(now four)
005BCD 7F5BCD 20 1D                       bra   RevCntrDone      ; Branch to RevCntrDone:
005BCF 7F5BCF                         CAS6:
005BCF 7F5BCF 73 10 21                    dec   RevCntr          ; Decrement "RevCntr"(now three)
005BD2 7F5BD2 20 18                       bra   RevCntrDone      ; Branch to RevCntrDone:
005BD4 7F5BD4                         CAS7:
005BD4 7F5BD4 73 10 21                    dec   RevCntr          ; Decrement "RevCntr"(now two)
005BD7 7F5BD7 20 13                       bra   RevCntrDone      ; Branch to RevCntrDone:
005BD9 7F5BD9                         CAS8:
005BD9 7F5BD9 73 10 21                    dec   RevCntr          ; Decrement "RevCntr"(now one)
005BDC 7F5BDC 20 0E                       bra   RevCntrDone      ; Branch to RevCntrDone:
005BDE 7F5BDE                         CAS9:
005BDE 7F5BDE 73 10 21                    dec   RevCntr          ; Decrement "RevCntr"(now zero)
005BE1 7F5BE1 20 09                       bra   RevCntrDone      ; Branch to RevCntrDone:
005BE3 7F5BE3                         CAS10:
005BE3 7F5BE3 1C 10 24 20                 bset  ICflgs,RevMarker ; Set "RevMarker" flag of "ICflags" bit field
005BE7 7F5BE7 18 0B 09 10 21              movb  #$09,RevCntr     ; Load "RevCntr" with decimal 9(We have 10 CAS signals so the
                                                                 ; crank has turned 1 revolution, reset the counter to nine)
005BEC 7F5BEC                         RevCntrDone:
                                      ;*****************************************************************************************
                                      ; - "State" event handlers
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; CT3/T1  Synchronization point, no event.
                                      ; CT3/T2  Start timer for ignition #1, waste #6
                                      ; CT3/T3 - Start timer for ignition #10, waste #5
                                      ; CT3/T4  Start injection pulse for #3 & #6
                                      ; CT4/T5 - Synchronization point, no event.
                                      ; CT4/T6 - Start timer for ignition #9, waste #8
                                      ; CT4/T7 - Start timer for ignition #4, waste #7
                                      ; CT4/T8 - Start injection pulse for #5 & #8
                                      ; CT4/T9  No event.
                                      ; CT4/T10 - Start timer for ignition #3, waste #2
                                      ; CT4/T1  Synchronization point, start timer for ignition #6, waste #1
                                      ; CT4/T2 - Start injection pulse for #7 & #2
                                      ; CT4/T3 - No event.
                                      ; CT4/T4 - Start timer for ignition #5, waste #10
                                      ; CT1/T5 - Synchronization point, start timer for ignition #8, waste #9
                                      ; CT1/T6 - Start injection pulse for #1 & #10
                                      ; CT1/T7 - No event.
                                      ; CT1/T8 - Start timer for ignition #7, waste #4
                                      ; CT1/T9 - Start timer for ignition #2, waste #3
                                      ; CT1/T10 - Start injection pulse for #9 & #4
                                      ; Repeat
                                      ; Ignition timers start 150 degrees BTDC on compression. Injectors start pulse width
                                      ; when the intake valve just begins to open on odd cylinders, and 54 degrees before the
                                      ; intake valve starts to open on even cylinders.
                                      ;*****************************************************************************************
005BEC 7F5BEC B6 10 14                    ldaa    State           ; Load accu A with value in "State"
005BEF 7F5BEF 81 7D                       cmpa    #$7D            ; Compare with decimal 125 (CT3/T1)
005BF1 7F5BF1 27 72                       beq     Notch_CT3_T1    ; If the Z bit of CCR is set, branch to Notch_CT3_T1:
005BF3 7F5BF3 81 6F                       cmpa    #$6F            ; Compare with decimal 111 (CT3/T2)
005BF5 7F5BF5 18 27 03 AF                 beq     Notch_CT3_T2    ; If the Z bit of CCR is set, branch to Notch_CT3_T2:
005BF9 7F5BF9 81 70                       cmpa    #$70            ; Compare with decimal 112 (CT3/T3)
005BFB 7F5BFB 18 27 03 B9                 beq     Notch_CT3_T3    ; If the Z bit of CCR is set, branch to Notch_CT3_T3:
005BFF 7F5BFF 81 71                       cmpa    #$71            ; Compare with decimal 113 (CT3/T4)
005C01 7F5C01 18 27 03 C3                 beq     Notch_CT3_T4    ; If the Z bit of CCR is set, branch to Notch_CT3_T4:
005C05 7F5C05 81 7F                       cmpa    #$7F            ; Compare with decimal 127 (CT4/T5)
005C07 7F5C07 18 27 03 F7                 beq     Notch_CT4_T5    ; If the Z bit of CCR is set, branch to Notch_CT4_T5:
005C0B 7F5C0B 81 7B                       cmpa    #$7B            ; Compare with decimal 123 (CT4/T6)
005C0D 7F5C0D 18 27 07 34                 beq     Notch_CT4_T6    ; If the Z bit of CCR is set, branch to Notch_CT4/T6:
005C11 7F5C11 81 7A                       cmpa    #$7A            ; Compare with decimal 122 (CT4/T7)
005C13 7F5C13 18 27 07 3E                 beq     Notch_CT4_T7    ; If the Z bit of CCR is set, branch to Notch_CT4_T7:
005C17 7F5C17 81 79                       cmpa    #$79            ; Compare with decimal 121 (CT4/T8)
005C19 7F5C19 18 27 07 48                 beq     Notch_CT4_T8    ; If the Z bit of CCR is set, branch to Notch_CT4_T8:
005C1D 7F5C1D 81 78                       cmpa    #$78            ; Compare with decimal 120 (CT4/T9)
005C1F 7F5C1F 18 27 07 7C                 beq     Notch_CT4_T9    ; If the Z bit of CCR is set, branch to Notch_CT4_T9:
005C23 7F5C23 81 77                       cmpa    #$77            ; Compare with decimal 119 (CT4/T10)
005C25 7F5C25 18 27 0A B9                 beq     Notch_CT4_T10   ; If the Z bit of CCR is set, branch to Notch_CT4_T10:
005C29 7F5C29 81 7E                       cmpa    #$7E            ; Compare with decimal 126 (CT4/T1)
005C2B 7F5C2B 18 27 0A C3                 beq     Notch_CT4_T1    ; If the Z bit of CCR is set, branch to Notch_CT4_T1:
005C2F 7F5C2F 81 76                       cmpa    #$76            ; Compare with decimal 118 (CT4/T2)
005C31 7F5C31 18 27 0A CD                 beq     Notch_CT4_T2    ; If the Z bit of CCR is set, branch to Notch_CT4_T2:
005C35 7F5C35 81 75                       cmpa    #$75            ; Compare with decimal 117 (CT4/T3)
005C37 7F5C37 18 27 0B 01                 beq     Notch_CT4_T3    ; If the Z bit of CCR is set, branch to Notch_CT4_T3:
005C3B 7F5C3B 81 74                       cmpa    #$74            ; Compare with decimal 116 (CT4/T4)
005C3D 7F5C3D 18 27 0E 3E                 beq     Notch_CT4_T4    ; If the Z bit of CCR is set, branch to Notch_CT4_T4:
005C41 7F5C41 81 7C                       cmpa    #$7C            ; Compare with decimal 124 (CT1/T5)
005C43 7F5C43 18 27 0E 48                 beq     Notch_CT1_T5    ; If the Z bit of CCR is set, branch to Notch_CT1_T5:
005C47 7F5C47 81 68                       cmpa    #$68            ; Compare with decimal 104 (CT1/T6)
005C49 7F5C49 18 27 0E 52                 beq     Notch_CT1_T6    ; If the Z bit of CCR is set, branch to Notch_CT1_T6:
005C4D 7F5C4D 81 69                       cmpa    #$69            ; Compare with decimal 105 (CT1/T7)
005C4F 7F5C4F 18 27 0E 86                 beq     Notch_CT1_T7    ; If the Z bit of CCR is set, branch to Notch_CT1_T7:
005C53 7F5C53 81 6A                       cmpa    #$6A            ; Compare with decimal 106 (CT1/T8)
005C55 7F5C55 18 27 11 C3                 beq     Notch_CT1_T8    ; If the Z bit of CCR is set, branch to Notch_CT1_T8:
005C59 7F5C59 81 6B                       cmpa    #$6B            ; Compare with decimal 107 (CT1/T9)
005C5B 7F5C5B 18 27 11 CD                 beq     Notch_CT1_T9    ; If the Z bit of CCR is set, branch to Notch_CT1_T9:
005C5F 7F5C5F 81 6C                       cmpa    #$6C            ; Compare with decimal 108 (CT1/T10)
005C61 7F5C61 18 27 11 D7                 beq     Notch_CT1_T10   ; If the Z bit of CCR is set, branch to Notch_CT1_T10:
005C65 7F5C65                         Notch_CT3_T1:
                                      ;*****************************************************************************************
                                      ; - This is one of 4 Synchronization points but no event happens
                                      ;*****************************************************************************************
005C65 7F5C65 MACRO                       ST_LU             ; Macro in igncalcs_BPEM.s
                                      ;***************************************************************************************** (ST_LU)
                                      ; For a 2.56uS timer 1 Sec = 1/.00000256 = 390625 tics                           (ST_LU)
                                      ; 1mS = 390625 / 1000 = 390.625 tics                                             (ST_LU)
                                      ; 0.1mS = 390.625 / 10 = 39.0625 tics                                            (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; 1 RPM/60 = .016666666 Rev per Sec                                              (ST_LU)
                                      ; 1/.016666666 = 60 sec period                                                   (ST_LU)
                                      ; 60/360 = .166666666 sec per degree at 1 RPM                                    (ST_LU)
                                      ; 60/5 = 12 sec Crank Angle Sensor period at 1 RPM                               (ST_LU)
                                      ; 12/.00000256 = 4687500 2.56uS tics at 1 RPM ("CASprdtk")                       (ST_LU)
                                      ; 4687500/72 = 65104.16667 2.56uS tics per degree at 1 RPM ("TkspDeg")           (ST_LU)
                                      ; .166666666/.00000256 = 65104.14063 2.56uS tics per degree at 1 RPM ("TkspDeg") (ST_LU)
                                      ; 1/65104.16667 = .000001528808485 degrees per tic at 1 RPM                      (ST_LU)
                                      ; 71.52666514/60 = 1.192111 Rev per Sec                                          (ST_LU)
                                      ; 1/1.192111 = .83884806 sec period                                              (ST_LU)
                                      ; .83884806/360 = .0023301335 sec per degree at 71.52666 RPM                     (ST_LU)
                                      ; .83884806/5 = .167769612 sec Crank Angle Sensor period at 71.52666 RPM         (ST_LU)
                                      ; .167769612/.00000256 = 65535 2.56uS tics at 71.52666 RPM ("CASprdtk")          (ST_LU)
                                      ; 65535/72 = 910.208333 2.56uS tics per degree at 71.52666 RPM ("TkspDeg")       (ST_LU)
                                      ; .0023301335/.00000256 = 910.2083984 2.56uS tics per degree at 71.52666 RPM ("TkspDeg") (ST_LU)
                                      ; 1/910.208333 = .001098649577 degrees per tic at 71.52666 RPM                   (ST_LU)
                                      ; 500 RPM/60 = 8.333333333 Rev per Sec                                           (ST_LU)
                                      ; 1/8.333333333 = .12 sec period                                                 (ST_LU)
                                      ; .12/360 = .0003333333 sec per degree at 500 RPM                                (ST_LU)
                                      ; .12/5 = .024 sec Crank Angle Sensor period at 500 RPM                          (ST_LU)
                                      ; .024/.00000256 = 9375 2.56uS tics at 500 RPM ("CASprdtk")                      (ST_LU)
                                      ; 9375/72 = 130.2083333 2.56uS tics per degree at 500 RPM ("TkspDeg")            (ST_LU)
                                      ; .0003333333/.00000256 = 130.2083203 2.56uS tics per degree at 500 RPM ("TkspDeg") (ST_LU)
                                      ; 1/130.2083333 = .00768 degrees per tic at 500 RPM                              (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; 4250 RPM/60 = 70.8333333 Rev per Sec                                           (ST_LU)
                                      ; 1/70.8333333 = .014117647 sec period                                           (ST_LU)
                                      ; .014117647/360 = .00003921568629 sec per degree at 4250 RPM                    (ST_LU)
                                      ; .014117647/5 = .0028235294 sec Crank Angle Sensor period at 5000 RPM           (ST_LU)
                                      ; .0028235294/.00000256 = 1102.941172 2.56uS tics at 5000 RPM ("CASprdtk")       (ST_LU)
                                      ; 1102.941172/72 = 15.31862739 2.56uS tics per degree at 4250 RPM ("TkspDeg")    (ST_LU)
                                      ; .00003921568629/.00000256 = 15.31862746 2.56uS tics per degree at 4250 RPM ("TkspDeg") (ST_LU)
                                      ; 1/15.31862739 = .06528 degrees per tic at 4250 RPM                             (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; Ignition crank notches are placed 150 degrees BTDC for their respective cylinder (ST_LU)
                                      ; Dwell times of .006sec crank and .004sec run seem to work well                 (ST_LU)
                                      ; Maximum ignition advance expected is 35 degrees BTDC at low load and high RPM  (ST_LU)
                                      ; From data logs cranking RPM is between ~154RPM and ~241RPM                     (ST_LU)
                                      ; Just before stall is ~251RPM                                                   (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; At 4250 RPM a 4mSec dwell time takes .004/.00003921568629 = 102 degrees of rotation (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; At power up the timers are initialized with a 5.12uS time base. A "Spantk"     (ST_LU)
                                      ; value of 65535 will happen at 84.441 RPM so this is the lowest RPM that can be (ST_LU)
                                      ; calculated during crank conditions. Resolution at 4250 RPM is 7.706 RPM. If the (ST_LU)
                                      ; time base were 2.56uS a "Spantk" value of 65535 will happen at 168.882 RPM.    (ST_LU)
                                      ; Resolution at 4250 RPM is 3.856 RPM. Cranking RPM can be lower than 168 RPM    (ST_LU)
                                      ; so this is why we begin with the 5.12uS base. When RPM reaches ~300 we are almost (ST_LU)
                                      ; ceratinly running so at that point the time base is switched to 2.56uS. This base (ST_LU)
                                      ; will allow ignition calculations to be done as low as ~169 RPM which is probably lower (ST_LU)
                                      ; than the speed at which the engine can be made to run.                         (ST_LU)
                                      ; With a time base of 5.12uS "CASprd512" of 7812 happens at 300 RPM. When the period gets (ST_LU)
                                      ; shorter than this the time base is switched over to 2.56uS ("CASprd256").      (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; - Ignition timing in degrees to 0.1 degree resolution is selected from the 3D  (ST_LU)
                                      ;   lookup table "ST" which plots manifold pressure against RPM. A potentiometer on the (ST_LU)
                                      ;   dash board allows a manual trim of the "ST" values of from 0 to 20 degrees advance (ST_LU)
                                      ;   and from 0 to 20 degrees retard. The ignition system is what is called "waste spark", (ST_LU)
                                      ;   which pairs cylinders on a single coil. The spark is delivered to both cylinders at (ST_LU)
                                      ;   the same time. One cylinder recieves the spark at the appropriate time for ignition. (ST_LU)
                                      ;   The other recieves it when the exhaust valve is open. Hence the name "waste spark". (ST_LU)
                                      ;   On this 10 cylinder engine there are 5 coils, each controlled by its own hardware (ST_LU)
                                      ;   timer. The cylinders are paired 1&6, 10&5, 9&8, 4&7, 3&2                     (ST_LU)
                                      ;   In an ignition event the timer is first loaded with the output compare value in (ST_LU)
                                      ;   "Delaytk". At the compare interrupt the coil is energised and the timer is loaded (ST_LU)
                                      ;   with the output compare value in "DwllFintk". At the compare interrupt the coil is (ST_LU)
                                      ;   de-energized to fire the spark. The delay in timer ticks will depend on the timer base (ST_LU)
                                      ;   rate of either 5.12 uS for cranking or 2.56uS for running.                   (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;  Crank Signal                                                                  (ST_LU)
                                      ;   150BTDC                          Ign                    20ATDC               (ST_LU)
                                      ;      <- Delay          -><- Dwell -><-      ST + Trim     ->                   (ST_LU)
                                      ;     I___________________I__________ I_______________________I                  (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;                          <-            Advance            ->                   (ST_LU)
                                      ;      <-            Ignition Span (170 degrees)            ->                   (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ; - Look up current value in ST table (STcurr) (degrees*10)                      (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
005C65 7F5C65 FE 10 78                    ldx   Mapx10     ; Load index register X with value in "Mapx10"(Column value Manifold (ST_LU)
                                                           ; Absolute Pressure*10 )                                    (ST_LU)
005C68 7F5C68 FC 10 A0                    ldd   RPM        ; Load double accumulator D with value in "RPM" (Row value RPM) (ST_LU)
005C6B 7F5C6B 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                   (ST_LU)
005C70 7F5C70 CD 08 00                    ldy   #stBins_E  ; Load index register Y with address of the first value in ST table (ST_LU)
005C73 7F5C73 16 6E 77                    jsr   3D_LOOKUP  ; Jump to subroutine at 3D_LOOKUP:                          (ST_LU)
005C76 7F5C76 7C 10 D2                    std   STcurr     ; Copy result to "STcurr"                                   (ST_LU)
005C79 7F5C79 MACRO                       DWELL_COR_LU      ; Macro in igncalcs_BPEM.s
                                      ;***************************************************************************************** (DWELL_COR_LU)
                                      ; - Look up current value in Dwell Battery Adjustment Table (dwellcor)(% x 10)   (DWELL_COR_LU)
                                      ;***************************************************************************************** (DWELL_COR_LU)
005C79 7F5C79 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (DWELL_COR_LU)
005C7E 7F5C7E 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (DWELL_COR_LU)
                                                                  ;  ->page where the desired curve resides            (DWELL_COR_LU)
005C84 7F5C84 18 03 01 7A 10 27           movw #$017A,CrvRowOfst  ; 378 -> Offset from the curve page to the curve row(dwellvolts) (DWELL_COR_LU)
                                                                      ;(actual offset is 756                           (DWELL_COR_LU)
005C8A 7F5C8A 18 03 01 80 10 29           movw #$0180,CrvColOfst  ; 384 -> Offset from the curve page to the curve column(dwellcorr) (DWELL_COR_LU)
                                                                      ;(actual offset is 768)                          (DWELL_COR_LU)
005C90 7F5C90 18 04 10 68 10 2B           movw BatVx10,CrvCmpVal  ; Battery Voltage (Volts x 10) -> Curve comparison value (DWELL_COR_LU)
005C96 7F5C96 18 0B 05 10 2D              movb #$05,CrvBinCnt     ; 5 -> number of bins in the curve row or column minus 1 (DWELL_COR_LU)
005C9B 7F5C9B 16 6F 46                    jsr   CRV_LU_P   ; Jump to subroutine at CRV_LU_P:(located in interp_BEEM488.s module) (DWELL_COR_LU)
005C9E 7F5C9E 7C 10 D6                    std   DwellCor   ; Copy result to Dwell battery correction (% x 10)          (DWELL_COR_LU)
005CA1 7F5CA1 MACRO                       VE_LU             ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (VE_LU)
                                      ; The base value for injector pulse width calculations in mS to 0.1mS resolution is called (VE_LU)
                                      ; "ReqFuel". It represents the pulse width reqired to achieve 14.7:1 Air/Fuel Ratio at (VE_LU)
                                      ; 100% volumetric efficiency. The VE table contains percentage values to 0.1 percent (VE_LU)
                                      ; resolultion and plots intake manifold pressure in KPA to 0.1KPA resolution against RPM. (VE_LU)
                                      ; These values are part of the injector pulse width calculations for a running engine. (VE_LU)
                                      ;***************************************************************************************** (VE_LU)
                                      ;***************************************************************************************** (VE_LU)
                                      ; - Look up current value in VE table (veCurr)(%x10)                             (VE_LU)
                                      ;***************************************************************************************** (VE_LU)
005CA1 7F5CA1 FE 10 78                    ldx   Mapx10     ; Load index register X with value in "Mapx10"(Column value Manifold (VE_LU)
                                                           ; Absolute Pressure x 10 )                                  (VE_LU)
005CA4 7F5CA4 FC 10 A0                    ldd   RPM        ; Load double accumulator D with value in "RPM" (Row value RPM) (VE_LU)
005CA7 7F5CA7 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (VE_LU)
005CAC 7F5CAC CD 08 00                    ldy   #veBins_E    ; Load index register Y with address of the first value in VE table (VE_LU)
                                                           ;(in RAM)                                                   (VE_LU)
005CAF 7F5CAF 16 6E 77                    jsr   3D_LOOKUP  ; Jump to subroutine at 3D_LOOKUP:                          (VE_LU)
005CB2 7F5CB2 7C 10 A8                    std   VEcurr     ; Copy result to "VEcurr"(%x10)                             (VE_LU)
005CB5 7F5CB5 MACRO                       AFR_LU            ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (AFR_LU)
                                      ; The Air/Fuel Ratio of the fuel mixture affects how an engine will run. Generally (AFR_LU)
                                      ; speaking AFRs of less than ~7:1 are too rich to ignite. Ratios of greater than ~20:1 are (AFR_LU)
                                      ; too lean to ignite. Stoichiometric ratio is at ~14.7:1. This is the ratio at which all (AFR_LU)
                                      ; the fuel and all the oxygen are consumed and is best for emmisions concerns. Best power (AFR_LU)
                                      ; is obtained between ratios of ~12:1 and ~13:1. Best economy is obtained as lean as ~18:1 (AFR_LU)
                                      ; in some engines. This controller runs in open loop so the AFR numbers are used as (AFR_LU)
                                      ; a tuning aid only.                                                             (AFR_LU)
                                      ;***************************************************************************************** (AFR_LU)
                                      ;***************************************************************************************** (AFR_LU)
                                      ; - Look up current value in AFR table (afrCurr)(AFRx10)                         (AFR_LU)
                                      ;***************************************************************************************** (AFR_LU)
005CB5 7F5CB5 FE 10 78                    ldx   Mapx10     ; Load index register X with value in "Mapx10"(Column value Manifold (AFR_LU)
                                                           ; Absolute Pressure x 10 )                                  (AFR_LU)
005CB8 7F5CB8 FC 10 A0                    ldd   RPM        ; Load double accumulator D with value in "RPM" (Row value RPM) (AFR_LU)
005CBB 7F5CBB 18 0B FD 00 17              movb  #(BUF_RAM_P3_START>>16),EPAGE  ; Move $FD into EPAGE                   (AFR_LU)
005CC0 7F5CC0 CD 08 00                    ldy   #afrBins_E   ; Load index register Y with address of the first value in AFR table (AFR_LU)
                                                           ;(in RAM)                                                   (AFR_LU)
005CC3 7F5CC3 16 6E 77                    jsr   3D_LOOKUP  ; Jump to subroutine at 3D_LOOKUP:                          (AFR_LU)
005CC6 7F5CC6 7C 10 A6                    std   AFRcurr    ; Copy result to "AFRcurr"                                  (AFR_LU)
005CC9 7F5CC9 MACRO                       TOE_OFC_CALCS     ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - When the engine is running and the throttle is opened quickly a richer mixture is (TOE_OFC_CALCS)
                                      ;   required for a short period of time. This additional pulse width time is called (TOE_OFC_CALCS)
                                      ;   Throttle Opening Enrichment. Conversly, when the engine is in over run       (TOE_OFC_CALCS)
                                      ;   conditions no fuel is required so the injectors can be turned off, subject to (TOE_OFC_CALCS)
                                      ;   permissives. This condtion is call Overrun Fuel Cut.                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check to see if the throttle is opening or if it is at steady state or closing (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
005CC9 7F5CC9                         TOE_OFC_CHK:                                                                     (TOE_OFC_CALCS)
005CC9 7F5CC9 FE 10 7C                    ldx   TpsPctx10       ; Load index register X with value in "TpsPctx10"      (TOE_OFC_CALCS)
005CCC 7F5CCC BE 10 45                    cpx   TpsPctx10last   ; (X)-(M:M+1)Compare with value in "TpsPctx10last"     (TOE_OFC_CALCS)
005CCF 7F5CCF 18 23 01 84                 bls   OFC_CHK         ; If "TpsPctx10" is equal to or less than "TpsPctx10last" branch to (TOE_OFC_CALCS)
                                                                    ; OFC_CHK:(Throttle is steady or closing so check for OFC permissives) (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Current Throttle position percent - throttle position percent 100mS ago = throttle position (TOE_OFC_CALCS)
                                      ;   percent difference over time in seconds "TpsPctx10" - "TpsPctx10last" = "TpsPctDOT" (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
005CD3 7F5CD3 18 B0 10 45                 subx  TpsPctx10last   ; (X)-(M:M-1)=>X Subtract "TpsPctx10last" from "TpsPctx10" (TOE_OFC_CALCS)
005CD7 7F5CD7 7E 10 B6                    stx   TpsPctDOT       ; Copy result to "TpsPctDOT"                           (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - The throttle is opening. Check to see if it is opening at a rate greater than the threshold (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
005CDA 7F5CDA 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
005CDF 7F5CDF CD 08 00                    ldy   #veBins_E       ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                                ; on buffer RAM page 1 (veBins_E)                      (TOE_OFC_CALCS)
005CE2 7F5CE2 EE EA 03 D0                 ldx   $03D0,Y         ; Load Accu D with value in buffer RAM page 1 offset 976 (tpsThresh) (TOE_OFC_CALCS)
                                                                ;(TPSdot threshold)(offset = 976)($03D0)               (TOE_OFC_CALCS)
005CE6 7F5CE6 BE 10 B6                    cpx   TpsPctDOT       ; Compare "tpsThresh" with "TpsPctDOT"                 (TOE_OFC_CALCS)
005CE9 7F5CE9 18 22 01 3D                 bhi   TOE_CHK_TIME    ; If "tpsThresh" is greater than "TpsPctDOT", branch to TOE_CHK_TIME: (TOE_OFC_CALCS)
                                                                ; ("TpsPctDOT" below threshold so check if acceleration is done) (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - The throttle is opening at a rate greater then the threshold. Check to see if TOE is in (TOE_OFC_CALCS)
                                      ;   progress.                                                                    (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
005CED 7F5CED 1E 10 E1 20 2D              brset engine,TOEon,TOE_CALC ; If "TOEon" bit of "engine" bit field           (TOE_OFC_CALCS)
                                                                ; is set, branch to TOE_CALC: (TOE in progress)        (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ;- The throttle is opening at a rate greater than the threshold and TOE is not in progress (TOE_OFC_CALCS)
                                      ;  so prepare to add in the enrichement.                                         (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
005CF2 7F5CF2 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
005CF7 7F5CF7 CD 08 00                    ldy   #veBins_E       ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                              ; on buffer RAM page 1 (veBins_E)                        (TOE_OFC_CALCS)
005CFA 7F5CFA EC EA 03 BC                 ldd  $03BC,Y        ; Load Accu D with value in buffer RAM page 1 (offset 956) (First element (TOE_OFC_CALCS)
                                                              ; of "TOEbins" table)(Start with first element, will determine actual (TOE_OFC_CALCS)
                                                              ; next time around)                                      (TOE_OFC_CALCS)
005CFE 7F5CFE 7B 10 BB                    stab   TOEpct       ; Copy to Throttle Opening Enrichment percent(used in later calculations) (TOE_OFC_CALCS)
005D01 7F5D01 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
005D06 7F5D06 CD 08 00                    ldy   #veBins_E     ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                              ; on buffer RAM page 1 (veBins_E)                        (TOE_OFC_CALCS)
005D09 7F5D09 EC EA 03 D2                 ldd   $03D2,Y       ; Load Accu D with value in buffer RAM page 1 offset 978 (TOEtime_F) (TOE_OFC_CALCS)
005D0D 7F5D0D 7B 10 CF                    stab  TOEdurCnt     ; Copy to "TOEdurCnt" (Throttle Opening Enrichment duration (TOE_OFC_CALCS)
                                                                  ; (decremented every 100 mS))                        (TOE_OFC_CALCS)
005D10 7F5D10 1C 10 E1 20                 bset  engine,TOEon  ; Set "TOEon" bit of "engine" variable (in TOE mode)     (TOE_OFC_CALCS)
005D14 7F5D14 1C 10 E2 08                 bset  engine2,TOEduron  ; Set "TOEduron" bit of "engine2" variable (TOE duration) (TOE_OFC_CALCS)
005D18 7F5D18 1D 10 E1 40                 bclr  engine,OFCon  ; Clear "OFCon" bit of "engine" variable (not in OFC mode) (TOE_OFC_CALCS)
005D1C 7F5D1C 06 5E 99                    job   OFC_LOOP      ; Jump or branch to OFC_LOOP:(fall through)              (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Calculate the cold temperature add-on enrichment "ColdAddpct" (%) from -39.72 (TOE_OFC_CALCS)
                                      ;   degrees to 179.9 degrees.                                                    (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
005D1F 7F5D1F                         TOE_CALC:                                                                        (TOE_OFC_CALCS)
005D1F 7F5D1F FC 10 6A                    ldd  cltAdc       ; "cltAdc" -> D                                            (TOE_OFC_CALCS)
005D22 7F5D22 8C 00 93                    cpd  #$0093       ; Compare "cltADC" with decimal 147(ADC @ 179.9F)          (TOE_OFC_CALCS)
005D25 7F5D25 23 02                       bls  RailColdAdd  ; If "cltADC" is lower or the same as 147, branch to RailColdAdd: (TOE_OFC_CALCS)
005D27 7F5D27 20 05                       bra  DoColdAdd    ; Branch to DoColdAdd:                                     (TOE_OFC_CALCS)
005D29 7F5D29                         RailColdAdd:                                                                     (TOE_OFC_CALCS)
005D29 7F5D29 79 10 B9                    clr   ColdAddpct   ; Clear "ColdAddpct" (no cold adder)                      (TOE_OFC_CALCS)
005D2C 7F5D2C 20 3C                       bra   ColdAddDone  ; Branch to ColdAddDone: (skip over)                      (TOE_OFC_CALCS)
005D2E 7F5D2E                         DoColdAdd:                                                                       (TOE_OFC_CALCS)
005D2E 7F5D2E CC 00 93                    ldd  #$0093      ; Load double accumulator with decimal 147 (ADC @ 179.9F)   (TOE_OFC_CALCS)
005D31 7F5D31 3B                          pshd             ; Push to stack (V1)                                        (TOE_OFC_CALCS)
005D32 7F5D32 FC 10 6A                    ldd  cltAdc      ; Load double accumulator with "cltAdc"                     (TOE_OFC_CALCS)
005D35 7F5D35 3B                          pshd             ; Push to stack (V)                                         (TOE_OFC_CALCS)
005D36 7F5D36 CC 03 EB                    ldd  #$03EB      ; Load double accumulator with decimal 1003 (ADC @ -39.72F) (TOE_OFC_CALCS)
005D39 7F5D39 3B                          pshd             ; Push to stack (V2)                                        (TOE_OFC_CALCS)
005D3A 7F5D3A CC 00 00                    ldd  #$0000      ; Load double accumulator with decimal 0 (added amount at 179.9F) (TOE_OFC_CALCS)
005D3D 7F5D3D 3B                          pshd             ; Push to stack (Z1)                                        (TOE_OFC_CALCS)
005D3E 7F5D3E 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
005D43 7F5D43 CD 08 00                    ldy   #veBins_E    ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                           ; on buffer RAM page 1 (veBins_E)                           (TOE_OFC_CALCS)
005D46 7F5D46 EC EA 03 D4                 ldd   $03D4,Y    ; Load Accu D with value in buffer RAM page 1 (ColdAdd_F)(offset 980) (TOE_OFC_CALCS)
                                                           ;(added amount at -39.72F)                                  (TOE_OFC_CALCS)
005D4A 7F5D4A 3B                          pshd             ; Push to stack (Z2)                                        (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z2       |  SP+ 0                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z1       |  SP+ 2                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V2       |  SP+ 4                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V        |  SP+ 6                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V1       |  SP+ 8                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                      ;                     V      V1      V2      Z1    Z2                            (TOE_OFC_CALCS)
005D4B 7F5D4B MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; ==========================                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ; result: D: interpolated result                                                 (TOE_OFC_CALCS/2D_IPOL)
                                      ; SSTACK: none                                                                   (TOE_OFC_CALCS/2D_IPOL)
                                      ;         no registers are preserved                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    ^ V                                                                         (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                                                                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z2+....................*                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                    :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   :       :        :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
005D4B 7F5D4B EC 86                                   LDD       \1    ; load V                                         (TOE_OFC_CALCS/2D_IPOL)
005D4D 7F5D4D A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
005D4F 7F5D4F B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
005D51 7F5D51 EC 80                                   LDD       \5    ; load Z2                                        (TOE_OFC_CALCS/2D_IPOL)
005D53 7F5D53 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
005D55 7F5D55 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (TOE_OFC_CALCS/2D_IPOL)
005D57 7F5D57 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
005D59 7F5D59 EC 84                                   LDD       \3    ; load V2                                        (TOE_OFC_CALCS/2D_IPOL)
005D5B 7F5D5B A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
005D5D 7F5D5D B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (TOE_OFC_CALCS/2D_IPOL)
                                      ;*********************************************************************           (TOE_OFC_CALCS/2D_IPOL)
005D5F 7F5D5F 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (TOE_OFC_CALCS/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (TOE_OFC_CALCS/2D_IPOL)
005D61 7F5D61 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
005D63 7F5D63 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Free stack space (result in D)                                               (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
005D65 7F5D65 1B 8A                       leas  10,SP       ; Stack pointer -> bottom of stack                         (TOE_OFC_CALCS)
005D67 7F5D67 7B 10 B9                    stab  ColdAddpct  ; Copy result to "ColdAddpct" (%)(bins are byte values)    (TOE_OFC_CALCS)
005D6A 7F5D6A                         ColdAddDone:                                                                     (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Calculate the cold temperature multiplier enrichment "ColdMulpct" (%), from -39.72 degrees (TOE_OFC_CALCS)
                                      ;   to 179.9 degrees.                                                            (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
005D6A 7F5D6A FC 10 6A                    ldd  cltADC       ; "cltADC" -> D                                            (TOE_OFC_CALCS)
005D6D 7F5D6D 8C 00 93                    cpd  #$0093       ; Compare "cltADC" with decimal 147(ADC @ 179.9F)          (TOE_OFC_CALCS)
005D70 7F5D70 23 02                       bls  RailColdMul  ; If "cltADC" is lower or the same as 147, branch to RailColdMul: (TOE_OFC_CALCS)
005D72 7F5D72 20 07                       bra  DoColdMul    ; Branch to DoColdMul: (skip over)                         (TOE_OFC_CALCS)
005D74 7F5D74                         RailColdMul:                                                                     (TOE_OFC_CALCS)
005D74 7F5D74 18 0B 64 10 BA             movb #$64,ColdMulpct  ; Decimal 100 -> "ColdMulpct" (100% = no multiplier))   (TOE_OFC_CALCS)
005D79 7F5D79 20 3C                      bra   ColdMulDone     ; Branch to ColdMulDone: (skip over)                    (TOE_OFC_CALCS)
005D7B 7F5D7B                         DoColdMul:                                                                       (TOE_OFC_CALCS)
005D7B 7F5D7B CC 00 93                    ldd  #$0093      ; Load double accumulator with decimal 147 (ADC @ 179.9F)   (TOE_OFC_CALCS)
005D7E 7F5D7E 3B                          pshd             ; Push to stack (V1)                                        (TOE_OFC_CALCS)
005D7F 7F5D7F FC 10 6A                    ldd  cltAdc      ; Load double accumulator with "cltAdc"                     (TOE_OFC_CALCS)
005D82 7F5D82 3B                          pshd             ; Push to stack (V)                                         (TOE_OFC_CALCS)
005D83 7F5D83 CC 03 EB                    ldd  #$03EB      ; Load double accumulator with decimal 1003 (ADC @ -39.72F) (TOE_OFC_CALCS)
005D86 7F5D86 3B                          pshd             ; Push to stack (V2)                                        (TOE_OFC_CALCS)
005D87 7F5D87 CC 00 64                    ldd  #$0064      ; Load double accumulator with decimal 100 (multiplier amount at 179.9F) (TOE_OFC_CALCS)
                                                           ;(1.00 multiplier at 180 degrees)                           (TOE_OFC_CALCS)
005D8A 7F5D8A 3B                          pshd             ; Push to stack (Z1)                                        (TOE_OFC_CALCS)
005D8B 7F5D8B 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
005D90 7F5D90 CD 08 00                    ldy   #veBins_E    ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                           ; on buffer RAM page 1 (veBins_E)                           (TOE_OFC_CALCS)
005D93 7F5D93 EC EA 03 D6                 ldd   $03D6,Y    ; Load Accu D with value in buffer RAM page 1 "ColdMul_F"(offset 982) (TOE_OFC_CALCS)
                                                           ;(added amount at -39.72F)                                  (TOE_OFC_CALCS)
005D97 7F5D97 3B                          pshd             ; Push to stack (Z2)                                        (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z2       |  SP+ 0                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z1       |  SP+ 2                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V2       |  SP+ 4                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V        |  SP+ 6                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V1       |  SP+ 8                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                      ;                     V      V1      V2      Z1    Z2                            (TOE_OFC_CALCS)
005D98 7F5D98 MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; ==========================                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ; result: D: interpolated result                                                 (TOE_OFC_CALCS/2D_IPOL)
                                      ; SSTACK: none                                                                   (TOE_OFC_CALCS/2D_IPOL)
                                      ;         no registers are preserved                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    ^ V                                                                         (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                                                                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z2+....................*                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                    :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   :       :        :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
005D98 7F5D98 EC 86                                   LDD       \1    ; load V                                         (TOE_OFC_CALCS/2D_IPOL)
005D9A 7F5D9A A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
005D9C 7F5D9C B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
005D9E 7F5D9E EC 80                                   LDD       \5    ; load Z2                                        (TOE_OFC_CALCS/2D_IPOL)
005DA0 7F5DA0 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
005DA2 7F5DA2 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (TOE_OFC_CALCS/2D_IPOL)
005DA4 7F5DA4 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
005DA6 7F5DA6 EC 84                                   LDD       \3    ; load V2                                        (TOE_OFC_CALCS/2D_IPOL)
005DA8 7F5DA8 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
005DAA 7F5DAA B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (TOE_OFC_CALCS/2D_IPOL)
                                      ;*********************************************************************           (TOE_OFC_CALCS/2D_IPOL)
005DAC 7F5DAC 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (TOE_OFC_CALCS/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (TOE_OFC_CALCS/2D_IPOL)
005DAE 7F5DAE B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
005DB0 7F5DB0 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Free stack space (result in D)                                               (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
005DB2 7F5DB2 1B 8A                      leas  10,SP         ; Stack pointer -> bottom of stack                        (TOE_OFC_CALCS)
005DB4 7F5DB4 7B 10 BA                   stab   ColdMulpct   ; Copy result to "ColdMulpct" (%) (bins are byte values)  (TOE_OFC_CALCS)
005DB7 7F5DB7                         ColdMulDone:                                                                     (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; First determine "TpsPctDOT" ("TpsPctx10" - "TpsPctx10last") (both updated every 100mS (TOE_OFC_CALCS)
                                      ; in rti_BEEM488.s)                                                              (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
005DB7 7F5DB7 FE 10 7C                   ldx   TpsPctx10         ; "TpsPctx10" -> Accu X                               (TOE_OFC_CALCS)
005DBA 7F5DBA 18 B0 10 45                subx  TpsPctx10last     ; (X)-(M:M+1)=>X Subtract "TpsPctx10last" from "TpsPctx10" (TOE_OFC_CALCS)
005DBE 7F5DBE 7E 10 B6                   stx   TpsPctDOT         ; Copy result to "TpsPctDOT" (%/Sec)                  (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Look up current value in Throttle Opening Enrichment Table (TpsDOTcor)(%)(byte value) (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
005DC1 7F5DC1 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
005DC6 7F5DC6 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr    ; Address of the first value in VE table(in RAM)(page pointer) (TOE_OFC_CALCS)
                                                                   ; ->page where the desired curve resides            (TOE_OFC_CALCS)
005DCC 7F5DCC 18 03 01 E2 10 27           movw #$01E2,CrvRowOfst   ; 482 -> Offset from the curve page to the curve row (TOE_OFC_CALCS)
                                                                       ; (TOERates_F)(actual offset is 964)($03C4)     (TOE_OFC_CALCS)
005DD2 7F5DD2 18 03 01 DE 10 29           movw #$01DE,CrvColOfst   ; 478 -> Offset from the curve page to the curve column (TOE_OFC_CALCS)
                                                                       ; (TOEBins_F)(actual offset is 956)($03BC)      (TOE_OFC_CALCS)
005DD8 7F5DD8 18 04 10 B6 10 2B           movw TpsPctDOT,CrvCmpVal ; TPS% difference over time (%/Sec)(update every 100mSec) (TOE_OFC_CALCS)
                                                                   ; -> Curve comparison value                         (TOE_OFC_CALCS)
005DDE 7F5DDE 18 0B 03 10 2D              movb #$03,CrvBinCnt      ; 3 -> number of bins in the curve row or column minus 1 (TOE_OFC_CALCS)
005DE3 7F5DE3 16 6F 46                    jsr  CRV_LU_P            ; Jump to subroutine at CRV_LU_P:(located in interp_BEEM488.s module) (TOE_OFC_CALCS)
005DE6 7F5DE6 7B 10 B8                    stab TpsDOTcor           ; Copy result to TpsDOTcor (%)(byte value)          (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Multiply "TpsDOTcor" by "ColdMulpct" and divide by 100                       (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
005DE9 7F5DE9 B6 10 B8                    ldaa  TpsDOTcor      ; "TpsDOTcor" -> A (%)                                  (TOE_OFC_CALCS)
005DEC 7F5DEC F6 10 BA                    ldab  ColdMulpct     ; "ColdMulpct" -> B (%)                                 (TOE_OFC_CALCS)
005DEF 7F5DEF 12                          mul                  ; (A)x(B)->A:B (TpsDOTcor x ColdMulpct) result in D     (TOE_OFC_CALCS)
005DF0 7F5DF0 CE 00 64                    ldx   #$0064         ; Decimal 100 -> X                                      (TOE_OFC_CALCS)
005DF3 7F5DF3 18 10                       idiv                 ; (D)/(X)->(X)rem(D) ((TpsDOTcor x ColdMulpct)/100)(%)  (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check the remainder and round up if >=5                                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
005DF5 7F5DF5 8C 00 05                    cpd   #$0005         ; Compare idiv remainder with decimal 5                 (TOE_OFC_CALCS)
005DF8 7F5DF8 2F 05                       ble   NO_ROUND_UP    ; If remainder of idiv <= 5, branch to NO_ROUND_UP:     (TOE_OFC_CALCS)
005DFA 7F5DFA B7 50                       tfr   X,A            ; idiv result -> A                                      (TOE_OFC_CALCS)
005DFC 7F5DFC 42                          inca                 ; idiv result + 1 -> A (round up)                       (TOE_OFC_CALCS)
005DFD 7F5DFD 20 02                       bra   ADD_COLDADD    ; Branch to ADD_COLDADD:(fall through)                  (TOE_OFC_CALCS)
005DFF 7F5DFF                         NO_ROUND_UP:                                                                     (TOE_OFC_CALCS)
005DFF 7F5DFF B7 50                       tfr   X,A            ; idiv result -> A                                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Add the result with "ColdAddpct". Compare the result with the current "TOEpct" and (TOE_OFC_CALCS)
                                      ;   and save the highest value as "TOEpct". This is the final TOE value(%)       (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
005E01 7F5E01                         ADD_COLDADD:                                                                     (TOE_OFC_CALCS)
005E01 7F5E01 BB 10 B9                    adda  ColdAddpct     ; (A)+(M)->(A) (("TpsDOTcor" * ColdMulpct)/100) + "ColdAddpct") (TOE_OFC_CALCS)
005E04 7F5E04 7A 10 F9                    staa  tmp5b           ; Copy to "tmp5b"(("TpsDOTcor" * ColdMulpct)/100) + "ColdAddpct") (TOE_OFC_CALCS)
005E07 7F5E07 B1 10 BB                    cmpa  TOEpct         ; Compare result with "TOEpct"                          (TOE_OFC_CALCS)
005E0A 7F5E0A 25 1E                       blo   TOE_CHK_TIME   ; If (A) is less than (M), branch to TOE_CHK_TIME: (result (TOE_OFC_CALCS)
                                                               ; < "TOEpct" so use this value for "TOEpct" and check if (TOE_OFC_CALCS)
                                                                                       ; acceleration is done)         (TOE_OFC_CALCS)
005E0C 7F5E0C B6 10 F9                    ldaa  tmp5b          ; "tmp5b" -> A(("TpsDOTcor" * ColdMulpct)/100) + "ColdAddpct") (TOE_OFC_CALCS)
005E0F 7F5E0F 7A 10 BB                    staa  TOEpct         ; Copy result to "TOEpct"(result is higher than current (TOE_OFC_CALCS)
                                                               ; so update TOEpct with the higher value)               (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Calculate the Throttle Opening Enrichment adder for PW calculations.         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
005E12 7F5E12 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
005E17 7F5E17 CD 08 00                    ldy   #veBins_E   ; Load index register Y with address of first configurable (TOE_OFC_CALCS)
                                                            ; constant on buffer RAM page 1 (veBins_E)                 (TOE_OFC_CALCS)
005E1A 7F5E1A EC EA 03 EC                 ldd   $03EC,Y     ; Load Accu D with value in buffer RAM page 1 (offset 1004)($03EC) (TOE_OFC_CALCS)
                                                            ; ("reqFuel" in Accu B)                                    (TOE_OFC_CALCS)
005E1E 7F5E1E B6 10 BB                    ldaa  TOEpct      ; "TOEpct" -> Accu D (%)                                   (TOE_OFC_CALCS)
005E21 7F5E21 12                          mul               ;(A)x(B)->A:B (reqFuel" x "TOEpct")                        (TOE_OFC_CALCS)
005E22 7F5E22 CE 00 64                        ldx  #$0064       ; Decimal 100 -> Accu X                                (TOE_OFC_CALCS)
005E25 7F5E25 18 10                       idiv              ;(D)/(X)->X:rem->D (reqFuel" x "TOEpct")/10                (TOE_OFC_CALCS)
005E27 7F5E27 7E 10 BC                    stx  TOEpw        ; Result -> "TOEpw" TOE adder (mS x 10)                    (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check to see if Throttle Opening Enrichment is done.                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
005E2A 7F5E2A                          TOE_CHK_TIME:                                                                   (TOE_OFC_CALCS)
005E2A 7F5E2A 1E 10 E1 40 07              brset  engine,OFCon,RESET_TOE ; If Overrun Fuel Cut bit of "Engine" bit field is set, (TOE_OFC_CALCS)
                                                                        ; branch to RESET_TOE:                         (TOE_OFC_CALCS)
005E2F 7F5E2F B6 10 CF                     ldaa  TOEdurCnt    ; "TOEdurCnt" -> Accu A                                  (TOE_OFC_CALCS)
005E32 7F5E32 27 02                            beq   RESET_TOE    ; If "TOEdurCnt" = zero branch to RESET_TOE:(timer has timed out) (TOE_OFC_CALCS)
005E34 7F5E34 20 1F                            bra   TOE_LOOP     ; Branch to "TOE_LOOP:(Timer hasn't timed out yet)   (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - The throttle is no longer opening and the duration timer has timed out so clear (TOE_OFC_CALCS)
                                      ;    "TOEpct" and the "TOEon" bit of "engine" bit field.                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
005E36 7F5E36                         RESET_TOE:                                                                       (TOE_OFC_CALCS)
005E36 7F5E36 1D 10 E1 20                 bclr  engine,TOEon      ; Clear "TOEon" bit of "engine" bit field            (TOE_OFC_CALCS)
005E3A 7F5E3A 1D 10 E2 08                 bclr  engine2,TOEduron  ; Clear "TOEduron" bit of "engine2" variable (TOE duration) (TOE_OFC_CALCS)
005E3E 7F5E3E 79 10 BB                    clr   TOEpct            ; Clear Throttle Opening Enrichment (%)              (TOE_OFC_CALCS)
005E41 7F5E41 79 10 B9                    clr   ColdAddpct        ; Clear Throttle Opening Enrichment cold adder (%)   (TOE_OFC_CALCS)
005E44 7F5E44 79 10 BA                    clr   ColdMulpct        ; Clear Throttle Opening Enrichment cold multiplier (%) (TOE_OFC_CALCS)
005E47 7F5E47 79 10 B8                    clr   TpsDOTcor         ; Clear Throttle Opening Enrichment table value(%)   (TOE_OFC_CALCS)
005E4A 7F5E4A 79 10 CF                    clr   TOEdurCnt         ; Clear Throttle Opening Enrichment duration counter (TOE_OFC_CALCS)
005E4D 7F5E4D 18 79 10 BC                 clrw  TOEpw             ; Clear Throttle Opening Enrichment adder (mS x 100) (TOE_OFC_CALCS)
005E51 7F5E51 18 79 10 BE                 clrw  PWlessTOE         ; Clear Injector pulse width before "TOEpw" and "Deadband" (mS x 10) (TOE_OFC_CALCS)
005E55 7F5E55                         TOE_LOOP:                                                                        (TOE_OFC_CALCS)
005E55 7F5E55 20 42                       job  OFC_LOOP       ; Jump or branch to OFC_LOOP:(Finished with TOE, not in OFC so (TOE_OFC_CALCS)
                                                                  ; fall through)                                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Overrun Fuel Cut mode 2/07/21 Note change in rti_BPEM488.s                   (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;                                                                                (TOE_OFC_CALCS)
                                      ; - Engine overrun occurs when the the vehicle is in motion, the throttle is closed and (TOE_OFC_CALCS)
                                      ;   the engine is turning faster than the driver wants it to be, either because of vehicle (TOE_OFC_CALCS)
                                      ;   inertia or by being on a negative grade. Under these conditions there will be a slight (TOE_OFC_CALCS)
                                      ;   increase in engine braking and some fuel can be saved if the fuel injectors are not (TOE_OFC_CALCS)
                                      ;   pulsed. OFC is only enabled manually by pulsing up on the dash mounted SPDT spring (TOE_OFC_CALCS)
                                      ;   return to centre toggle switch. In order to enter OFC mode several permissive (TOE_OFC_CALCS)
                                      ;   conditions must be met first. The throttle opening must be equal to or less than the (TOE_OFC_CALCS)
                                      ;   minimum permitted opening and the engine RPM must be equal to or more than the minimum (TOE_OFC_CALCS)
                                      ;   permitted RPM. OFC can be disabled manually by the driver at any time by pulsing (TOE_OFC_CALCS)
                                      ;   down on the dash mounted toggle switch. It will be disabled automatically if either (TOE_OFC_CALCS)
                                      ;   or both of the permissive conditions are no longer met                       (TOE_OFC_CALCS)
                                      ;                                                                                (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check to see if we have permissives for Overrun Fuel Cut at steady state or closing (TOE_OFC_CALCS)
                                      ;   throttle.                                                                    (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
005E57 7F5E57                         OFC_CHK:                                                                         (TOE_OFC_CALCS)
005E57 7F5E57 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
005E5C 7F5E5C CD 08 00                    ldy   #veBins_E     ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                            ; on buffer RAM page 1 (veBins_E)                          (TOE_OFC_CALCS)
005E5F 7F5E5F EE EA 03 DA                 ldx   $03DA,Y     ; Load X with value in buffer RAM page 1 offset 986 (OFCtps) (TOE_OFC_CALCS)
                                                            ;(Overrun Fuel Cut min TPS%)                               (TOE_OFC_CALCS)
005E63 7F5E63 BE 10 7C                    cpx  TpsPctx10    ; Compare it with value in "TpsPctx10"                     (TOE_OFC_CALCS)
005E66 7F5E66 25 2D                       blo  OFC_CHK_DONE ; If (X)>(M), branch to OFC_CHK_DONE:                      (TOE_OFC_CALCS)
                                                            ;(TPS is above minimum so no fuel cut)                     (TOE_OFC_CALCS)
005E68 7F5E68 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
005E6D 7F5E6D CD 08 00                    ldy   #veBins_E     ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                            ; on buffer RAM page 1 (veBins_E)                          (TOE_OFC_CALCS)
005E70 7F5E70 EE EA 03 DC                 ldx   $03DC,Y     ; Load X with value in buffer RAM page 1 offset 988 (OFCrpm) (TOE_OFC_CALCS)
                                                            ;(Overrun Fuel Cut min RPM)                                (TOE_OFC_CALCS)
005E74 7F5E74 BE 10 A0                    cpx  RPM          ; Compare it value in RPM                                  (TOE_OFC_CALCS)
005E77 7F5E77 22 1C                       bhi  OFC_CHK_DONE ; If (X)<(M), branch to OFC_CHK_DONE:                      (TOE_OFC_CALCS)
                                                            ;(RPM is below minimum so no fuel cut                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - We have permissives for Overrun Fuel Cut. Check to see if OFC is already on and being (TOE_OFC_CALCS)
                                      ;   being commanded off.                                                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
005E79 7F5E79 1F 10 E1 40 07                  brclr  engine,OFCon,OFC_EN_CHK ; If "OFCon" bit of "engine" bit field is clear, branch (TOE_OFC_CALCS)
                                                                             ; to OFC_EN_CHK: (OFC is off, check to see if it is (TOE_OFC_CALCS)
                                                                                                         ; being commanded on (TOE_OFC_CALCS)
005E7E 7F5E7E 1F 10 DC 20 12              brclr PortAbits,OFCdis,OFC_CHK_DONE ; If "OFCdis" bit of "PortAbits" is clear (Low), (TOE_OFC_CALCS)
                                                                ; branch to OFC_CHK_DONE: (OFC is on and OFC disable switch is on, (TOE_OFC_CALCS)
                                                                                ; so disable fuel cut)                 (TOE_OFC_CALCS)
005E83 7F5E83 20 14                           bra  OFC_LOOP     ; branch to OFC_LOOP:(OFC is on, permissives are met and not being (TOE_OFC_CALCS)
                                                                ; commanded off, keep looping until permissives are no longer met (TOE_OFC_CALCS)
                                                                                ; or OFC has been commanded off)       (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - We have permissives for Overrun Fuel Cut and it is not being commanded off. Check to (TOE_OFC_CALCS)
                                      ;   see if OFC is off and being commanded on.                                    (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
005E85 7F5E85                         OFC_EN_CHK:                                                                      (TOE_OFC_CALCS)
005E85 7F5E85 1E 10 E1 40 0F                  brset  engine,OFCon,OFC_LOOP   ; If "OFCon" bit of "engine" bit field is set, branch (TOE_OFC_CALCS)
                                                                             ; to OFC_LOOP: (OFC is already on so skip over) (TOE_OFC_CALCS)
005E8A 7F5E8A 1E 10 DC 10 0A              brset PortAbits,OFCen,OFC_LOOP ; "If OFCen" bit of "PortAbits" is set (High), branch to (TOE_OFC_CALCS)
                                                                             ; OFC_LOOP: (OFC enable switch is off so skip over) (TOE_OFC_CALCS)
005E8F 7F5E8F 1C 10 E1 40                     bset engine,OFCon              ; Set "OFCon" bit of "engine" bit field (This bit will be tested (TOE_OFC_CALCS)
                                                                             ; in the final pulse width calculations, if set the pulse width (TOE_OFC_CALCS)
                                                                                             ; will be set to zero     (TOE_OFC_CALCS)
005E93 7F5E93 20 04                           bra  OFC_LOOP                  ; branch to OFC_LOOP:(keep looping until permissives are no (TOE_OFC_CALCS)
                                                                             ; longer met or OFC has been commanded off) (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Permissives have not or are no longer are being met or OFC has been commanded off. (TOE_OFC_CALCS)
                                      ;   Clear the flag.                                                              (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
005E95 7F5E95                         OFC_CHK_DONE:                                                                    (TOE_OFC_CALCS)
005E95 7F5E95 1D 10 E1 40                     bclr engine,OFCon     ; Clear "OFCon" bit of "engine" bit field          (TOE_OFC_CALCS)
005E99 7F5E99                         OFC_LOOP:                                                                        (TOE_OFC_CALCS)
005E99 7F5E99 MACRO                       RUN_PW_CALCS      ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate injector pulse width for a running engine "PW" (mS x 10)           (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ;barocor:      ds 2 ; Barometric Pressure Correction (% x 10) (104)              (RUN_PW_CALCS)
                                      ;matcor:       ds 2 ; Manifold Air Temperature Correction (% x 10)(108)          (RUN_PW_CALCS)
                                      ;Mapx10:       ds 2 ; Manifold Absolute Pressure (KPAx10)(update every revolution) (24) (RUN_PW_CALCS)
                                      ;Ftrmx10:      ds 2 ; Fuel Trim (% x 10)(update every mSec)(+-20%) (36)          (RUN_PW_CALCS)
                                      ;WUEandASEcor: ds 2 ; The sum of WUEcor and ASEcor (% x 10)                      (RUN_PW_CALCS)
                                      ;veCurr:       ds 2 ; Current value in VE table (% x 10) (72)                    (RUN_PW_CALCS)
                                      ;PWcalc1:      ds 2 ; PW calculations result 1                                   (RUN_PW_CALCS)
                                      ;PWcalc2:      ds 2 ; PW calculations result 2                                   (RUN_PW_CALCS)
                                      ;PWcalc3:      ds 2 ; PW calculations result 3                                   (RUN_PW_CALCS)
                                      ;PWcalc4:      ds 2 ; PW calculations result 4                                   (RUN_PW_CALCS)
                                      ;PWcalc5:      ds 2 ; PW calculations result 5                                   (RUN_PW_CALCS)
                                      ;reqFuel:      ds 2 ; Pulse width for 14.7 AFR @ 100% VE (mS x 10)               (RUN_PW_CALCS)
                                      ;PWlessTOE:    ds 2 ; Injector pulse width before "TOEpw" and "Deadband" (mS x 10) (RUN_PW_CALCS)
                                      ;TOEpw:        ds 2 ; Throttle Opening Enrichment adder (mS x 100)               (RUN_PW_CALCS)
                                      ;Deadband:     ds 2 ; injector deadband at current battery voltage mS*100        (RUN_PW_CALCS)
                                      ;FDpw:         ds 2 ; Fuel Delivery pulse width (PW - Deadband) (mS x 10)        (RUN_PW_CALCS)
                                      ;PW:           ds 2 ; Running engine injector pulsewidth (mS x 10)               (RUN_PW_CALCS)
                                      ;PWtk:         ds 2 ; Running engine injector pulsewidth (uS x 2.56)(102)        (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Method:                                                                      (RUN_PW_CALCS)
                                      ;                                                                                (RUN_PW_CALCS)
                                      ; ("barocor" * "matcor") / 1000 = "PWcalc1" (0.1% resolution)                    (RUN_PW_CALCS)
                                      ; ("Mapx10" * "Ftrmx10") / 1000 = "PWcalc2" (0.1% resolution)                    (RUN_PW_CALCS)
                                      ; ("PWcalc1" * "PWcalc2") / 1000 = "PWcalc3" (0.1% resolution)                   (RUN_PW_CALCS)
                                      ; ("WUEandASEcor" * "veCurr") / 1000 = "PWcalc4" (0.1% resolution)               (RUN_PW_CALCS)
                                      ; ("PWcalc3" * "PWcalc4") / 1000 = "PWcalc5" (0.1% resolution)                   (RUN_PW_CALCS)
                                      ; ("PWcalc5" * reqFuel") / 1000 = "PWlessTOE" (0.1mS resolution)                 (RUN_PW_CALCS)
                                      ; "PWlessTOE" + "TOEpw" = "FDpw"  (0.1mS resolution)                             (RUN_PW_CALCS)
                                      ; "FDpw" + "Deadband" = "PW"  (0.1mS resolution)                                 (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate total corrections before Throttle Opening Enrichment and deadband. (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
005E99 7F5E99 1E 10 E1 40 02              brset engine,OFCon,NoPWrunCalcs1 ; if "OFCon" bit of "engine" bit field is set branch (RUN_PW_CALCS)
                                                                           ; to NoPWrunCalcs1: (In overrun fuel cut mode so (RUN_PW_CALCS)
                                                                           ; fall through)                             (RUN_PW_CALCS)
005E9E 7F5E9E 20 03                       bra  PWrunCalcs    ; Branch to PWrunCalcs:                                   (RUN_PW_CALCS)
005EA0 7F5EA0                         NoPWrunCalcs1:                                                                   (RUN_PW_CALCS)
005EA0 7F5EA0 06 5F 31                    job  NoPWrunCalcs  ; Jump or branch to NoPWrunCalcs: (long branch)           (RUN_PW_CALCS)
005EA3 7F5EA3                         PWrunCalcs:                                                                      (RUN_PW_CALCS)
005EA3 7F5EA3 FC 10 AA                    ldd  barocor      ; "barocor" -> Accu D (% x 10)                             (RUN_PW_CALCS)
005EA6 7F5EA6 FD 10 AC                    ldy  matcor       ; "matcor" -> Accu D (% x 10)                              (RUN_PW_CALCS)
005EA9 7F5EA9 13                          emul              ; (D)*(Y)->Y:D "barocor" * "matcor"                        (RUN_PW_CALCS)
005EAA 7F5EAA CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
005EAD 7F5EAD 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("barocor"*"matcor")/1000="PWcalc1" (RUN_PW_CALCS)
005EAE 7F5EAE 7D 10 4B                        sty  PWcalc1      ; Result -> "PWcalc1"                                  (RUN_PW_CALCS)
005EB1 7F5EB1 FC 10 78                    ldd  Mapx10       ; "Mapx10" -> Accu D (% x 10)                              (RUN_PW_CALCS)
005EB4 7F5EB4 FD 10 94                    ldy  Ftrmx10      ; "Ftrmx10" -> Accu D (% x 10)                             (RUN_PW_CALCS)
005EB7 7F5EB7 13                          emul              ; (D)*(Y)->Y:D "Mapx10" * "Ftrmx10"                        (RUN_PW_CALCS)
005EB8 7F5EB8 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
005EBB 7F5EBB 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("Mapx10"*"Ftrmx10")/1000="PWcalc2" (RUN_PW_CALCS)
005EBC 7F5EBC 7D 10 4D                        sty  PWcalc2      ; Result -> "PWcalc2"                                  (RUN_PW_CALCS)
005EBF 7F5EBF FC 10 4B                    ldd  PWcalc1      ; "PWcalc1" -> Accu D (% x 10)                             (RUN_PW_CALCS)
005EC2 7F5EC2 FD 10 4D                    ldy  PWcalc2      ; "PWcalc2" -> Accu D (% x 10)                             (RUN_PW_CALCS)
005EC5 7F5EC5 13                          emul              ; (D)*(Y)->Y:D "PWcalc1" * "PWcalc2"                       (RUN_PW_CALCS)
005EC6 7F5EC6 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
005EC9 7F5EC9 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("PWcalc1"*"PWcalc2")/1000="PWcalc3" (RUN_PW_CALCS)
005ECA 7F5ECA 7D 10 4F                        sty  PWcalc3      ; Result -> "PWcalc3"                                  (RUN_PW_CALCS)
005ECD 7F5ECD FC 10 B2                    ldd  WUEandASEcor ; "WUEandASEcor" -> Accu D (% x 10)                        (RUN_PW_CALCS)
005ED0 7F5ED0 FD 10 A8                    ldy  veCurr       ; "veCurr" -> Accu D (% x 10)                              (RUN_PW_CALCS)
005ED3 7F5ED3 13                          emul              ; (D)*(Y)->Y:D "WUEandASEcor" * "veCurr"                   (RUN_PW_CALCS)
005ED4 7F5ED4 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
005ED7 7F5ED7 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("WUEandASEcor"*"veCurr")/1000="PWcalc4" (RUN_PW_CALCS)
005ED8 7F5ED8 7D 10 51                        sty  PWcalc4      ; Result -> "PWcalc4"                                  (RUN_PW_CALCS)
005EDB 7F5EDB FC 10 4F                    ldd  PWcalc3      ; "PWcalc3" -> Accu D (% x 10)                             (RUN_PW_CALCS)
005EDE 7F5EDE FD 10 51                    ldy  PWcalc4      ; "PWcalc4" -> Accu D (% x 10)                             (RUN_PW_CALCS)
005EE1 7F5EE1 13                          emul              ; (D)*(Y)->Y:D "PWcalc3" * "PWcalc4"                       (RUN_PW_CALCS)
005EE2 7F5EE2 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
005EE5 7F5EE5 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("PWcalc3"*"PWcalc4")/1000="PWcalc5" (RUN_PW_CALCS)
005EE6 7F5EE6 7D 10 53                        sty  PWcalc5      ; Result -> "PWcalc5"(total corrections before Throttle Opening (RUN_PW_CALCS)
                                                                ; Enrichment and deadband)                             (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate injector pulse width before Throttle Opening Enrichment pulse width and (RUN_PW_CALCS)
                                      ;   Deadband.                                                                    (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
005EE9 7F5EE9 FC 10 53                    ldd  PWcalc5      ; "PWcalc5" -> Accu D (% x 10)                             (RUN_PW_CALCS)
005EEC 7F5EEC 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (RUN_PW_CALCS)
005EF1 7F5EF1 CD 08 00                    ldy   #veBins_E   ; Load index register Y with address of first configurable (RUN_PW_CALCS)
                                                            ; constant on buffer RAM page 1 (veBins_E)                 (RUN_PW_CALCS)
005EF4 7F5EF4 EE EA 03 EC                 ldx   $03EC,Y     ; Load Accu X with value in buffer RAM page 1 (offset 1004)($03EC) (RUN_PW_CALCS)
                                                            ; ("reqFuel")                                              (RUN_PW_CALCS)
005EF8 7F5EF8 B7 56                       tfr  X,Y          ; "reqFuel" -> Accu Y                                      (RUN_PW_CALCS)
005EFA 7F5EFA 13                          emul              ; (D)*(Y)->Y:D "PWcalc5" * "reqfuel"                       (RUN_PW_CALCS)
005EFB 7F5EFB CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
005EFE 7F5EFE 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("PWcalc5"*"reqFuel")/1000="PWlessTOE" (RUN_PW_CALCS)
005EFF 7F5EFF 7D 10 BE                        sty  PWlessTOE    ; Result -> "PWlessTOE" (mS x 10)                      (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Add the Throttle Opening Enricment pulse width and store as "FDpw"(fuel delivery (RUN_PW_CALCS)
                                      ;   pulse width)(mS x 10)                                                        (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
005F02 7F5F02 B7 64                       tfr  Y,D          ; "PWlessTOE" -> Accu D                                    (RUN_PW_CALCS)
005F04 7F5F04 F3 10 BC                        addd TOEpw        ; (A:B)+(M:M+1)->A:B ("PWlessTOE"+"TOEpw"="FDpw"       (RUN_PW_CALCS)
005F07 7F5F07 7C 10 C6                        std  FDpw         ; Result -> "FDpw" (fuel delivery pulsewidth (mS x 10) (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Add "deadband" and store the result as "PW"(final injector pulsewidth)(mS x 10) (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
005F0A 7F5F0A F3 10 C0                        addd Deadband    ; (A:B)+(M:M+1)->A:B ("FDpw"+"Deadband"="PW"            (RUN_PW_CALCS)
005F0D 7F5F0D 7C 10 C8                        std  PW          ; Result -> "PW" (final injector pulsewidth) (mS x 10)  (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Convert "PW" to timer ticks in 2.56uS resolution.                            (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
005F10 7F5F10 FC 10 C8                    ldd   PW         ; "PW" -> Accu D                                            (RUN_PW_CALCS)
005F13 7F5F13 CD 27 10                        ldy   #$2710     ; Load index register Y with decimal 10000 (for integer math) (RUN_PW_CALCS)
005F16 7F5F16 13                              emul             ;(D)x(Y)=Y:D "PW" * 10,000                              (RUN_PW_CALCS)
005F17 7F5F17 CE 01 00                        ldx   #$100      ; Decimal 256 -> Accu X                                 (RUN_PW_CALCS)
005F1A 7F5F1A 11                          ediv             ;(Y:D)/(X)=Y;Rem->D "PW" * 10,000 / 256 = "PWtk"            (RUN_PW_CALCS)
005F1B 7F5F1B 7D 10 5B                    sty   PWtk       ; Copy result to "PWtk" (Running engine injector pulsewidth) (RUN_PW_CALCS)
                                                               ; (uS x 2.56)                                           (RUN_PW_CALCS)
005F1E 7F5F1E 7D 10 5F                    sty   InjOCadd2  ; Second injector output compare adder (2.56uS res)         (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Injector duty cycle percentage is the time the injector takes to inject the fuel (RUN_PW_CALCS)
                                      ;   divided by the time available x 100. The time available is the engine cycle which is (RUN_PW_CALCS)
                                      ;   two crankshaft revolutions. It is important to know what our duty cycle is at high (RUN_PW_CALCS)
                                      ;   engine speeds and loads. 80% is considered a safe maximum. The crank angle period is (RUN_PW_CALCS)
                                      ;   measured over 72 degrees of crank rotation. In run mode the timer is set to a 2.56uS (RUN_PW_CALCS)
                                      ;   time base and the pulse width timer value is in 2.56uS resolution. The engine cycle (RUN_PW_CALCS)
                                      ;   period in 2.56uS resolution can be calculated by multiplying the period by 10, for (RUN_PW_CALCS)
                                      ;   the two revolutions in the cycle. The duty cycle percentage is calculated by (RUN_PW_CALCS)
                                      ;   dividing "PWtk" by the cycle period and dividing by 100.                     (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate injector duty cycle                                                (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
005F21 7F5F21 FC 10 5B                    ldd  PWtk           ; "PWtk"->Accu D                                         (RUN_PW_CALCS)
005F24 7F5F24 CD 00 0A                    ldy  #$000A         ; Decimal 10-> Accu Y (for integer math)                 (RUN_PW_CALCS)
005F27 7F5F27 13                              emul                ;(D)x(Y)=Y:D "PWtk"*10                               (RUN_PW_CALCS)
005F28 7F5F28 FE 10 9C                    ldx  CASprd256      ; "CASprd256"-> Accu X (running period for 72 degrees rotation) (RUN_PW_CALCS)
005F2B 7F5F2B 11                          ediv                ;(Y:D)/(X)=Y;Rem->D ("PWtk"*10)/"CASprd256"              (RUN_PW_CALCS)
005F2C 7F5F2C 7D 10 E8                    sty  DutyCyclex10   ; Copy result to "DutyCyclex10" (Injector duty cycle x 10) (RUN_PW_CALCS)
005F2F 7F5F2F 20 24                       bra  PWrunCalcsDone ; Branch to PWrunCalcsDone:                              (RUN_PW_CALCS)
005F31 7F5F31                         NoPWrunCalcs:                                                                    (RUN_PW_CALCS)
005F31 7F5F31 18 79 10 BE                 clrw  PWlessTOE     ; Clear "PWlessTOE" Injector PW before "TOEpw"+"Deadband"(mS x 10) (RUN_PW_CALCS)
005F35 7F5F35 18 79 10 BC                 clrw  TOEpw         ; Clear "TOEpw" Throttle Opening Enrichment adder (mS x 100) (RUN_PW_CALCS)
005F39 7F5F39 18 79 10 C6                 clrw  FDpw          ; Clear "FDpw" Fuel Delivery pulse width (PW - Deadband)(mS x 10) (RUN_PW_CALCS)
005F3D 7F5F3D 18 79 10 C8                 clrw  PW            ; Clear "PW" Running engine injector pulsewidth (mS x 10) (RUN_PW_CALCS)
005F41 7F5F41 18 79 10 5B                 clrw  PWtk          ; Clear "PWtk" Running injector pulsewidth timer ticks(uS x 2.56) (RUN_PW_CALCS)
005F45 7F5F45 18 03 00 02 10 5D           movw  #$0002,InjOCadd1     ; First injector output compare adder (5.12uS res or 2.56uS res) (RUN_PW_CALCS)
005F4B 7F5F4B 18 03 00 02 10 5F           movw  #$0002,InjOCadd2     ; Second injector output compare adder (5.12uS res or 2.56uS res) (RUN_PW_CALCS)
005F51 7F5F51 18 79 10 E8                 clrw  DutyCyclex10  ; Clear "DutyCyclex10" Injector duty cycle in run mode (% x 10) (RUN_PW_CALCS)
005F55 7F5F55                         PWrunCalcsDone:                                                                  (RUN_PW_CALCS)
005F55 7F5F55 MACRO                       BARO_COR_LU       ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (BARO_COR_LU)
                                      ; - Look up current value in Barometric Correction Table (barocor)               (BARO_COR_LU)
                                      ;***************************************************************************************** (BARO_COR_LU)
005F55 7F5F55 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (BARO_COR_LU)
005F5A 7F5F5A 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (BARO_COR_LU)
                                                                  ; -> page where the desired curve resides            (BARO_COR_LU)
005F60 7F5F60 18 03 01 68 10 27           movw #$0168,CrvRowOfst  ; 360 -> Offset from the curve page to the curve row(barCorVals) (BARO_COR_LU)
                                                                      ; (actual offset is 720)                         (BARO_COR_LU)
005F66 7F5F66 18 03 01 71 10 29           movw #$0171,CrvColOfst  ; 369 -> Offset from the curve page to the curve column(barCorDelta) (BARO_COR_LU)
                                                                      ; (actual offset is 738)                         (BARO_COR_LU)
005F6C 7F5F6C 18 04 10 84 10 2B           movw Barox10,CrvCmpVal  ; Barometric Pressure (KPAx10) -> Curve comparison value (BARO_COR_LU)
005F72 7F5F72 18 0B 08 10 2D              movb #$08,CrvBinCnt     ; 8 -> number of bins in the curve row or column minus 1 (BARO_COR_LU)
005F77 7F5F77 16 6F 46                    jsr   CRV_LU_P   ; Jump to subroutine at CRV_LU_P:(located in interp_BEEM488.s module) (BARO_COR_LU)
005F7A 7F5F7A 7C 10 AA                    std   barocor    ; Copy result to Barometric correction (% x 10)             (BARO_COR_LU)
005F7D 7F5F7D MACRO                       MAT_COR_LU        ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (MAT_COR_LU)
                                      ; - Look up current value in MAT Air Density Table (matcor)                      (MAT_COR_LU)
                                      ;***************************************************************************************** (MAT_COR_LU)
005F7D 7F5F7D 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (MAT_COR_LU)
005F82 7F5F82 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (MAT_COR_LU)
                                                                  ;  ->page where the desired curve resides            (MAT_COR_LU)
005F88 7F5F88 18 03 01 9A 10 27           movw #$019A,CrvRowOfst  ; 410 -> Offset from the curve page to the curve row(matCorrTemps2) (MAT_COR_LU)
                                                                      ; (actual offset is 820)                         (MAT_COR_LU)
005F8E 7F5F8E 18 03 01 A3 10 29           movw #$01A3,CrvColOfst  ; 419 -> Offset from the curve page to the curve column(matCorrDelta2) (MAT_COR_LU)
                                                                      ; (actual offset is 838)                         (MAT_COR_LU)
005F94 7F5F94 18 04 10 70 10 2B           movw Matx10,CrvCmpVal   ; Manifold Air Temperature (Degrees F x 10) ->       (MAT_COR_LU)
                                                                  ; Curve comparison value                             (MAT_COR_LU)
005F9A 7F5F9A 18 0B 08 10 2D              movb #$08,CrvBinCnt     ; 8 -> number of bins in the curve row or column minus 1 (MAT_COR_LU)
005F9F 7F5F9F 16 70 0F                    jsr   CRV_LU_NP  ; Jump to subroutine at CRV_LU_NP:(located in interp_BEEM488.s module) (MAT_COR_LU)
005FA2 7F5FA2 7C 10 AC                    std   matcor     ; Copy result to Manifold Air Temperature Correction (% x 10) (MAT_COR_LU)
                                                            ; All of these Macro calls moved from the main loop in BPEM488.s
                                                            ; as a work around for random corrupted returns 5-4-21
005FA5 7F5FA5 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
005FA8 7F5FA8                         Notch_CT3_T2:
                                      ;*****************************************************************************************
                                      ; - If we are here the crankshaft is at 150 degrees before top dead centre on the
                                      ;   compression/power strokes for #1 cylinder. Start the hardware timer to delay the
                                      ;   coil dwell for spark #1, waste #6 if we are in run mode.
                                      ;*****************************************************************************************
005FA8 7F5FA8 MACRO                       FIRE_IGN1                 ; macro in Tim_BPEM488.s
                                      ;***************************************************************************************** (FIRE_IGN1)
                                      ; - PT0(P9) - IOC0 OC0 LED red  (D7)(1to28)(Ign1)(1&6) Control                   (FIRE_IGN1)
                                      ;***************************************************************************************** (FIRE_IGN1)
                                      ;***************************************************************************************** (FIRE_IGN1)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_IGN1)
                                      ;***************************************************************************************** (FIRE_IGN1)
005FA8 7F5FA8 4C 49 80                    bset ECT_TCTL2,Bit7 ; Set Ch3 output line to 1 on compare                    (FIRE_IGN1)
005FAB 7F5FAB 4C 49 40                    bset ECT_TCTL2,Bit6 ; Set Ch3 output line to 1 on compare                    (FIRE_IGN1)
005FAE 7F5FAE DC 44                       ldd  ECT_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_IGN1)
005FB0 7F5FB0 F3 10 41                    addd IgnOCadd1      ; Add "IgnOCadd1" (Delay time from crank signal to energise coil) (FIRE_IGN1)
005FB3 7F5FB3 5C 56                       std  ECT_TC3H       ; Copy result to Timer IC/OC register 0 (Start OC operation) (FIRE_IGN1)
005FB5 7F5FB5 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
005FB8 7F5FB8                         Notch_CT3_T3:
                                      ;*****************************************************************************************
                                      ; - If we are here the crankshaft is at 150 degrees before top dead centre on the
                                      ;   compression/power strokes for #10 cylinder. Start the hardware timer to delay the coil
                                      ;   coil dwell for spark #10, waste #5 if we are in run mode.
                                      ;*****************************************************************************************
005FB8 7F5FB8 MACRO                       FIRE_IGN2                 ; macro in Tim_BEEM488.s
                                                              ; (Will trigger an interrupt after the delay time)(LED off) (FIRE_IGN2)
                                      ;***************************************************************************************** (FIRE_IGN2)
                                      ; - PT4 - IOC4 OC4 Ign2(10&5) Control                                            (FIRE_IGN2)
                                      ;***************************************************************************************** (FIRE_IGN2)
                                      ;***************************************************************************************** (FIRE_IGN2)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_IGN2)
                                      ;***************************************************************************************** (FIRE_IGN2)
005FB8 7F5FB8 4C 48 02                    bset ECT_TCTL1,Bit1 ; Set Ch4 output line to 1 on compare                    (FIRE_IGN2)
005FBB 7F5FBB 4C 48 01                    bset ECT_TCTL1,Bit0 ; Set Ch4 output line to 1 on compare                    (FIRE_IGN2)
005FBE 7F5FBE DC 44                       ldd  ECT_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_IGN2)
005FC0 7F5FC0 F3 10 41                    addd IgnOCadd1      ; Add "IgnOCadd1" (Delay time from crank signal to energise coil) (FIRE_IGN2)
005FC3 7F5FC3 5C 58                       std  ECT_TC4H       ; Copy result to Timer IC/OC register 2 (Start OC operation) (FIRE_IGN2)
005FC5 7F5FC5 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
005FC8 7F5FC8                         Notch_CT3_T4:
                                      ;*****************************************************************************************
                                      ; - If we are here the crankshaft is at 6 degrees before top dead centre on the
                                      ;   exhaust/intake strokes for #3 cylinder and 60 degrees before top dead centre on the
                                      ;   exhaust/intake strokes for #6 cylinder. #3 intake valve is just sstarting to open
                                      ;   and #6 intake valve is 54 degrees before it will start to open. Start the pulse
                                      ;   width for injectors 3&6.
                                      ;*****************************************************************************************
005FC8 7F5FC8 1E 10 E1 80 11              brset engine,FldClr,INJ3FldClr ; If "FldClr" bit of "engine" bit field is set branch
                                                                         ; to INJ3FldClr:
005FCD 7F5FCD MACRO                       FIRE_INJ3                      ; Macro in Tim_BPEM488.s
                                                                  ; (Will trigger an interrupt after the delay time)(LED off) (FIRE_INJ3)
                                      ;***************************************************************************************** (FIRE_INJ3)
                                      ;; - PP2 - TIM1 OC2(Inj3)(3&6) Control                                           (FIRE_INJ3)
                                      ;***************************************************************************************** (FIRE_INJ3)
                                      ;***************************************************************************************** (FIRE_INJ3)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_INJ3)
                                      ;***************************************************************************************** (FIRE_INJ3)
005FCD 7F5FCD 1C 03 D9 10                 bset TIM_TCTL2,Bit4 ; Set Ch2 output line to 1 on compare                    (FIRE_INJ3)
005FD1 7F5FD1 1C 03 D9 20                 bset TIM_TCTL2,Bit5 ; Set Ch2 output line to 1 on compare                    (FIRE_INJ3)
005FD5 7F5FD5 FC 03 D4                    ldd  TIM_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_INJ3)
005FD8 7F5FD8 F3 10 5D                    addd InjOCadd1      ; (A:B)+(M:M+1->A:B Add "InjOCadd1" (Delay from trigger to start (FIRE_INJ3)
                                                              ; of injection)                                          (FIRE_INJ3)
005FDB 7F5FDB 7C 03 E4                    std  TIM_TC2H       ; Copy result to Timer IC/OC register2 (Start OC operation) (FIRE_INJ3)
005FDE 7F5FDE                         INJ3FldClr:
                                      ;***********************************************************************************************
                                      ; - Update Fuel Delivery Pulse Width Total so the results can be used by Tuner Studio and
                                      ;   Shadow Dash to calculate current fuel burn.
                                      ;***********************************************************************************************
005FDE 7F5FDE FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10)-> Accu D
005FE1 7F5FE1 F3 10 C6                    addd FDpw           ; (A:B)+(M:M+1->A:B Add  Fuel Delivery pulse width (mS x 10)
005FE4 7F5FE4 7C 10 D0                    std  FDt            ; Copy result to "FDT" (update "FDt")(mS x 10)
                                      ;***********************************************************************************************
                                      ; - Update the Fuel Delivery counter so that on roll over (65535mS)a pulsed signal can be sent to the
                                      ;   to the totalizer(open collector output)
                                      ;***********************************************************************************************
005FE7 7F5FE7 FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10))-> Accu D
005FEA 7F5FEA F3 10 61                        addd FDcnt          ; (A:B)+(M:M+1)->A:B (fuel delivery pulsewidth + fuel delivery counter)
005FED 7F5FED 25 05                       bcs  Totalizer3R     ; If the cary bit of CCR is set, branch to Totalizer3R: ("FDcnt"
                                                                  ;  rollover, pulse the totalizer)
005FEF 7F5FEF 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
005FF2 7F5FF2 20 0B                       bra  TotalizerDone3R ; Branch to TotalizerDone3R:
005FF4 7F5FF4                         Totalizer3R:
005FF4 7F5FF4 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
005FF7 7F5FF7 4C 01 08                    bset PORTB,AIOT     ; Set "AIOT" pin on Port B (PB6)(start totalizer pulse)
005FFA 7F5FFA 86 03                           ldaa #$03           ; Decimal 3->Accu A (3 mS)
005FFC 7F5FFC 7A 10 63                    staa AIOTcnt        ; Copy to "AIOTcnt" ( counter for totalizer pulse width,
                                                                  ; decremented every mS)
005FFF 7F5FFF                         TotalizerDone3R:
005FFF 7F5FFF 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
006002 7F6002                         Notch_CT4_T5:
                                      ;*****************************************************************************************
                                      ; - This is one of 4 Synchronization points but no event happens
                                      ;*****************************************************************************************
006002 7F6002 MACRO                       ST_LU             ; Macro in igncalcs_BPEM.s
                                      ;***************************************************************************************** (ST_LU)
                                      ; For a 2.56uS timer 1 Sec = 1/.00000256 = 390625 tics                           (ST_LU)
                                      ; 1mS = 390625 / 1000 = 390.625 tics                                             (ST_LU)
                                      ; 0.1mS = 390.625 / 10 = 39.0625 tics                                            (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; 1 RPM/60 = .016666666 Rev per Sec                                              (ST_LU)
                                      ; 1/.016666666 = 60 sec period                                                   (ST_LU)
                                      ; 60/360 = .166666666 sec per degree at 1 RPM                                    (ST_LU)
                                      ; 60/5 = 12 sec Crank Angle Sensor period at 1 RPM                               (ST_LU)
                                      ; 12/.00000256 = 4687500 2.56uS tics at 1 RPM ("CASprdtk")                       (ST_LU)
                                      ; 4687500/72 = 65104.16667 2.56uS tics per degree at 1 RPM ("TkspDeg")           (ST_LU)
                                      ; .166666666/.00000256 = 65104.14063 2.56uS tics per degree at 1 RPM ("TkspDeg") (ST_LU)
                                      ; 1/65104.16667 = .000001528808485 degrees per tic at 1 RPM                      (ST_LU)
                                      ; 71.52666514/60 = 1.192111 Rev per Sec                                          (ST_LU)
                                      ; 1/1.192111 = .83884806 sec period                                              (ST_LU)
                                      ; .83884806/360 = .0023301335 sec per degree at 71.52666 RPM                     (ST_LU)
                                      ; .83884806/5 = .167769612 sec Crank Angle Sensor period at 71.52666 RPM         (ST_LU)
                                      ; .167769612/.00000256 = 65535 2.56uS tics at 71.52666 RPM ("CASprdtk")          (ST_LU)
                                      ; 65535/72 = 910.208333 2.56uS tics per degree at 71.52666 RPM ("TkspDeg")       (ST_LU)
                                      ; .0023301335/.00000256 = 910.2083984 2.56uS tics per degree at 71.52666 RPM ("TkspDeg") (ST_LU)
                                      ; 1/910.208333 = .001098649577 degrees per tic at 71.52666 RPM                   (ST_LU)
                                      ; 500 RPM/60 = 8.333333333 Rev per Sec                                           (ST_LU)
                                      ; 1/8.333333333 = .12 sec period                                                 (ST_LU)
                                      ; .12/360 = .0003333333 sec per degree at 500 RPM                                (ST_LU)
                                      ; .12/5 = .024 sec Crank Angle Sensor period at 500 RPM                          (ST_LU)
                                      ; .024/.00000256 = 9375 2.56uS tics at 500 RPM ("CASprdtk")                      (ST_LU)
                                      ; 9375/72 = 130.2083333 2.56uS tics per degree at 500 RPM ("TkspDeg")            (ST_LU)
                                      ; .0003333333/.00000256 = 130.2083203 2.56uS tics per degree at 500 RPM ("TkspDeg") (ST_LU)
                                      ; 1/130.2083333 = .00768 degrees per tic at 500 RPM                              (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; 4250 RPM/60 = 70.8333333 Rev per Sec                                           (ST_LU)
                                      ; 1/70.8333333 = .014117647 sec period                                           (ST_LU)
                                      ; .014117647/360 = .00003921568629 sec per degree at 4250 RPM                    (ST_LU)
                                      ; .014117647/5 = .0028235294 sec Crank Angle Sensor period at 5000 RPM           (ST_LU)
                                      ; .0028235294/.00000256 = 1102.941172 2.56uS tics at 5000 RPM ("CASprdtk")       (ST_LU)
                                      ; 1102.941172/72 = 15.31862739 2.56uS tics per degree at 4250 RPM ("TkspDeg")    (ST_LU)
                                      ; .00003921568629/.00000256 = 15.31862746 2.56uS tics per degree at 4250 RPM ("TkspDeg") (ST_LU)
                                      ; 1/15.31862739 = .06528 degrees per tic at 4250 RPM                             (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; Ignition crank notches are placed 150 degrees BTDC for their respective cylinder (ST_LU)
                                      ; Dwell times of .006sec crank and .004sec run seem to work well                 (ST_LU)
                                      ; Maximum ignition advance expected is 35 degrees BTDC at low load and high RPM  (ST_LU)
                                      ; From data logs cranking RPM is between ~154RPM and ~241RPM                     (ST_LU)
                                      ; Just before stall is ~251RPM                                                   (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; At 4250 RPM a 4mSec dwell time takes .004/.00003921568629 = 102 degrees of rotation (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; At power up the timers are initialized with a 5.12uS time base. A "Spantk"     (ST_LU)
                                      ; value of 65535 will happen at 84.441 RPM so this is the lowest RPM that can be (ST_LU)
                                      ; calculated during crank conditions. Resolution at 4250 RPM is 7.706 RPM. If the (ST_LU)
                                      ; time base were 2.56uS a "Spantk" value of 65535 will happen at 168.882 RPM.    (ST_LU)
                                      ; Resolution at 4250 RPM is 3.856 RPM. Cranking RPM can be lower than 168 RPM    (ST_LU)
                                      ; so this is why we begin with the 5.12uS base. When RPM reaches ~300 we are almost (ST_LU)
                                      ; ceratinly running so at that point the time base is switched to 2.56uS. This base (ST_LU)
                                      ; will allow ignition calculations to be done as low as ~169 RPM which is probably lower (ST_LU)
                                      ; than the speed at which the engine can be made to run.                         (ST_LU)
                                      ; With a time base of 5.12uS "CASprd512" of 7812 happens at 300 RPM. When the period gets (ST_LU)
                                      ; shorter than this the time base is switched over to 2.56uS ("CASprd256").      (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; - Ignition timing in degrees to 0.1 degree resolution is selected from the 3D  (ST_LU)
                                      ;   lookup table "ST" which plots manifold pressure against RPM. A potentiometer on the (ST_LU)
                                      ;   dash board allows a manual trim of the "ST" values of from 0 to 20 degrees advance (ST_LU)
                                      ;   and from 0 to 20 degrees retard. The ignition system is what is called "waste spark", (ST_LU)
                                      ;   which pairs cylinders on a single coil. The spark is delivered to both cylinders at (ST_LU)
                                      ;   the same time. One cylinder recieves the spark at the appropriate time for ignition. (ST_LU)
                                      ;   The other recieves it when the exhaust valve is open. Hence the name "waste spark". (ST_LU)
                                      ;   On this 10 cylinder engine there are 5 coils, each controlled by its own hardware (ST_LU)
                                      ;   timer. The cylinders are paired 1&6, 10&5, 9&8, 4&7, 3&2                     (ST_LU)
                                      ;   In an ignition event the timer is first loaded with the output compare value in (ST_LU)
                                      ;   "Delaytk". At the compare interrupt the coil is energised and the timer is loaded (ST_LU)
                                      ;   with the output compare value in "DwllFintk". At the compare interrupt the coil is (ST_LU)
                                      ;   de-energized to fire the spark. The delay in timer ticks will depend on the timer base (ST_LU)
                                      ;   rate of either 5.12 uS for cranking or 2.56uS for running.                   (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;  Crank Signal                                                                  (ST_LU)
                                      ;   150BTDC                          Ign                    20ATDC               (ST_LU)
                                      ;      <- Delay          -><- Dwell -><-      ST + Trim     ->                   (ST_LU)
                                      ;     I___________________I__________ I_______________________I                  (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;                          <-            Advance            ->                   (ST_LU)
                                      ;      <-            Ignition Span (170 degrees)            ->                   (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ; - Look up current value in ST table (STcurr) (degrees*10)                      (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
006002 7F6002 FE 10 78                    ldx   Mapx10     ; Load index register X with value in "Mapx10"(Column value Manifold (ST_LU)
                                                           ; Absolute Pressure*10 )                                    (ST_LU)
006005 7F6005 FC 10 A0                    ldd   RPM        ; Load double accumulator D with value in "RPM" (Row value RPM) (ST_LU)
006008 7F6008 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                   (ST_LU)
00600D 7F600D CD 08 00                    ldy   #stBins_E  ; Load index register Y with address of the first value in ST table (ST_LU)
006010 7F6010 16 6E 77                    jsr   3D_LOOKUP  ; Jump to subroutine at 3D_LOOKUP:                          (ST_LU)
006013 7F6013 7C 10 D2                    std   STcurr     ; Copy result to "STcurr"                                   (ST_LU)
006016 7F6016 MACRO                       DWELL_COR_LU      ; Macro in igncalcs_BPEM.s
                                      ;***************************************************************************************** (DWELL_COR_LU)
                                      ; - Look up current value in Dwell Battery Adjustment Table (dwellcor)(% x 10)   (DWELL_COR_LU)
                                      ;***************************************************************************************** (DWELL_COR_LU)
006016 7F6016 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (DWELL_COR_LU)
00601B 7F601B 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (DWELL_COR_LU)
                                                                  ;  ->page where the desired curve resides            (DWELL_COR_LU)
006021 7F6021 18 03 01 7A 10 27           movw #$017A,CrvRowOfst  ; 378 -> Offset from the curve page to the curve row(dwellvolts) (DWELL_COR_LU)
                                                                      ;(actual offset is 756                           (DWELL_COR_LU)
006027 7F6027 18 03 01 80 10 29           movw #$0180,CrvColOfst  ; 384 -> Offset from the curve page to the curve column(dwellcorr) (DWELL_COR_LU)
                                                                      ;(actual offset is 768)                          (DWELL_COR_LU)
00602D 7F602D 18 04 10 68 10 2B           movw BatVx10,CrvCmpVal  ; Battery Voltage (Volts x 10) -> Curve comparison value (DWELL_COR_LU)
006033 7F6033 18 0B 05 10 2D              movb #$05,CrvBinCnt     ; 5 -> number of bins in the curve row or column minus 1 (DWELL_COR_LU)
006038 7F6038 16 6F 46                    jsr   CRV_LU_P   ; Jump to subroutine at CRV_LU_P:(located in interp_BEEM488.s module) (DWELL_COR_LU)
00603B 7F603B 7C 10 D6                    std   DwellCor   ; Copy result to Dwell battery correction (% x 10)          (DWELL_COR_LU)
00603E 7F603E MACRO                       VE_LU             ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (VE_LU)
                                      ; The base value for injector pulse width calculations in mS to 0.1mS resolution is called (VE_LU)
                                      ; "ReqFuel". It represents the pulse width reqired to achieve 14.7:1 Air/Fuel Ratio at (VE_LU)
                                      ; 100% volumetric efficiency. The VE table contains percentage values to 0.1 percent (VE_LU)
                                      ; resolultion and plots intake manifold pressure in KPA to 0.1KPA resolution against RPM. (VE_LU)
                                      ; These values are part of the injector pulse width calculations for a running engine. (VE_LU)
                                      ;***************************************************************************************** (VE_LU)
                                      ;***************************************************************************************** (VE_LU)
                                      ; - Look up current value in VE table (veCurr)(%x10)                             (VE_LU)
                                      ;***************************************************************************************** (VE_LU)
00603E 7F603E FE 10 78                    ldx   Mapx10     ; Load index register X with value in "Mapx10"(Column value Manifold (VE_LU)
                                                           ; Absolute Pressure x 10 )                                  (VE_LU)
006041 7F6041 FC 10 A0                    ldd   RPM        ; Load double accumulator D with value in "RPM" (Row value RPM) (VE_LU)
006044 7F6044 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (VE_LU)
006049 7F6049 CD 08 00                    ldy   #veBins_E    ; Load index register Y with address of the first value in VE table (VE_LU)
                                                           ;(in RAM)                                                   (VE_LU)
00604C 7F604C 16 6E 77                    jsr   3D_LOOKUP  ; Jump to subroutine at 3D_LOOKUP:                          (VE_LU)
00604F 7F604F 7C 10 A8                    std   VEcurr     ; Copy result to "VEcurr"(%x10)                             (VE_LU)
006052 7F6052 MACRO                       AFR_LU            ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (AFR_LU)
                                      ; The Air/Fuel Ratio of the fuel mixture affects how an engine will run. Generally (AFR_LU)
                                      ; speaking AFRs of less than ~7:1 are too rich to ignite. Ratios of greater than ~20:1 are (AFR_LU)
                                      ; too lean to ignite. Stoichiometric ratio is at ~14.7:1. This is the ratio at which all (AFR_LU)
                                      ; the fuel and all the oxygen are consumed and is best for emmisions concerns. Best power (AFR_LU)
                                      ; is obtained between ratios of ~12:1 and ~13:1. Best economy is obtained as lean as ~18:1 (AFR_LU)
                                      ; in some engines. This controller runs in open loop so the AFR numbers are used as (AFR_LU)
                                      ; a tuning aid only.                                                             (AFR_LU)
                                      ;***************************************************************************************** (AFR_LU)
                                      ;***************************************************************************************** (AFR_LU)
                                      ; - Look up current value in AFR table (afrCurr)(AFRx10)                         (AFR_LU)
                                      ;***************************************************************************************** (AFR_LU)
006052 7F6052 FE 10 78                    ldx   Mapx10     ; Load index register X with value in "Mapx10"(Column value Manifold (AFR_LU)
                                                           ; Absolute Pressure x 10 )                                  (AFR_LU)
006055 7F6055 FC 10 A0                    ldd   RPM        ; Load double accumulator D with value in "RPM" (Row value RPM) (AFR_LU)
006058 7F6058 18 0B FD 00 17              movb  #(BUF_RAM_P3_START>>16),EPAGE  ; Move $FD into EPAGE                   (AFR_LU)
00605D 7F605D CD 08 00                    ldy   #afrBins_E   ; Load index register Y with address of the first value in AFR table (AFR_LU)
                                                           ;(in RAM)                                                   (AFR_LU)
006060 7F6060 16 6E 77                    jsr   3D_LOOKUP  ; Jump to subroutine at 3D_LOOKUP:                          (AFR_LU)
006063 7F6063 7C 10 A6                    std   AFRcurr    ; Copy result to "AFRcurr"                                  (AFR_LU)
006066 7F6066 MACRO                       TOE_OFC_CALCS     ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - When the engine is running and the throttle is opened quickly a richer mixture is (TOE_OFC_CALCS)
                                      ;   required for a short period of time. This additional pulse width time is called (TOE_OFC_CALCS)
                                      ;   Throttle Opening Enrichment. Conversly, when the engine is in over run       (TOE_OFC_CALCS)
                                      ;   conditions no fuel is required so the injectors can be turned off, subject to (TOE_OFC_CALCS)
                                      ;   permissives. This condtion is call Overrun Fuel Cut.                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check to see if the throttle is opening or if it is at steady state or closing (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
006066 7F6066                         TOE_OFC_CHK:                                                                     (TOE_OFC_CALCS)
006066 7F6066 FE 10 7C                    ldx   TpsPctx10       ; Load index register X with value in "TpsPctx10"      (TOE_OFC_CALCS)
006069 7F6069 BE 10 45                    cpx   TpsPctx10last   ; (X)-(M:M+1)Compare with value in "TpsPctx10last"     (TOE_OFC_CALCS)
00606C 7F606C 18 23 01 84                 bls   OFC_CHK         ; If "TpsPctx10" is equal to or less than "TpsPctx10last" branch to (TOE_OFC_CALCS)
                                                                    ; OFC_CHK:(Throttle is steady or closing so check for OFC permissives) (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Current Throttle position percent - throttle position percent 100mS ago = throttle position (TOE_OFC_CALCS)
                                      ;   percent difference over time in seconds "TpsPctx10" - "TpsPctx10last" = "TpsPctDOT" (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
006070 7F6070 18 B0 10 45                 subx  TpsPctx10last   ; (X)-(M:M-1)=>X Subtract "TpsPctx10last" from "TpsPctx10" (TOE_OFC_CALCS)
006074 7F6074 7E 10 B6                    stx   TpsPctDOT       ; Copy result to "TpsPctDOT"                           (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - The throttle is opening. Check to see if it is opening at a rate greater than the threshold (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
006077 7F6077 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
00607C 7F607C CD 08 00                    ldy   #veBins_E       ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                                ; on buffer RAM page 1 (veBins_E)                      (TOE_OFC_CALCS)
00607F 7F607F EE EA 03 D0                 ldx   $03D0,Y         ; Load Accu D with value in buffer RAM page 1 offset 976 (tpsThresh) (TOE_OFC_CALCS)
                                                                ;(TPSdot threshold)(offset = 976)($03D0)               (TOE_OFC_CALCS)
006083 7F6083 BE 10 B6                    cpx   TpsPctDOT       ; Compare "tpsThresh" with "TpsPctDOT"                 (TOE_OFC_CALCS)
006086 7F6086 18 22 01 3D                 bhi   TOE_CHK_TIME    ; If "tpsThresh" is greater than "TpsPctDOT", branch to TOE_CHK_TIME: (TOE_OFC_CALCS)
                                                                ; ("TpsPctDOT" below threshold so check if acceleration is done) (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - The throttle is opening at a rate greater then the threshold. Check to see if TOE is in (TOE_OFC_CALCS)
                                      ;   progress.                                                                    (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
00608A 7F608A 1E 10 E1 20 2D              brset engine,TOEon,TOE_CALC ; If "TOEon" bit of "engine" bit field           (TOE_OFC_CALCS)
                                                                ; is set, branch to TOE_CALC: (TOE in progress)        (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ;- The throttle is opening at a rate greater than the threshold and TOE is not in progress (TOE_OFC_CALCS)
                                      ;  so prepare to add in the enrichement.                                         (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
00608F 7F608F 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006094 7F6094 CD 08 00                    ldy   #veBins_E       ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                              ; on buffer RAM page 1 (veBins_E)                        (TOE_OFC_CALCS)
006097 7F6097 EC EA 03 BC                 ldd  $03BC,Y        ; Load Accu D with value in buffer RAM page 1 (offset 956) (First element (TOE_OFC_CALCS)
                                                              ; of "TOEbins" table)(Start with first element, will determine actual (TOE_OFC_CALCS)
                                                              ; next time around)                                      (TOE_OFC_CALCS)
00609B 7F609B 7B 10 BB                    stab   TOEpct       ; Copy to Throttle Opening Enrichment percent(used in later calculations) (TOE_OFC_CALCS)
00609E 7F609E 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
0060A3 7F60A3 CD 08 00                    ldy   #veBins_E     ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                              ; on buffer RAM page 1 (veBins_E)                        (TOE_OFC_CALCS)
0060A6 7F60A6 EC EA 03 D2                 ldd   $03D2,Y       ; Load Accu D with value in buffer RAM page 1 offset 978 (TOEtime_F) (TOE_OFC_CALCS)
0060AA 7F60AA 7B 10 CF                    stab  TOEdurCnt     ; Copy to "TOEdurCnt" (Throttle Opening Enrichment duration (TOE_OFC_CALCS)
                                                                  ; (decremented every 100 mS))                        (TOE_OFC_CALCS)
0060AD 7F60AD 1C 10 E1 20                 bset  engine,TOEon  ; Set "TOEon" bit of "engine" variable (in TOE mode)     (TOE_OFC_CALCS)
0060B1 7F60B1 1C 10 E2 08                 bset  engine2,TOEduron  ; Set "TOEduron" bit of "engine2" variable (TOE duration) (TOE_OFC_CALCS)
0060B5 7F60B5 1D 10 E1 40                 bclr  engine,OFCon  ; Clear "OFCon" bit of "engine" variable (not in OFC mode) (TOE_OFC_CALCS)
0060B9 7F60B9 06 62 36                    job   OFC_LOOP      ; Jump or branch to OFC_LOOP:(fall through)              (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Calculate the cold temperature add-on enrichment "ColdAddpct" (%) from -39.72 (TOE_OFC_CALCS)
                                      ;   degrees to 179.9 degrees.                                                    (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
0060BC 7F60BC                         TOE_CALC:                                                                        (TOE_OFC_CALCS)
0060BC 7F60BC FC 10 6A                    ldd  cltAdc       ; "cltAdc" -> D                                            (TOE_OFC_CALCS)
0060BF 7F60BF 8C 00 93                    cpd  #$0093       ; Compare "cltADC" with decimal 147(ADC @ 179.9F)          (TOE_OFC_CALCS)
0060C2 7F60C2 23 02                       bls  RailColdAdd  ; If "cltADC" is lower or the same as 147, branch to RailColdAdd: (TOE_OFC_CALCS)
0060C4 7F60C4 20 05                       bra  DoColdAdd    ; Branch to DoColdAdd:                                     (TOE_OFC_CALCS)
0060C6 7F60C6                         RailColdAdd:                                                                     (TOE_OFC_CALCS)
0060C6 7F60C6 79 10 B9                    clr   ColdAddpct   ; Clear "ColdAddpct" (no cold adder)                      (TOE_OFC_CALCS)
0060C9 7F60C9 20 3C                       bra   ColdAddDone  ; Branch to ColdAddDone: (skip over)                      (TOE_OFC_CALCS)
0060CB 7F60CB                         DoColdAdd:                                                                       (TOE_OFC_CALCS)
0060CB 7F60CB CC 00 93                    ldd  #$0093      ; Load double accumulator with decimal 147 (ADC @ 179.9F)   (TOE_OFC_CALCS)
0060CE 7F60CE 3B                          pshd             ; Push to stack (V1)                                        (TOE_OFC_CALCS)
0060CF 7F60CF FC 10 6A                    ldd  cltAdc      ; Load double accumulator with "cltAdc"                     (TOE_OFC_CALCS)
0060D2 7F60D2 3B                          pshd             ; Push to stack (V)                                         (TOE_OFC_CALCS)
0060D3 7F60D3 CC 03 EB                    ldd  #$03EB      ; Load double accumulator with decimal 1003 (ADC @ -39.72F) (TOE_OFC_CALCS)
0060D6 7F60D6 3B                          pshd             ; Push to stack (V2)                                        (TOE_OFC_CALCS)
0060D7 7F60D7 CC 00 00                    ldd  #$0000      ; Load double accumulator with decimal 0 (added amount at 179.9F) (TOE_OFC_CALCS)
0060DA 7F60DA 3B                          pshd             ; Push to stack (Z1)                                        (TOE_OFC_CALCS)
0060DB 7F60DB 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
0060E0 7F60E0 CD 08 00                    ldy   #veBins_E    ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                           ; on buffer RAM page 1 (veBins_E)                           (TOE_OFC_CALCS)
0060E3 7F60E3 EC EA 03 D4                 ldd   $03D4,Y    ; Load Accu D with value in buffer RAM page 1 (ColdAdd_F)(offset 980) (TOE_OFC_CALCS)
                                                           ;(added amount at -39.72F)                                  (TOE_OFC_CALCS)
0060E7 7F60E7 3B                          pshd             ; Push to stack (Z2)                                        (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z2       |  SP+ 0                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z1       |  SP+ 2                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V2       |  SP+ 4                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V        |  SP+ 6                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V1       |  SP+ 8                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                      ;                     V      V1      V2      Z1    Z2                            (TOE_OFC_CALCS)
0060E8 7F60E8 MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; ==========================                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ; result: D: interpolated result                                                 (TOE_OFC_CALCS/2D_IPOL)
                                      ; SSTACK: none                                                                   (TOE_OFC_CALCS/2D_IPOL)
                                      ;         no registers are preserved                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    ^ V                                                                         (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                                                                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z2+....................*                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                    :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   :       :        :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
0060E8 7F60E8 EC 86                                   LDD       \1    ; load V                                         (TOE_OFC_CALCS/2D_IPOL)
0060EA 7F60EA A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
0060EC 7F60EC B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
0060EE 7F60EE EC 80                                   LDD       \5    ; load Z2                                        (TOE_OFC_CALCS/2D_IPOL)
0060F0 7F60F0 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
0060F2 7F60F2 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (TOE_OFC_CALCS/2D_IPOL)
0060F4 7F60F4 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
0060F6 7F60F6 EC 84                                   LDD       \3    ; load V2                                        (TOE_OFC_CALCS/2D_IPOL)
0060F8 7F60F8 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
0060FA 7F60FA B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (TOE_OFC_CALCS/2D_IPOL)
                                      ;*********************************************************************           (TOE_OFC_CALCS/2D_IPOL)
0060FC 7F60FC 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (TOE_OFC_CALCS/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (TOE_OFC_CALCS/2D_IPOL)
0060FE 7F60FE B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006100 7F6100 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Free stack space (result in D)                                               (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006102 7F6102 1B 8A                       leas  10,SP       ; Stack pointer -> bottom of stack                         (TOE_OFC_CALCS)
006104 7F6104 7B 10 B9                    stab  ColdAddpct  ; Copy result to "ColdAddpct" (%)(bins are byte values)    (TOE_OFC_CALCS)
006107 7F6107                         ColdAddDone:                                                                     (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Calculate the cold temperature multiplier enrichment "ColdMulpct" (%), from -39.72 degrees (TOE_OFC_CALCS)
                                      ;   to 179.9 degrees.                                                            (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
006107 7F6107 FC 10 6A                    ldd  cltADC       ; "cltADC" -> D                                            (TOE_OFC_CALCS)
00610A 7F610A 8C 00 93                    cpd  #$0093       ; Compare "cltADC" with decimal 147(ADC @ 179.9F)          (TOE_OFC_CALCS)
00610D 7F610D 23 02                       bls  RailColdMul  ; If "cltADC" is lower or the same as 147, branch to RailColdMul: (TOE_OFC_CALCS)
00610F 7F610F 20 07                       bra  DoColdMul    ; Branch to DoColdMul: (skip over)                         (TOE_OFC_CALCS)
006111 7F6111                         RailColdMul:                                                                     (TOE_OFC_CALCS)
006111 7F6111 18 0B 64 10 BA             movb #$64,ColdMulpct  ; Decimal 100 -> "ColdMulpct" (100% = no multiplier))   (TOE_OFC_CALCS)
006116 7F6116 20 3C                      bra   ColdMulDone     ; Branch to ColdMulDone: (skip over)                    (TOE_OFC_CALCS)
006118 7F6118                         DoColdMul:                                                                       (TOE_OFC_CALCS)
006118 7F6118 CC 00 93                    ldd  #$0093      ; Load double accumulator with decimal 147 (ADC @ 179.9F)   (TOE_OFC_CALCS)
00611B 7F611B 3B                          pshd             ; Push to stack (V1)                                        (TOE_OFC_CALCS)
00611C 7F611C FC 10 6A                    ldd  cltAdc      ; Load double accumulator with "cltAdc"                     (TOE_OFC_CALCS)
00611F 7F611F 3B                          pshd             ; Push to stack (V)                                         (TOE_OFC_CALCS)
006120 7F6120 CC 03 EB                    ldd  #$03EB      ; Load double accumulator with decimal 1003 (ADC @ -39.72F) (TOE_OFC_CALCS)
006123 7F6123 3B                          pshd             ; Push to stack (V2)                                        (TOE_OFC_CALCS)
006124 7F6124 CC 00 64                    ldd  #$0064      ; Load double accumulator with decimal 100 (multiplier amount at 179.9F) (TOE_OFC_CALCS)
                                                           ;(1.00 multiplier at 180 degrees)                           (TOE_OFC_CALCS)
006127 7F6127 3B                          pshd             ; Push to stack (Z1)                                        (TOE_OFC_CALCS)
006128 7F6128 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
00612D 7F612D CD 08 00                    ldy   #veBins_E    ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                           ; on buffer RAM page 1 (veBins_E)                           (TOE_OFC_CALCS)
006130 7F6130 EC EA 03 D6                 ldd   $03D6,Y    ; Load Accu D with value in buffer RAM page 1 "ColdMul_F"(offset 982) (TOE_OFC_CALCS)
                                                           ;(added amount at -39.72F)                                  (TOE_OFC_CALCS)
006134 7F6134 3B                          pshd             ; Push to stack (Z2)                                        (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z2       |  SP+ 0                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z1       |  SP+ 2                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V2       |  SP+ 4                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V        |  SP+ 6                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V1       |  SP+ 8                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                      ;                     V      V1      V2      Z1    Z2                            (TOE_OFC_CALCS)
006135 7F6135 MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; ==========================                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ; result: D: interpolated result                                                 (TOE_OFC_CALCS/2D_IPOL)
                                      ; SSTACK: none                                                                   (TOE_OFC_CALCS/2D_IPOL)
                                      ;         no registers are preserved                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    ^ V                                                                         (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                                                                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z2+....................*                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                    :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   :       :        :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006135 7F6135 EC 86                                   LDD       \1    ; load V                                         (TOE_OFC_CALCS/2D_IPOL)
006137 7F6137 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
006139 7F6139 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
00613B 7F613B EC 80                                   LDD       \5    ; load Z2                                        (TOE_OFC_CALCS/2D_IPOL)
00613D 7F613D A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
00613F 7F613F 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (TOE_OFC_CALCS/2D_IPOL)
006141 7F6141 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006143 7F6143 EC 84                                   LDD       \3    ; load V2                                        (TOE_OFC_CALCS/2D_IPOL)
006145 7F6145 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
006147 7F6147 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (TOE_OFC_CALCS/2D_IPOL)
                                      ;*********************************************************************           (TOE_OFC_CALCS/2D_IPOL)
006149 7F6149 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (TOE_OFC_CALCS/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (TOE_OFC_CALCS/2D_IPOL)
00614B 7F614B B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
00614D 7F614D E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Free stack space (result in D)                                               (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
00614F 7F614F 1B 8A                      leas  10,SP         ; Stack pointer -> bottom of stack                        (TOE_OFC_CALCS)
006151 7F6151 7B 10 BA                   stab   ColdMulpct   ; Copy result to "ColdMulpct" (%) (bins are byte values)  (TOE_OFC_CALCS)
006154 7F6154                         ColdMulDone:                                                                     (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; First determine "TpsPctDOT" ("TpsPctx10" - "TpsPctx10last") (both updated every 100mS (TOE_OFC_CALCS)
                                      ; in rti_BEEM488.s)                                                              (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006154 7F6154 FE 10 7C                   ldx   TpsPctx10         ; "TpsPctx10" -> Accu X                               (TOE_OFC_CALCS)
006157 7F6157 18 B0 10 45                subx  TpsPctx10last     ; (X)-(M:M+1)=>X Subtract "TpsPctx10last" from "TpsPctx10" (TOE_OFC_CALCS)
00615B 7F615B 7E 10 B6                   stx   TpsPctDOT         ; Copy result to "TpsPctDOT" (%/Sec)                  (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Look up current value in Throttle Opening Enrichment Table (TpsDOTcor)(%)(byte value) (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
00615E 7F615E 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006163 7F6163 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr    ; Address of the first value in VE table(in RAM)(page pointer) (TOE_OFC_CALCS)
                                                                   ; ->page where the desired curve resides            (TOE_OFC_CALCS)
006169 7F6169 18 03 01 E2 10 27           movw #$01E2,CrvRowOfst   ; 482 -> Offset from the curve page to the curve row (TOE_OFC_CALCS)
                                                                       ; (TOERates_F)(actual offset is 964)($03C4)     (TOE_OFC_CALCS)
00616F 7F616F 18 03 01 DE 10 29           movw #$01DE,CrvColOfst   ; 478 -> Offset from the curve page to the curve column (TOE_OFC_CALCS)
                                                                       ; (TOEBins_F)(actual offset is 956)($03BC)      (TOE_OFC_CALCS)
006175 7F6175 18 04 10 B6 10 2B           movw TpsPctDOT,CrvCmpVal ; TPS% difference over time (%/Sec)(update every 100mSec) (TOE_OFC_CALCS)
                                                                   ; -> Curve comparison value                         (TOE_OFC_CALCS)
00617B 7F617B 18 0B 03 10 2D              movb #$03,CrvBinCnt      ; 3 -> number of bins in the curve row or column minus 1 (TOE_OFC_CALCS)
006180 7F6180 16 6F 46                    jsr  CRV_LU_P            ; Jump to subroutine at CRV_LU_P:(located in interp_BEEM488.s module) (TOE_OFC_CALCS)
006183 7F6183 7B 10 B8                    stab TpsDOTcor           ; Copy result to TpsDOTcor (%)(byte value)          (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Multiply "TpsDOTcor" by "ColdMulpct" and divide by 100                       (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006186 7F6186 B6 10 B8                    ldaa  TpsDOTcor      ; "TpsDOTcor" -> A (%)                                  (TOE_OFC_CALCS)
006189 7F6189 F6 10 BA                    ldab  ColdMulpct     ; "ColdMulpct" -> B (%)                                 (TOE_OFC_CALCS)
00618C 7F618C 12                          mul                  ; (A)x(B)->A:B (TpsDOTcor x ColdMulpct) result in D     (TOE_OFC_CALCS)
00618D 7F618D CE 00 64                    ldx   #$0064         ; Decimal 100 -> X                                      (TOE_OFC_CALCS)
006190 7F6190 18 10                       idiv                 ; (D)/(X)->(X)rem(D) ((TpsDOTcor x ColdMulpct)/100)(%)  (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check the remainder and round up if >=5                                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006192 7F6192 8C 00 05                    cpd   #$0005         ; Compare idiv remainder with decimal 5                 (TOE_OFC_CALCS)
006195 7F6195 2F 05                       ble   NO_ROUND_UP    ; If remainder of idiv <= 5, branch to NO_ROUND_UP:     (TOE_OFC_CALCS)
006197 7F6197 B7 50                       tfr   X,A            ; idiv result -> A                                      (TOE_OFC_CALCS)
006199 7F6199 42                          inca                 ; idiv result + 1 -> A (round up)                       (TOE_OFC_CALCS)
00619A 7F619A 20 02                       bra   ADD_COLDADD    ; Branch to ADD_COLDADD:(fall through)                  (TOE_OFC_CALCS)
00619C 7F619C                         NO_ROUND_UP:                                                                     (TOE_OFC_CALCS)
00619C 7F619C B7 50                       tfr   X,A            ; idiv result -> A                                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Add the result with "ColdAddpct". Compare the result with the current "TOEpct" and (TOE_OFC_CALCS)
                                      ;   and save the highest value as "TOEpct". This is the final TOE value(%)       (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
00619E 7F619E                         ADD_COLDADD:                                                                     (TOE_OFC_CALCS)
00619E 7F619E BB 10 B9                    adda  ColdAddpct     ; (A)+(M)->(A) (("TpsDOTcor" * ColdMulpct)/100) + "ColdAddpct") (TOE_OFC_CALCS)
0061A1 7F61A1 7A 10 F9                    staa  tmp5b           ; Copy to "tmp5b"(("TpsDOTcor" * ColdMulpct)/100) + "ColdAddpct") (TOE_OFC_CALCS)
0061A4 7F61A4 B1 10 BB                    cmpa  TOEpct         ; Compare result with "TOEpct"                          (TOE_OFC_CALCS)
0061A7 7F61A7 25 1E                       blo   TOE_CHK_TIME   ; If (A) is less than (M), branch to TOE_CHK_TIME: (result (TOE_OFC_CALCS)
                                                               ; < "TOEpct" so use this value for "TOEpct" and check if (TOE_OFC_CALCS)
                                                                                       ; acceleration is done)         (TOE_OFC_CALCS)
0061A9 7F61A9 B6 10 F9                    ldaa  tmp5b          ; "tmp5b" -> A(("TpsDOTcor" * ColdMulpct)/100) + "ColdAddpct") (TOE_OFC_CALCS)
0061AC 7F61AC 7A 10 BB                    staa  TOEpct         ; Copy result to "TOEpct"(result is higher than current (TOE_OFC_CALCS)
                                                               ; so update TOEpct with the higher value)               (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Calculate the Throttle Opening Enrichment adder for PW calculations.         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
0061AF 7F61AF 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
0061B4 7F61B4 CD 08 00                    ldy   #veBins_E   ; Load index register Y with address of first configurable (TOE_OFC_CALCS)
                                                            ; constant on buffer RAM page 1 (veBins_E)                 (TOE_OFC_CALCS)
0061B7 7F61B7 EC EA 03 EC                 ldd   $03EC,Y     ; Load Accu D with value in buffer RAM page 1 (offset 1004)($03EC) (TOE_OFC_CALCS)
                                                            ; ("reqFuel" in Accu B)                                    (TOE_OFC_CALCS)
0061BB 7F61BB B6 10 BB                    ldaa  TOEpct      ; "TOEpct" -> Accu D (%)                                   (TOE_OFC_CALCS)
0061BE 7F61BE 12                          mul               ;(A)x(B)->A:B (reqFuel" x "TOEpct")                        (TOE_OFC_CALCS)
0061BF 7F61BF CE 00 64                        ldx  #$0064       ; Decimal 100 -> Accu X                                (TOE_OFC_CALCS)
0061C2 7F61C2 18 10                       idiv              ;(D)/(X)->X:rem->D (reqFuel" x "TOEpct")/10                (TOE_OFC_CALCS)
0061C4 7F61C4 7E 10 BC                    stx  TOEpw        ; Result -> "TOEpw" TOE adder (mS x 10)                    (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check to see if Throttle Opening Enrichment is done.                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
0061C7 7F61C7                          TOE_CHK_TIME:                                                                   (TOE_OFC_CALCS)
0061C7 7F61C7 1E 10 E1 40 07              brset  engine,OFCon,RESET_TOE ; If Overrun Fuel Cut bit of "Engine" bit field is set, (TOE_OFC_CALCS)
                                                                        ; branch to RESET_TOE:                         (TOE_OFC_CALCS)
0061CC 7F61CC B6 10 CF                     ldaa  TOEdurCnt    ; "TOEdurCnt" -> Accu A                                  (TOE_OFC_CALCS)
0061CF 7F61CF 27 02                            beq   RESET_TOE    ; If "TOEdurCnt" = zero branch to RESET_TOE:(timer has timed out) (TOE_OFC_CALCS)
0061D1 7F61D1 20 1F                            bra   TOE_LOOP     ; Branch to "TOE_LOOP:(Timer hasn't timed out yet)   (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - The throttle is no longer opening and the duration timer has timed out so clear (TOE_OFC_CALCS)
                                      ;    "TOEpct" and the "TOEon" bit of "engine" bit field.                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
0061D3 7F61D3                         RESET_TOE:                                                                       (TOE_OFC_CALCS)
0061D3 7F61D3 1D 10 E1 20                 bclr  engine,TOEon      ; Clear "TOEon" bit of "engine" bit field            (TOE_OFC_CALCS)
0061D7 7F61D7 1D 10 E2 08                 bclr  engine2,TOEduron  ; Clear "TOEduron" bit of "engine2" variable (TOE duration) (TOE_OFC_CALCS)
0061DB 7F61DB 79 10 BB                    clr   TOEpct            ; Clear Throttle Opening Enrichment (%)              (TOE_OFC_CALCS)
0061DE 7F61DE 79 10 B9                    clr   ColdAddpct        ; Clear Throttle Opening Enrichment cold adder (%)   (TOE_OFC_CALCS)
0061E1 7F61E1 79 10 BA                    clr   ColdMulpct        ; Clear Throttle Opening Enrichment cold multiplier (%) (TOE_OFC_CALCS)
0061E4 7F61E4 79 10 B8                    clr   TpsDOTcor         ; Clear Throttle Opening Enrichment table value(%)   (TOE_OFC_CALCS)
0061E7 7F61E7 79 10 CF                    clr   TOEdurCnt         ; Clear Throttle Opening Enrichment duration counter (TOE_OFC_CALCS)
0061EA 7F61EA 18 79 10 BC                 clrw  TOEpw             ; Clear Throttle Opening Enrichment adder (mS x 100) (TOE_OFC_CALCS)
0061EE 7F61EE 18 79 10 BE                 clrw  PWlessTOE         ; Clear Injector pulse width before "TOEpw" and "Deadband" (mS x 10) (TOE_OFC_CALCS)
0061F2 7F61F2                         TOE_LOOP:                                                                        (TOE_OFC_CALCS)
0061F2 7F61F2 20 42                       job  OFC_LOOP       ; Jump or branch to OFC_LOOP:(Finished with TOE, not in OFC so (TOE_OFC_CALCS)
                                                                  ; fall through)                                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Overrun Fuel Cut mode 2/07/21 Note change in rti_BPEM488.s                   (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;                                                                                (TOE_OFC_CALCS)
                                      ; - Engine overrun occurs when the the vehicle is in motion, the throttle is closed and (TOE_OFC_CALCS)
                                      ;   the engine is turning faster than the driver wants it to be, either because of vehicle (TOE_OFC_CALCS)
                                      ;   inertia or by being on a negative grade. Under these conditions there will be a slight (TOE_OFC_CALCS)
                                      ;   increase in engine braking and some fuel can be saved if the fuel injectors are not (TOE_OFC_CALCS)
                                      ;   pulsed. OFC is only enabled manually by pulsing up on the dash mounted SPDT spring (TOE_OFC_CALCS)
                                      ;   return to centre toggle switch. In order to enter OFC mode several permissive (TOE_OFC_CALCS)
                                      ;   conditions must be met first. The throttle opening must be equal to or less than the (TOE_OFC_CALCS)
                                      ;   minimum permitted opening and the engine RPM must be equal to or more than the minimum (TOE_OFC_CALCS)
                                      ;   permitted RPM. OFC can be disabled manually by the driver at any time by pulsing (TOE_OFC_CALCS)
                                      ;   down on the dash mounted toggle switch. It will be disabled automatically if either (TOE_OFC_CALCS)
                                      ;   or both of the permissive conditions are no longer met                       (TOE_OFC_CALCS)
                                      ;                                                                                (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check to see if we have permissives for Overrun Fuel Cut at steady state or closing (TOE_OFC_CALCS)
                                      ;   throttle.                                                                    (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
0061F4 7F61F4                         OFC_CHK:                                                                         (TOE_OFC_CALCS)
0061F4 7F61F4 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
0061F9 7F61F9 CD 08 00                    ldy   #veBins_E     ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                            ; on buffer RAM page 1 (veBins_E)                          (TOE_OFC_CALCS)
0061FC 7F61FC EE EA 03 DA                 ldx   $03DA,Y     ; Load X with value in buffer RAM page 1 offset 986 (OFCtps) (TOE_OFC_CALCS)
                                                            ;(Overrun Fuel Cut min TPS%)                               (TOE_OFC_CALCS)
006200 7F6200 BE 10 7C                    cpx  TpsPctx10    ; Compare it with value in "TpsPctx10"                     (TOE_OFC_CALCS)
006203 7F6203 25 2D                       blo  OFC_CHK_DONE ; If (X)>(M), branch to OFC_CHK_DONE:                      (TOE_OFC_CALCS)
                                                            ;(TPS is above minimum so no fuel cut)                     (TOE_OFC_CALCS)
006205 7F6205 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
00620A 7F620A CD 08 00                    ldy   #veBins_E     ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                            ; on buffer RAM page 1 (veBins_E)                          (TOE_OFC_CALCS)
00620D 7F620D EE EA 03 DC                 ldx   $03DC,Y     ; Load X with value in buffer RAM page 1 offset 988 (OFCrpm) (TOE_OFC_CALCS)
                                                            ;(Overrun Fuel Cut min RPM)                                (TOE_OFC_CALCS)
006211 7F6211 BE 10 A0                    cpx  RPM          ; Compare it value in RPM                                  (TOE_OFC_CALCS)
006214 7F6214 22 1C                       bhi  OFC_CHK_DONE ; If (X)<(M), branch to OFC_CHK_DONE:                      (TOE_OFC_CALCS)
                                                            ;(RPM is below minimum so no fuel cut                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - We have permissives for Overrun Fuel Cut. Check to see if OFC is already on and being (TOE_OFC_CALCS)
                                      ;   being commanded off.                                                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006216 7F6216 1F 10 E1 40 07                  brclr  engine,OFCon,OFC_EN_CHK ; If "OFCon" bit of "engine" bit field is clear, branch (TOE_OFC_CALCS)
                                                                             ; to OFC_EN_CHK: (OFC is off, check to see if it is (TOE_OFC_CALCS)
                                                                                                         ; being commanded on (TOE_OFC_CALCS)
00621B 7F621B 1F 10 DC 20 12              brclr PortAbits,OFCdis,OFC_CHK_DONE ; If "OFCdis" bit of "PortAbits" is clear (Low), (TOE_OFC_CALCS)
                                                                ; branch to OFC_CHK_DONE: (OFC is on and OFC disable switch is on, (TOE_OFC_CALCS)
                                                                                ; so disable fuel cut)                 (TOE_OFC_CALCS)
006220 7F6220 20 14                           bra  OFC_LOOP     ; branch to OFC_LOOP:(OFC is on, permissives are met and not being (TOE_OFC_CALCS)
                                                                ; commanded off, keep looping until permissives are no longer met (TOE_OFC_CALCS)
                                                                                ; or OFC has been commanded off)       (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - We have permissives for Overrun Fuel Cut and it is not being commanded off. Check to (TOE_OFC_CALCS)
                                      ;   see if OFC is off and being commanded on.                                    (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006222 7F6222                         OFC_EN_CHK:                                                                      (TOE_OFC_CALCS)
006222 7F6222 1E 10 E1 40 0F                  brset  engine,OFCon,OFC_LOOP   ; If "OFCon" bit of "engine" bit field is set, branch (TOE_OFC_CALCS)
                                                                             ; to OFC_LOOP: (OFC is already on so skip over) (TOE_OFC_CALCS)
006227 7F6227 1E 10 DC 10 0A              brset PortAbits,OFCen,OFC_LOOP ; "If OFCen" bit of "PortAbits" is set (High), branch to (TOE_OFC_CALCS)
                                                                             ; OFC_LOOP: (OFC enable switch is off so skip over) (TOE_OFC_CALCS)
00622C 7F622C 1C 10 E1 40                     bset engine,OFCon              ; Set "OFCon" bit of "engine" bit field (This bit will be tested (TOE_OFC_CALCS)
                                                                             ; in the final pulse width calculations, if set the pulse width (TOE_OFC_CALCS)
                                                                                             ; will be set to zero     (TOE_OFC_CALCS)
006230 7F6230 20 04                           bra  OFC_LOOP                  ; branch to OFC_LOOP:(keep looping until permissives are no (TOE_OFC_CALCS)
                                                                             ; longer met or OFC has been commanded off) (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Permissives have not or are no longer are being met or OFC has been commanded off. (TOE_OFC_CALCS)
                                      ;   Clear the flag.                                                              (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006232 7F6232                         OFC_CHK_DONE:                                                                    (TOE_OFC_CALCS)
006232 7F6232 1D 10 E1 40                     bclr engine,OFCon     ; Clear "OFCon" bit of "engine" bit field          (TOE_OFC_CALCS)
006236 7F6236                         OFC_LOOP:                                                                        (TOE_OFC_CALCS)
006236 7F6236 MACRO                       RUN_PW_CALCS      ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate injector pulse width for a running engine "PW" (mS x 10)           (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ;barocor:      ds 2 ; Barometric Pressure Correction (% x 10) (104)              (RUN_PW_CALCS)
                                      ;matcor:       ds 2 ; Manifold Air Temperature Correction (% x 10)(108)          (RUN_PW_CALCS)
                                      ;Mapx10:       ds 2 ; Manifold Absolute Pressure (KPAx10)(update every revolution) (24) (RUN_PW_CALCS)
                                      ;Ftrmx10:      ds 2 ; Fuel Trim (% x 10)(update every mSec)(+-20%) (36)          (RUN_PW_CALCS)
                                      ;WUEandASEcor: ds 2 ; The sum of WUEcor and ASEcor (% x 10)                      (RUN_PW_CALCS)
                                      ;veCurr:       ds 2 ; Current value in VE table (% x 10) (72)                    (RUN_PW_CALCS)
                                      ;PWcalc1:      ds 2 ; PW calculations result 1                                   (RUN_PW_CALCS)
                                      ;PWcalc2:      ds 2 ; PW calculations result 2                                   (RUN_PW_CALCS)
                                      ;PWcalc3:      ds 2 ; PW calculations result 3                                   (RUN_PW_CALCS)
                                      ;PWcalc4:      ds 2 ; PW calculations result 4                                   (RUN_PW_CALCS)
                                      ;PWcalc5:      ds 2 ; PW calculations result 5                                   (RUN_PW_CALCS)
                                      ;reqFuel:      ds 2 ; Pulse width for 14.7 AFR @ 100% VE (mS x 10)               (RUN_PW_CALCS)
                                      ;PWlessTOE:    ds 2 ; Injector pulse width before "TOEpw" and "Deadband" (mS x 10) (RUN_PW_CALCS)
                                      ;TOEpw:        ds 2 ; Throttle Opening Enrichment adder (mS x 100)               (RUN_PW_CALCS)
                                      ;Deadband:     ds 2 ; injector deadband at current battery voltage mS*100        (RUN_PW_CALCS)
                                      ;FDpw:         ds 2 ; Fuel Delivery pulse width (PW - Deadband) (mS x 10)        (RUN_PW_CALCS)
                                      ;PW:           ds 2 ; Running engine injector pulsewidth (mS x 10)               (RUN_PW_CALCS)
                                      ;PWtk:         ds 2 ; Running engine injector pulsewidth (uS x 2.56)(102)        (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Method:                                                                      (RUN_PW_CALCS)
                                      ;                                                                                (RUN_PW_CALCS)
                                      ; ("barocor" * "matcor") / 1000 = "PWcalc1" (0.1% resolution)                    (RUN_PW_CALCS)
                                      ; ("Mapx10" * "Ftrmx10") / 1000 = "PWcalc2" (0.1% resolution)                    (RUN_PW_CALCS)
                                      ; ("PWcalc1" * "PWcalc2") / 1000 = "PWcalc3" (0.1% resolution)                   (RUN_PW_CALCS)
                                      ; ("WUEandASEcor" * "veCurr") / 1000 = "PWcalc4" (0.1% resolution)               (RUN_PW_CALCS)
                                      ; ("PWcalc3" * "PWcalc4") / 1000 = "PWcalc5" (0.1% resolution)                   (RUN_PW_CALCS)
                                      ; ("PWcalc5" * reqFuel") / 1000 = "PWlessTOE" (0.1mS resolution)                 (RUN_PW_CALCS)
                                      ; "PWlessTOE" + "TOEpw" = "FDpw"  (0.1mS resolution)                             (RUN_PW_CALCS)
                                      ; "FDpw" + "Deadband" = "PW"  (0.1mS resolution)                                 (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate total corrections before Throttle Opening Enrichment and deadband. (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
006236 7F6236 1E 10 E1 40 02              brset engine,OFCon,NoPWrunCalcs1 ; if "OFCon" bit of "engine" bit field is set branch (RUN_PW_CALCS)
                                                                           ; to NoPWrunCalcs1: (In overrun fuel cut mode so (RUN_PW_CALCS)
                                                                           ; fall through)                             (RUN_PW_CALCS)
00623B 7F623B 20 03                       bra  PWrunCalcs    ; Branch to PWrunCalcs:                                   (RUN_PW_CALCS)
00623D 7F623D                         NoPWrunCalcs1:                                                                   (RUN_PW_CALCS)
00623D 7F623D 06 62 CE                    job  NoPWrunCalcs  ; Jump or branch to NoPWrunCalcs: (long branch)           (RUN_PW_CALCS)
006240 7F6240                         PWrunCalcs:                                                                      (RUN_PW_CALCS)
006240 7F6240 FC 10 AA                    ldd  barocor      ; "barocor" -> Accu D (% x 10)                             (RUN_PW_CALCS)
006243 7F6243 FD 10 AC                    ldy  matcor       ; "matcor" -> Accu D (% x 10)                              (RUN_PW_CALCS)
006246 7F6246 13                          emul              ; (D)*(Y)->Y:D "barocor" * "matcor"                        (RUN_PW_CALCS)
006247 7F6247 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
00624A 7F624A 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("barocor"*"matcor")/1000="PWcalc1" (RUN_PW_CALCS)
00624B 7F624B 7D 10 4B                        sty  PWcalc1      ; Result -> "PWcalc1"                                  (RUN_PW_CALCS)
00624E 7F624E FC 10 78                    ldd  Mapx10       ; "Mapx10" -> Accu D (% x 10)                              (RUN_PW_CALCS)
006251 7F6251 FD 10 94                    ldy  Ftrmx10      ; "Ftrmx10" -> Accu D (% x 10)                             (RUN_PW_CALCS)
006254 7F6254 13                          emul              ; (D)*(Y)->Y:D "Mapx10" * "Ftrmx10"                        (RUN_PW_CALCS)
006255 7F6255 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
006258 7F6258 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("Mapx10"*"Ftrmx10")/1000="PWcalc2" (RUN_PW_CALCS)
006259 7F6259 7D 10 4D                        sty  PWcalc2      ; Result -> "PWcalc2"                                  (RUN_PW_CALCS)
00625C 7F625C FC 10 4B                    ldd  PWcalc1      ; "PWcalc1" -> Accu D (% x 10)                             (RUN_PW_CALCS)
00625F 7F625F FD 10 4D                    ldy  PWcalc2      ; "PWcalc2" -> Accu D (% x 10)                             (RUN_PW_CALCS)
006262 7F6262 13                          emul              ; (D)*(Y)->Y:D "PWcalc1" * "PWcalc2"                       (RUN_PW_CALCS)
006263 7F6263 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
006266 7F6266 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("PWcalc1"*"PWcalc2")/1000="PWcalc3" (RUN_PW_CALCS)
006267 7F6267 7D 10 4F                        sty  PWcalc3      ; Result -> "PWcalc3"                                  (RUN_PW_CALCS)
00626A 7F626A FC 10 B2                    ldd  WUEandASEcor ; "WUEandASEcor" -> Accu D (% x 10)                        (RUN_PW_CALCS)
00626D 7F626D FD 10 A8                    ldy  veCurr       ; "veCurr" -> Accu D (% x 10)                              (RUN_PW_CALCS)
006270 7F6270 13                          emul              ; (D)*(Y)->Y:D "WUEandASEcor" * "veCurr"                   (RUN_PW_CALCS)
006271 7F6271 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
006274 7F6274 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("WUEandASEcor"*"veCurr")/1000="PWcalc4" (RUN_PW_CALCS)
006275 7F6275 7D 10 51                        sty  PWcalc4      ; Result -> "PWcalc4"                                  (RUN_PW_CALCS)
006278 7F6278 FC 10 4F                    ldd  PWcalc3      ; "PWcalc3" -> Accu D (% x 10)                             (RUN_PW_CALCS)
00627B 7F627B FD 10 51                    ldy  PWcalc4      ; "PWcalc4" -> Accu D (% x 10)                             (RUN_PW_CALCS)
00627E 7F627E 13                          emul              ; (D)*(Y)->Y:D "PWcalc3" * "PWcalc4"                       (RUN_PW_CALCS)
00627F 7F627F CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
006282 7F6282 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("PWcalc3"*"PWcalc4")/1000="PWcalc5" (RUN_PW_CALCS)
006283 7F6283 7D 10 53                        sty  PWcalc5      ; Result -> "PWcalc5"(total corrections before Throttle Opening (RUN_PW_CALCS)
                                                                ; Enrichment and deadband)                             (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate injector pulse width before Throttle Opening Enrichment pulse width and (RUN_PW_CALCS)
                                      ;   Deadband.                                                                    (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
006286 7F6286 FC 10 53                    ldd  PWcalc5      ; "PWcalc5" -> Accu D (% x 10)                             (RUN_PW_CALCS)
006289 7F6289 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (RUN_PW_CALCS)
00628E 7F628E CD 08 00                    ldy   #veBins_E   ; Load index register Y with address of first configurable (RUN_PW_CALCS)
                                                            ; constant on buffer RAM page 1 (veBins_E)                 (RUN_PW_CALCS)
006291 7F6291 EE EA 03 EC                 ldx   $03EC,Y     ; Load Accu X with value in buffer RAM page 1 (offset 1004)($03EC) (RUN_PW_CALCS)
                                                            ; ("reqFuel")                                              (RUN_PW_CALCS)
006295 7F6295 B7 56                       tfr  X,Y          ; "reqFuel" -> Accu Y                                      (RUN_PW_CALCS)
006297 7F6297 13                          emul              ; (D)*(Y)->Y:D "PWcalc5" * "reqfuel"                       (RUN_PW_CALCS)
006298 7F6298 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
00629B 7F629B 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("PWcalc5"*"reqFuel")/1000="PWlessTOE" (RUN_PW_CALCS)
00629C 7F629C 7D 10 BE                        sty  PWlessTOE    ; Result -> "PWlessTOE" (mS x 10)                      (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Add the Throttle Opening Enricment pulse width and store as "FDpw"(fuel delivery (RUN_PW_CALCS)
                                      ;   pulse width)(mS x 10)                                                        (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
00629F 7F629F B7 64                       tfr  Y,D          ; "PWlessTOE" -> Accu D                                    (RUN_PW_CALCS)
0062A1 7F62A1 F3 10 BC                        addd TOEpw        ; (A:B)+(M:M+1)->A:B ("PWlessTOE"+"TOEpw"="FDpw"       (RUN_PW_CALCS)
0062A4 7F62A4 7C 10 C6                        std  FDpw         ; Result -> "FDpw" (fuel delivery pulsewidth (mS x 10) (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Add "deadband" and store the result as "PW"(final injector pulsewidth)(mS x 10) (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
0062A7 7F62A7 F3 10 C0                        addd Deadband    ; (A:B)+(M:M+1)->A:B ("FDpw"+"Deadband"="PW"            (RUN_PW_CALCS)
0062AA 7F62AA 7C 10 C8                        std  PW          ; Result -> "PW" (final injector pulsewidth) (mS x 10)  (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Convert "PW" to timer ticks in 2.56uS resolution.                            (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
0062AD 7F62AD FC 10 C8                    ldd   PW         ; "PW" -> Accu D                                            (RUN_PW_CALCS)
0062B0 7F62B0 CD 27 10                        ldy   #$2710     ; Load index register Y with decimal 10000 (for integer math) (RUN_PW_CALCS)
0062B3 7F62B3 13                              emul             ;(D)x(Y)=Y:D "PW" * 10,000                              (RUN_PW_CALCS)
0062B4 7F62B4 CE 01 00                        ldx   #$100      ; Decimal 256 -> Accu X                                 (RUN_PW_CALCS)
0062B7 7F62B7 11                          ediv             ;(Y:D)/(X)=Y;Rem->D "PW" * 10,000 / 256 = "PWtk"            (RUN_PW_CALCS)
0062B8 7F62B8 7D 10 5B                    sty   PWtk       ; Copy result to "PWtk" (Running engine injector pulsewidth) (RUN_PW_CALCS)
                                                               ; (uS x 2.56)                                           (RUN_PW_CALCS)
0062BB 7F62BB 7D 10 5F                    sty   InjOCadd2  ; Second injector output compare adder (2.56uS res)         (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Injector duty cycle percentage is the time the injector takes to inject the fuel (RUN_PW_CALCS)
                                      ;   divided by the time available x 100. The time available is the engine cycle which is (RUN_PW_CALCS)
                                      ;   two crankshaft revolutions. It is important to know what our duty cycle is at high (RUN_PW_CALCS)
                                      ;   engine speeds and loads. 80% is considered a safe maximum. The crank angle period is (RUN_PW_CALCS)
                                      ;   measured over 72 degrees of crank rotation. In run mode the timer is set to a 2.56uS (RUN_PW_CALCS)
                                      ;   time base and the pulse width timer value is in 2.56uS resolution. The engine cycle (RUN_PW_CALCS)
                                      ;   period in 2.56uS resolution can be calculated by multiplying the period by 10, for (RUN_PW_CALCS)
                                      ;   the two revolutions in the cycle. The duty cycle percentage is calculated by (RUN_PW_CALCS)
                                      ;   dividing "PWtk" by the cycle period and dividing by 100.                     (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate injector duty cycle                                                (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
0062BE 7F62BE FC 10 5B                    ldd  PWtk           ; "PWtk"->Accu D                                         (RUN_PW_CALCS)
0062C1 7F62C1 CD 00 0A                    ldy  #$000A         ; Decimal 10-> Accu Y (for integer math)                 (RUN_PW_CALCS)
0062C4 7F62C4 13                              emul                ;(D)x(Y)=Y:D "PWtk"*10                               (RUN_PW_CALCS)
0062C5 7F62C5 FE 10 9C                    ldx  CASprd256      ; "CASprd256"-> Accu X (running period for 72 degrees rotation) (RUN_PW_CALCS)
0062C8 7F62C8 11                          ediv                ;(Y:D)/(X)=Y;Rem->D ("PWtk"*10)/"CASprd256"              (RUN_PW_CALCS)
0062C9 7F62C9 7D 10 E8                    sty  DutyCyclex10   ; Copy result to "DutyCyclex10" (Injector duty cycle x 10) (RUN_PW_CALCS)
0062CC 7F62CC 20 24                       bra  PWrunCalcsDone ; Branch to PWrunCalcsDone:                              (RUN_PW_CALCS)
0062CE 7F62CE                         NoPWrunCalcs:                                                                    (RUN_PW_CALCS)
0062CE 7F62CE 18 79 10 BE                 clrw  PWlessTOE     ; Clear "PWlessTOE" Injector PW before "TOEpw"+"Deadband"(mS x 10) (RUN_PW_CALCS)
0062D2 7F62D2 18 79 10 BC                 clrw  TOEpw         ; Clear "TOEpw" Throttle Opening Enrichment adder (mS x 100) (RUN_PW_CALCS)
0062D6 7F62D6 18 79 10 C6                 clrw  FDpw          ; Clear "FDpw" Fuel Delivery pulse width (PW - Deadband)(mS x 10) (RUN_PW_CALCS)
0062DA 7F62DA 18 79 10 C8                 clrw  PW            ; Clear "PW" Running engine injector pulsewidth (mS x 10) (RUN_PW_CALCS)
0062DE 7F62DE 18 79 10 5B                 clrw  PWtk          ; Clear "PWtk" Running injector pulsewidth timer ticks(uS x 2.56) (RUN_PW_CALCS)
0062E2 7F62E2 18 03 00 02 10 5D           movw  #$0002,InjOCadd1     ; First injector output compare adder (5.12uS res or 2.56uS res) (RUN_PW_CALCS)
0062E8 7F62E8 18 03 00 02 10 5F           movw  #$0002,InjOCadd2     ; Second injector output compare adder (5.12uS res or 2.56uS res) (RUN_PW_CALCS)
0062EE 7F62EE 18 79 10 E8                 clrw  DutyCyclex10  ; Clear "DutyCyclex10" Injector duty cycle in run mode (% x 10) (RUN_PW_CALCS)
0062F2 7F62F2                         PWrunCalcsDone:                                                                  (RUN_PW_CALCS)
0062F2 7F62F2 MACRO                       BARO_COR_LU       ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (BARO_COR_LU)
                                      ; - Look up current value in Barometric Correction Table (barocor)               (BARO_COR_LU)
                                      ;***************************************************************************************** (BARO_COR_LU)
0062F2 7F62F2 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (BARO_COR_LU)
0062F7 7F62F7 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (BARO_COR_LU)
                                                                  ; -> page where the desired curve resides            (BARO_COR_LU)
0062FD 7F62FD 18 03 01 68 10 27           movw #$0168,CrvRowOfst  ; 360 -> Offset from the curve page to the curve row(barCorVals) (BARO_COR_LU)
                                                                      ; (actual offset is 720)                         (BARO_COR_LU)
006303 7F6303 18 03 01 71 10 29           movw #$0171,CrvColOfst  ; 369 -> Offset from the curve page to the curve column(barCorDelta) (BARO_COR_LU)
                                                                      ; (actual offset is 738)                         (BARO_COR_LU)
006309 7F6309 18 04 10 84 10 2B           movw Barox10,CrvCmpVal  ; Barometric Pressure (KPAx10) -> Curve comparison value (BARO_COR_LU)
00630F 7F630F 18 0B 08 10 2D              movb #$08,CrvBinCnt     ; 8 -> number of bins in the curve row or column minus 1 (BARO_COR_LU)
006314 7F6314 16 6F 46                    jsr   CRV_LU_P   ; Jump to subroutine at CRV_LU_P:(located in interp_BEEM488.s module) (BARO_COR_LU)
006317 7F6317 7C 10 AA                    std   barocor    ; Copy result to Barometric correction (% x 10)             (BARO_COR_LU)
00631A 7F631A MACRO                       MAT_COR_LU        ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (MAT_COR_LU)
                                      ; - Look up current value in MAT Air Density Table (matcor)                      (MAT_COR_LU)
                                      ;***************************************************************************************** (MAT_COR_LU)
00631A 7F631A 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (MAT_COR_LU)
00631F 7F631F 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (MAT_COR_LU)
                                                                  ;  ->page where the desired curve resides            (MAT_COR_LU)
006325 7F6325 18 03 01 9A 10 27           movw #$019A,CrvRowOfst  ; 410 -> Offset from the curve page to the curve row(matCorrTemps2) (MAT_COR_LU)
                                                                      ; (actual offset is 820)                         (MAT_COR_LU)
00632B 7F632B 18 03 01 A3 10 29           movw #$01A3,CrvColOfst  ; 419 -> Offset from the curve page to the curve column(matCorrDelta2) (MAT_COR_LU)
                                                                      ; (actual offset is 838)                         (MAT_COR_LU)
006331 7F6331 18 04 10 70 10 2B           movw Matx10,CrvCmpVal   ; Manifold Air Temperature (Degrees F x 10) ->       (MAT_COR_LU)
                                                                  ; Curve comparison value                             (MAT_COR_LU)
006337 7F6337 18 0B 08 10 2D              movb #$08,CrvBinCnt     ; 8 -> number of bins in the curve row or column minus 1 (MAT_COR_LU)
00633C 7F633C 16 70 0F                    jsr   CRV_LU_NP  ; Jump to subroutine at CRV_LU_NP:(located in interp_BEEM488.s module) (MAT_COR_LU)
00633F 7F633F 7C 10 AC                    std   matcor     ; Copy result to Manifold Air Temperature Correction (% x 10) (MAT_COR_LU)
                                                            ; All of these Macro calls moved from the main loop in BPEM488.s
                                                            ; as a work around for random corrupted returns 5-4-21
006342 7F6342 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
006345 7F6345                         Notch_CT4_T6:
                                      ;*****************************************************************************************
                                      ; - If we are here the crankshaft is at 150 degrees before top dead centre on the
                                      ;   compression/power strokes for #9 cylinder. Start the hardware timer to delay the
                                      ;   coil dwell for spark #9, waste #8 if we are in run mode.
                                      ;*****************************************************************************************
006345 7F6345 MACRO                       FIRE_IGN3                 ; macro in Tim_BPEM488.s
                                                              ; (Will trigger an interrupt after the delay time)(LED off) (FIRE_IGN3)
                                      ;***************************************************************************************** (FIRE_IGN3)
                                      ; - PT5 - IOC5 OC5 Ign3(9&8) Control                                             (FIRE_IGN3)
                                      ;***************************************************************************************** (FIRE_IGN3)
                                      ;***************************************************************************************** (FIRE_IGN3)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_IGN3)
                                      ;***************************************************************************************** (FIRE_IGN3)
006345 7F6345 4C 48 08                    bset ECT_TCTL1,Bit3 ; Set Ch5 output line to 1 on compare                    (FIRE_IGN3)
006348 7F6348 4C 48 04                    bset ECT_TCTL1,Bit2 ; Set Ch5 output line to 1 on compare                    (FIRE_IGN3)
00634B 7F634B DC 44                       ldd  ECT_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_IGN3)
00634D 7F634D F3 10 41                    addd IgnOCadd1      ; Add "IgnOCadd1" (Delay time from crank signal to energise coil) (FIRE_IGN3)
006350 7F6350 5C 5A                       std  ECT_TC5H       ; Copy result to Timer IC/OC register 2 (Start OC operation) (FIRE_IGN3)
006352 7F6352 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
006355 7F6355                         Notch_CT4_T7:
                                      ;*****************************************************************************************
                                      ; - If we are here the crankshaft is at 150 degrees before top dead centre on the
                                      ;   compression/power strokes for #4 cylinder. Start the hardware timer to delay the coil
                                      ;   coil dwell for spark #4, waste #7 if we are in run mode.
                                      ;*****************************************************************************************
006355 7F6355 MACRO                       FIRE_IGN4                 ; macro in Tim_BPEM488.s
                                                              ; (Will trigger an interrupt after the delay time)(LED off) (FIRE_IGN4)
                                      ;***************************************************************************************** (FIRE_IGN4)
                                      ; - PT6 - IOC6 OC6 Ign4(4&7) Control                                             (FIRE_IGN4)
                                      ;***************************************************************************************** (FIRE_IGN4)
                                      ;***************************************************************************************** (FIRE_IGN4)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_IGN4)
                                      ;***************************************************************************************** (FIRE_IGN4)
006355 7F6355 4C 48 20                    bset ECT_TCTL1,Bit5 ; Set Ch6 output line to 1 on compare                    (FIRE_IGN4)
006358 7F6358 4C 48 10                    bset ECT_TCTL1,Bit4 ; Set Ch6 output line to 1 on compare                    (FIRE_IGN4)
00635B 7F635B DC 44                       ldd  ECT_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_IGN4)
00635D 7F635D F3 10 41                    addd IgnOCadd1      ; Add "IgnOCadd1" (Delay time from crank signal to energise coil) (FIRE_IGN4)
006360 7F6360 5C 5C                       std  ECT_TC6H       ; Copy result to Timer IC/OC register 2 (Start OC operation) (FIRE_IGN4)
006362 7F6362 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
006365 7F6365                         Notch_CT4_T8:
                                      ;*****************************************************************************************
                                      ; - If we are here the crankshaft is at 6 degrees before top dead centre on the
                                      ;   exhaust/intake strokes for #5 cylinder and 60 degrees before top dead centre on the
                                      ;   exhaust/intake strokes for #8 cylinder. #5 intake valve is just sstarting to open
                                      ;   and #8 intake valve is 54 degrees before it will start to open. Start the pulse
                                      ;   width for injectors 5&8.
                                      ;*****************************************************************************************
006365 7F6365 1E 10 E1 80 11              brset engine,FldClr,INJ4FldClr ; If "FldClr" bit of "engine" bit field is set branch
                                                                         ; to INJ4FldClr:
00636A 7F636A MACRO                       FIRE_INJ4                 ; Macro in Tim_BPEM488.s
                                                                  ; (Will trigger an interrupt after the delay time)(LED off) (FIRE_INJ4)
                                      ;***************************************************************************************** (FIRE_INJ4)
                                      ; - PP3 - TIM1 OC3(Inj4)(5&8) Control                                            (FIRE_INJ4)
                                      ;***************************************************************************************** (FIRE_INJ4)
                                      ;***************************************************************************************** (FIRE_INJ4)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_INJ4)
                                      ;***************************************************************************************** (FIRE_INJ4)
00636A 7F636A 1C 03 D9 40                 bset TIM_TCTL2,Bit6 ; Set Ch3 output line to 1 on compare                    (FIRE_INJ4)
00636E 7F636E 1C 03 D9 80                 bset TIM_TCTL2,Bit7 ; Set Ch3 output line to 1 on compare                    (FIRE_INJ4)
006372 7F6372 FC 03 D4                    ldd  TIM_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_INJ4)
006375 7F6375 F3 10 5D                    addd InjOCadd1      ; (A:B)+(M:M+1->A:B Add "InjOCadd1" (Delay from trigger to start (FIRE_INJ4)
                                                              ; of injection)                                          (FIRE_INJ4)
006378 7F6378 7C 03 E6                    std  TIM_TC3H       ; Copy result to Timer IC/OC register 3 (Start OC operation) (FIRE_INJ4)
00637B 7F637B                         INJ4FldClr:
                                      ;***********************************************************************************************
                                      ; - Update Fuel Delivery Pulse Width Total so the results can be used by Tuner Studio and
                                      ;   Shadow Dash to calculate current fuel burn.
                                      ;***********************************************************************************************
00637B 7F637B FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10)-> Accu D
00637E 7F637E F3 10 C6                    addd FDpw           ; (A:B)+(M:M+1->A:B Add  Fuel Delivery pulse width (mS x 10)
006381 7F6381 7C 10 D0                    std  FDt            ; Copy result to "FDT" (update "FDt")(mS x 10)
                                      ;***********************************************************************************************
                                      ; - Update the Fuel Delivery counter so that on roll over (65535mS)a pulsed signal can be sent to the
                                      ;   to the totalizer(open collector output)
                                      ;***********************************************************************************************
006384 7F6384 FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10)-> Accu D
006387 7F6387 F3 10 61                        addd FDcnt          ; (A:B)+(M:M+1)->A:B (fuel delivery pulsewidth + fuel delivery counter)
00638A 7F638A 25 05                       bcs  Totalizer4R     ; If the cary bit of CCR is set, branch to Totalizer4R: ("FDcnt"
                                                                  ;  rollover, pulse the totalizer)
00638C 7F638C 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
00638F 7F638F 20 0B                       bra  TotalizerDone4R ; Branch to TotalizerDone4R:
006391 7F6391                         Totalizer4R:
006391 7F6391 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
006394 7F6394 4C 01 08                    bset PORTB,AIOT     ; Set "AIOT" pin on Port B (PB6)(start totalizer pulse)
006397 7F6397 86 03                           ldaa #$03           ; Decimal 3->Accu A (3 mS)
006399 7F6399 7A 10 63                    staa AIOTcnt        ; Copy to "AIOTcnt" ( counter for totalizer pulse width,
                                                                  ; decremented every mS)
00639C 7F639C                         TotalizerDone4R:
00639C 7F639C 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
00639F 7F639F                         Notch_CT4_T9:
                                      ;*****************************************************************************************
                                      ; - No event
                                      ;*****************************************************************************************
00639F 7F639F MACRO                       ST_LU             ; Macro in igncalcs_BPEM.s
                                      ;***************************************************************************************** (ST_LU)
                                      ; For a 2.56uS timer 1 Sec = 1/.00000256 = 390625 tics                           (ST_LU)
                                      ; 1mS = 390625 / 1000 = 390.625 tics                                             (ST_LU)
                                      ; 0.1mS = 390.625 / 10 = 39.0625 tics                                            (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; 1 RPM/60 = .016666666 Rev per Sec                                              (ST_LU)
                                      ; 1/.016666666 = 60 sec period                                                   (ST_LU)
                                      ; 60/360 = .166666666 sec per degree at 1 RPM                                    (ST_LU)
                                      ; 60/5 = 12 sec Crank Angle Sensor period at 1 RPM                               (ST_LU)
                                      ; 12/.00000256 = 4687500 2.56uS tics at 1 RPM ("CASprdtk")                       (ST_LU)
                                      ; 4687500/72 = 65104.16667 2.56uS tics per degree at 1 RPM ("TkspDeg")           (ST_LU)
                                      ; .166666666/.00000256 = 65104.14063 2.56uS tics per degree at 1 RPM ("TkspDeg") (ST_LU)
                                      ; 1/65104.16667 = .000001528808485 degrees per tic at 1 RPM                      (ST_LU)
                                      ; 71.52666514/60 = 1.192111 Rev per Sec                                          (ST_LU)
                                      ; 1/1.192111 = .83884806 sec period                                              (ST_LU)
                                      ; .83884806/360 = .0023301335 sec per degree at 71.52666 RPM                     (ST_LU)
                                      ; .83884806/5 = .167769612 sec Crank Angle Sensor period at 71.52666 RPM         (ST_LU)
                                      ; .167769612/.00000256 = 65535 2.56uS tics at 71.52666 RPM ("CASprdtk")          (ST_LU)
                                      ; 65535/72 = 910.208333 2.56uS tics per degree at 71.52666 RPM ("TkspDeg")       (ST_LU)
                                      ; .0023301335/.00000256 = 910.2083984 2.56uS tics per degree at 71.52666 RPM ("TkspDeg") (ST_LU)
                                      ; 1/910.208333 = .001098649577 degrees per tic at 71.52666 RPM                   (ST_LU)
                                      ; 500 RPM/60 = 8.333333333 Rev per Sec                                           (ST_LU)
                                      ; 1/8.333333333 = .12 sec period                                                 (ST_LU)
                                      ; .12/360 = .0003333333 sec per degree at 500 RPM                                (ST_LU)
                                      ; .12/5 = .024 sec Crank Angle Sensor period at 500 RPM                          (ST_LU)
                                      ; .024/.00000256 = 9375 2.56uS tics at 500 RPM ("CASprdtk")                      (ST_LU)
                                      ; 9375/72 = 130.2083333 2.56uS tics per degree at 500 RPM ("TkspDeg")            (ST_LU)
                                      ; .0003333333/.00000256 = 130.2083203 2.56uS tics per degree at 500 RPM ("TkspDeg") (ST_LU)
                                      ; 1/130.2083333 = .00768 degrees per tic at 500 RPM                              (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; 4250 RPM/60 = 70.8333333 Rev per Sec                                           (ST_LU)
                                      ; 1/70.8333333 = .014117647 sec period                                           (ST_LU)
                                      ; .014117647/360 = .00003921568629 sec per degree at 4250 RPM                    (ST_LU)
                                      ; .014117647/5 = .0028235294 sec Crank Angle Sensor period at 5000 RPM           (ST_LU)
                                      ; .0028235294/.00000256 = 1102.941172 2.56uS tics at 5000 RPM ("CASprdtk")       (ST_LU)
                                      ; 1102.941172/72 = 15.31862739 2.56uS tics per degree at 4250 RPM ("TkspDeg")    (ST_LU)
                                      ; .00003921568629/.00000256 = 15.31862746 2.56uS tics per degree at 4250 RPM ("TkspDeg") (ST_LU)
                                      ; 1/15.31862739 = .06528 degrees per tic at 4250 RPM                             (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; Ignition crank notches are placed 150 degrees BTDC for their respective cylinder (ST_LU)
                                      ; Dwell times of .006sec crank and .004sec run seem to work well                 (ST_LU)
                                      ; Maximum ignition advance expected is 35 degrees BTDC at low load and high RPM  (ST_LU)
                                      ; From data logs cranking RPM is between ~154RPM and ~241RPM                     (ST_LU)
                                      ; Just before stall is ~251RPM                                                   (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; At 4250 RPM a 4mSec dwell time takes .004/.00003921568629 = 102 degrees of rotation (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; At power up the timers are initialized with a 5.12uS time base. A "Spantk"     (ST_LU)
                                      ; value of 65535 will happen at 84.441 RPM so this is the lowest RPM that can be (ST_LU)
                                      ; calculated during crank conditions. Resolution at 4250 RPM is 7.706 RPM. If the (ST_LU)
                                      ; time base were 2.56uS a "Spantk" value of 65535 will happen at 168.882 RPM.    (ST_LU)
                                      ; Resolution at 4250 RPM is 3.856 RPM. Cranking RPM can be lower than 168 RPM    (ST_LU)
                                      ; so this is why we begin with the 5.12uS base. When RPM reaches ~300 we are almost (ST_LU)
                                      ; ceratinly running so at that point the time base is switched to 2.56uS. This base (ST_LU)
                                      ; will allow ignition calculations to be done as low as ~169 RPM which is probably lower (ST_LU)
                                      ; than the speed at which the engine can be made to run.                         (ST_LU)
                                      ; With a time base of 5.12uS "CASprd512" of 7812 happens at 300 RPM. When the period gets (ST_LU)
                                      ; shorter than this the time base is switched over to 2.56uS ("CASprd256").      (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; - Ignition timing in degrees to 0.1 degree resolution is selected from the 3D  (ST_LU)
                                      ;   lookup table "ST" which plots manifold pressure against RPM. A potentiometer on the (ST_LU)
                                      ;   dash board allows a manual trim of the "ST" values of from 0 to 20 degrees advance (ST_LU)
                                      ;   and from 0 to 20 degrees retard. The ignition system is what is called "waste spark", (ST_LU)
                                      ;   which pairs cylinders on a single coil. The spark is delivered to both cylinders at (ST_LU)
                                      ;   the same time. One cylinder recieves the spark at the appropriate time for ignition. (ST_LU)
                                      ;   The other recieves it when the exhaust valve is open. Hence the name "waste spark". (ST_LU)
                                      ;   On this 10 cylinder engine there are 5 coils, each controlled by its own hardware (ST_LU)
                                      ;   timer. The cylinders are paired 1&6, 10&5, 9&8, 4&7, 3&2                     (ST_LU)
                                      ;   In an ignition event the timer is first loaded with the output compare value in (ST_LU)
                                      ;   "Delaytk". At the compare interrupt the coil is energised and the timer is loaded (ST_LU)
                                      ;   with the output compare value in "DwllFintk". At the compare interrupt the coil is (ST_LU)
                                      ;   de-energized to fire the spark. The delay in timer ticks will depend on the timer base (ST_LU)
                                      ;   rate of either 5.12 uS for cranking or 2.56uS for running.                   (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;  Crank Signal                                                                  (ST_LU)
                                      ;   150BTDC                          Ign                    20ATDC               (ST_LU)
                                      ;      <- Delay          -><- Dwell -><-      ST + Trim     ->                   (ST_LU)
                                      ;     I___________________I__________ I_______________________I                  (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;                          <-            Advance            ->                   (ST_LU)
                                      ;      <-            Ignition Span (170 degrees)            ->                   (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ; - Look up current value in ST table (STcurr) (degrees*10)                      (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
00639F 7F639F FE 10 78                    ldx   Mapx10     ; Load index register X with value in "Mapx10"(Column value Manifold (ST_LU)
                                                           ; Absolute Pressure*10 )                                    (ST_LU)
0063A2 7F63A2 FC 10 A0                    ldd   RPM        ; Load double accumulator D with value in "RPM" (Row value RPM) (ST_LU)
0063A5 7F63A5 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                   (ST_LU)
0063AA 7F63AA CD 08 00                    ldy   #stBins_E  ; Load index register Y with address of the first value in ST table (ST_LU)
0063AD 7F63AD 16 6E 77                    jsr   3D_LOOKUP  ; Jump to subroutine at 3D_LOOKUP:                          (ST_LU)
0063B0 7F63B0 7C 10 D2                    std   STcurr     ; Copy result to "STcurr"                                   (ST_LU)
0063B3 7F63B3 MACRO                       DWELL_COR_LU      ; Macro in igncalcs_BPEM.s
                                      ;***************************************************************************************** (DWELL_COR_LU)
                                      ; - Look up current value in Dwell Battery Adjustment Table (dwellcor)(% x 10)   (DWELL_COR_LU)
                                      ;***************************************************************************************** (DWELL_COR_LU)
0063B3 7F63B3 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (DWELL_COR_LU)
0063B8 7F63B8 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (DWELL_COR_LU)
                                                                  ;  ->page where the desired curve resides            (DWELL_COR_LU)
0063BE 7F63BE 18 03 01 7A 10 27           movw #$017A,CrvRowOfst  ; 378 -> Offset from the curve page to the curve row(dwellvolts) (DWELL_COR_LU)
                                                                      ;(actual offset is 756                           (DWELL_COR_LU)
0063C4 7F63C4 18 03 01 80 10 29           movw #$0180,CrvColOfst  ; 384 -> Offset from the curve page to the curve column(dwellcorr) (DWELL_COR_LU)
                                                                      ;(actual offset is 768)                          (DWELL_COR_LU)
0063CA 7F63CA 18 04 10 68 10 2B           movw BatVx10,CrvCmpVal  ; Battery Voltage (Volts x 10) -> Curve comparison value (DWELL_COR_LU)
0063D0 7F63D0 18 0B 05 10 2D              movb #$05,CrvBinCnt     ; 5 -> number of bins in the curve row or column minus 1 (DWELL_COR_LU)
0063D5 7F63D5 16 6F 46                    jsr   CRV_LU_P   ; Jump to subroutine at CRV_LU_P:(located in interp_BEEM488.s module) (DWELL_COR_LU)
0063D8 7F63D8 7C 10 D6                    std   DwellCor   ; Copy result to Dwell battery correction (% x 10)          (DWELL_COR_LU)
0063DB 7F63DB MACRO                       VE_LU             ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (VE_LU)
                                      ; The base value for injector pulse width calculations in mS to 0.1mS resolution is called (VE_LU)
                                      ; "ReqFuel". It represents the pulse width reqired to achieve 14.7:1 Air/Fuel Ratio at (VE_LU)
                                      ; 100% volumetric efficiency. The VE table contains percentage values to 0.1 percent (VE_LU)
                                      ; resolultion and plots intake manifold pressure in KPA to 0.1KPA resolution against RPM. (VE_LU)
                                      ; These values are part of the injector pulse width calculations for a running engine. (VE_LU)
                                      ;***************************************************************************************** (VE_LU)
                                      ;***************************************************************************************** (VE_LU)
                                      ; - Look up current value in VE table (veCurr)(%x10)                             (VE_LU)
                                      ;***************************************************************************************** (VE_LU)
0063DB 7F63DB FE 10 78                    ldx   Mapx10     ; Load index register X with value in "Mapx10"(Column value Manifold (VE_LU)
                                                           ; Absolute Pressure x 10 )                                  (VE_LU)
0063DE 7F63DE FC 10 A0                    ldd   RPM        ; Load double accumulator D with value in "RPM" (Row value RPM) (VE_LU)
0063E1 7F63E1 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (VE_LU)
0063E6 7F63E6 CD 08 00                    ldy   #veBins_E    ; Load index register Y with address of the first value in VE table (VE_LU)
                                                           ;(in RAM)                                                   (VE_LU)
0063E9 7F63E9 16 6E 77                    jsr   3D_LOOKUP  ; Jump to subroutine at 3D_LOOKUP:                          (VE_LU)
0063EC 7F63EC 7C 10 A8                    std   VEcurr     ; Copy result to "VEcurr"(%x10)                             (VE_LU)
0063EF 7F63EF MACRO                       AFR_LU            ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (AFR_LU)
                                      ; The Air/Fuel Ratio of the fuel mixture affects how an engine will run. Generally (AFR_LU)
                                      ; speaking AFRs of less than ~7:1 are too rich to ignite. Ratios of greater than ~20:1 are (AFR_LU)
                                      ; too lean to ignite. Stoichiometric ratio is at ~14.7:1. This is the ratio at which all (AFR_LU)
                                      ; the fuel and all the oxygen are consumed and is best for emmisions concerns. Best power (AFR_LU)
                                      ; is obtained between ratios of ~12:1 and ~13:1. Best economy is obtained as lean as ~18:1 (AFR_LU)
                                      ; in some engines. This controller runs in open loop so the AFR numbers are used as (AFR_LU)
                                      ; a tuning aid only.                                                             (AFR_LU)
                                      ;***************************************************************************************** (AFR_LU)
                                      ;***************************************************************************************** (AFR_LU)
                                      ; - Look up current value in AFR table (afrCurr)(AFRx10)                         (AFR_LU)
                                      ;***************************************************************************************** (AFR_LU)
0063EF 7F63EF FE 10 78                    ldx   Mapx10     ; Load index register X with value in "Mapx10"(Column value Manifold (AFR_LU)
                                                           ; Absolute Pressure x 10 )                                  (AFR_LU)
0063F2 7F63F2 FC 10 A0                    ldd   RPM        ; Load double accumulator D with value in "RPM" (Row value RPM) (AFR_LU)
0063F5 7F63F5 18 0B FD 00 17              movb  #(BUF_RAM_P3_START>>16),EPAGE  ; Move $FD into EPAGE                   (AFR_LU)
0063FA 7F63FA CD 08 00                    ldy   #afrBins_E   ; Load index register Y with address of the first value in AFR table (AFR_LU)
                                                           ;(in RAM)                                                   (AFR_LU)
0063FD 7F63FD 16 6E 77                    jsr   3D_LOOKUP  ; Jump to subroutine at 3D_LOOKUP:                          (AFR_LU)
006400 7F6400 7C 10 A6                    std   AFRcurr    ; Copy result to "AFRcurr"                                  (AFR_LU)
006403 7F6403 MACRO                       TOE_OFC_CALCS     ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - When the engine is running and the throttle is opened quickly a richer mixture is (TOE_OFC_CALCS)
                                      ;   required for a short period of time. This additional pulse width time is called (TOE_OFC_CALCS)
                                      ;   Throttle Opening Enrichment. Conversly, when the engine is in over run       (TOE_OFC_CALCS)
                                      ;   conditions no fuel is required so the injectors can be turned off, subject to (TOE_OFC_CALCS)
                                      ;   permissives. This condtion is call Overrun Fuel Cut.                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check to see if the throttle is opening or if it is at steady state or closing (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
006403 7F6403                         TOE_OFC_CHK:                                                                     (TOE_OFC_CALCS)
006403 7F6403 FE 10 7C                    ldx   TpsPctx10       ; Load index register X with value in "TpsPctx10"      (TOE_OFC_CALCS)
006406 7F6406 BE 10 45                    cpx   TpsPctx10last   ; (X)-(M:M+1)Compare with value in "TpsPctx10last"     (TOE_OFC_CALCS)
006409 7F6409 18 23 01 84                 bls   OFC_CHK         ; If "TpsPctx10" is equal to or less than "TpsPctx10last" branch to (TOE_OFC_CALCS)
                                                                    ; OFC_CHK:(Throttle is steady or closing so check for OFC permissives) (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Current Throttle position percent - throttle position percent 100mS ago = throttle position (TOE_OFC_CALCS)
                                      ;   percent difference over time in seconds "TpsPctx10" - "TpsPctx10last" = "TpsPctDOT" (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
00640D 7F640D 18 B0 10 45                 subx  TpsPctx10last   ; (X)-(M:M-1)=>X Subtract "TpsPctx10last" from "TpsPctx10" (TOE_OFC_CALCS)
006411 7F6411 7E 10 B6                    stx   TpsPctDOT       ; Copy result to "TpsPctDOT"                           (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - The throttle is opening. Check to see if it is opening at a rate greater than the threshold (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
006414 7F6414 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006419 7F6419 CD 08 00                    ldy   #veBins_E       ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                                ; on buffer RAM page 1 (veBins_E)                      (TOE_OFC_CALCS)
00641C 7F641C EE EA 03 D0                 ldx   $03D0,Y         ; Load Accu D with value in buffer RAM page 1 offset 976 (tpsThresh) (TOE_OFC_CALCS)
                                                                ;(TPSdot threshold)(offset = 976)($03D0)               (TOE_OFC_CALCS)
006420 7F6420 BE 10 B6                    cpx   TpsPctDOT       ; Compare "tpsThresh" with "TpsPctDOT"                 (TOE_OFC_CALCS)
006423 7F6423 18 22 01 3D                 bhi   TOE_CHK_TIME    ; If "tpsThresh" is greater than "TpsPctDOT", branch to TOE_CHK_TIME: (TOE_OFC_CALCS)
                                                                ; ("TpsPctDOT" below threshold so check if acceleration is done) (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - The throttle is opening at a rate greater then the threshold. Check to see if TOE is in (TOE_OFC_CALCS)
                                      ;   progress.                                                                    (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
006427 7F6427 1E 10 E1 20 2D              brset engine,TOEon,TOE_CALC ; If "TOEon" bit of "engine" bit field           (TOE_OFC_CALCS)
                                                                ; is set, branch to TOE_CALC: (TOE in progress)        (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ;- The throttle is opening at a rate greater than the threshold and TOE is not in progress (TOE_OFC_CALCS)
                                      ;  so prepare to add in the enrichement.                                         (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
00642C 7F642C 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006431 7F6431 CD 08 00                    ldy   #veBins_E       ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                              ; on buffer RAM page 1 (veBins_E)                        (TOE_OFC_CALCS)
006434 7F6434 EC EA 03 BC                 ldd  $03BC,Y        ; Load Accu D with value in buffer RAM page 1 (offset 956) (First element (TOE_OFC_CALCS)
                                                              ; of "TOEbins" table)(Start with first element, will determine actual (TOE_OFC_CALCS)
                                                              ; next time around)                                      (TOE_OFC_CALCS)
006438 7F6438 7B 10 BB                    stab   TOEpct       ; Copy to Throttle Opening Enrichment percent(used in later calculations) (TOE_OFC_CALCS)
00643B 7F643B 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006440 7F6440 CD 08 00                    ldy   #veBins_E     ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                              ; on buffer RAM page 1 (veBins_E)                        (TOE_OFC_CALCS)
006443 7F6443 EC EA 03 D2                 ldd   $03D2,Y       ; Load Accu D with value in buffer RAM page 1 offset 978 (TOEtime_F) (TOE_OFC_CALCS)
006447 7F6447 7B 10 CF                    stab  TOEdurCnt     ; Copy to "TOEdurCnt" (Throttle Opening Enrichment duration (TOE_OFC_CALCS)
                                                                  ; (decremented every 100 mS))                        (TOE_OFC_CALCS)
00644A 7F644A 1C 10 E1 20                 bset  engine,TOEon  ; Set "TOEon" bit of "engine" variable (in TOE mode)     (TOE_OFC_CALCS)
00644E 7F644E 1C 10 E2 08                 bset  engine2,TOEduron  ; Set "TOEduron" bit of "engine2" variable (TOE duration) (TOE_OFC_CALCS)
006452 7F6452 1D 10 E1 40                 bclr  engine,OFCon  ; Clear "OFCon" bit of "engine" variable (not in OFC mode) (TOE_OFC_CALCS)
006456 7F6456 06 65 D3                    job   OFC_LOOP      ; Jump or branch to OFC_LOOP:(fall through)              (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Calculate the cold temperature add-on enrichment "ColdAddpct" (%) from -39.72 (TOE_OFC_CALCS)
                                      ;   degrees to 179.9 degrees.                                                    (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
006459 7F6459                         TOE_CALC:                                                                        (TOE_OFC_CALCS)
006459 7F6459 FC 10 6A                    ldd  cltAdc       ; "cltAdc" -> D                                            (TOE_OFC_CALCS)
00645C 7F645C 8C 00 93                    cpd  #$0093       ; Compare "cltADC" with decimal 147(ADC @ 179.9F)          (TOE_OFC_CALCS)
00645F 7F645F 23 02                       bls  RailColdAdd  ; If "cltADC" is lower or the same as 147, branch to RailColdAdd: (TOE_OFC_CALCS)
006461 7F6461 20 05                       bra  DoColdAdd    ; Branch to DoColdAdd:                                     (TOE_OFC_CALCS)
006463 7F6463                         RailColdAdd:                                                                     (TOE_OFC_CALCS)
006463 7F6463 79 10 B9                    clr   ColdAddpct   ; Clear "ColdAddpct" (no cold adder)                      (TOE_OFC_CALCS)
006466 7F6466 20 3C                       bra   ColdAddDone  ; Branch to ColdAddDone: (skip over)                      (TOE_OFC_CALCS)
006468 7F6468                         DoColdAdd:                                                                       (TOE_OFC_CALCS)
006468 7F6468 CC 00 93                    ldd  #$0093      ; Load double accumulator with decimal 147 (ADC @ 179.9F)   (TOE_OFC_CALCS)
00646B 7F646B 3B                          pshd             ; Push to stack (V1)                                        (TOE_OFC_CALCS)
00646C 7F646C FC 10 6A                    ldd  cltAdc      ; Load double accumulator with "cltAdc"                     (TOE_OFC_CALCS)
00646F 7F646F 3B                          pshd             ; Push to stack (V)                                         (TOE_OFC_CALCS)
006470 7F6470 CC 03 EB                    ldd  #$03EB      ; Load double accumulator with decimal 1003 (ADC @ -39.72F) (TOE_OFC_CALCS)
006473 7F6473 3B                          pshd             ; Push to stack (V2)                                        (TOE_OFC_CALCS)
006474 7F6474 CC 00 00                    ldd  #$0000      ; Load double accumulator with decimal 0 (added amount at 179.9F) (TOE_OFC_CALCS)
006477 7F6477 3B                          pshd             ; Push to stack (Z1)                                        (TOE_OFC_CALCS)
006478 7F6478 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
00647D 7F647D CD 08 00                    ldy   #veBins_E    ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                           ; on buffer RAM page 1 (veBins_E)                           (TOE_OFC_CALCS)
006480 7F6480 EC EA 03 D4                 ldd   $03D4,Y    ; Load Accu D with value in buffer RAM page 1 (ColdAdd_F)(offset 980) (TOE_OFC_CALCS)
                                                           ;(added amount at -39.72F)                                  (TOE_OFC_CALCS)
006484 7F6484 3B                          pshd             ; Push to stack (Z2)                                        (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z2       |  SP+ 0                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z1       |  SP+ 2                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V2       |  SP+ 4                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V        |  SP+ 6                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V1       |  SP+ 8                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                      ;                     V      V1      V2      Z1    Z2                            (TOE_OFC_CALCS)
006485 7F6485 MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; ==========================                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ; result: D: interpolated result                                                 (TOE_OFC_CALCS/2D_IPOL)
                                      ; SSTACK: none                                                                   (TOE_OFC_CALCS/2D_IPOL)
                                      ;         no registers are preserved                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    ^ V                                                                         (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                                                                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z2+....................*                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                    :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   :       :        :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006485 7F6485 EC 86                                   LDD       \1    ; load V                                         (TOE_OFC_CALCS/2D_IPOL)
006487 7F6487 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
006489 7F6489 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
00648B 7F648B EC 80                                   LDD       \5    ; load Z2                                        (TOE_OFC_CALCS/2D_IPOL)
00648D 7F648D A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
00648F 7F648F 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (TOE_OFC_CALCS/2D_IPOL)
006491 7F6491 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006493 7F6493 EC 84                                   LDD       \3    ; load V2                                        (TOE_OFC_CALCS/2D_IPOL)
006495 7F6495 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
006497 7F6497 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (TOE_OFC_CALCS/2D_IPOL)
                                      ;*********************************************************************           (TOE_OFC_CALCS/2D_IPOL)
006499 7F6499 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (TOE_OFC_CALCS/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (TOE_OFC_CALCS/2D_IPOL)
00649B 7F649B B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
00649D 7F649D E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Free stack space (result in D)                                               (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
00649F 7F649F 1B 8A                       leas  10,SP       ; Stack pointer -> bottom of stack                         (TOE_OFC_CALCS)
0064A1 7F64A1 7B 10 B9                    stab  ColdAddpct  ; Copy result to "ColdAddpct" (%)(bins are byte values)    (TOE_OFC_CALCS)
0064A4 7F64A4                         ColdAddDone:                                                                     (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Calculate the cold temperature multiplier enrichment "ColdMulpct" (%), from -39.72 degrees (TOE_OFC_CALCS)
                                      ;   to 179.9 degrees.                                                            (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
0064A4 7F64A4 FC 10 6A                    ldd  cltADC       ; "cltADC" -> D                                            (TOE_OFC_CALCS)
0064A7 7F64A7 8C 00 93                    cpd  #$0093       ; Compare "cltADC" with decimal 147(ADC @ 179.9F)          (TOE_OFC_CALCS)
0064AA 7F64AA 23 02                       bls  RailColdMul  ; If "cltADC" is lower or the same as 147, branch to RailColdMul: (TOE_OFC_CALCS)
0064AC 7F64AC 20 07                       bra  DoColdMul    ; Branch to DoColdMul: (skip over)                         (TOE_OFC_CALCS)
0064AE 7F64AE                         RailColdMul:                                                                     (TOE_OFC_CALCS)
0064AE 7F64AE 18 0B 64 10 BA             movb #$64,ColdMulpct  ; Decimal 100 -> "ColdMulpct" (100% = no multiplier))   (TOE_OFC_CALCS)
0064B3 7F64B3 20 3C                      bra   ColdMulDone     ; Branch to ColdMulDone: (skip over)                    (TOE_OFC_CALCS)
0064B5 7F64B5                         DoColdMul:                                                                       (TOE_OFC_CALCS)
0064B5 7F64B5 CC 00 93                    ldd  #$0093      ; Load double accumulator with decimal 147 (ADC @ 179.9F)   (TOE_OFC_CALCS)
0064B8 7F64B8 3B                          pshd             ; Push to stack (V1)                                        (TOE_OFC_CALCS)
0064B9 7F64B9 FC 10 6A                    ldd  cltAdc      ; Load double accumulator with "cltAdc"                     (TOE_OFC_CALCS)
0064BC 7F64BC 3B                          pshd             ; Push to stack (V)                                         (TOE_OFC_CALCS)
0064BD 7F64BD CC 03 EB                    ldd  #$03EB      ; Load double accumulator with decimal 1003 (ADC @ -39.72F) (TOE_OFC_CALCS)
0064C0 7F64C0 3B                          pshd             ; Push to stack (V2)                                        (TOE_OFC_CALCS)
0064C1 7F64C1 CC 00 64                    ldd  #$0064      ; Load double accumulator with decimal 100 (multiplier amount at 179.9F) (TOE_OFC_CALCS)
                                                           ;(1.00 multiplier at 180 degrees)                           (TOE_OFC_CALCS)
0064C4 7F64C4 3B                          pshd             ; Push to stack (Z1)                                        (TOE_OFC_CALCS)
0064C5 7F64C5 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
0064CA 7F64CA CD 08 00                    ldy   #veBins_E    ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                           ; on buffer RAM page 1 (veBins_E)                           (TOE_OFC_CALCS)
0064CD 7F64CD EC EA 03 D6                 ldd   $03D6,Y    ; Load Accu D with value in buffer RAM page 1 "ColdMul_F"(offset 982) (TOE_OFC_CALCS)
                                                           ;(added amount at -39.72F)                                  (TOE_OFC_CALCS)
0064D1 7F64D1 3B                          pshd             ; Push to stack (Z2)                                        (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z2       |  SP+ 0                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z1       |  SP+ 2                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V2       |  SP+ 4                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V        |  SP+ 6                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V1       |  SP+ 8                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                      ;                     V      V1      V2      Z1    Z2                            (TOE_OFC_CALCS)
0064D2 7F64D2 MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; ==========================                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ; result: D: interpolated result                                                 (TOE_OFC_CALCS/2D_IPOL)
                                      ; SSTACK: none                                                                   (TOE_OFC_CALCS/2D_IPOL)
                                      ;         no registers are preserved                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    ^ V                                                                         (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                                                                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z2+....................*                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                    :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   :       :        :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
0064D2 7F64D2 EC 86                                   LDD       \1    ; load V                                         (TOE_OFC_CALCS/2D_IPOL)
0064D4 7F64D4 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
0064D6 7F64D6 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
0064D8 7F64D8 EC 80                                   LDD       \5    ; load Z2                                        (TOE_OFC_CALCS/2D_IPOL)
0064DA 7F64DA A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
0064DC 7F64DC 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (TOE_OFC_CALCS/2D_IPOL)
0064DE 7F64DE B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
0064E0 7F64E0 EC 84                                   LDD       \3    ; load V2                                        (TOE_OFC_CALCS/2D_IPOL)
0064E2 7F64E2 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
0064E4 7F64E4 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (TOE_OFC_CALCS/2D_IPOL)
                                      ;*********************************************************************           (TOE_OFC_CALCS/2D_IPOL)
0064E6 7F64E6 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (TOE_OFC_CALCS/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (TOE_OFC_CALCS/2D_IPOL)
0064E8 7F64E8 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
0064EA 7F64EA E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Free stack space (result in D)                                               (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
0064EC 7F64EC 1B 8A                      leas  10,SP         ; Stack pointer -> bottom of stack                        (TOE_OFC_CALCS)
0064EE 7F64EE 7B 10 BA                   stab   ColdMulpct   ; Copy result to "ColdMulpct" (%) (bins are byte values)  (TOE_OFC_CALCS)
0064F1 7F64F1                         ColdMulDone:                                                                     (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; First determine "TpsPctDOT" ("TpsPctx10" - "TpsPctx10last") (both updated every 100mS (TOE_OFC_CALCS)
                                      ; in rti_BEEM488.s)                                                              (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
0064F1 7F64F1 FE 10 7C                   ldx   TpsPctx10         ; "TpsPctx10" -> Accu X                               (TOE_OFC_CALCS)
0064F4 7F64F4 18 B0 10 45                subx  TpsPctx10last     ; (X)-(M:M+1)=>X Subtract "TpsPctx10last" from "TpsPctx10" (TOE_OFC_CALCS)
0064F8 7F64F8 7E 10 B6                   stx   TpsPctDOT         ; Copy result to "TpsPctDOT" (%/Sec)                  (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Look up current value in Throttle Opening Enrichment Table (TpsDOTcor)(%)(byte value) (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
0064FB 7F64FB 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006500 7F6500 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr    ; Address of the first value in VE table(in RAM)(page pointer) (TOE_OFC_CALCS)
                                                                   ; ->page where the desired curve resides            (TOE_OFC_CALCS)
006506 7F6506 18 03 01 E2 10 27           movw #$01E2,CrvRowOfst   ; 482 -> Offset from the curve page to the curve row (TOE_OFC_CALCS)
                                                                       ; (TOERates_F)(actual offset is 964)($03C4)     (TOE_OFC_CALCS)
00650C 7F650C 18 03 01 DE 10 29           movw #$01DE,CrvColOfst   ; 478 -> Offset from the curve page to the curve column (TOE_OFC_CALCS)
                                                                       ; (TOEBins_F)(actual offset is 956)($03BC)      (TOE_OFC_CALCS)
006512 7F6512 18 04 10 B6 10 2B           movw TpsPctDOT,CrvCmpVal ; TPS% difference over time (%/Sec)(update every 100mSec) (TOE_OFC_CALCS)
                                                                   ; -> Curve comparison value                         (TOE_OFC_CALCS)
006518 7F6518 18 0B 03 10 2D              movb #$03,CrvBinCnt      ; 3 -> number of bins in the curve row or column minus 1 (TOE_OFC_CALCS)
00651D 7F651D 16 6F 46                    jsr  CRV_LU_P            ; Jump to subroutine at CRV_LU_P:(located in interp_BEEM488.s module) (TOE_OFC_CALCS)
006520 7F6520 7B 10 B8                    stab TpsDOTcor           ; Copy result to TpsDOTcor (%)(byte value)          (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Multiply "TpsDOTcor" by "ColdMulpct" and divide by 100                       (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006523 7F6523 B6 10 B8                    ldaa  TpsDOTcor      ; "TpsDOTcor" -> A (%)                                  (TOE_OFC_CALCS)
006526 7F6526 F6 10 BA                    ldab  ColdMulpct     ; "ColdMulpct" -> B (%)                                 (TOE_OFC_CALCS)
006529 7F6529 12                          mul                  ; (A)x(B)->A:B (TpsDOTcor x ColdMulpct) result in D     (TOE_OFC_CALCS)
00652A 7F652A CE 00 64                    ldx   #$0064         ; Decimal 100 -> X                                      (TOE_OFC_CALCS)
00652D 7F652D 18 10                       idiv                 ; (D)/(X)->(X)rem(D) ((TpsDOTcor x ColdMulpct)/100)(%)  (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check the remainder and round up if >=5                                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
00652F 7F652F 8C 00 05                    cpd   #$0005         ; Compare idiv remainder with decimal 5                 (TOE_OFC_CALCS)
006532 7F6532 2F 05                       ble   NO_ROUND_UP    ; If remainder of idiv <= 5, branch to NO_ROUND_UP:     (TOE_OFC_CALCS)
006534 7F6534 B7 50                       tfr   X,A            ; idiv result -> A                                      (TOE_OFC_CALCS)
006536 7F6536 42                          inca                 ; idiv result + 1 -> A (round up)                       (TOE_OFC_CALCS)
006537 7F6537 20 02                       bra   ADD_COLDADD    ; Branch to ADD_COLDADD:(fall through)                  (TOE_OFC_CALCS)
006539 7F6539                         NO_ROUND_UP:                                                                     (TOE_OFC_CALCS)
006539 7F6539 B7 50                       tfr   X,A            ; idiv result -> A                                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Add the result with "ColdAddpct". Compare the result with the current "TOEpct" and (TOE_OFC_CALCS)
                                      ;   and save the highest value as "TOEpct". This is the final TOE value(%)       (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
00653B 7F653B                         ADD_COLDADD:                                                                     (TOE_OFC_CALCS)
00653B 7F653B BB 10 B9                    adda  ColdAddpct     ; (A)+(M)->(A) (("TpsDOTcor" * ColdMulpct)/100) + "ColdAddpct") (TOE_OFC_CALCS)
00653E 7F653E 7A 10 F9                    staa  tmp5b           ; Copy to "tmp5b"(("TpsDOTcor" * ColdMulpct)/100) + "ColdAddpct") (TOE_OFC_CALCS)
006541 7F6541 B1 10 BB                    cmpa  TOEpct         ; Compare result with "TOEpct"                          (TOE_OFC_CALCS)
006544 7F6544 25 1E                       blo   TOE_CHK_TIME   ; If (A) is less than (M), branch to TOE_CHK_TIME: (result (TOE_OFC_CALCS)
                                                               ; < "TOEpct" so use this value for "TOEpct" and check if (TOE_OFC_CALCS)
                                                                                       ; acceleration is done)         (TOE_OFC_CALCS)
006546 7F6546 B6 10 F9                    ldaa  tmp5b          ; "tmp5b" -> A(("TpsDOTcor" * ColdMulpct)/100) + "ColdAddpct") (TOE_OFC_CALCS)
006549 7F6549 7A 10 BB                    staa  TOEpct         ; Copy result to "TOEpct"(result is higher than current (TOE_OFC_CALCS)
                                                               ; so update TOEpct with the higher value)               (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Calculate the Throttle Opening Enrichment adder for PW calculations.         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
00654C 7F654C 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006551 7F6551 CD 08 00                    ldy   #veBins_E   ; Load index register Y with address of first configurable (TOE_OFC_CALCS)
                                                            ; constant on buffer RAM page 1 (veBins_E)                 (TOE_OFC_CALCS)
006554 7F6554 EC EA 03 EC                 ldd   $03EC,Y     ; Load Accu D with value in buffer RAM page 1 (offset 1004)($03EC) (TOE_OFC_CALCS)
                                                            ; ("reqFuel" in Accu B)                                    (TOE_OFC_CALCS)
006558 7F6558 B6 10 BB                    ldaa  TOEpct      ; "TOEpct" -> Accu D (%)                                   (TOE_OFC_CALCS)
00655B 7F655B 12                          mul               ;(A)x(B)->A:B (reqFuel" x "TOEpct")                        (TOE_OFC_CALCS)
00655C 7F655C CE 00 64                        ldx  #$0064       ; Decimal 100 -> Accu X                                (TOE_OFC_CALCS)
00655F 7F655F 18 10                       idiv              ;(D)/(X)->X:rem->D (reqFuel" x "TOEpct")/10                (TOE_OFC_CALCS)
006561 7F6561 7E 10 BC                    stx  TOEpw        ; Result -> "TOEpw" TOE adder (mS x 10)                    (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check to see if Throttle Opening Enrichment is done.                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006564 7F6564                          TOE_CHK_TIME:                                                                   (TOE_OFC_CALCS)
006564 7F6564 1E 10 E1 40 07              brset  engine,OFCon,RESET_TOE ; If Overrun Fuel Cut bit of "Engine" bit field is set, (TOE_OFC_CALCS)
                                                                        ; branch to RESET_TOE:                         (TOE_OFC_CALCS)
006569 7F6569 B6 10 CF                     ldaa  TOEdurCnt    ; "TOEdurCnt" -> Accu A                                  (TOE_OFC_CALCS)
00656C 7F656C 27 02                            beq   RESET_TOE    ; If "TOEdurCnt" = zero branch to RESET_TOE:(timer has timed out) (TOE_OFC_CALCS)
00656E 7F656E 20 1F                            bra   TOE_LOOP     ; Branch to "TOE_LOOP:(Timer hasn't timed out yet)   (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - The throttle is no longer opening and the duration timer has timed out so clear (TOE_OFC_CALCS)
                                      ;    "TOEpct" and the "TOEon" bit of "engine" bit field.                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006570 7F6570                         RESET_TOE:                                                                       (TOE_OFC_CALCS)
006570 7F6570 1D 10 E1 20                 bclr  engine,TOEon      ; Clear "TOEon" bit of "engine" bit field            (TOE_OFC_CALCS)
006574 7F6574 1D 10 E2 08                 bclr  engine2,TOEduron  ; Clear "TOEduron" bit of "engine2" variable (TOE duration) (TOE_OFC_CALCS)
006578 7F6578 79 10 BB                    clr   TOEpct            ; Clear Throttle Opening Enrichment (%)              (TOE_OFC_CALCS)
00657B 7F657B 79 10 B9                    clr   ColdAddpct        ; Clear Throttle Opening Enrichment cold adder (%)   (TOE_OFC_CALCS)
00657E 7F657E 79 10 BA                    clr   ColdMulpct        ; Clear Throttle Opening Enrichment cold multiplier (%) (TOE_OFC_CALCS)
006581 7F6581 79 10 B8                    clr   TpsDOTcor         ; Clear Throttle Opening Enrichment table value(%)   (TOE_OFC_CALCS)
006584 7F6584 79 10 CF                    clr   TOEdurCnt         ; Clear Throttle Opening Enrichment duration counter (TOE_OFC_CALCS)
006587 7F6587 18 79 10 BC                 clrw  TOEpw             ; Clear Throttle Opening Enrichment adder (mS x 100) (TOE_OFC_CALCS)
00658B 7F658B 18 79 10 BE                 clrw  PWlessTOE         ; Clear Injector pulse width before "TOEpw" and "Deadband" (mS x 10) (TOE_OFC_CALCS)
00658F 7F658F                         TOE_LOOP:                                                                        (TOE_OFC_CALCS)
00658F 7F658F 20 42                       job  OFC_LOOP       ; Jump or branch to OFC_LOOP:(Finished with TOE, not in OFC so (TOE_OFC_CALCS)
                                                                  ; fall through)                                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Overrun Fuel Cut mode 2/07/21 Note change in rti_BPEM488.s                   (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;                                                                                (TOE_OFC_CALCS)
                                      ; - Engine overrun occurs when the the vehicle is in motion, the throttle is closed and (TOE_OFC_CALCS)
                                      ;   the engine is turning faster than the driver wants it to be, either because of vehicle (TOE_OFC_CALCS)
                                      ;   inertia or by being on a negative grade. Under these conditions there will be a slight (TOE_OFC_CALCS)
                                      ;   increase in engine braking and some fuel can be saved if the fuel injectors are not (TOE_OFC_CALCS)
                                      ;   pulsed. OFC is only enabled manually by pulsing up on the dash mounted SPDT spring (TOE_OFC_CALCS)
                                      ;   return to centre toggle switch. In order to enter OFC mode several permissive (TOE_OFC_CALCS)
                                      ;   conditions must be met first. The throttle opening must be equal to or less than the (TOE_OFC_CALCS)
                                      ;   minimum permitted opening and the engine RPM must be equal to or more than the minimum (TOE_OFC_CALCS)
                                      ;   permitted RPM. OFC can be disabled manually by the driver at any time by pulsing (TOE_OFC_CALCS)
                                      ;   down on the dash mounted toggle switch. It will be disabled automatically if either (TOE_OFC_CALCS)
                                      ;   or both of the permissive conditions are no longer met                       (TOE_OFC_CALCS)
                                      ;                                                                                (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check to see if we have permissives for Overrun Fuel Cut at steady state or closing (TOE_OFC_CALCS)
                                      ;   throttle.                                                                    (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006591 7F6591                         OFC_CHK:                                                                         (TOE_OFC_CALCS)
006591 7F6591 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006596 7F6596 CD 08 00                    ldy   #veBins_E     ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                            ; on buffer RAM page 1 (veBins_E)                          (TOE_OFC_CALCS)
006599 7F6599 EE EA 03 DA                 ldx   $03DA,Y     ; Load X with value in buffer RAM page 1 offset 986 (OFCtps) (TOE_OFC_CALCS)
                                                            ;(Overrun Fuel Cut min TPS%)                               (TOE_OFC_CALCS)
00659D 7F659D BE 10 7C                    cpx  TpsPctx10    ; Compare it with value in "TpsPctx10"                     (TOE_OFC_CALCS)
0065A0 7F65A0 25 2D                       blo  OFC_CHK_DONE ; If (X)>(M), branch to OFC_CHK_DONE:                      (TOE_OFC_CALCS)
                                                            ;(TPS is above minimum so no fuel cut)                     (TOE_OFC_CALCS)
0065A2 7F65A2 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
0065A7 7F65A7 CD 08 00                    ldy   #veBins_E     ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                            ; on buffer RAM page 1 (veBins_E)                          (TOE_OFC_CALCS)
0065AA 7F65AA EE EA 03 DC                 ldx   $03DC,Y     ; Load X with value in buffer RAM page 1 offset 988 (OFCrpm) (TOE_OFC_CALCS)
                                                            ;(Overrun Fuel Cut min RPM)                                (TOE_OFC_CALCS)
0065AE 7F65AE BE 10 A0                    cpx  RPM          ; Compare it value in RPM                                  (TOE_OFC_CALCS)
0065B1 7F65B1 22 1C                       bhi  OFC_CHK_DONE ; If (X)<(M), branch to OFC_CHK_DONE:                      (TOE_OFC_CALCS)
                                                            ;(RPM is below minimum so no fuel cut                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - We have permissives for Overrun Fuel Cut. Check to see if OFC is already on and being (TOE_OFC_CALCS)
                                      ;   being commanded off.                                                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
0065B3 7F65B3 1F 10 E1 40 07                  brclr  engine,OFCon,OFC_EN_CHK ; If "OFCon" bit of "engine" bit field is clear, branch (TOE_OFC_CALCS)
                                                                             ; to OFC_EN_CHK: (OFC is off, check to see if it is (TOE_OFC_CALCS)
                                                                                                         ; being commanded on (TOE_OFC_CALCS)
0065B8 7F65B8 1F 10 DC 20 12              brclr PortAbits,OFCdis,OFC_CHK_DONE ; If "OFCdis" bit of "PortAbits" is clear (Low), (TOE_OFC_CALCS)
                                                                ; branch to OFC_CHK_DONE: (OFC is on and OFC disable switch is on, (TOE_OFC_CALCS)
                                                                                ; so disable fuel cut)                 (TOE_OFC_CALCS)
0065BD 7F65BD 20 14                           bra  OFC_LOOP     ; branch to OFC_LOOP:(OFC is on, permissives are met and not being (TOE_OFC_CALCS)
                                                                ; commanded off, keep looping until permissives are no longer met (TOE_OFC_CALCS)
                                                                                ; or OFC has been commanded off)       (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - We have permissives for Overrun Fuel Cut and it is not being commanded off. Check to (TOE_OFC_CALCS)
                                      ;   see if OFC is off and being commanded on.                                    (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
0065BF 7F65BF                         OFC_EN_CHK:                                                                      (TOE_OFC_CALCS)
0065BF 7F65BF 1E 10 E1 40 0F                  brset  engine,OFCon,OFC_LOOP   ; If "OFCon" bit of "engine" bit field is set, branch (TOE_OFC_CALCS)
                                                                             ; to OFC_LOOP: (OFC is already on so skip over) (TOE_OFC_CALCS)
0065C4 7F65C4 1E 10 DC 10 0A              brset PortAbits,OFCen,OFC_LOOP ; "If OFCen" bit of "PortAbits" is set (High), branch to (TOE_OFC_CALCS)
                                                                             ; OFC_LOOP: (OFC enable switch is off so skip over) (TOE_OFC_CALCS)
0065C9 7F65C9 1C 10 E1 40                     bset engine,OFCon              ; Set "OFCon" bit of "engine" bit field (This bit will be tested (TOE_OFC_CALCS)
                                                                             ; in the final pulse width calculations, if set the pulse width (TOE_OFC_CALCS)
                                                                                             ; will be set to zero     (TOE_OFC_CALCS)
0065CD 7F65CD 20 04                           bra  OFC_LOOP                  ; branch to OFC_LOOP:(keep looping until permissives are no (TOE_OFC_CALCS)
                                                                             ; longer met or OFC has been commanded off) (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Permissives have not or are no longer are being met or OFC has been commanded off. (TOE_OFC_CALCS)
                                      ;   Clear the flag.                                                              (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
0065CF 7F65CF                         OFC_CHK_DONE:                                                                    (TOE_OFC_CALCS)
0065CF 7F65CF 1D 10 E1 40                     bclr engine,OFCon     ; Clear "OFCon" bit of "engine" bit field          (TOE_OFC_CALCS)
0065D3 7F65D3                         OFC_LOOP:                                                                        (TOE_OFC_CALCS)
0065D3 7F65D3 MACRO                       RUN_PW_CALCS      ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate injector pulse width for a running engine "PW" (mS x 10)           (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ;barocor:      ds 2 ; Barometric Pressure Correction (% x 10) (104)              (RUN_PW_CALCS)
                                      ;matcor:       ds 2 ; Manifold Air Temperature Correction (% x 10)(108)          (RUN_PW_CALCS)
                                      ;Mapx10:       ds 2 ; Manifold Absolute Pressure (KPAx10)(update every revolution) (24) (RUN_PW_CALCS)
                                      ;Ftrmx10:      ds 2 ; Fuel Trim (% x 10)(update every mSec)(+-20%) (36)          (RUN_PW_CALCS)
                                      ;WUEandASEcor: ds 2 ; The sum of WUEcor and ASEcor (% x 10)                      (RUN_PW_CALCS)
                                      ;veCurr:       ds 2 ; Current value in VE table (% x 10) (72)                    (RUN_PW_CALCS)
                                      ;PWcalc1:      ds 2 ; PW calculations result 1                                   (RUN_PW_CALCS)
                                      ;PWcalc2:      ds 2 ; PW calculations result 2                                   (RUN_PW_CALCS)
                                      ;PWcalc3:      ds 2 ; PW calculations result 3                                   (RUN_PW_CALCS)
                                      ;PWcalc4:      ds 2 ; PW calculations result 4                                   (RUN_PW_CALCS)
                                      ;PWcalc5:      ds 2 ; PW calculations result 5                                   (RUN_PW_CALCS)
                                      ;reqFuel:      ds 2 ; Pulse width for 14.7 AFR @ 100% VE (mS x 10)               (RUN_PW_CALCS)
                                      ;PWlessTOE:    ds 2 ; Injector pulse width before "TOEpw" and "Deadband" (mS x 10) (RUN_PW_CALCS)
                                      ;TOEpw:        ds 2 ; Throttle Opening Enrichment adder (mS x 100)               (RUN_PW_CALCS)
                                      ;Deadband:     ds 2 ; injector deadband at current battery voltage mS*100        (RUN_PW_CALCS)
                                      ;FDpw:         ds 2 ; Fuel Delivery pulse width (PW - Deadband) (mS x 10)        (RUN_PW_CALCS)
                                      ;PW:           ds 2 ; Running engine injector pulsewidth (mS x 10)               (RUN_PW_CALCS)
                                      ;PWtk:         ds 2 ; Running engine injector pulsewidth (uS x 2.56)(102)        (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Method:                                                                      (RUN_PW_CALCS)
                                      ;                                                                                (RUN_PW_CALCS)
                                      ; ("barocor" * "matcor") / 1000 = "PWcalc1" (0.1% resolution)                    (RUN_PW_CALCS)
                                      ; ("Mapx10" * "Ftrmx10") / 1000 = "PWcalc2" (0.1% resolution)                    (RUN_PW_CALCS)
                                      ; ("PWcalc1" * "PWcalc2") / 1000 = "PWcalc3" (0.1% resolution)                   (RUN_PW_CALCS)
                                      ; ("WUEandASEcor" * "veCurr") / 1000 = "PWcalc4" (0.1% resolution)               (RUN_PW_CALCS)
                                      ; ("PWcalc3" * "PWcalc4") / 1000 = "PWcalc5" (0.1% resolution)                   (RUN_PW_CALCS)
                                      ; ("PWcalc5" * reqFuel") / 1000 = "PWlessTOE" (0.1mS resolution)                 (RUN_PW_CALCS)
                                      ; "PWlessTOE" + "TOEpw" = "FDpw"  (0.1mS resolution)                             (RUN_PW_CALCS)
                                      ; "FDpw" + "Deadband" = "PW"  (0.1mS resolution)                                 (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate total corrections before Throttle Opening Enrichment and deadband. (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
0065D3 7F65D3 1E 10 E1 40 02              brset engine,OFCon,NoPWrunCalcs1 ; if "OFCon" bit of "engine" bit field is set branch (RUN_PW_CALCS)
                                                                           ; to NoPWrunCalcs1: (In overrun fuel cut mode so (RUN_PW_CALCS)
                                                                           ; fall through)                             (RUN_PW_CALCS)
0065D8 7F65D8 20 03                       bra  PWrunCalcs    ; Branch to PWrunCalcs:                                   (RUN_PW_CALCS)
0065DA 7F65DA                         NoPWrunCalcs1:                                                                   (RUN_PW_CALCS)
0065DA 7F65DA 06 66 6B                    job  NoPWrunCalcs  ; Jump or branch to NoPWrunCalcs: (long branch)           (RUN_PW_CALCS)
0065DD 7F65DD                         PWrunCalcs:                                                                      (RUN_PW_CALCS)
0065DD 7F65DD FC 10 AA                    ldd  barocor      ; "barocor" -> Accu D (% x 10)                             (RUN_PW_CALCS)
0065E0 7F65E0 FD 10 AC                    ldy  matcor       ; "matcor" -> Accu D (% x 10)                              (RUN_PW_CALCS)
0065E3 7F65E3 13                          emul              ; (D)*(Y)->Y:D "barocor" * "matcor"                        (RUN_PW_CALCS)
0065E4 7F65E4 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
0065E7 7F65E7 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("barocor"*"matcor")/1000="PWcalc1" (RUN_PW_CALCS)
0065E8 7F65E8 7D 10 4B                        sty  PWcalc1      ; Result -> "PWcalc1"                                  (RUN_PW_CALCS)
0065EB 7F65EB FC 10 78                    ldd  Mapx10       ; "Mapx10" -> Accu D (% x 10)                              (RUN_PW_CALCS)
0065EE 7F65EE FD 10 94                    ldy  Ftrmx10      ; "Ftrmx10" -> Accu D (% x 10)                             (RUN_PW_CALCS)
0065F1 7F65F1 13                          emul              ; (D)*(Y)->Y:D "Mapx10" * "Ftrmx10"                        (RUN_PW_CALCS)
0065F2 7F65F2 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
0065F5 7F65F5 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("Mapx10"*"Ftrmx10")/1000="PWcalc2" (RUN_PW_CALCS)
0065F6 7F65F6 7D 10 4D                        sty  PWcalc2      ; Result -> "PWcalc2"                                  (RUN_PW_CALCS)
0065F9 7F65F9 FC 10 4B                    ldd  PWcalc1      ; "PWcalc1" -> Accu D (% x 10)                             (RUN_PW_CALCS)
0065FC 7F65FC FD 10 4D                    ldy  PWcalc2      ; "PWcalc2" -> Accu D (% x 10)                             (RUN_PW_CALCS)
0065FF 7F65FF 13                          emul              ; (D)*(Y)->Y:D "PWcalc1" * "PWcalc2"                       (RUN_PW_CALCS)
006600 7F6600 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
006603 7F6603 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("PWcalc1"*"PWcalc2")/1000="PWcalc3" (RUN_PW_CALCS)
006604 7F6604 7D 10 4F                        sty  PWcalc3      ; Result -> "PWcalc3"                                  (RUN_PW_CALCS)
006607 7F6607 FC 10 B2                    ldd  WUEandASEcor ; "WUEandASEcor" -> Accu D (% x 10)                        (RUN_PW_CALCS)
00660A 7F660A FD 10 A8                    ldy  veCurr       ; "veCurr" -> Accu D (% x 10)                              (RUN_PW_CALCS)
00660D 7F660D 13                          emul              ; (D)*(Y)->Y:D "WUEandASEcor" * "veCurr"                   (RUN_PW_CALCS)
00660E 7F660E CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
006611 7F6611 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("WUEandASEcor"*"veCurr")/1000="PWcalc4" (RUN_PW_CALCS)
006612 7F6612 7D 10 51                        sty  PWcalc4      ; Result -> "PWcalc4"                                  (RUN_PW_CALCS)
006615 7F6615 FC 10 4F                    ldd  PWcalc3      ; "PWcalc3" -> Accu D (% x 10)                             (RUN_PW_CALCS)
006618 7F6618 FD 10 51                    ldy  PWcalc4      ; "PWcalc4" -> Accu D (% x 10)                             (RUN_PW_CALCS)
00661B 7F661B 13                          emul              ; (D)*(Y)->Y:D "PWcalc3" * "PWcalc4"                       (RUN_PW_CALCS)
00661C 7F661C CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
00661F 7F661F 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("PWcalc3"*"PWcalc4")/1000="PWcalc5" (RUN_PW_CALCS)
006620 7F6620 7D 10 53                        sty  PWcalc5      ; Result -> "PWcalc5"(total corrections before Throttle Opening (RUN_PW_CALCS)
                                                                ; Enrichment and deadband)                             (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate injector pulse width before Throttle Opening Enrichment pulse width and (RUN_PW_CALCS)
                                      ;   Deadband.                                                                    (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
006623 7F6623 FC 10 53                    ldd  PWcalc5      ; "PWcalc5" -> Accu D (% x 10)                             (RUN_PW_CALCS)
006626 7F6626 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (RUN_PW_CALCS)
00662B 7F662B CD 08 00                    ldy   #veBins_E   ; Load index register Y with address of first configurable (RUN_PW_CALCS)
                                                            ; constant on buffer RAM page 1 (veBins_E)                 (RUN_PW_CALCS)
00662E 7F662E EE EA 03 EC                 ldx   $03EC,Y     ; Load Accu X with value in buffer RAM page 1 (offset 1004)($03EC) (RUN_PW_CALCS)
                                                            ; ("reqFuel")                                              (RUN_PW_CALCS)
006632 7F6632 B7 56                       tfr  X,Y          ; "reqFuel" -> Accu Y                                      (RUN_PW_CALCS)
006634 7F6634 13                          emul              ; (D)*(Y)->Y:D "PWcalc5" * "reqfuel"                       (RUN_PW_CALCS)
006635 7F6635 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
006638 7F6638 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("PWcalc5"*"reqFuel")/1000="PWlessTOE" (RUN_PW_CALCS)
006639 7F6639 7D 10 BE                        sty  PWlessTOE    ; Result -> "PWlessTOE" (mS x 10)                      (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Add the Throttle Opening Enricment pulse width and store as "FDpw"(fuel delivery (RUN_PW_CALCS)
                                      ;   pulse width)(mS x 10)                                                        (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
00663C 7F663C B7 64                       tfr  Y,D          ; "PWlessTOE" -> Accu D                                    (RUN_PW_CALCS)
00663E 7F663E F3 10 BC                        addd TOEpw        ; (A:B)+(M:M+1)->A:B ("PWlessTOE"+"TOEpw"="FDpw"       (RUN_PW_CALCS)
006641 7F6641 7C 10 C6                        std  FDpw         ; Result -> "FDpw" (fuel delivery pulsewidth (mS x 10) (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Add "deadband" and store the result as "PW"(final injector pulsewidth)(mS x 10) (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
006644 7F6644 F3 10 C0                        addd Deadband    ; (A:B)+(M:M+1)->A:B ("FDpw"+"Deadband"="PW"            (RUN_PW_CALCS)
006647 7F6647 7C 10 C8                        std  PW          ; Result -> "PW" (final injector pulsewidth) (mS x 10)  (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Convert "PW" to timer ticks in 2.56uS resolution.                            (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
00664A 7F664A FC 10 C8                    ldd   PW         ; "PW" -> Accu D                                            (RUN_PW_CALCS)
00664D 7F664D CD 27 10                        ldy   #$2710     ; Load index register Y with decimal 10000 (for integer math) (RUN_PW_CALCS)
006650 7F6650 13                              emul             ;(D)x(Y)=Y:D "PW" * 10,000                              (RUN_PW_CALCS)
006651 7F6651 CE 01 00                        ldx   #$100      ; Decimal 256 -> Accu X                                 (RUN_PW_CALCS)
006654 7F6654 11                          ediv             ;(Y:D)/(X)=Y;Rem->D "PW" * 10,000 / 256 = "PWtk"            (RUN_PW_CALCS)
006655 7F6655 7D 10 5B                    sty   PWtk       ; Copy result to "PWtk" (Running engine injector pulsewidth) (RUN_PW_CALCS)
                                                               ; (uS x 2.56)                                           (RUN_PW_CALCS)
006658 7F6658 7D 10 5F                    sty   InjOCadd2  ; Second injector output compare adder (2.56uS res)         (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Injector duty cycle percentage is the time the injector takes to inject the fuel (RUN_PW_CALCS)
                                      ;   divided by the time available x 100. The time available is the engine cycle which is (RUN_PW_CALCS)
                                      ;   two crankshaft revolutions. It is important to know what our duty cycle is at high (RUN_PW_CALCS)
                                      ;   engine speeds and loads. 80% is considered a safe maximum. The crank angle period is (RUN_PW_CALCS)
                                      ;   measured over 72 degrees of crank rotation. In run mode the timer is set to a 2.56uS (RUN_PW_CALCS)
                                      ;   time base and the pulse width timer value is in 2.56uS resolution. The engine cycle (RUN_PW_CALCS)
                                      ;   period in 2.56uS resolution can be calculated by multiplying the period by 10, for (RUN_PW_CALCS)
                                      ;   the two revolutions in the cycle. The duty cycle percentage is calculated by (RUN_PW_CALCS)
                                      ;   dividing "PWtk" by the cycle period and dividing by 100.                     (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate injector duty cycle                                                (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
00665B 7F665B FC 10 5B                    ldd  PWtk           ; "PWtk"->Accu D                                         (RUN_PW_CALCS)
00665E 7F665E CD 00 0A                    ldy  #$000A         ; Decimal 10-> Accu Y (for integer math)                 (RUN_PW_CALCS)
006661 7F6661 13                              emul                ;(D)x(Y)=Y:D "PWtk"*10                               (RUN_PW_CALCS)
006662 7F6662 FE 10 9C                    ldx  CASprd256      ; "CASprd256"-> Accu X (running period for 72 degrees rotation) (RUN_PW_CALCS)
006665 7F6665 11                          ediv                ;(Y:D)/(X)=Y;Rem->D ("PWtk"*10)/"CASprd256"              (RUN_PW_CALCS)
006666 7F6666 7D 10 E8                    sty  DutyCyclex10   ; Copy result to "DutyCyclex10" (Injector duty cycle x 10) (RUN_PW_CALCS)
006669 7F6669 20 24                       bra  PWrunCalcsDone ; Branch to PWrunCalcsDone:                              (RUN_PW_CALCS)
00666B 7F666B                         NoPWrunCalcs:                                                                    (RUN_PW_CALCS)
00666B 7F666B 18 79 10 BE                 clrw  PWlessTOE     ; Clear "PWlessTOE" Injector PW before "TOEpw"+"Deadband"(mS x 10) (RUN_PW_CALCS)
00666F 7F666F 18 79 10 BC                 clrw  TOEpw         ; Clear "TOEpw" Throttle Opening Enrichment adder (mS x 100) (RUN_PW_CALCS)
006673 7F6673 18 79 10 C6                 clrw  FDpw          ; Clear "FDpw" Fuel Delivery pulse width (PW - Deadband)(mS x 10) (RUN_PW_CALCS)
006677 7F6677 18 79 10 C8                 clrw  PW            ; Clear "PW" Running engine injector pulsewidth (mS x 10) (RUN_PW_CALCS)
00667B 7F667B 18 79 10 5B                 clrw  PWtk          ; Clear "PWtk" Running injector pulsewidth timer ticks(uS x 2.56) (RUN_PW_CALCS)
00667F 7F667F 18 03 00 02 10 5D           movw  #$0002,InjOCadd1     ; First injector output compare adder (5.12uS res or 2.56uS res) (RUN_PW_CALCS)
006685 7F6685 18 03 00 02 10 5F           movw  #$0002,InjOCadd2     ; Second injector output compare adder (5.12uS res or 2.56uS res) (RUN_PW_CALCS)
00668B 7F668B 18 79 10 E8                 clrw  DutyCyclex10  ; Clear "DutyCyclex10" Injector duty cycle in run mode (% x 10) (RUN_PW_CALCS)
00668F 7F668F                         PWrunCalcsDone:                                                                  (RUN_PW_CALCS)
00668F 7F668F MACRO                       BARO_COR_LU       ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (BARO_COR_LU)
                                      ; - Look up current value in Barometric Correction Table (barocor)               (BARO_COR_LU)
                                      ;***************************************************************************************** (BARO_COR_LU)
00668F 7F668F 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (BARO_COR_LU)
006694 7F6694 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (BARO_COR_LU)
                                                                  ; -> page where the desired curve resides            (BARO_COR_LU)
00669A 7F669A 18 03 01 68 10 27           movw #$0168,CrvRowOfst  ; 360 -> Offset from the curve page to the curve row(barCorVals) (BARO_COR_LU)
                                                                      ; (actual offset is 720)                         (BARO_COR_LU)
0066A0 7F66A0 18 03 01 71 10 29           movw #$0171,CrvColOfst  ; 369 -> Offset from the curve page to the curve column(barCorDelta) (BARO_COR_LU)
                                                                      ; (actual offset is 738)                         (BARO_COR_LU)
0066A6 7F66A6 18 04 10 84 10 2B           movw Barox10,CrvCmpVal  ; Barometric Pressure (KPAx10) -> Curve comparison value (BARO_COR_LU)
0066AC 7F66AC 18 0B 08 10 2D              movb #$08,CrvBinCnt     ; 8 -> number of bins in the curve row or column minus 1 (BARO_COR_LU)
0066B1 7F66B1 16 6F 46                    jsr   CRV_LU_P   ; Jump to subroutine at CRV_LU_P:(located in interp_BEEM488.s module) (BARO_COR_LU)
0066B4 7F66B4 7C 10 AA                    std   barocor    ; Copy result to Barometric correction (% x 10)             (BARO_COR_LU)
0066B7 7F66B7 MACRO                       MAT_COR_LU        ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (MAT_COR_LU)
                                      ; - Look up current value in MAT Air Density Table (matcor)                      (MAT_COR_LU)
                                      ;***************************************************************************************** (MAT_COR_LU)
0066B7 7F66B7 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (MAT_COR_LU)
0066BC 7F66BC 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (MAT_COR_LU)
                                                                  ;  ->page where the desired curve resides            (MAT_COR_LU)
0066C2 7F66C2 18 03 01 9A 10 27           movw #$019A,CrvRowOfst  ; 410 -> Offset from the curve page to the curve row(matCorrTemps2) (MAT_COR_LU)
                                                                      ; (actual offset is 820)                         (MAT_COR_LU)
0066C8 7F66C8 18 03 01 A3 10 29           movw #$01A3,CrvColOfst  ; 419 -> Offset from the curve page to the curve column(matCorrDelta2) (MAT_COR_LU)
                                                                      ; (actual offset is 838)                         (MAT_COR_LU)
0066CE 7F66CE 18 04 10 70 10 2B           movw Matx10,CrvCmpVal   ; Manifold Air Temperature (Degrees F x 10) ->       (MAT_COR_LU)
                                                                  ; Curve comparison value                             (MAT_COR_LU)
0066D4 7F66D4 18 0B 08 10 2D              movb #$08,CrvBinCnt     ; 8 -> number of bins in the curve row or column minus 1 (MAT_COR_LU)
0066D9 7F66D9 16 70 0F                    jsr   CRV_LU_NP  ; Jump to subroutine at CRV_LU_NP:(located in interp_BEEM488.s module) (MAT_COR_LU)
0066DC 7F66DC 7C 10 AC                    std   matcor     ; Copy result to Manifold Air Temperature Correction (% x 10) (MAT_COR_LU)
                                                            ; All of these Macro calls moved from the main loop in BPEM488.s
                                                            ; as a work around for random corrupted returns 5-4-21
0066DF 7F66DF 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
0066E2 7F66E2                         Notch_CT4_T10:
                                      ;*****************************************************************************************
                                      ; - If we are here the crankshaft is at 150 degrees before top dead centre on the
                                      ;   compression/power strokes for #3 cylinder. Start the hardware timer to delay the .
                                      ;   coil dwell for spark #3, waste #2 if we are in run mode.
                                      ;*****************************************************************************************
0066E2 7F66E2 MACRO                       FIRE_IGN5                 ; macro in Tim_BPEM488.s
                                                              ; (Will trigger an interrupt after the delay time)(LED off) (FIRE_IGN5)
                                      ;***************************************************************************************** (FIRE_IGN5)
                                      ; - PT7 - IOC7 OC7 Ign5(3&2) Control                                             (FIRE_IGN5)
                                      ;***************************************************************************************** (FIRE_IGN5)
                                      ;***************************************************************************************** (FIRE_IGN5)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_IGN5)
                                      ;***************************************************************************************** (FIRE_IGN5)
0066E2 7F66E2 4C 48 80                    bset ECT_TCTL1,Bit7 ; Set Ch7 output line to 1 on compare                    (FIRE_IGN5)
0066E5 7F66E5 4C 48 40                    bset ECT_TCTL1,Bit6 ; Set Ch7 output line to 1 on compare                    (FIRE_IGN5)
0066E8 7F66E8 DC 44                       ldd  ECT_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_IGN5)
0066EA 7F66EA F3 10 41                    addd IgnOCadd1      ; Add "IgnOCadd1" (Delay time from crank signal to energise coil) (FIRE_IGN5)
0066ED 7F66ED 5C 5E                       std  ECT_TC7H       ; Copy result to Timer IC/OC register 2 (Start OC operation) (FIRE_IGN5)
0066EF 7F66EF 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
0066F2 7F66F2                         Notch_CT4_T1:
                                      ;*****************************************************************************************
                                      ; - If we are here the crankshaft is at 150 degrees before top dead centre on the
                                      ;   compression/power strokes for #6 cylinder. Start the hardware timer to delay the
                                      ;   coil dwell for spark #6, waste #1 if we are in run mode.
                                      ;*****************************************************************************************
0066F2 7F66F2 MACRO                       FIRE_IGN1                 ; macro in Tim_BPEM488.s
                                      ;***************************************************************************************** (FIRE_IGN1)
                                      ; - PT0(P9) - IOC0 OC0 LED red  (D7)(1to28)(Ign1)(1&6) Control                   (FIRE_IGN1)
                                      ;***************************************************************************************** (FIRE_IGN1)
                                      ;***************************************************************************************** (FIRE_IGN1)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_IGN1)
                                      ;***************************************************************************************** (FIRE_IGN1)
0066F2 7F66F2 4C 49 80                    bset ECT_TCTL2,Bit7 ; Set Ch3 output line to 1 on compare                    (FIRE_IGN1)
0066F5 7F66F5 4C 49 40                    bset ECT_TCTL2,Bit6 ; Set Ch3 output line to 1 on compare                    (FIRE_IGN1)
0066F8 7F66F8 DC 44                       ldd  ECT_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_IGN1)
0066FA 7F66FA F3 10 41                    addd IgnOCadd1      ; Add "IgnOCadd1" (Delay time from crank signal to energise coil) (FIRE_IGN1)
0066FD 7F66FD 5C 56                       std  ECT_TC3H       ; Copy result to Timer IC/OC register 0 (Start OC operation) (FIRE_IGN1)
0066FF 7F66FF 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
006702 7F6702                         Notch_CT4_T2:
                                      ;*****************************************************************************************
                                      ; - If we are here it is 1 of 4 synchronization points and the crankshaft is at 6 degrees
                                      ;   before top dead centre on the exhaust/intake strokes for #7 cylinder and 60 degrees
                                      ;   before top dead centre on the exhaust/intake strokes for #2 cylinder. #5 intake valve
                                      ;   is just starting to open and #8 intake valve is 54 degrees before it will start to
                                      ;   open. Start the pulse width for injectors 7&2.
                                      ;*****************************************************************************************
006702 7F6702 1E 10 E1 80 11              brset engine,FldClr,INJ5FldClr ; If "FldClr" bit of "engine" bit field is set branch
                                                                         ; to INJ5FldClr:
006707 7F6707 MACRO                       FIRE_INJ5                 ; Macro in Tim_BPEM488.s
                                                                  ; (Will trigger an interrupt after the delay time)(LED off) (FIRE_INJ5)
                                      ;***************************************************************************************** (FIRE_INJ5)
                                      ; - PP4 - TIM1 OC4(Inj5)(7&2) Control                                            (FIRE_INJ5)
                                      ;***************************************************************************************** (FIRE_INJ5)
                                      ;***************************************************************************************** (FIRE_INJ5)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_INJ5)
                                      ;***************************************************************************************** (FIRE_INJ5)
006707 7F6707 1C 03 D8 01                 bset TIM_TCTL1,Bit0 ; Set Ch4 output line to 1 on compare                    (FIRE_INJ5)
00670B 7F670B 1C 03 D8 02                 bset TIM_TCTL1,Bit1 ; Set Ch4 output line to 1 on compare                    (FIRE_INJ5)
00670F 7F670F FC 03 D4                    ldd  TIM_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_INJ5)
006712 7F6712 F3 10 5D                    addd InjOCadd1      ; (A:B)+(M:M+1->A:B Add "InjOCadd1" (Delay from trigger to start (FIRE_INJ5)
                                                              ; of injection)                                          (FIRE_INJ5)
006715 7F6715 7C 03 E8                    std  TIM_TC4H       ; Copy result to Timer IC/OC register 4(Start OC operation) (FIRE_INJ5)
006718 7F6718                         INJ5FldClr:
                                      ;***********************************************************************************************
                                      ; - Update Fuel Delivery Pulse Width Total so the results can be used by Tuner Studio and
                                      ;   Shadow Dash to calculate current fuel burn.
                                      ;***********************************************************************************************
006718 7F6718 FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10)-> Accu D
00671B 7F671B F3 10 C6                    addd FDpw           ; (A:B)+(M:M+1->A:B Add  Fuel Delivery pulse width (mS x 10)
00671E 7F671E 7C 10 D0                    std  FDt            ; Copy result to "FDT" (update "FDt")(mS x 10)
                                      ;***********************************************************************************************
                                      ; - Update the Fuel Delivery counter so that on roll over (65535mS)a pulsed signal can be sent to the
                                      ;   to the totalizer(open collector output)
                                      ;***********************************************************************************************
006721 7F6721 FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10)-> Accu D
006724 7F6724 F3 10 61                        addd FDcnt          ; (A:B)+(M:M+1)->A:B (fuel delivery pulsewidth + fuel delivery counter)
006727 7F6727 25 05                       bcs  Totalizer5R    ; If the cary bit of CCR is set, branch to Totalizer5R: ("FDcnt"
                                                                  ;  rollover, pulse the totalizer)
006729 7F6729 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
00672C 7F672C 20 0B                       bra  TotalizerDone5R ; Branch to TotalizerDone5R:
00672E 7F672E                         Totalizer5R:
00672E 7F672E 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
006731 7F6731 4C 01 08                    bset PORTB,AIOT     ; Set "AIOT" pin on Port B (PB6)(start totalizer pulse)
006734 7F6734 86 03                           ldaa #$03           ; Decimal 3->Accu A (3 mS)
006736 7F6736 7A 10 63                    staa AIOTcnt        ; Copy to "AIOTcnt" ( counter for totalizer pulse width,
                                                                  ; decremented every mS)
006739 7F6739                         TotalizerDone5R:
006739 7F6739 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
00673C 7F673C                         Notch_CT4_T3:
                                      ;*****************************************************************************************
                                      ; - No event
                                      ;*****************************************************************************************
00673C 7F673C MACRO                       ST_LU             ; Macro in igncalcs_BPEM.s
                                      ;***************************************************************************************** (ST_LU)
                                      ; For a 2.56uS timer 1 Sec = 1/.00000256 = 390625 tics                           (ST_LU)
                                      ; 1mS = 390625 / 1000 = 390.625 tics                                             (ST_LU)
                                      ; 0.1mS = 390.625 / 10 = 39.0625 tics                                            (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; 1 RPM/60 = .016666666 Rev per Sec                                              (ST_LU)
                                      ; 1/.016666666 = 60 sec period                                                   (ST_LU)
                                      ; 60/360 = .166666666 sec per degree at 1 RPM                                    (ST_LU)
                                      ; 60/5 = 12 sec Crank Angle Sensor period at 1 RPM                               (ST_LU)
                                      ; 12/.00000256 = 4687500 2.56uS tics at 1 RPM ("CASprdtk")                       (ST_LU)
                                      ; 4687500/72 = 65104.16667 2.56uS tics per degree at 1 RPM ("TkspDeg")           (ST_LU)
                                      ; .166666666/.00000256 = 65104.14063 2.56uS tics per degree at 1 RPM ("TkspDeg") (ST_LU)
                                      ; 1/65104.16667 = .000001528808485 degrees per tic at 1 RPM                      (ST_LU)
                                      ; 71.52666514/60 = 1.192111 Rev per Sec                                          (ST_LU)
                                      ; 1/1.192111 = .83884806 sec period                                              (ST_LU)
                                      ; .83884806/360 = .0023301335 sec per degree at 71.52666 RPM                     (ST_LU)
                                      ; .83884806/5 = .167769612 sec Crank Angle Sensor period at 71.52666 RPM         (ST_LU)
                                      ; .167769612/.00000256 = 65535 2.56uS tics at 71.52666 RPM ("CASprdtk")          (ST_LU)
                                      ; 65535/72 = 910.208333 2.56uS tics per degree at 71.52666 RPM ("TkspDeg")       (ST_LU)
                                      ; .0023301335/.00000256 = 910.2083984 2.56uS tics per degree at 71.52666 RPM ("TkspDeg") (ST_LU)
                                      ; 1/910.208333 = .001098649577 degrees per tic at 71.52666 RPM                   (ST_LU)
                                      ; 500 RPM/60 = 8.333333333 Rev per Sec                                           (ST_LU)
                                      ; 1/8.333333333 = .12 sec period                                                 (ST_LU)
                                      ; .12/360 = .0003333333 sec per degree at 500 RPM                                (ST_LU)
                                      ; .12/5 = .024 sec Crank Angle Sensor period at 500 RPM                          (ST_LU)
                                      ; .024/.00000256 = 9375 2.56uS tics at 500 RPM ("CASprdtk")                      (ST_LU)
                                      ; 9375/72 = 130.2083333 2.56uS tics per degree at 500 RPM ("TkspDeg")            (ST_LU)
                                      ; .0003333333/.00000256 = 130.2083203 2.56uS tics per degree at 500 RPM ("TkspDeg") (ST_LU)
                                      ; 1/130.2083333 = .00768 degrees per tic at 500 RPM                              (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; 4250 RPM/60 = 70.8333333 Rev per Sec                                           (ST_LU)
                                      ; 1/70.8333333 = .014117647 sec period                                           (ST_LU)
                                      ; .014117647/360 = .00003921568629 sec per degree at 4250 RPM                    (ST_LU)
                                      ; .014117647/5 = .0028235294 sec Crank Angle Sensor period at 5000 RPM           (ST_LU)
                                      ; .0028235294/.00000256 = 1102.941172 2.56uS tics at 5000 RPM ("CASprdtk")       (ST_LU)
                                      ; 1102.941172/72 = 15.31862739 2.56uS tics per degree at 4250 RPM ("TkspDeg")    (ST_LU)
                                      ; .00003921568629/.00000256 = 15.31862746 2.56uS tics per degree at 4250 RPM ("TkspDeg") (ST_LU)
                                      ; 1/15.31862739 = .06528 degrees per tic at 4250 RPM                             (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; Ignition crank notches are placed 150 degrees BTDC for their respective cylinder (ST_LU)
                                      ; Dwell times of .006sec crank and .004sec run seem to work well                 (ST_LU)
                                      ; Maximum ignition advance expected is 35 degrees BTDC at low load and high RPM  (ST_LU)
                                      ; From data logs cranking RPM is between ~154RPM and ~241RPM                     (ST_LU)
                                      ; Just before stall is ~251RPM                                                   (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; At 4250 RPM a 4mSec dwell time takes .004/.00003921568629 = 102 degrees of rotation (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; At power up the timers are initialized with a 5.12uS time base. A "Spantk"     (ST_LU)
                                      ; value of 65535 will happen at 84.441 RPM so this is the lowest RPM that can be (ST_LU)
                                      ; calculated during crank conditions. Resolution at 4250 RPM is 7.706 RPM. If the (ST_LU)
                                      ; time base were 2.56uS a "Spantk" value of 65535 will happen at 168.882 RPM.    (ST_LU)
                                      ; Resolution at 4250 RPM is 3.856 RPM. Cranking RPM can be lower than 168 RPM    (ST_LU)
                                      ; so this is why we begin with the 5.12uS base. When RPM reaches ~300 we are almost (ST_LU)
                                      ; ceratinly running so at that point the time base is switched to 2.56uS. This base (ST_LU)
                                      ; will allow ignition calculations to be done as low as ~169 RPM which is probably lower (ST_LU)
                                      ; than the speed at which the engine can be made to run.                         (ST_LU)
                                      ; With a time base of 5.12uS "CASprd512" of 7812 happens at 300 RPM. When the period gets (ST_LU)
                                      ; shorter than this the time base is switched over to 2.56uS ("CASprd256").      (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; - Ignition timing in degrees to 0.1 degree resolution is selected from the 3D  (ST_LU)
                                      ;   lookup table "ST" which plots manifold pressure against RPM. A potentiometer on the (ST_LU)
                                      ;   dash board allows a manual trim of the "ST" values of from 0 to 20 degrees advance (ST_LU)
                                      ;   and from 0 to 20 degrees retard. The ignition system is what is called "waste spark", (ST_LU)
                                      ;   which pairs cylinders on a single coil. The spark is delivered to both cylinders at (ST_LU)
                                      ;   the same time. One cylinder recieves the spark at the appropriate time for ignition. (ST_LU)
                                      ;   The other recieves it when the exhaust valve is open. Hence the name "waste spark". (ST_LU)
                                      ;   On this 10 cylinder engine there are 5 coils, each controlled by its own hardware (ST_LU)
                                      ;   timer. The cylinders are paired 1&6, 10&5, 9&8, 4&7, 3&2                     (ST_LU)
                                      ;   In an ignition event the timer is first loaded with the output compare value in (ST_LU)
                                      ;   "Delaytk". At the compare interrupt the coil is energised and the timer is loaded (ST_LU)
                                      ;   with the output compare value in "DwllFintk". At the compare interrupt the coil is (ST_LU)
                                      ;   de-energized to fire the spark. The delay in timer ticks will depend on the timer base (ST_LU)
                                      ;   rate of either 5.12 uS for cranking or 2.56uS for running.                   (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;  Crank Signal                                                                  (ST_LU)
                                      ;   150BTDC                          Ign                    20ATDC               (ST_LU)
                                      ;      <- Delay          -><- Dwell -><-      ST + Trim     ->                   (ST_LU)
                                      ;     I___________________I__________ I_______________________I                  (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;                          <-            Advance            ->                   (ST_LU)
                                      ;      <-            Ignition Span (170 degrees)            ->                   (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ; - Look up current value in ST table (STcurr) (degrees*10)                      (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
00673C 7F673C FE 10 78                    ldx   Mapx10     ; Load index register X with value in "Mapx10"(Column value Manifold (ST_LU)
                                                           ; Absolute Pressure*10 )                                    (ST_LU)
00673F 7F673F FC 10 A0                    ldd   RPM        ; Load double accumulator D with value in "RPM" (Row value RPM) (ST_LU)
006742 7F6742 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                   (ST_LU)
006747 7F6747 CD 08 00                    ldy   #stBins_E  ; Load index register Y with address of the first value in ST table (ST_LU)
00674A 7F674A 16 6E 77                    jsr   3D_LOOKUP  ; Jump to subroutine at 3D_LOOKUP:                          (ST_LU)
00674D 7F674D 7C 10 D2                    std   STcurr     ; Copy result to "STcurr"                                   (ST_LU)
006750 7F6750 MACRO                       DWELL_COR_LU      ; Macro in igncalcs_BPEM.s
                                      ;***************************************************************************************** (DWELL_COR_LU)
                                      ; - Look up current value in Dwell Battery Adjustment Table (dwellcor)(% x 10)   (DWELL_COR_LU)
                                      ;***************************************************************************************** (DWELL_COR_LU)
006750 7F6750 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (DWELL_COR_LU)
006755 7F6755 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (DWELL_COR_LU)
                                                                  ;  ->page where the desired curve resides            (DWELL_COR_LU)
00675B 7F675B 18 03 01 7A 10 27           movw #$017A,CrvRowOfst  ; 378 -> Offset from the curve page to the curve row(dwellvolts) (DWELL_COR_LU)
                                                                      ;(actual offset is 756                           (DWELL_COR_LU)
006761 7F6761 18 03 01 80 10 29           movw #$0180,CrvColOfst  ; 384 -> Offset from the curve page to the curve column(dwellcorr) (DWELL_COR_LU)
                                                                      ;(actual offset is 768)                          (DWELL_COR_LU)
006767 7F6767 18 04 10 68 10 2B           movw BatVx10,CrvCmpVal  ; Battery Voltage (Volts x 10) -> Curve comparison value (DWELL_COR_LU)
00676D 7F676D 18 0B 05 10 2D              movb #$05,CrvBinCnt     ; 5 -> number of bins in the curve row or column minus 1 (DWELL_COR_LU)
006772 7F6772 16 6F 46                    jsr   CRV_LU_P   ; Jump to subroutine at CRV_LU_P:(located in interp_BEEM488.s module) (DWELL_COR_LU)
006775 7F6775 7C 10 D6                    std   DwellCor   ; Copy result to Dwell battery correction (% x 10)          (DWELL_COR_LU)
006778 7F6778 MACRO                       VE_LU             ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (VE_LU)
                                      ; The base value for injector pulse width calculations in mS to 0.1mS resolution is called (VE_LU)
                                      ; "ReqFuel". It represents the pulse width reqired to achieve 14.7:1 Air/Fuel Ratio at (VE_LU)
                                      ; 100% volumetric efficiency. The VE table contains percentage values to 0.1 percent (VE_LU)
                                      ; resolultion and plots intake manifold pressure in KPA to 0.1KPA resolution against RPM. (VE_LU)
                                      ; These values are part of the injector pulse width calculations for a running engine. (VE_LU)
                                      ;***************************************************************************************** (VE_LU)
                                      ;***************************************************************************************** (VE_LU)
                                      ; - Look up current value in VE table (veCurr)(%x10)                             (VE_LU)
                                      ;***************************************************************************************** (VE_LU)
006778 7F6778 FE 10 78                    ldx   Mapx10     ; Load index register X with value in "Mapx10"(Column value Manifold (VE_LU)
                                                           ; Absolute Pressure x 10 )                                  (VE_LU)
00677B 7F677B FC 10 A0                    ldd   RPM        ; Load double accumulator D with value in "RPM" (Row value RPM) (VE_LU)
00677E 7F677E 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (VE_LU)
006783 7F6783 CD 08 00                    ldy   #veBins_E    ; Load index register Y with address of the first value in VE table (VE_LU)
                                                           ;(in RAM)                                                   (VE_LU)
006786 7F6786 16 6E 77                    jsr   3D_LOOKUP  ; Jump to subroutine at 3D_LOOKUP:                          (VE_LU)
006789 7F6789 7C 10 A8                    std   VEcurr     ; Copy result to "VEcurr"(%x10)                             (VE_LU)
00678C 7F678C MACRO                       AFR_LU            ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (AFR_LU)
                                      ; The Air/Fuel Ratio of the fuel mixture affects how an engine will run. Generally (AFR_LU)
                                      ; speaking AFRs of less than ~7:1 are too rich to ignite. Ratios of greater than ~20:1 are (AFR_LU)
                                      ; too lean to ignite. Stoichiometric ratio is at ~14.7:1. This is the ratio at which all (AFR_LU)
                                      ; the fuel and all the oxygen are consumed and is best for emmisions concerns. Best power (AFR_LU)
                                      ; is obtained between ratios of ~12:1 and ~13:1. Best economy is obtained as lean as ~18:1 (AFR_LU)
                                      ; in some engines. This controller runs in open loop so the AFR numbers are used as (AFR_LU)
                                      ; a tuning aid only.                                                             (AFR_LU)
                                      ;***************************************************************************************** (AFR_LU)
                                      ;***************************************************************************************** (AFR_LU)
                                      ; - Look up current value in AFR table (afrCurr)(AFRx10)                         (AFR_LU)
                                      ;***************************************************************************************** (AFR_LU)
00678C 7F678C FE 10 78                    ldx   Mapx10     ; Load index register X with value in "Mapx10"(Column value Manifold (AFR_LU)
                                                           ; Absolute Pressure x 10 )                                  (AFR_LU)
00678F 7F678F FC 10 A0                    ldd   RPM        ; Load double accumulator D with value in "RPM" (Row value RPM) (AFR_LU)
006792 7F6792 18 0B FD 00 17              movb  #(BUF_RAM_P3_START>>16),EPAGE  ; Move $FD into EPAGE                   (AFR_LU)
006797 7F6797 CD 08 00                    ldy   #afrBins_E   ; Load index register Y with address of the first value in AFR table (AFR_LU)
                                                           ;(in RAM)                                                   (AFR_LU)
00679A 7F679A 16 6E 77                    jsr   3D_LOOKUP  ; Jump to subroutine at 3D_LOOKUP:                          (AFR_LU)
00679D 7F679D 7C 10 A6                    std   AFRcurr    ; Copy result to "AFRcurr"                                  (AFR_LU)
0067A0 7F67A0 MACRO                       TOE_OFC_CALCS     ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - When the engine is running and the throttle is opened quickly a richer mixture is (TOE_OFC_CALCS)
                                      ;   required for a short period of time. This additional pulse width time is called (TOE_OFC_CALCS)
                                      ;   Throttle Opening Enrichment. Conversly, when the engine is in over run       (TOE_OFC_CALCS)
                                      ;   conditions no fuel is required so the injectors can be turned off, subject to (TOE_OFC_CALCS)
                                      ;   permissives. This condtion is call Overrun Fuel Cut.                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check to see if the throttle is opening or if it is at steady state or closing (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
0067A0 7F67A0                         TOE_OFC_CHK:                                                                     (TOE_OFC_CALCS)
0067A0 7F67A0 FE 10 7C                    ldx   TpsPctx10       ; Load index register X with value in "TpsPctx10"      (TOE_OFC_CALCS)
0067A3 7F67A3 BE 10 45                    cpx   TpsPctx10last   ; (X)-(M:M+1)Compare with value in "TpsPctx10last"     (TOE_OFC_CALCS)
0067A6 7F67A6 18 23 01 84                 bls   OFC_CHK         ; If "TpsPctx10" is equal to or less than "TpsPctx10last" branch to (TOE_OFC_CALCS)
                                                                    ; OFC_CHK:(Throttle is steady or closing so check for OFC permissives) (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Current Throttle position percent - throttle position percent 100mS ago = throttle position (TOE_OFC_CALCS)
                                      ;   percent difference over time in seconds "TpsPctx10" - "TpsPctx10last" = "TpsPctDOT" (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
0067AA 7F67AA 18 B0 10 45                 subx  TpsPctx10last   ; (X)-(M:M-1)=>X Subtract "TpsPctx10last" from "TpsPctx10" (TOE_OFC_CALCS)
0067AE 7F67AE 7E 10 B6                    stx   TpsPctDOT       ; Copy result to "TpsPctDOT"                           (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - The throttle is opening. Check to see if it is opening at a rate greater than the threshold (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
0067B1 7F67B1 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
0067B6 7F67B6 CD 08 00                    ldy   #veBins_E       ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                                ; on buffer RAM page 1 (veBins_E)                      (TOE_OFC_CALCS)
0067B9 7F67B9 EE EA 03 D0                 ldx   $03D0,Y         ; Load Accu D with value in buffer RAM page 1 offset 976 (tpsThresh) (TOE_OFC_CALCS)
                                                                ;(TPSdot threshold)(offset = 976)($03D0)               (TOE_OFC_CALCS)
0067BD 7F67BD BE 10 B6                    cpx   TpsPctDOT       ; Compare "tpsThresh" with "TpsPctDOT"                 (TOE_OFC_CALCS)
0067C0 7F67C0 18 22 01 3D                 bhi   TOE_CHK_TIME    ; If "tpsThresh" is greater than "TpsPctDOT", branch to TOE_CHK_TIME: (TOE_OFC_CALCS)
                                                                ; ("TpsPctDOT" below threshold so check if acceleration is done) (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - The throttle is opening at a rate greater then the threshold. Check to see if TOE is in (TOE_OFC_CALCS)
                                      ;   progress.                                                                    (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
0067C4 7F67C4 1E 10 E1 20 2D              brset engine,TOEon,TOE_CALC ; If "TOEon" bit of "engine" bit field           (TOE_OFC_CALCS)
                                                                ; is set, branch to TOE_CALC: (TOE in progress)        (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ;- The throttle is opening at a rate greater than the threshold and TOE is not in progress (TOE_OFC_CALCS)
                                      ;  so prepare to add in the enrichement.                                         (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
0067C9 7F67C9 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
0067CE 7F67CE CD 08 00                    ldy   #veBins_E       ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                              ; on buffer RAM page 1 (veBins_E)                        (TOE_OFC_CALCS)
0067D1 7F67D1 EC EA 03 BC                 ldd  $03BC,Y        ; Load Accu D with value in buffer RAM page 1 (offset 956) (First element (TOE_OFC_CALCS)
                                                              ; of "TOEbins" table)(Start with first element, will determine actual (TOE_OFC_CALCS)
                                                              ; next time around)                                      (TOE_OFC_CALCS)
0067D5 7F67D5 7B 10 BB                    stab   TOEpct       ; Copy to Throttle Opening Enrichment percent(used in later calculations) (TOE_OFC_CALCS)
0067D8 7F67D8 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
0067DD 7F67DD CD 08 00                    ldy   #veBins_E     ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                              ; on buffer RAM page 1 (veBins_E)                        (TOE_OFC_CALCS)
0067E0 7F67E0 EC EA 03 D2                 ldd   $03D2,Y       ; Load Accu D with value in buffer RAM page 1 offset 978 (TOEtime_F) (TOE_OFC_CALCS)
0067E4 7F67E4 7B 10 CF                    stab  TOEdurCnt     ; Copy to "TOEdurCnt" (Throttle Opening Enrichment duration (TOE_OFC_CALCS)
                                                                  ; (decremented every 100 mS))                        (TOE_OFC_CALCS)
0067E7 7F67E7 1C 10 E1 20                 bset  engine,TOEon  ; Set "TOEon" bit of "engine" variable (in TOE mode)     (TOE_OFC_CALCS)
0067EB 7F67EB 1C 10 E2 08                 bset  engine2,TOEduron  ; Set "TOEduron" bit of "engine2" variable (TOE duration) (TOE_OFC_CALCS)
0067EF 7F67EF 1D 10 E1 40                 bclr  engine,OFCon  ; Clear "OFCon" bit of "engine" variable (not in OFC mode) (TOE_OFC_CALCS)
0067F3 7F67F3 06 69 70                    job   OFC_LOOP      ; Jump or branch to OFC_LOOP:(fall through)              (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Calculate the cold temperature add-on enrichment "ColdAddpct" (%) from -39.72 (TOE_OFC_CALCS)
                                      ;   degrees to 179.9 degrees.                                                    (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
0067F6 7F67F6                         TOE_CALC:                                                                        (TOE_OFC_CALCS)
0067F6 7F67F6 FC 10 6A                    ldd  cltAdc       ; "cltAdc" -> D                                            (TOE_OFC_CALCS)
0067F9 7F67F9 8C 00 93                    cpd  #$0093       ; Compare "cltADC" with decimal 147(ADC @ 179.9F)          (TOE_OFC_CALCS)
0067FC 7F67FC 23 02                       bls  RailColdAdd  ; If "cltADC" is lower or the same as 147, branch to RailColdAdd: (TOE_OFC_CALCS)
0067FE 7F67FE 20 05                       bra  DoColdAdd    ; Branch to DoColdAdd:                                     (TOE_OFC_CALCS)
006800 7F6800                         RailColdAdd:                                                                     (TOE_OFC_CALCS)
006800 7F6800 79 10 B9                    clr   ColdAddpct   ; Clear "ColdAddpct" (no cold adder)                      (TOE_OFC_CALCS)
006803 7F6803 20 3C                       bra   ColdAddDone  ; Branch to ColdAddDone: (skip over)                      (TOE_OFC_CALCS)
006805 7F6805                         DoColdAdd:                                                                       (TOE_OFC_CALCS)
006805 7F6805 CC 00 93                    ldd  #$0093      ; Load double accumulator with decimal 147 (ADC @ 179.9F)   (TOE_OFC_CALCS)
006808 7F6808 3B                          pshd             ; Push to stack (V1)                                        (TOE_OFC_CALCS)
006809 7F6809 FC 10 6A                    ldd  cltAdc      ; Load double accumulator with "cltAdc"                     (TOE_OFC_CALCS)
00680C 7F680C 3B                          pshd             ; Push to stack (V)                                         (TOE_OFC_CALCS)
00680D 7F680D CC 03 EB                    ldd  #$03EB      ; Load double accumulator with decimal 1003 (ADC @ -39.72F) (TOE_OFC_CALCS)
006810 7F6810 3B                          pshd             ; Push to stack (V2)                                        (TOE_OFC_CALCS)
006811 7F6811 CC 00 00                    ldd  #$0000      ; Load double accumulator with decimal 0 (added amount at 179.9F) (TOE_OFC_CALCS)
006814 7F6814 3B                          pshd             ; Push to stack (Z1)                                        (TOE_OFC_CALCS)
006815 7F6815 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
00681A 7F681A CD 08 00                    ldy   #veBins_E    ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                           ; on buffer RAM page 1 (veBins_E)                           (TOE_OFC_CALCS)
00681D 7F681D EC EA 03 D4                 ldd   $03D4,Y    ; Load Accu D with value in buffer RAM page 1 (ColdAdd_F)(offset 980) (TOE_OFC_CALCS)
                                                           ;(added amount at -39.72F)                                  (TOE_OFC_CALCS)
006821 7F6821 3B                          pshd             ; Push to stack (Z2)                                        (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z2       |  SP+ 0                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z1       |  SP+ 2                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V2       |  SP+ 4                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V        |  SP+ 6                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V1       |  SP+ 8                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                      ;                     V      V1      V2      Z1    Z2                            (TOE_OFC_CALCS)
006822 7F6822 MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; ==========================                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ; result: D: interpolated result                                                 (TOE_OFC_CALCS/2D_IPOL)
                                      ; SSTACK: none                                                                   (TOE_OFC_CALCS/2D_IPOL)
                                      ;         no registers are preserved                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    ^ V                                                                         (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                                                                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z2+....................*                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                    :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   :       :        :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006822 7F6822 EC 86                                   LDD       \1    ; load V                                         (TOE_OFC_CALCS/2D_IPOL)
006824 7F6824 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
006826 7F6826 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006828 7F6828 EC 80                                   LDD       \5    ; load Z2                                        (TOE_OFC_CALCS/2D_IPOL)
00682A 7F682A A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
00682C 7F682C 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (TOE_OFC_CALCS/2D_IPOL)
00682E 7F682E B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006830 7F6830 EC 84                                   LDD       \3    ; load V2                                        (TOE_OFC_CALCS/2D_IPOL)
006832 7F6832 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
006834 7F6834 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (TOE_OFC_CALCS/2D_IPOL)
                                      ;*********************************************************************           (TOE_OFC_CALCS/2D_IPOL)
006836 7F6836 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (TOE_OFC_CALCS/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (TOE_OFC_CALCS/2D_IPOL)
006838 7F6838 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
00683A 7F683A E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Free stack space (result in D)                                               (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
00683C 7F683C 1B 8A                       leas  10,SP       ; Stack pointer -> bottom of stack                         (TOE_OFC_CALCS)
00683E 7F683E 7B 10 B9                    stab  ColdAddpct  ; Copy result to "ColdAddpct" (%)(bins are byte values)    (TOE_OFC_CALCS)
006841 7F6841                         ColdAddDone:                                                                     (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Calculate the cold temperature multiplier enrichment "ColdMulpct" (%), from -39.72 degrees (TOE_OFC_CALCS)
                                      ;   to 179.9 degrees.                                                            (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
006841 7F6841 FC 10 6A                    ldd  cltADC       ; "cltADC" -> D                                            (TOE_OFC_CALCS)
006844 7F6844 8C 00 93                    cpd  #$0093       ; Compare "cltADC" with decimal 147(ADC @ 179.9F)          (TOE_OFC_CALCS)
006847 7F6847 23 02                       bls  RailColdMul  ; If "cltADC" is lower or the same as 147, branch to RailColdMul: (TOE_OFC_CALCS)
006849 7F6849 20 07                       bra  DoColdMul    ; Branch to DoColdMul: (skip over)                         (TOE_OFC_CALCS)
00684B 7F684B                         RailColdMul:                                                                     (TOE_OFC_CALCS)
00684B 7F684B 18 0B 64 10 BA             movb #$64,ColdMulpct  ; Decimal 100 -> "ColdMulpct" (100% = no multiplier))   (TOE_OFC_CALCS)
006850 7F6850 20 3C                      bra   ColdMulDone     ; Branch to ColdMulDone: (skip over)                    (TOE_OFC_CALCS)
006852 7F6852                         DoColdMul:                                                                       (TOE_OFC_CALCS)
006852 7F6852 CC 00 93                    ldd  #$0093      ; Load double accumulator with decimal 147 (ADC @ 179.9F)   (TOE_OFC_CALCS)
006855 7F6855 3B                          pshd             ; Push to stack (V1)                                        (TOE_OFC_CALCS)
006856 7F6856 FC 10 6A                    ldd  cltAdc      ; Load double accumulator with "cltAdc"                     (TOE_OFC_CALCS)
006859 7F6859 3B                          pshd             ; Push to stack (V)                                         (TOE_OFC_CALCS)
00685A 7F685A CC 03 EB                    ldd  #$03EB      ; Load double accumulator with decimal 1003 (ADC @ -39.72F) (TOE_OFC_CALCS)
00685D 7F685D 3B                          pshd             ; Push to stack (V2)                                        (TOE_OFC_CALCS)
00685E 7F685E CC 00 64                    ldd  #$0064      ; Load double accumulator with decimal 100 (multiplier amount at 179.9F) (TOE_OFC_CALCS)
                                                           ;(1.00 multiplier at 180 degrees)                           (TOE_OFC_CALCS)
006861 7F6861 3B                          pshd             ; Push to stack (Z1)                                        (TOE_OFC_CALCS)
006862 7F6862 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006867 7F6867 CD 08 00                    ldy   #veBins_E    ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                           ; on buffer RAM page 1 (veBins_E)                           (TOE_OFC_CALCS)
00686A 7F686A EC EA 03 D6                 ldd   $03D6,Y    ; Load Accu D with value in buffer RAM page 1 "ColdMul_F"(offset 982) (TOE_OFC_CALCS)
                                                           ;(added amount at -39.72F)                                  (TOE_OFC_CALCS)
00686E 7F686E 3B                          pshd             ; Push to stack (Z2)                                        (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z2       |  SP+ 0                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z1       |  SP+ 2                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V2       |  SP+ 4                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V        |  SP+ 6                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V1       |  SP+ 8                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                      ;                     V      V1      V2      Z1    Z2                            (TOE_OFC_CALCS)
00686F 7F686F MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; ==========================                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ; result: D: interpolated result                                                 (TOE_OFC_CALCS/2D_IPOL)
                                      ; SSTACK: none                                                                   (TOE_OFC_CALCS/2D_IPOL)
                                      ;         no registers are preserved                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    ^ V                                                                         (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                                                                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z2+....................*                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                    :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   :       :        :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
00686F 7F686F EC 86                                   LDD       \1    ; load V                                         (TOE_OFC_CALCS/2D_IPOL)
006871 7F6871 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
006873 7F6873 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006875 7F6875 EC 80                                   LDD       \5    ; load Z2                                        (TOE_OFC_CALCS/2D_IPOL)
006877 7F6877 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006879 7F6879 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (TOE_OFC_CALCS/2D_IPOL)
00687B 7F687B B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
00687D 7F687D EC 84                                   LDD       \3    ; load V2                                        (TOE_OFC_CALCS/2D_IPOL)
00687F 7F687F A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
006881 7F6881 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (TOE_OFC_CALCS/2D_IPOL)
                                      ;*********************************************************************           (TOE_OFC_CALCS/2D_IPOL)
006883 7F6883 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (TOE_OFC_CALCS/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (TOE_OFC_CALCS/2D_IPOL)
006885 7F6885 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006887 7F6887 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Free stack space (result in D)                                               (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006889 7F6889 1B 8A                      leas  10,SP         ; Stack pointer -> bottom of stack                        (TOE_OFC_CALCS)
00688B 7F688B 7B 10 BA                   stab   ColdMulpct   ; Copy result to "ColdMulpct" (%) (bins are byte values)  (TOE_OFC_CALCS)
00688E 7F688E                         ColdMulDone:                                                                     (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; First determine "TpsPctDOT" ("TpsPctx10" - "TpsPctx10last") (both updated every 100mS (TOE_OFC_CALCS)
                                      ; in rti_BEEM488.s)                                                              (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
00688E 7F688E FE 10 7C                   ldx   TpsPctx10         ; "TpsPctx10" -> Accu X                               (TOE_OFC_CALCS)
006891 7F6891 18 B0 10 45                subx  TpsPctx10last     ; (X)-(M:M+1)=>X Subtract "TpsPctx10last" from "TpsPctx10" (TOE_OFC_CALCS)
006895 7F6895 7E 10 B6                   stx   TpsPctDOT         ; Copy result to "TpsPctDOT" (%/Sec)                  (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Look up current value in Throttle Opening Enrichment Table (TpsDOTcor)(%)(byte value) (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006898 7F6898 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
00689D 7F689D 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr    ; Address of the first value in VE table(in RAM)(page pointer) (TOE_OFC_CALCS)
                                                                   ; ->page where the desired curve resides            (TOE_OFC_CALCS)
0068A3 7F68A3 18 03 01 E2 10 27           movw #$01E2,CrvRowOfst   ; 482 -> Offset from the curve page to the curve row (TOE_OFC_CALCS)
                                                                       ; (TOERates_F)(actual offset is 964)($03C4)     (TOE_OFC_CALCS)
0068A9 7F68A9 18 03 01 DE 10 29           movw #$01DE,CrvColOfst   ; 478 -> Offset from the curve page to the curve column (TOE_OFC_CALCS)
                                                                       ; (TOEBins_F)(actual offset is 956)($03BC)      (TOE_OFC_CALCS)
0068AF 7F68AF 18 04 10 B6 10 2B           movw TpsPctDOT,CrvCmpVal ; TPS% difference over time (%/Sec)(update every 100mSec) (TOE_OFC_CALCS)
                                                                   ; -> Curve comparison value                         (TOE_OFC_CALCS)
0068B5 7F68B5 18 0B 03 10 2D              movb #$03,CrvBinCnt      ; 3 -> number of bins in the curve row or column minus 1 (TOE_OFC_CALCS)
0068BA 7F68BA 16 6F 46                    jsr  CRV_LU_P            ; Jump to subroutine at CRV_LU_P:(located in interp_BEEM488.s module) (TOE_OFC_CALCS)
0068BD 7F68BD 7B 10 B8                    stab TpsDOTcor           ; Copy result to TpsDOTcor (%)(byte value)          (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Multiply "TpsDOTcor" by "ColdMulpct" and divide by 100                       (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
0068C0 7F68C0 B6 10 B8                    ldaa  TpsDOTcor      ; "TpsDOTcor" -> A (%)                                  (TOE_OFC_CALCS)
0068C3 7F68C3 F6 10 BA                    ldab  ColdMulpct     ; "ColdMulpct" -> B (%)                                 (TOE_OFC_CALCS)
0068C6 7F68C6 12                          mul                  ; (A)x(B)->A:B (TpsDOTcor x ColdMulpct) result in D     (TOE_OFC_CALCS)
0068C7 7F68C7 CE 00 64                    ldx   #$0064         ; Decimal 100 -> X                                      (TOE_OFC_CALCS)
0068CA 7F68CA 18 10                       idiv                 ; (D)/(X)->(X)rem(D) ((TpsDOTcor x ColdMulpct)/100)(%)  (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check the remainder and round up if >=5                                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
0068CC 7F68CC 8C 00 05                    cpd   #$0005         ; Compare idiv remainder with decimal 5                 (TOE_OFC_CALCS)
0068CF 7F68CF 2F 05                       ble   NO_ROUND_UP    ; If remainder of idiv <= 5, branch to NO_ROUND_UP:     (TOE_OFC_CALCS)
0068D1 7F68D1 B7 50                       tfr   X,A            ; idiv result -> A                                      (TOE_OFC_CALCS)
0068D3 7F68D3 42                          inca                 ; idiv result + 1 -> A (round up)                       (TOE_OFC_CALCS)
0068D4 7F68D4 20 02                       bra   ADD_COLDADD    ; Branch to ADD_COLDADD:(fall through)                  (TOE_OFC_CALCS)
0068D6 7F68D6                         NO_ROUND_UP:                                                                     (TOE_OFC_CALCS)
0068D6 7F68D6 B7 50                       tfr   X,A            ; idiv result -> A                                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Add the result with "ColdAddpct". Compare the result with the current "TOEpct" and (TOE_OFC_CALCS)
                                      ;   and save the highest value as "TOEpct". This is the final TOE value(%)       (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
0068D8 7F68D8                         ADD_COLDADD:                                                                     (TOE_OFC_CALCS)
0068D8 7F68D8 BB 10 B9                    adda  ColdAddpct     ; (A)+(M)->(A) (("TpsDOTcor" * ColdMulpct)/100) + "ColdAddpct") (TOE_OFC_CALCS)
0068DB 7F68DB 7A 10 F9                    staa  tmp5b           ; Copy to "tmp5b"(("TpsDOTcor" * ColdMulpct)/100) + "ColdAddpct") (TOE_OFC_CALCS)
0068DE 7F68DE B1 10 BB                    cmpa  TOEpct         ; Compare result with "TOEpct"                          (TOE_OFC_CALCS)
0068E1 7F68E1 25 1E                       blo   TOE_CHK_TIME   ; If (A) is less than (M), branch to TOE_CHK_TIME: (result (TOE_OFC_CALCS)
                                                               ; < "TOEpct" so use this value for "TOEpct" and check if (TOE_OFC_CALCS)
                                                                                       ; acceleration is done)         (TOE_OFC_CALCS)
0068E3 7F68E3 B6 10 F9                    ldaa  tmp5b          ; "tmp5b" -> A(("TpsDOTcor" * ColdMulpct)/100) + "ColdAddpct") (TOE_OFC_CALCS)
0068E6 7F68E6 7A 10 BB                    staa  TOEpct         ; Copy result to "TOEpct"(result is higher than current (TOE_OFC_CALCS)
                                                               ; so update TOEpct with the higher value)               (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Calculate the Throttle Opening Enrichment adder for PW calculations.         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
0068E9 7F68E9 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
0068EE 7F68EE CD 08 00                    ldy   #veBins_E   ; Load index register Y with address of first configurable (TOE_OFC_CALCS)
                                                            ; constant on buffer RAM page 1 (veBins_E)                 (TOE_OFC_CALCS)
0068F1 7F68F1 EC EA 03 EC                 ldd   $03EC,Y     ; Load Accu D with value in buffer RAM page 1 (offset 1004)($03EC) (TOE_OFC_CALCS)
                                                            ; ("reqFuel" in Accu B)                                    (TOE_OFC_CALCS)
0068F5 7F68F5 B6 10 BB                    ldaa  TOEpct      ; "TOEpct" -> Accu D (%)                                   (TOE_OFC_CALCS)
0068F8 7F68F8 12                          mul               ;(A)x(B)->A:B (reqFuel" x "TOEpct")                        (TOE_OFC_CALCS)
0068F9 7F68F9 CE 00 64                        ldx  #$0064       ; Decimal 100 -> Accu X                                (TOE_OFC_CALCS)
0068FC 7F68FC 18 10                       idiv              ;(D)/(X)->X:rem->D (reqFuel" x "TOEpct")/10                (TOE_OFC_CALCS)
0068FE 7F68FE 7E 10 BC                    stx  TOEpw        ; Result -> "TOEpw" TOE adder (mS x 10)                    (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check to see if Throttle Opening Enrichment is done.                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006901 7F6901                          TOE_CHK_TIME:                                                                   (TOE_OFC_CALCS)
006901 7F6901 1E 10 E1 40 07              brset  engine,OFCon,RESET_TOE ; If Overrun Fuel Cut bit of "Engine" bit field is set, (TOE_OFC_CALCS)
                                                                        ; branch to RESET_TOE:                         (TOE_OFC_CALCS)
006906 7F6906 B6 10 CF                     ldaa  TOEdurCnt    ; "TOEdurCnt" -> Accu A                                  (TOE_OFC_CALCS)
006909 7F6909 27 02                            beq   RESET_TOE    ; If "TOEdurCnt" = zero branch to RESET_TOE:(timer has timed out) (TOE_OFC_CALCS)
00690B 7F690B 20 1F                            bra   TOE_LOOP     ; Branch to "TOE_LOOP:(Timer hasn't timed out yet)   (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - The throttle is no longer opening and the duration timer has timed out so clear (TOE_OFC_CALCS)
                                      ;    "TOEpct" and the "TOEon" bit of "engine" bit field.                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
00690D 7F690D                         RESET_TOE:                                                                       (TOE_OFC_CALCS)
00690D 7F690D 1D 10 E1 20                 bclr  engine,TOEon      ; Clear "TOEon" bit of "engine" bit field            (TOE_OFC_CALCS)
006911 7F6911 1D 10 E2 08                 bclr  engine2,TOEduron  ; Clear "TOEduron" bit of "engine2" variable (TOE duration) (TOE_OFC_CALCS)
006915 7F6915 79 10 BB                    clr   TOEpct            ; Clear Throttle Opening Enrichment (%)              (TOE_OFC_CALCS)
006918 7F6918 79 10 B9                    clr   ColdAddpct        ; Clear Throttle Opening Enrichment cold adder (%)   (TOE_OFC_CALCS)
00691B 7F691B 79 10 BA                    clr   ColdMulpct        ; Clear Throttle Opening Enrichment cold multiplier (%) (TOE_OFC_CALCS)
00691E 7F691E 79 10 B8                    clr   TpsDOTcor         ; Clear Throttle Opening Enrichment table value(%)   (TOE_OFC_CALCS)
006921 7F6921 79 10 CF                    clr   TOEdurCnt         ; Clear Throttle Opening Enrichment duration counter (TOE_OFC_CALCS)
006924 7F6924 18 79 10 BC                 clrw  TOEpw             ; Clear Throttle Opening Enrichment adder (mS x 100) (TOE_OFC_CALCS)
006928 7F6928 18 79 10 BE                 clrw  PWlessTOE         ; Clear Injector pulse width before "TOEpw" and "Deadband" (mS x 10) (TOE_OFC_CALCS)
00692C 7F692C                         TOE_LOOP:                                                                        (TOE_OFC_CALCS)
00692C 7F692C 20 42                       job  OFC_LOOP       ; Jump or branch to OFC_LOOP:(Finished with TOE, not in OFC so (TOE_OFC_CALCS)
                                                                  ; fall through)                                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Overrun Fuel Cut mode 2/07/21 Note change in rti_BPEM488.s                   (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;                                                                                (TOE_OFC_CALCS)
                                      ; - Engine overrun occurs when the the vehicle is in motion, the throttle is closed and (TOE_OFC_CALCS)
                                      ;   the engine is turning faster than the driver wants it to be, either because of vehicle (TOE_OFC_CALCS)
                                      ;   inertia or by being on a negative grade. Under these conditions there will be a slight (TOE_OFC_CALCS)
                                      ;   increase in engine braking and some fuel can be saved if the fuel injectors are not (TOE_OFC_CALCS)
                                      ;   pulsed. OFC is only enabled manually by pulsing up on the dash mounted SPDT spring (TOE_OFC_CALCS)
                                      ;   return to centre toggle switch. In order to enter OFC mode several permissive (TOE_OFC_CALCS)
                                      ;   conditions must be met first. The throttle opening must be equal to or less than the (TOE_OFC_CALCS)
                                      ;   minimum permitted opening and the engine RPM must be equal to or more than the minimum (TOE_OFC_CALCS)
                                      ;   permitted RPM. OFC can be disabled manually by the driver at any time by pulsing (TOE_OFC_CALCS)
                                      ;   down on the dash mounted toggle switch. It will be disabled automatically if either (TOE_OFC_CALCS)
                                      ;   or both of the permissive conditions are no longer met                       (TOE_OFC_CALCS)
                                      ;                                                                                (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check to see if we have permissives for Overrun Fuel Cut at steady state or closing (TOE_OFC_CALCS)
                                      ;   throttle.                                                                    (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
00692E 7F692E                         OFC_CHK:                                                                         (TOE_OFC_CALCS)
00692E 7F692E 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006933 7F6933 CD 08 00                    ldy   #veBins_E     ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                            ; on buffer RAM page 1 (veBins_E)                          (TOE_OFC_CALCS)
006936 7F6936 EE EA 03 DA                 ldx   $03DA,Y     ; Load X with value in buffer RAM page 1 offset 986 (OFCtps) (TOE_OFC_CALCS)
                                                            ;(Overrun Fuel Cut min TPS%)                               (TOE_OFC_CALCS)
00693A 7F693A BE 10 7C                    cpx  TpsPctx10    ; Compare it with value in "TpsPctx10"                     (TOE_OFC_CALCS)
00693D 7F693D 25 2D                       blo  OFC_CHK_DONE ; If (X)>(M), branch to OFC_CHK_DONE:                      (TOE_OFC_CALCS)
                                                            ;(TPS is above minimum so no fuel cut)                     (TOE_OFC_CALCS)
00693F 7F693F 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006944 7F6944 CD 08 00                    ldy   #veBins_E     ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                            ; on buffer RAM page 1 (veBins_E)                          (TOE_OFC_CALCS)
006947 7F6947 EE EA 03 DC                 ldx   $03DC,Y     ; Load X with value in buffer RAM page 1 offset 988 (OFCrpm) (TOE_OFC_CALCS)
                                                            ;(Overrun Fuel Cut min RPM)                                (TOE_OFC_CALCS)
00694B 7F694B BE 10 A0                    cpx  RPM          ; Compare it value in RPM                                  (TOE_OFC_CALCS)
00694E 7F694E 22 1C                       bhi  OFC_CHK_DONE ; If (X)<(M), branch to OFC_CHK_DONE:                      (TOE_OFC_CALCS)
                                                            ;(RPM is below minimum so no fuel cut                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - We have permissives for Overrun Fuel Cut. Check to see if OFC is already on and being (TOE_OFC_CALCS)
                                      ;   being commanded off.                                                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006950 7F6950 1F 10 E1 40 07                  brclr  engine,OFCon,OFC_EN_CHK ; If "OFCon" bit of "engine" bit field is clear, branch (TOE_OFC_CALCS)
                                                                             ; to OFC_EN_CHK: (OFC is off, check to see if it is (TOE_OFC_CALCS)
                                                                                                         ; being commanded on (TOE_OFC_CALCS)
006955 7F6955 1F 10 DC 20 12              brclr PortAbits,OFCdis,OFC_CHK_DONE ; If "OFCdis" bit of "PortAbits" is clear (Low), (TOE_OFC_CALCS)
                                                                ; branch to OFC_CHK_DONE: (OFC is on and OFC disable switch is on, (TOE_OFC_CALCS)
                                                                                ; so disable fuel cut)                 (TOE_OFC_CALCS)
00695A 7F695A 20 14                           bra  OFC_LOOP     ; branch to OFC_LOOP:(OFC is on, permissives are met and not being (TOE_OFC_CALCS)
                                                                ; commanded off, keep looping until permissives are no longer met (TOE_OFC_CALCS)
                                                                                ; or OFC has been commanded off)       (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - We have permissives for Overrun Fuel Cut and it is not being commanded off. Check to (TOE_OFC_CALCS)
                                      ;   see if OFC is off and being commanded on.                                    (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
00695C 7F695C                         OFC_EN_CHK:                                                                      (TOE_OFC_CALCS)
00695C 7F695C 1E 10 E1 40 0F                  brset  engine,OFCon,OFC_LOOP   ; If "OFCon" bit of "engine" bit field is set, branch (TOE_OFC_CALCS)
                                                                             ; to OFC_LOOP: (OFC is already on so skip over) (TOE_OFC_CALCS)
006961 7F6961 1E 10 DC 10 0A              brset PortAbits,OFCen,OFC_LOOP ; "If OFCen" bit of "PortAbits" is set (High), branch to (TOE_OFC_CALCS)
                                                                             ; OFC_LOOP: (OFC enable switch is off so skip over) (TOE_OFC_CALCS)
006966 7F6966 1C 10 E1 40                     bset engine,OFCon              ; Set "OFCon" bit of "engine" bit field (This bit will be tested (TOE_OFC_CALCS)
                                                                             ; in the final pulse width calculations, if set the pulse width (TOE_OFC_CALCS)
                                                                                             ; will be set to zero     (TOE_OFC_CALCS)
00696A 7F696A 20 04                           bra  OFC_LOOP                  ; branch to OFC_LOOP:(keep looping until permissives are no (TOE_OFC_CALCS)
                                                                             ; longer met or OFC has been commanded off) (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Permissives have not or are no longer are being met or OFC has been commanded off. (TOE_OFC_CALCS)
                                      ;   Clear the flag.                                                              (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
00696C 7F696C                         OFC_CHK_DONE:                                                                    (TOE_OFC_CALCS)
00696C 7F696C 1D 10 E1 40                     bclr engine,OFCon     ; Clear "OFCon" bit of "engine" bit field          (TOE_OFC_CALCS)
006970 7F6970                         OFC_LOOP:                                                                        (TOE_OFC_CALCS)
006970 7F6970 MACRO                       RUN_PW_CALCS      ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate injector pulse width for a running engine "PW" (mS x 10)           (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ;barocor:      ds 2 ; Barometric Pressure Correction (% x 10) (104)              (RUN_PW_CALCS)
                                      ;matcor:       ds 2 ; Manifold Air Temperature Correction (% x 10)(108)          (RUN_PW_CALCS)
                                      ;Mapx10:       ds 2 ; Manifold Absolute Pressure (KPAx10)(update every revolution) (24) (RUN_PW_CALCS)
                                      ;Ftrmx10:      ds 2 ; Fuel Trim (% x 10)(update every mSec)(+-20%) (36)          (RUN_PW_CALCS)
                                      ;WUEandASEcor: ds 2 ; The sum of WUEcor and ASEcor (% x 10)                      (RUN_PW_CALCS)
                                      ;veCurr:       ds 2 ; Current value in VE table (% x 10) (72)                    (RUN_PW_CALCS)
                                      ;PWcalc1:      ds 2 ; PW calculations result 1                                   (RUN_PW_CALCS)
                                      ;PWcalc2:      ds 2 ; PW calculations result 2                                   (RUN_PW_CALCS)
                                      ;PWcalc3:      ds 2 ; PW calculations result 3                                   (RUN_PW_CALCS)
                                      ;PWcalc4:      ds 2 ; PW calculations result 4                                   (RUN_PW_CALCS)
                                      ;PWcalc5:      ds 2 ; PW calculations result 5                                   (RUN_PW_CALCS)
                                      ;reqFuel:      ds 2 ; Pulse width for 14.7 AFR @ 100% VE (mS x 10)               (RUN_PW_CALCS)
                                      ;PWlessTOE:    ds 2 ; Injector pulse width before "TOEpw" and "Deadband" (mS x 10) (RUN_PW_CALCS)
                                      ;TOEpw:        ds 2 ; Throttle Opening Enrichment adder (mS x 100)               (RUN_PW_CALCS)
                                      ;Deadband:     ds 2 ; injector deadband at current battery voltage mS*100        (RUN_PW_CALCS)
                                      ;FDpw:         ds 2 ; Fuel Delivery pulse width (PW - Deadband) (mS x 10)        (RUN_PW_CALCS)
                                      ;PW:           ds 2 ; Running engine injector pulsewidth (mS x 10)               (RUN_PW_CALCS)
                                      ;PWtk:         ds 2 ; Running engine injector pulsewidth (uS x 2.56)(102)        (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Method:                                                                      (RUN_PW_CALCS)
                                      ;                                                                                (RUN_PW_CALCS)
                                      ; ("barocor" * "matcor") / 1000 = "PWcalc1" (0.1% resolution)                    (RUN_PW_CALCS)
                                      ; ("Mapx10" * "Ftrmx10") / 1000 = "PWcalc2" (0.1% resolution)                    (RUN_PW_CALCS)
                                      ; ("PWcalc1" * "PWcalc2") / 1000 = "PWcalc3" (0.1% resolution)                   (RUN_PW_CALCS)
                                      ; ("WUEandASEcor" * "veCurr") / 1000 = "PWcalc4" (0.1% resolution)               (RUN_PW_CALCS)
                                      ; ("PWcalc3" * "PWcalc4") / 1000 = "PWcalc5" (0.1% resolution)                   (RUN_PW_CALCS)
                                      ; ("PWcalc5" * reqFuel") / 1000 = "PWlessTOE" (0.1mS resolution)                 (RUN_PW_CALCS)
                                      ; "PWlessTOE" + "TOEpw" = "FDpw"  (0.1mS resolution)                             (RUN_PW_CALCS)
                                      ; "FDpw" + "Deadband" = "PW"  (0.1mS resolution)                                 (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate total corrections before Throttle Opening Enrichment and deadband. (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
006970 7F6970 1E 10 E1 40 02              brset engine,OFCon,NoPWrunCalcs1 ; if "OFCon" bit of "engine" bit field is set branch (RUN_PW_CALCS)
                                                                           ; to NoPWrunCalcs1: (In overrun fuel cut mode so (RUN_PW_CALCS)
                                                                           ; fall through)                             (RUN_PW_CALCS)
006975 7F6975 20 03                       bra  PWrunCalcs    ; Branch to PWrunCalcs:                                   (RUN_PW_CALCS)
006977 7F6977                         NoPWrunCalcs1:                                                                   (RUN_PW_CALCS)
006977 7F6977 06 6A 08                    job  NoPWrunCalcs  ; Jump or branch to NoPWrunCalcs: (long branch)           (RUN_PW_CALCS)
00697A 7F697A                         PWrunCalcs:                                                                      (RUN_PW_CALCS)
00697A 7F697A FC 10 AA                    ldd  barocor      ; "barocor" -> Accu D (% x 10)                             (RUN_PW_CALCS)
00697D 7F697D FD 10 AC                    ldy  matcor       ; "matcor" -> Accu D (% x 10)                              (RUN_PW_CALCS)
006980 7F6980 13                          emul              ; (D)*(Y)->Y:D "barocor" * "matcor"                        (RUN_PW_CALCS)
006981 7F6981 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
006984 7F6984 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("barocor"*"matcor")/1000="PWcalc1" (RUN_PW_CALCS)
006985 7F6985 7D 10 4B                        sty  PWcalc1      ; Result -> "PWcalc1"                                  (RUN_PW_CALCS)
006988 7F6988 FC 10 78                    ldd  Mapx10       ; "Mapx10" -> Accu D (% x 10)                              (RUN_PW_CALCS)
00698B 7F698B FD 10 94                    ldy  Ftrmx10      ; "Ftrmx10" -> Accu D (% x 10)                             (RUN_PW_CALCS)
00698E 7F698E 13                          emul              ; (D)*(Y)->Y:D "Mapx10" * "Ftrmx10"                        (RUN_PW_CALCS)
00698F 7F698F CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
006992 7F6992 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("Mapx10"*"Ftrmx10")/1000="PWcalc2" (RUN_PW_CALCS)
006993 7F6993 7D 10 4D                        sty  PWcalc2      ; Result -> "PWcalc2"                                  (RUN_PW_CALCS)
006996 7F6996 FC 10 4B                    ldd  PWcalc1      ; "PWcalc1" -> Accu D (% x 10)                             (RUN_PW_CALCS)
006999 7F6999 FD 10 4D                    ldy  PWcalc2      ; "PWcalc2" -> Accu D (% x 10)                             (RUN_PW_CALCS)
00699C 7F699C 13                          emul              ; (D)*(Y)->Y:D "PWcalc1" * "PWcalc2"                       (RUN_PW_CALCS)
00699D 7F699D CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
0069A0 7F69A0 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("PWcalc1"*"PWcalc2")/1000="PWcalc3" (RUN_PW_CALCS)
0069A1 7F69A1 7D 10 4F                        sty  PWcalc3      ; Result -> "PWcalc3"                                  (RUN_PW_CALCS)
0069A4 7F69A4 FC 10 B2                    ldd  WUEandASEcor ; "WUEandASEcor" -> Accu D (% x 10)                        (RUN_PW_CALCS)
0069A7 7F69A7 FD 10 A8                    ldy  veCurr       ; "veCurr" -> Accu D (% x 10)                              (RUN_PW_CALCS)
0069AA 7F69AA 13                          emul              ; (D)*(Y)->Y:D "WUEandASEcor" * "veCurr"                   (RUN_PW_CALCS)
0069AB 7F69AB CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
0069AE 7F69AE 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("WUEandASEcor"*"veCurr")/1000="PWcalc4" (RUN_PW_CALCS)
0069AF 7F69AF 7D 10 51                        sty  PWcalc4      ; Result -> "PWcalc4"                                  (RUN_PW_CALCS)
0069B2 7F69B2 FC 10 4F                    ldd  PWcalc3      ; "PWcalc3" -> Accu D (% x 10)                             (RUN_PW_CALCS)
0069B5 7F69B5 FD 10 51                    ldy  PWcalc4      ; "PWcalc4" -> Accu D (% x 10)                             (RUN_PW_CALCS)
0069B8 7F69B8 13                          emul              ; (D)*(Y)->Y:D "PWcalc3" * "PWcalc4"                       (RUN_PW_CALCS)
0069B9 7F69B9 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
0069BC 7F69BC 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("PWcalc3"*"PWcalc4")/1000="PWcalc5" (RUN_PW_CALCS)
0069BD 7F69BD 7D 10 53                        sty  PWcalc5      ; Result -> "PWcalc5"(total corrections before Throttle Opening (RUN_PW_CALCS)
                                                                ; Enrichment and deadband)                             (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate injector pulse width before Throttle Opening Enrichment pulse width and (RUN_PW_CALCS)
                                      ;   Deadband.                                                                    (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
0069C0 7F69C0 FC 10 53                    ldd  PWcalc5      ; "PWcalc5" -> Accu D (% x 10)                             (RUN_PW_CALCS)
0069C3 7F69C3 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (RUN_PW_CALCS)
0069C8 7F69C8 CD 08 00                    ldy   #veBins_E   ; Load index register Y with address of first configurable (RUN_PW_CALCS)
                                                            ; constant on buffer RAM page 1 (veBins_E)                 (RUN_PW_CALCS)
0069CB 7F69CB EE EA 03 EC                 ldx   $03EC,Y     ; Load Accu X with value in buffer RAM page 1 (offset 1004)($03EC) (RUN_PW_CALCS)
                                                            ; ("reqFuel")                                              (RUN_PW_CALCS)
0069CF 7F69CF B7 56                       tfr  X,Y          ; "reqFuel" -> Accu Y                                      (RUN_PW_CALCS)
0069D1 7F69D1 13                          emul              ; (D)*(Y)->Y:D "PWcalc5" * "reqfuel"                       (RUN_PW_CALCS)
0069D2 7F69D2 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
0069D5 7F69D5 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("PWcalc5"*"reqFuel")/1000="PWlessTOE" (RUN_PW_CALCS)
0069D6 7F69D6 7D 10 BE                        sty  PWlessTOE    ; Result -> "PWlessTOE" (mS x 10)                      (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Add the Throttle Opening Enricment pulse width and store as "FDpw"(fuel delivery (RUN_PW_CALCS)
                                      ;   pulse width)(mS x 10)                                                        (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
0069D9 7F69D9 B7 64                       tfr  Y,D          ; "PWlessTOE" -> Accu D                                    (RUN_PW_CALCS)
0069DB 7F69DB F3 10 BC                        addd TOEpw        ; (A:B)+(M:M+1)->A:B ("PWlessTOE"+"TOEpw"="FDpw"       (RUN_PW_CALCS)
0069DE 7F69DE 7C 10 C6                        std  FDpw         ; Result -> "FDpw" (fuel delivery pulsewidth (mS x 10) (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Add "deadband" and store the result as "PW"(final injector pulsewidth)(mS x 10) (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
0069E1 7F69E1 F3 10 C0                        addd Deadband    ; (A:B)+(M:M+1)->A:B ("FDpw"+"Deadband"="PW"            (RUN_PW_CALCS)
0069E4 7F69E4 7C 10 C8                        std  PW          ; Result -> "PW" (final injector pulsewidth) (mS x 10)  (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Convert "PW" to timer ticks in 2.56uS resolution.                            (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
0069E7 7F69E7 FC 10 C8                    ldd   PW         ; "PW" -> Accu D                                            (RUN_PW_CALCS)
0069EA 7F69EA CD 27 10                        ldy   #$2710     ; Load index register Y with decimal 10000 (for integer math) (RUN_PW_CALCS)
0069ED 7F69ED 13                              emul             ;(D)x(Y)=Y:D "PW" * 10,000                              (RUN_PW_CALCS)
0069EE 7F69EE CE 01 00                        ldx   #$100      ; Decimal 256 -> Accu X                                 (RUN_PW_CALCS)
0069F1 7F69F1 11                          ediv             ;(Y:D)/(X)=Y;Rem->D "PW" * 10,000 / 256 = "PWtk"            (RUN_PW_CALCS)
0069F2 7F69F2 7D 10 5B                    sty   PWtk       ; Copy result to "PWtk" (Running engine injector pulsewidth) (RUN_PW_CALCS)
                                                               ; (uS x 2.56)                                           (RUN_PW_CALCS)
0069F5 7F69F5 7D 10 5F                    sty   InjOCadd2  ; Second injector output compare adder (2.56uS res)         (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Injector duty cycle percentage is the time the injector takes to inject the fuel (RUN_PW_CALCS)
                                      ;   divided by the time available x 100. The time available is the engine cycle which is (RUN_PW_CALCS)
                                      ;   two crankshaft revolutions. It is important to know what our duty cycle is at high (RUN_PW_CALCS)
                                      ;   engine speeds and loads. 80% is considered a safe maximum. The crank angle period is (RUN_PW_CALCS)
                                      ;   measured over 72 degrees of crank rotation. In run mode the timer is set to a 2.56uS (RUN_PW_CALCS)
                                      ;   time base and the pulse width timer value is in 2.56uS resolution. The engine cycle (RUN_PW_CALCS)
                                      ;   period in 2.56uS resolution can be calculated by multiplying the period by 10, for (RUN_PW_CALCS)
                                      ;   the two revolutions in the cycle. The duty cycle percentage is calculated by (RUN_PW_CALCS)
                                      ;   dividing "PWtk" by the cycle period and dividing by 100.                     (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate injector duty cycle                                                (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
0069F8 7F69F8 FC 10 5B                    ldd  PWtk           ; "PWtk"->Accu D                                         (RUN_PW_CALCS)
0069FB 7F69FB CD 00 0A                    ldy  #$000A         ; Decimal 10-> Accu Y (for integer math)                 (RUN_PW_CALCS)
0069FE 7F69FE 13                              emul                ;(D)x(Y)=Y:D "PWtk"*10                               (RUN_PW_CALCS)
0069FF 7F69FF FE 10 9C                    ldx  CASprd256      ; "CASprd256"-> Accu X (running period for 72 degrees rotation) (RUN_PW_CALCS)
006A02 7F6A02 11                          ediv                ;(Y:D)/(X)=Y;Rem->D ("PWtk"*10)/"CASprd256"              (RUN_PW_CALCS)
006A03 7F6A03 7D 10 E8                    sty  DutyCyclex10   ; Copy result to "DutyCyclex10" (Injector duty cycle x 10) (RUN_PW_CALCS)
006A06 7F6A06 20 24                       bra  PWrunCalcsDone ; Branch to PWrunCalcsDone:                              (RUN_PW_CALCS)
006A08 7F6A08                         NoPWrunCalcs:                                                                    (RUN_PW_CALCS)
006A08 7F6A08 18 79 10 BE                 clrw  PWlessTOE     ; Clear "PWlessTOE" Injector PW before "TOEpw"+"Deadband"(mS x 10) (RUN_PW_CALCS)
006A0C 7F6A0C 18 79 10 BC                 clrw  TOEpw         ; Clear "TOEpw" Throttle Opening Enrichment adder (mS x 100) (RUN_PW_CALCS)
006A10 7F6A10 18 79 10 C6                 clrw  FDpw          ; Clear "FDpw" Fuel Delivery pulse width (PW - Deadband)(mS x 10) (RUN_PW_CALCS)
006A14 7F6A14 18 79 10 C8                 clrw  PW            ; Clear "PW" Running engine injector pulsewidth (mS x 10) (RUN_PW_CALCS)
006A18 7F6A18 18 79 10 5B                 clrw  PWtk          ; Clear "PWtk" Running injector pulsewidth timer ticks(uS x 2.56) (RUN_PW_CALCS)
006A1C 7F6A1C 18 03 00 02 10 5D           movw  #$0002,InjOCadd1     ; First injector output compare adder (5.12uS res or 2.56uS res) (RUN_PW_CALCS)
006A22 7F6A22 18 03 00 02 10 5F           movw  #$0002,InjOCadd2     ; Second injector output compare adder (5.12uS res or 2.56uS res) (RUN_PW_CALCS)
006A28 7F6A28 18 79 10 E8                 clrw  DutyCyclex10  ; Clear "DutyCyclex10" Injector duty cycle in run mode (% x 10) (RUN_PW_CALCS)
006A2C 7F6A2C                         PWrunCalcsDone:                                                                  (RUN_PW_CALCS)
006A2C 7F6A2C MACRO                       BARO_COR_LU       ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (BARO_COR_LU)
                                      ; - Look up current value in Barometric Correction Table (barocor)               (BARO_COR_LU)
                                      ;***************************************************************************************** (BARO_COR_LU)
006A2C 7F6A2C 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (BARO_COR_LU)
006A31 7F6A31 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (BARO_COR_LU)
                                                                  ; -> page where the desired curve resides            (BARO_COR_LU)
006A37 7F6A37 18 03 01 68 10 27           movw #$0168,CrvRowOfst  ; 360 -> Offset from the curve page to the curve row(barCorVals) (BARO_COR_LU)
                                                                      ; (actual offset is 720)                         (BARO_COR_LU)
006A3D 7F6A3D 18 03 01 71 10 29           movw #$0171,CrvColOfst  ; 369 -> Offset from the curve page to the curve column(barCorDelta) (BARO_COR_LU)
                                                                      ; (actual offset is 738)                         (BARO_COR_LU)
006A43 7F6A43 18 04 10 84 10 2B           movw Barox10,CrvCmpVal  ; Barometric Pressure (KPAx10) -> Curve comparison value (BARO_COR_LU)
006A49 7F6A49 18 0B 08 10 2D              movb #$08,CrvBinCnt     ; 8 -> number of bins in the curve row or column minus 1 (BARO_COR_LU)
006A4E 7F6A4E 16 6F 46                    jsr   CRV_LU_P   ; Jump to subroutine at CRV_LU_P:(located in interp_BEEM488.s module) (BARO_COR_LU)
006A51 7F6A51 7C 10 AA                    std   barocor    ; Copy result to Barometric correction (% x 10)             (BARO_COR_LU)
006A54 7F6A54 MACRO                       MAT_COR_LU        ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (MAT_COR_LU)
                                      ; - Look up current value in MAT Air Density Table (matcor)                      (MAT_COR_LU)
                                      ;***************************************************************************************** (MAT_COR_LU)
006A54 7F6A54 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (MAT_COR_LU)
006A59 7F6A59 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (MAT_COR_LU)
                                                                  ;  ->page where the desired curve resides            (MAT_COR_LU)
006A5F 7F6A5F 18 03 01 9A 10 27           movw #$019A,CrvRowOfst  ; 410 -> Offset from the curve page to the curve row(matCorrTemps2) (MAT_COR_LU)
                                                                      ; (actual offset is 820)                         (MAT_COR_LU)
006A65 7F6A65 18 03 01 A3 10 29           movw #$01A3,CrvColOfst  ; 419 -> Offset from the curve page to the curve column(matCorrDelta2) (MAT_COR_LU)
                                                                      ; (actual offset is 838)                         (MAT_COR_LU)
006A6B 7F6A6B 18 04 10 70 10 2B           movw Matx10,CrvCmpVal   ; Manifold Air Temperature (Degrees F x 10) ->       (MAT_COR_LU)
                                                                  ; Curve comparison value                             (MAT_COR_LU)
006A71 7F6A71 18 0B 08 10 2D              movb #$08,CrvBinCnt     ; 8 -> number of bins in the curve row or column minus 1 (MAT_COR_LU)
006A76 7F6A76 16 70 0F                    jsr   CRV_LU_NP  ; Jump to subroutine at CRV_LU_NP:(located in interp_BEEM488.s module) (MAT_COR_LU)
006A79 7F6A79 7C 10 AC                    std   matcor     ; Copy result to Manifold Air Temperature Correction (% x 10) (MAT_COR_LU)
                                                            ; All of these Macro calls moved from the main loop in BPEM488.s
                                                            ; as a work around for random corrupted returns 5-4-21
006A7C 7F6A7C 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
006A7F 7F6A7F                         Notch_CT4_T4:
                                      ;*****************************************************************************************
                                      ; - If we are here the crankshaft is at 150 degrees before top dead centre on the
                                      ;   compression/power strokes for #5 cylinder. Start the hardware timer to delay the
                                      ;   coil dwell for spark #5, waste #10 if we are in run mode.
                                      ;*****************************************************************************************
006A7F 7F6A7F MACRO                       FIRE_IGN2                 ; macro in Tim_BPEM488.s
                                                              ; (Will trigger an interrupt after the delay time)(LED off) (FIRE_IGN2)
                                      ;***************************************************************************************** (FIRE_IGN2)
                                      ; - PT4 - IOC4 OC4 Ign2(10&5) Control                                            (FIRE_IGN2)
                                      ;***************************************************************************************** (FIRE_IGN2)
                                      ;***************************************************************************************** (FIRE_IGN2)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_IGN2)
                                      ;***************************************************************************************** (FIRE_IGN2)
006A7F 7F6A7F 4C 48 02                    bset ECT_TCTL1,Bit1 ; Set Ch4 output line to 1 on compare                    (FIRE_IGN2)
006A82 7F6A82 4C 48 01                    bset ECT_TCTL1,Bit0 ; Set Ch4 output line to 1 on compare                    (FIRE_IGN2)
006A85 7F6A85 DC 44                       ldd  ECT_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_IGN2)
006A87 7F6A87 F3 10 41                    addd IgnOCadd1      ; Add "IgnOCadd1" (Delay time from crank signal to energise coil) (FIRE_IGN2)
006A8A 7F6A8A 5C 58                       std  ECT_TC4H       ; Copy result to Timer IC/OC register 2 (Start OC operation) (FIRE_IGN2)
006A8C 7F6A8C 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
006A8F 7F6A8F                         Notch_CT1_T5:
                                      ;*****************************************************************************************
                                      ; - If we are here the crankshaft is at 150 degrees before top dead centre on the
                                      ;   compression/power strokes for #8 cylinder. Start the hardware timer to delay the
                                      ;   coil dwell for spark #8, waste #9 if we are in run mode.
                                      ;*****************************************************************************************
006A8F 7F6A8F MACRO                       FIRE_IGN3                 ; macro in Tim_BPEM488.s
                                                              ; (Will trigger an interrupt after the delay time)(LED off) (FIRE_IGN3)
                                      ;***************************************************************************************** (FIRE_IGN3)
                                      ; - PT5 - IOC5 OC5 Ign3(9&8) Control                                             (FIRE_IGN3)
                                      ;***************************************************************************************** (FIRE_IGN3)
                                      ;***************************************************************************************** (FIRE_IGN3)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_IGN3)
                                      ;***************************************************************************************** (FIRE_IGN3)
006A8F 7F6A8F 4C 48 08                    bset ECT_TCTL1,Bit3 ; Set Ch5 output line to 1 on compare                    (FIRE_IGN3)
006A92 7F6A92 4C 48 04                    bset ECT_TCTL1,Bit2 ; Set Ch5 output line to 1 on compare                    (FIRE_IGN3)
006A95 7F6A95 DC 44                       ldd  ECT_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_IGN3)
006A97 7F6A97 F3 10 41                    addd IgnOCadd1      ; Add "IgnOCadd1" (Delay time from crank signal to energise coil) (FIRE_IGN3)
006A9A 7F6A9A 5C 5A                       std  ECT_TC5H       ; Copy result to Timer IC/OC register 2 (Start OC operation) (FIRE_IGN3)
006A9C 7F6A9C 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
006A9F 7F6A9F                         Notch_CT1_T6:
                                      ;*****************************************************************************************
                                      ; - If we are here the crankshaft is at 6 degrees before top dead centre on the
                                      ;   exhaust/intake strokes for #1 cylinder and 60 degrees before top dead centre on the
                                      ;   exhaust/intake strokes for #1 cylinder. #10 intake valve is just starting to open
                                      ;   and #8 intake valve is 54 degrees before it will start to open. Start the pulse
                                      ;   width for injectors 1&10.
                                      ;*****************************************************************************************
006A9F 7F6A9F 1E 10 E1 80 11              brset engine,FldClr,INJ1FldClr ; If "FldClr" bit of "engine" bit field is set branch
                                                                         ; to INJ1FldClr:
006AA4 7F6AA4 MACRO                       FIRE_INJ1                 ; Macro in Tim_BPEM488.s
                                      ;***************************************************************************************** (FIRE_INJ1)
                                      ; - PP0 - TIM1 OC0(Inj1)(1&10) Control                                           (FIRE_INJ1)
                                      ;***************************************************************************************** (FIRE_INJ1)
                                      ;***************************************************************************************** (FIRE_INJ1)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_INJ1)
                                      ;***************************************************************************************** (FIRE_INJ1)
006AA4 7F6AA4 1C 03 D9 01                 bset TIM_TCTL2,Bit0 ; Set Ch0 output line to 1 on compare                    (FIRE_INJ1)
006AA8 7F6AA8 1C 03 D9 02                 bset TIM_TCTL2,Bit1 ; Set Ch0 output line to 1 on compare                    (FIRE_INJ1)
006AAC 7F6AAC FC 03 D4                    ldd  TIM_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_INJ1)
006AAF 7F6AAF F3 10 5D                    addd InjOCadd1      ; (A:B)+(M:M+1->A:B Add "InjOCadd1" (Delay from trigger to start (FIRE_INJ1)
                                                              ; of injection)                                          (FIRE_INJ1)
006AB2 7F6AB2 7C 03 E0                    std  TIM_TC0H       ; Copy result to Timer IC/OC register 0 (Start OC operation) (FIRE_INJ1)
006AB5 7F6AB5                         INJ1FldClr:
                                      ;***********************************************************************************************
                                      ; - Update Fuel Delivery Pulse Width Total so the results can be used by Tuner Studio and
                                      ;   Shadow Dash to calculate current fuel burn.
                                      ;***********************************************************************************************
006AB5 7F6AB5 FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10)-> Accu D
006AB8 7F6AB8 F3 10 C6                    addd FDpw           ; (A:B)+(M:M+1->A:B Add  Fuel Delivery pulse width (mS x 10)
006ABB 7F6ABB 7C 10 D0                    std  FDt            ; Copy result to "FDT" (update "FDt")(mS x 10)
                                      ;***********************************************************************************************
                                      ; - Update the Fuel Delivery counter so that on roll over (65535mS)a pulsed signal can be sent to the
                                      ;   to the totalizer(open collector output)
                                      ;***********************************************************************************************
006ABE 7F6ABE FC 10 D0                    ldd  FDt             ; Fuel Delivery pulse width total(mS x 10)-> Accu D
006AC1 7F6AC1 F3 10 61                        addd FDcnt           ; (A:B)+(M:M+1)->A:B (fuel delivery pulsewidth + fuel delivery counter)
006AC4 7F6AC4 25 05                       bcs  Totalizer1R     ; If the cary bit of CCR is set, branch to Totalizer1R: ("FDcnt"
                                                                   ;  rollover, pulse the totalizer)
006AC6 7F6AC6 7C 10 61                        std  FDcnt           ; Copy the result to "FDcnt" (update "FDcnt")
006AC9 7F6AC9 20 0B                       bra  TotalizerDone1R ; Branch to TotalizerDone1R:
006ACB 7F6ACB                         Totalizer1R:
006ACB 7F6ACB 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
006ACE 7F6ACE 4C 01 08                    bset PORTB,AIOT     ; Set "AIOT" pin on Port B (PB6)(start totalizer pulse)
006AD1 7F6AD1 86 03                           ldaa #$03           ; Decimal 3->Accu A (3 mS)
006AD3 7F6AD3 7A 10 63                    staa AIOTcnt        ; Copy to "AIOTcnt" ( counter for totalizer pulse width,
                                                                  ; decremented every mS)
006AD6 7F6AD6                         TotalizerDone1R:
006AD6 7F6AD6 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
006AD9 7F6AD9                         Notch_CT1_T7:
                                      ;*****************************************************************************************
                                      ; - No event
                                      ;*****************************************************************************************
006AD9 7F6AD9 MACRO                       ST_LU             ; Macro in igncalcs_BPEM.s
                                      ;***************************************************************************************** (ST_LU)
                                      ; For a 2.56uS timer 1 Sec = 1/.00000256 = 390625 tics                           (ST_LU)
                                      ; 1mS = 390625 / 1000 = 390.625 tics                                             (ST_LU)
                                      ; 0.1mS = 390.625 / 10 = 39.0625 tics                                            (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; 1 RPM/60 = .016666666 Rev per Sec                                              (ST_LU)
                                      ; 1/.016666666 = 60 sec period                                                   (ST_LU)
                                      ; 60/360 = .166666666 sec per degree at 1 RPM                                    (ST_LU)
                                      ; 60/5 = 12 sec Crank Angle Sensor period at 1 RPM                               (ST_LU)
                                      ; 12/.00000256 = 4687500 2.56uS tics at 1 RPM ("CASprdtk")                       (ST_LU)
                                      ; 4687500/72 = 65104.16667 2.56uS tics per degree at 1 RPM ("TkspDeg")           (ST_LU)
                                      ; .166666666/.00000256 = 65104.14063 2.56uS tics per degree at 1 RPM ("TkspDeg") (ST_LU)
                                      ; 1/65104.16667 = .000001528808485 degrees per tic at 1 RPM                      (ST_LU)
                                      ; 71.52666514/60 = 1.192111 Rev per Sec                                          (ST_LU)
                                      ; 1/1.192111 = .83884806 sec period                                              (ST_LU)
                                      ; .83884806/360 = .0023301335 sec per degree at 71.52666 RPM                     (ST_LU)
                                      ; .83884806/5 = .167769612 sec Crank Angle Sensor period at 71.52666 RPM         (ST_LU)
                                      ; .167769612/.00000256 = 65535 2.56uS tics at 71.52666 RPM ("CASprdtk")          (ST_LU)
                                      ; 65535/72 = 910.208333 2.56uS tics per degree at 71.52666 RPM ("TkspDeg")       (ST_LU)
                                      ; .0023301335/.00000256 = 910.2083984 2.56uS tics per degree at 71.52666 RPM ("TkspDeg") (ST_LU)
                                      ; 1/910.208333 = .001098649577 degrees per tic at 71.52666 RPM                   (ST_LU)
                                      ; 500 RPM/60 = 8.333333333 Rev per Sec                                           (ST_LU)
                                      ; 1/8.333333333 = .12 sec period                                                 (ST_LU)
                                      ; .12/360 = .0003333333 sec per degree at 500 RPM                                (ST_LU)
                                      ; .12/5 = .024 sec Crank Angle Sensor period at 500 RPM                          (ST_LU)
                                      ; .024/.00000256 = 9375 2.56uS tics at 500 RPM ("CASprdtk")                      (ST_LU)
                                      ; 9375/72 = 130.2083333 2.56uS tics per degree at 500 RPM ("TkspDeg")            (ST_LU)
                                      ; .0003333333/.00000256 = 130.2083203 2.56uS tics per degree at 500 RPM ("TkspDeg") (ST_LU)
                                      ; 1/130.2083333 = .00768 degrees per tic at 500 RPM                              (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; 4250 RPM/60 = 70.8333333 Rev per Sec                                           (ST_LU)
                                      ; 1/70.8333333 = .014117647 sec period                                           (ST_LU)
                                      ; .014117647/360 = .00003921568629 sec per degree at 4250 RPM                    (ST_LU)
                                      ; .014117647/5 = .0028235294 sec Crank Angle Sensor period at 5000 RPM           (ST_LU)
                                      ; .0028235294/.00000256 = 1102.941172 2.56uS tics at 5000 RPM ("CASprdtk")       (ST_LU)
                                      ; 1102.941172/72 = 15.31862739 2.56uS tics per degree at 4250 RPM ("TkspDeg")    (ST_LU)
                                      ; .00003921568629/.00000256 = 15.31862746 2.56uS tics per degree at 4250 RPM ("TkspDeg") (ST_LU)
                                      ; 1/15.31862739 = .06528 degrees per tic at 4250 RPM                             (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; Ignition crank notches are placed 150 degrees BTDC for their respective cylinder (ST_LU)
                                      ; Dwell times of .006sec crank and .004sec run seem to work well                 (ST_LU)
                                      ; Maximum ignition advance expected is 35 degrees BTDC at low load and high RPM  (ST_LU)
                                      ; From data logs cranking RPM is between ~154RPM and ~241RPM                     (ST_LU)
                                      ; Just before stall is ~251RPM                                                   (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; At 4250 RPM a 4mSec dwell time takes .004/.00003921568629 = 102 degrees of rotation (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; At power up the timers are initialized with a 5.12uS time base. A "Spantk"     (ST_LU)
                                      ; value of 65535 will happen at 84.441 RPM so this is the lowest RPM that can be (ST_LU)
                                      ; calculated during crank conditions. Resolution at 4250 RPM is 7.706 RPM. If the (ST_LU)
                                      ; time base were 2.56uS a "Spantk" value of 65535 will happen at 168.882 RPM.    (ST_LU)
                                      ; Resolution at 4250 RPM is 3.856 RPM. Cranking RPM can be lower than 168 RPM    (ST_LU)
                                      ; so this is why we begin with the 5.12uS base. When RPM reaches ~300 we are almost (ST_LU)
                                      ; ceratinly running so at that point the time base is switched to 2.56uS. This base (ST_LU)
                                      ; will allow ignition calculations to be done as low as ~169 RPM which is probably lower (ST_LU)
                                      ; than the speed at which the engine can be made to run.                         (ST_LU)
                                      ; With a time base of 5.12uS "CASprd512" of 7812 happens at 300 RPM. When the period gets (ST_LU)
                                      ; shorter than this the time base is switched over to 2.56uS ("CASprd256").      (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ; - Ignition timing in degrees to 0.1 degree resolution is selected from the 3D  (ST_LU)
                                      ;   lookup table "ST" which plots manifold pressure against RPM. A potentiometer on the (ST_LU)
                                      ;   dash board allows a manual trim of the "ST" values of from 0 to 20 degrees advance (ST_LU)
                                      ;   and from 0 to 20 degrees retard. The ignition system is what is called "waste spark", (ST_LU)
                                      ;   which pairs cylinders on a single coil. The spark is delivered to both cylinders at (ST_LU)
                                      ;   the same time. One cylinder recieves the spark at the appropriate time for ignition. (ST_LU)
                                      ;   The other recieves it when the exhaust valve is open. Hence the name "waste spark". (ST_LU)
                                      ;   On this 10 cylinder engine there are 5 coils, each controlled by its own hardware (ST_LU)
                                      ;   timer. The cylinders are paired 1&6, 10&5, 9&8, 4&7, 3&2                     (ST_LU)
                                      ;   In an ignition event the timer is first loaded with the output compare value in (ST_LU)
                                      ;   "Delaytk". At the compare interrupt the coil is energised and the timer is loaded (ST_LU)
                                      ;   with the output compare value in "DwllFintk". At the compare interrupt the coil is (ST_LU)
                                      ;   de-energized to fire the spark. The delay in timer ticks will depend on the timer base (ST_LU)
                                      ;   rate of either 5.12 uS for cranking or 2.56uS for running.                   (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;  Crank Signal                                                                  (ST_LU)
                                      ;   150BTDC                          Ign                    20ATDC               (ST_LU)
                                      ;      <- Delay          -><- Dwell -><-      ST + Trim     ->                   (ST_LU)
                                      ;     I___________________I__________ I_______________________I                  (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;                          <-            Advance            ->                   (ST_LU)
                                      ;      <-            Ignition Span (170 degrees)            ->                   (ST_LU)
                                      ;                                                                                (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
                                      ; - Look up current value in ST table (STcurr) (degrees*10)                      (ST_LU)
                                      ;***************************************************************************************** (ST_LU)
006AD9 7F6AD9 FE 10 78                    ldx   Mapx10     ; Load index register X with value in "Mapx10"(Column value Manifold (ST_LU)
                                                           ; Absolute Pressure*10 )                                    (ST_LU)
006ADC 7F6ADC FC 10 A0                    ldd   RPM        ; Load double accumulator D with value in "RPM" (Row value RPM) (ST_LU)
006ADF 7F6ADF 18 0B FE 00 17              movb  #(BUF_RAM_P2_START>>16),EPAGE  ; Move $FE into EPAGE                   (ST_LU)
006AE4 7F6AE4 CD 08 00                    ldy   #stBins_E  ; Load index register Y with address of the first value in ST table (ST_LU)
006AE7 7F6AE7 16 6E 77                    jsr   3D_LOOKUP  ; Jump to subroutine at 3D_LOOKUP:                          (ST_LU)
006AEA 7F6AEA 7C 10 D2                    std   STcurr     ; Copy result to "STcurr"                                   (ST_LU)
006AED 7F6AED MACRO                       DWELL_COR_LU      ; Macro in igncalcs_BPEM.s
                                      ;***************************************************************************************** (DWELL_COR_LU)
                                      ; - Look up current value in Dwell Battery Adjustment Table (dwellcor)(% x 10)   (DWELL_COR_LU)
                                      ;***************************************************************************************** (DWELL_COR_LU)
006AED 7F6AED 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (DWELL_COR_LU)
006AF2 7F6AF2 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (DWELL_COR_LU)
                                                                  ;  ->page where the desired curve resides            (DWELL_COR_LU)
006AF8 7F6AF8 18 03 01 7A 10 27           movw #$017A,CrvRowOfst  ; 378 -> Offset from the curve page to the curve row(dwellvolts) (DWELL_COR_LU)
                                                                      ;(actual offset is 756                           (DWELL_COR_LU)
006AFE 7F6AFE 18 03 01 80 10 29           movw #$0180,CrvColOfst  ; 384 -> Offset from the curve page to the curve column(dwellcorr) (DWELL_COR_LU)
                                                                      ;(actual offset is 768)                          (DWELL_COR_LU)
006B04 7F6B04 18 04 10 68 10 2B           movw BatVx10,CrvCmpVal  ; Battery Voltage (Volts x 10) -> Curve comparison value (DWELL_COR_LU)
006B0A 7F6B0A 18 0B 05 10 2D              movb #$05,CrvBinCnt     ; 5 -> number of bins in the curve row or column minus 1 (DWELL_COR_LU)
006B0F 7F6B0F 16 6F 46                    jsr   CRV_LU_P   ; Jump to subroutine at CRV_LU_P:(located in interp_BEEM488.s module) (DWELL_COR_LU)
006B12 7F6B12 7C 10 D6                    std   DwellCor   ; Copy result to Dwell battery correction (% x 10)          (DWELL_COR_LU)
006B15 7F6B15 MACRO                       VE_LU             ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (VE_LU)
                                      ; The base value for injector pulse width calculations in mS to 0.1mS resolution is called (VE_LU)
                                      ; "ReqFuel". It represents the pulse width reqired to achieve 14.7:1 Air/Fuel Ratio at (VE_LU)
                                      ; 100% volumetric efficiency. The VE table contains percentage values to 0.1 percent (VE_LU)
                                      ; resolultion and plots intake manifold pressure in KPA to 0.1KPA resolution against RPM. (VE_LU)
                                      ; These values are part of the injector pulse width calculations for a running engine. (VE_LU)
                                      ;***************************************************************************************** (VE_LU)
                                      ;***************************************************************************************** (VE_LU)
                                      ; - Look up current value in VE table (veCurr)(%x10)                             (VE_LU)
                                      ;***************************************************************************************** (VE_LU)
006B15 7F6B15 FE 10 78                    ldx   Mapx10     ; Load index register X with value in "Mapx10"(Column value Manifold (VE_LU)
                                                           ; Absolute Pressure x 10 )                                  (VE_LU)
006B18 7F6B18 FC 10 A0                    ldd   RPM        ; Load double accumulator D with value in "RPM" (Row value RPM) (VE_LU)
006B1B 7F6B1B 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (VE_LU)
006B20 7F6B20 CD 08 00                    ldy   #veBins_E    ; Load index register Y with address of the first value in VE table (VE_LU)
                                                           ;(in RAM)                                                   (VE_LU)
006B23 7F6B23 16 6E 77                    jsr   3D_LOOKUP  ; Jump to subroutine at 3D_LOOKUP:                          (VE_LU)
006B26 7F6B26 7C 10 A8                    std   VEcurr     ; Copy result to "VEcurr"(%x10)                             (VE_LU)
006B29 7F6B29 MACRO                       AFR_LU            ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (AFR_LU)
                                      ; The Air/Fuel Ratio of the fuel mixture affects how an engine will run. Generally (AFR_LU)
                                      ; speaking AFRs of less than ~7:1 are too rich to ignite. Ratios of greater than ~20:1 are (AFR_LU)
                                      ; too lean to ignite. Stoichiometric ratio is at ~14.7:1. This is the ratio at which all (AFR_LU)
                                      ; the fuel and all the oxygen are consumed and is best for emmisions concerns. Best power (AFR_LU)
                                      ; is obtained between ratios of ~12:1 and ~13:1. Best economy is obtained as lean as ~18:1 (AFR_LU)
                                      ; in some engines. This controller runs in open loop so the AFR numbers are used as (AFR_LU)
                                      ; a tuning aid only.                                                             (AFR_LU)
                                      ;***************************************************************************************** (AFR_LU)
                                      ;***************************************************************************************** (AFR_LU)
                                      ; - Look up current value in AFR table (afrCurr)(AFRx10)                         (AFR_LU)
                                      ;***************************************************************************************** (AFR_LU)
006B29 7F6B29 FE 10 78                    ldx   Mapx10     ; Load index register X with value in "Mapx10"(Column value Manifold (AFR_LU)
                                                           ; Absolute Pressure x 10 )                                  (AFR_LU)
006B2C 7F6B2C FC 10 A0                    ldd   RPM        ; Load double accumulator D with value in "RPM" (Row value RPM) (AFR_LU)
006B2F 7F6B2F 18 0B FD 00 17              movb  #(BUF_RAM_P3_START>>16),EPAGE  ; Move $FD into EPAGE                   (AFR_LU)
006B34 7F6B34 CD 08 00                    ldy   #afrBins_E   ; Load index register Y with address of the first value in AFR table (AFR_LU)
                                                           ;(in RAM)                                                   (AFR_LU)
006B37 7F6B37 16 6E 77                    jsr   3D_LOOKUP  ; Jump to subroutine at 3D_LOOKUP:                          (AFR_LU)
006B3A 7F6B3A 7C 10 A6                    std   AFRcurr    ; Copy result to "AFRcurr"                                  (AFR_LU)
006B3D 7F6B3D MACRO                       TOE_OFC_CALCS     ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - When the engine is running and the throttle is opened quickly a richer mixture is (TOE_OFC_CALCS)
                                      ;   required for a short period of time. This additional pulse width time is called (TOE_OFC_CALCS)
                                      ;   Throttle Opening Enrichment. Conversly, when the engine is in over run       (TOE_OFC_CALCS)
                                      ;   conditions no fuel is required so the injectors can be turned off, subject to (TOE_OFC_CALCS)
                                      ;   permissives. This condtion is call Overrun Fuel Cut.                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check to see if the throttle is opening or if it is at steady state or closing (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
006B3D 7F6B3D                         TOE_OFC_CHK:                                                                     (TOE_OFC_CALCS)
006B3D 7F6B3D FE 10 7C                    ldx   TpsPctx10       ; Load index register X with value in "TpsPctx10"      (TOE_OFC_CALCS)
006B40 7F6B40 BE 10 45                    cpx   TpsPctx10last   ; (X)-(M:M+1)Compare with value in "TpsPctx10last"     (TOE_OFC_CALCS)
006B43 7F6B43 18 23 01 84                 bls   OFC_CHK         ; If "TpsPctx10" is equal to or less than "TpsPctx10last" branch to (TOE_OFC_CALCS)
                                                                    ; OFC_CHK:(Throttle is steady or closing so check for OFC permissives) (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Current Throttle position percent - throttle position percent 100mS ago = throttle position (TOE_OFC_CALCS)
                                      ;   percent difference over time in seconds "TpsPctx10" - "TpsPctx10last" = "TpsPctDOT" (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
006B47 7F6B47 18 B0 10 45                 subx  TpsPctx10last   ; (X)-(M:M-1)=>X Subtract "TpsPctx10last" from "TpsPctx10" (TOE_OFC_CALCS)
006B4B 7F6B4B 7E 10 B6                    stx   TpsPctDOT       ; Copy result to "TpsPctDOT"                           (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - The throttle is opening. Check to see if it is opening at a rate greater than the threshold (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
006B4E 7F6B4E 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006B53 7F6B53 CD 08 00                    ldy   #veBins_E       ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                                ; on buffer RAM page 1 (veBins_E)                      (TOE_OFC_CALCS)
006B56 7F6B56 EE EA 03 D0                 ldx   $03D0,Y         ; Load Accu D with value in buffer RAM page 1 offset 976 (tpsThresh) (TOE_OFC_CALCS)
                                                                ;(TPSdot threshold)(offset = 976)($03D0)               (TOE_OFC_CALCS)
006B5A 7F6B5A BE 10 B6                    cpx   TpsPctDOT       ; Compare "tpsThresh" with "TpsPctDOT"                 (TOE_OFC_CALCS)
006B5D 7F6B5D 18 22 01 3D                 bhi   TOE_CHK_TIME    ; If "tpsThresh" is greater than "TpsPctDOT", branch to TOE_CHK_TIME: (TOE_OFC_CALCS)
                                                                ; ("TpsPctDOT" below threshold so check if acceleration is done) (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - The throttle is opening at a rate greater then the threshold. Check to see if TOE is in (TOE_OFC_CALCS)
                                      ;   progress.                                                                    (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
006B61 7F6B61 1E 10 E1 20 2D              brset engine,TOEon,TOE_CALC ; If "TOEon" bit of "engine" bit field           (TOE_OFC_CALCS)
                                                                ; is set, branch to TOE_CALC: (TOE in progress)        (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ;- The throttle is opening at a rate greater than the threshold and TOE is not in progress (TOE_OFC_CALCS)
                                      ;  so prepare to add in the enrichement.                                         (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
006B66 7F6B66 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006B6B 7F6B6B CD 08 00                    ldy   #veBins_E       ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                              ; on buffer RAM page 1 (veBins_E)                        (TOE_OFC_CALCS)
006B6E 7F6B6E EC EA 03 BC                 ldd  $03BC,Y        ; Load Accu D with value in buffer RAM page 1 (offset 956) (First element (TOE_OFC_CALCS)
                                                              ; of "TOEbins" table)(Start with first element, will determine actual (TOE_OFC_CALCS)
                                                              ; next time around)                                      (TOE_OFC_CALCS)
006B72 7F6B72 7B 10 BB                    stab   TOEpct       ; Copy to Throttle Opening Enrichment percent(used in later calculations) (TOE_OFC_CALCS)
006B75 7F6B75 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006B7A 7F6B7A CD 08 00                    ldy   #veBins_E     ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                              ; on buffer RAM page 1 (veBins_E)                        (TOE_OFC_CALCS)
006B7D 7F6B7D EC EA 03 D2                 ldd   $03D2,Y       ; Load Accu D with value in buffer RAM page 1 offset 978 (TOEtime_F) (TOE_OFC_CALCS)
006B81 7F6B81 7B 10 CF                    stab  TOEdurCnt     ; Copy to "TOEdurCnt" (Throttle Opening Enrichment duration (TOE_OFC_CALCS)
                                                                  ; (decremented every 100 mS))                        (TOE_OFC_CALCS)
006B84 7F6B84 1C 10 E1 20                 bset  engine,TOEon  ; Set "TOEon" bit of "engine" variable (in TOE mode)     (TOE_OFC_CALCS)
006B88 7F6B88 1C 10 E2 08                 bset  engine2,TOEduron  ; Set "TOEduron" bit of "engine2" variable (TOE duration) (TOE_OFC_CALCS)
006B8C 7F6B8C 1D 10 E1 40                 bclr  engine,OFCon  ; Clear "OFCon" bit of "engine" variable (not in OFC mode) (TOE_OFC_CALCS)
006B90 7F6B90 06 6D 0D                    job   OFC_LOOP      ; Jump or branch to OFC_LOOP:(fall through)              (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Calculate the cold temperature add-on enrichment "ColdAddpct" (%) from -39.72 (TOE_OFC_CALCS)
                                      ;   degrees to 179.9 degrees.                                                    (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
006B93 7F6B93                         TOE_CALC:                                                                        (TOE_OFC_CALCS)
006B93 7F6B93 FC 10 6A                    ldd  cltAdc       ; "cltAdc" -> D                                            (TOE_OFC_CALCS)
006B96 7F6B96 8C 00 93                    cpd  #$0093       ; Compare "cltADC" with decimal 147(ADC @ 179.9F)          (TOE_OFC_CALCS)
006B99 7F6B99 23 02                       bls  RailColdAdd  ; If "cltADC" is lower or the same as 147, branch to RailColdAdd: (TOE_OFC_CALCS)
006B9B 7F6B9B 20 05                       bra  DoColdAdd    ; Branch to DoColdAdd:                                     (TOE_OFC_CALCS)
006B9D 7F6B9D                         RailColdAdd:                                                                     (TOE_OFC_CALCS)
006B9D 7F6B9D 79 10 B9                    clr   ColdAddpct   ; Clear "ColdAddpct" (no cold adder)                      (TOE_OFC_CALCS)
006BA0 7F6BA0 20 3C                       bra   ColdAddDone  ; Branch to ColdAddDone: (skip over)                      (TOE_OFC_CALCS)
006BA2 7F6BA2                         DoColdAdd:                                                                       (TOE_OFC_CALCS)
006BA2 7F6BA2 CC 00 93                    ldd  #$0093      ; Load double accumulator with decimal 147 (ADC @ 179.9F)   (TOE_OFC_CALCS)
006BA5 7F6BA5 3B                          pshd             ; Push to stack (V1)                                        (TOE_OFC_CALCS)
006BA6 7F6BA6 FC 10 6A                    ldd  cltAdc      ; Load double accumulator with "cltAdc"                     (TOE_OFC_CALCS)
006BA9 7F6BA9 3B                          pshd             ; Push to stack (V)                                         (TOE_OFC_CALCS)
006BAA 7F6BAA CC 03 EB                    ldd  #$03EB      ; Load double accumulator with decimal 1003 (ADC @ -39.72F) (TOE_OFC_CALCS)
006BAD 7F6BAD 3B                          pshd             ; Push to stack (V2)                                        (TOE_OFC_CALCS)
006BAE 7F6BAE CC 00 00                    ldd  #$0000      ; Load double accumulator with decimal 0 (added amount at 179.9F) (TOE_OFC_CALCS)
006BB1 7F6BB1 3B                          pshd             ; Push to stack (Z1)                                        (TOE_OFC_CALCS)
006BB2 7F6BB2 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006BB7 7F6BB7 CD 08 00                    ldy   #veBins_E    ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                           ; on buffer RAM page 1 (veBins_E)                           (TOE_OFC_CALCS)
006BBA 7F6BBA EC EA 03 D4                 ldd   $03D4,Y    ; Load Accu D with value in buffer RAM page 1 (ColdAdd_F)(offset 980) (TOE_OFC_CALCS)
                                                           ;(added amount at -39.72F)                                  (TOE_OFC_CALCS)
006BBE 7F6BBE 3B                          pshd             ; Push to stack (Z2)                                        (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z2       |  SP+ 0                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z1       |  SP+ 2                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V2       |  SP+ 4                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V        |  SP+ 6                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V1       |  SP+ 8                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                      ;                     V      V1      V2      Z1    Z2                            (TOE_OFC_CALCS)
006BBF 7F6BBF MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; ==========================                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ; result: D: interpolated result                                                 (TOE_OFC_CALCS/2D_IPOL)
                                      ; SSTACK: none                                                                   (TOE_OFC_CALCS/2D_IPOL)
                                      ;         no registers are preserved                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    ^ V                                                                         (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                                                                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z2+....................*                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                    :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   :       :        :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006BBF 7F6BBF EC 86                                   LDD       \1    ; load V                                         (TOE_OFC_CALCS/2D_IPOL)
006BC1 7F6BC1 A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
006BC3 7F6BC3 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006BC5 7F6BC5 EC 80                                   LDD       \5    ; load Z2                                        (TOE_OFC_CALCS/2D_IPOL)
006BC7 7F6BC7 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006BC9 7F6BC9 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (TOE_OFC_CALCS/2D_IPOL)
006BCB 7F6BCB B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006BCD 7F6BCD EC 84                                   LDD       \3    ; load V2                                        (TOE_OFC_CALCS/2D_IPOL)
006BCF 7F6BCF A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
006BD1 7F6BD1 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (TOE_OFC_CALCS/2D_IPOL)
                                      ;*********************************************************************           (TOE_OFC_CALCS/2D_IPOL)
006BD3 7F6BD3 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (TOE_OFC_CALCS/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (TOE_OFC_CALCS/2D_IPOL)
006BD5 7F6BD5 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006BD7 7F6BD7 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Free stack space (result in D)                                               (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006BD9 7F6BD9 1B 8A                       leas  10,SP       ; Stack pointer -> bottom of stack                         (TOE_OFC_CALCS)
006BDB 7F6BDB 7B 10 B9                    stab  ColdAddpct  ; Copy result to "ColdAddpct" (%)(bins are byte values)    (TOE_OFC_CALCS)
006BDE 7F6BDE                         ColdAddDone:                                                                     (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Calculate the cold temperature multiplier enrichment "ColdMulpct" (%), from -39.72 degrees (TOE_OFC_CALCS)
                                      ;   to 179.9 degrees.                                                            (TOE_OFC_CALCS)
                                      ;*********************************************************************************************** (TOE_OFC_CALCS)
006BDE 7F6BDE FC 10 6A                    ldd  cltADC       ; "cltADC" -> D                                            (TOE_OFC_CALCS)
006BE1 7F6BE1 8C 00 93                    cpd  #$0093       ; Compare "cltADC" with decimal 147(ADC @ 179.9F)          (TOE_OFC_CALCS)
006BE4 7F6BE4 23 02                       bls  RailColdMul  ; If "cltADC" is lower or the same as 147, branch to RailColdMul: (TOE_OFC_CALCS)
006BE6 7F6BE6 20 07                       bra  DoColdMul    ; Branch to DoColdMul: (skip over)                         (TOE_OFC_CALCS)
006BE8 7F6BE8                         RailColdMul:                                                                     (TOE_OFC_CALCS)
006BE8 7F6BE8 18 0B 64 10 BA             movb #$64,ColdMulpct  ; Decimal 100 -> "ColdMulpct" (100% = no multiplier))   (TOE_OFC_CALCS)
006BED 7F6BED 20 3C                      bra   ColdMulDone     ; Branch to ColdMulDone: (skip over)                    (TOE_OFC_CALCS)
006BEF 7F6BEF                         DoColdMul:                                                                       (TOE_OFC_CALCS)
006BEF 7F6BEF CC 00 93                    ldd  #$0093      ; Load double accumulator with decimal 147 (ADC @ 179.9F)   (TOE_OFC_CALCS)
006BF2 7F6BF2 3B                          pshd             ; Push to stack (V1)                                        (TOE_OFC_CALCS)
006BF3 7F6BF3 FC 10 6A                    ldd  cltAdc      ; Load double accumulator with "cltAdc"                     (TOE_OFC_CALCS)
006BF6 7F6BF6 3B                          pshd             ; Push to stack (V)                                         (TOE_OFC_CALCS)
006BF7 7F6BF7 CC 03 EB                    ldd  #$03EB      ; Load double accumulator with decimal 1003 (ADC @ -39.72F) (TOE_OFC_CALCS)
006BFA 7F6BFA 3B                          pshd             ; Push to stack (V2)                                        (TOE_OFC_CALCS)
006BFB 7F6BFB CC 00 64                    ldd  #$0064      ; Load double accumulator with decimal 100 (multiplier amount at 179.9F) (TOE_OFC_CALCS)
                                                           ;(1.00 multiplier at 180 degrees)                           (TOE_OFC_CALCS)
006BFE 7F6BFE 3B                          pshd             ; Push to stack (Z1)                                        (TOE_OFC_CALCS)
006BFF 7F6BFF 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006C04 7F6C04 CD 08 00                    ldy   #veBins_E    ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                           ; on buffer RAM page 1 (veBins_E)                           (TOE_OFC_CALCS)
006C07 7F6C07 EC EA 03 D6                 ldd   $03D6,Y    ; Load Accu D with value in buffer RAM page 1 "ColdMul_F"(offset 982) (TOE_OFC_CALCS)
                                                           ;(added amount at -39.72F)                                  (TOE_OFC_CALCS)
006C0B 7F6C0B 3B                          pshd             ; Push to stack (Z2)                                        (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z2       |  SP+ 0                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        Z1       |  SP+ 2                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V2       |  SP+ 4                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V        |  SP+ 6                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                                      ;    |        V1       |  SP+ 8                                  (TOE_OFC_CALCS)
                                                      ;    +--------+--------+                                         (TOE_OFC_CALCS)
                                      ;                     V      V1      V2      Z1    Z2                            (TOE_OFC_CALCS)
006C0C 7F6C0C MACRO                       2D_IPOL     (6,SP), (8,SP), (4,SP), (2,SP), (0,SP) ; Go to 2D_IPOL Macro, interp_BEPM.s (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; ==========================                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ; result: D: interpolated result                                                 (TOE_OFC_CALCS/2D_IPOL)
                                      ; SSTACK: none                                                                   (TOE_OFC_CALCS/2D_IPOL)
                                      ;         no registers are preserved                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    ^ V                                                                         (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                                                                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z2+....................*                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |                    :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (TOE_OFC_CALCS/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   :       :        :                                                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;                                                                                (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006C0C 7F6C0C EC 86                                   LDD       \1    ; load V                                         (TOE_OFC_CALCS/2D_IPOL)
006C0E 7F6C0E A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
006C10 7F6C10 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006C12 7F6C12 EC 80                                   LDD       \5    ; load Z2                                        (TOE_OFC_CALCS/2D_IPOL)
006C14 7F6C14 A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006C16 7F6C16 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (TOE_OFC_CALCS/2D_IPOL)
006C18 7F6C18 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006C1A 7F6C1A EC 84                                   LDD       \3    ; load V2                                        (TOE_OFC_CALCS/2D_IPOL)
006C1C 7F6C1C A3 88                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (TOE_OFC_CALCS/2D_IPOL)
006C1E 7F6C1E B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (TOE_OFC_CALCS/2D_IPOL)
                                      ;*********************************************************************           (TOE_OFC_CALCS/2D_IPOL)
006C20 7F6C20 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (TOE_OFC_CALCS/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (TOE_OFC_CALCS/2D_IPOL)
006C22 7F6C22 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS/2D_IPOL)
006C24 7F6C24 E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (TOE_OFC_CALCS/2D_IPOL)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Free stack space (result in D)                                               (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006C26 7F6C26 1B 8A                      leas  10,SP         ; Stack pointer -> bottom of stack                        (TOE_OFC_CALCS)
006C28 7F6C28 7B 10 BA                   stab   ColdMulpct   ; Copy result to "ColdMulpct" (%) (bins are byte values)  (TOE_OFC_CALCS)
006C2B 7F6C2B                         ColdMulDone:                                                                     (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; First determine "TpsPctDOT" ("TpsPctx10" - "TpsPctx10last") (both updated every 100mS (TOE_OFC_CALCS)
                                      ; in rti_BEEM488.s)                                                              (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006C2B 7F6C2B FE 10 7C                   ldx   TpsPctx10         ; "TpsPctx10" -> Accu X                               (TOE_OFC_CALCS)
006C2E 7F6C2E 18 B0 10 45                subx  TpsPctx10last     ; (X)-(M:M+1)=>X Subtract "TpsPctx10last" from "TpsPctx10" (TOE_OFC_CALCS)
006C32 7F6C32 7E 10 B6                   stx   TpsPctDOT         ; Copy result to "TpsPctDOT" (%/Sec)                  (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Look up current value in Throttle Opening Enrichment Table (TpsDOTcor)(%)(byte value) (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006C35 7F6C35 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006C3A 7F6C3A 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr    ; Address of the first value in VE table(in RAM)(page pointer) (TOE_OFC_CALCS)
                                                                   ; ->page where the desired curve resides            (TOE_OFC_CALCS)
006C40 7F6C40 18 03 01 E2 10 27           movw #$01E2,CrvRowOfst   ; 482 -> Offset from the curve page to the curve row (TOE_OFC_CALCS)
                                                                       ; (TOERates_F)(actual offset is 964)($03C4)     (TOE_OFC_CALCS)
006C46 7F6C46 18 03 01 DE 10 29           movw #$01DE,CrvColOfst   ; 478 -> Offset from the curve page to the curve column (TOE_OFC_CALCS)
                                                                       ; (TOEBins_F)(actual offset is 956)($03BC)      (TOE_OFC_CALCS)
006C4C 7F6C4C 18 04 10 B6 10 2B           movw TpsPctDOT,CrvCmpVal ; TPS% difference over time (%/Sec)(update every 100mSec) (TOE_OFC_CALCS)
                                                                   ; -> Curve comparison value                         (TOE_OFC_CALCS)
006C52 7F6C52 18 0B 03 10 2D              movb #$03,CrvBinCnt      ; 3 -> number of bins in the curve row or column minus 1 (TOE_OFC_CALCS)
006C57 7F6C57 16 6F 46                    jsr  CRV_LU_P            ; Jump to subroutine at CRV_LU_P:(located in interp_BEEM488.s module) (TOE_OFC_CALCS)
006C5A 7F6C5A 7B 10 B8                    stab TpsDOTcor           ; Copy result to TpsDOTcor (%)(byte value)          (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Multiply "TpsDOTcor" by "ColdMulpct" and divide by 100                       (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006C5D 7F6C5D B6 10 B8                    ldaa  TpsDOTcor      ; "TpsDOTcor" -> A (%)                                  (TOE_OFC_CALCS)
006C60 7F6C60 F6 10 BA                    ldab  ColdMulpct     ; "ColdMulpct" -> B (%)                                 (TOE_OFC_CALCS)
006C63 7F6C63 12                          mul                  ; (A)x(B)->A:B (TpsDOTcor x ColdMulpct) result in D     (TOE_OFC_CALCS)
006C64 7F6C64 CE 00 64                    ldx   #$0064         ; Decimal 100 -> X                                      (TOE_OFC_CALCS)
006C67 7F6C67 18 10                       idiv                 ; (D)/(X)->(X)rem(D) ((TpsDOTcor x ColdMulpct)/100)(%)  (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check the remainder and round up if >=5                                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006C69 7F6C69 8C 00 05                    cpd   #$0005         ; Compare idiv remainder with decimal 5                 (TOE_OFC_CALCS)
006C6C 7F6C6C 2F 05                       ble   NO_ROUND_UP    ; If remainder of idiv <= 5, branch to NO_ROUND_UP:     (TOE_OFC_CALCS)
006C6E 7F6C6E B7 50                       tfr   X,A            ; idiv result -> A                                      (TOE_OFC_CALCS)
006C70 7F6C70 42                          inca                 ; idiv result + 1 -> A (round up)                       (TOE_OFC_CALCS)
006C71 7F6C71 20 02                       bra   ADD_COLDADD    ; Branch to ADD_COLDADD:(fall through)                  (TOE_OFC_CALCS)
006C73 7F6C73                         NO_ROUND_UP:                                                                     (TOE_OFC_CALCS)
006C73 7F6C73 B7 50                       tfr   X,A            ; idiv result -> A                                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Add the result with "ColdAddpct". Compare the result with the current "TOEpct" and (TOE_OFC_CALCS)
                                      ;   and save the highest value as "TOEpct". This is the final TOE value(%)       (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006C75 7F6C75                         ADD_COLDADD:                                                                     (TOE_OFC_CALCS)
006C75 7F6C75 BB 10 B9                    adda  ColdAddpct     ; (A)+(M)->(A) (("TpsDOTcor" * ColdMulpct)/100) + "ColdAddpct") (TOE_OFC_CALCS)
006C78 7F6C78 7A 10 F9                    staa  tmp5b           ; Copy to "tmp5b"(("TpsDOTcor" * ColdMulpct)/100) + "ColdAddpct") (TOE_OFC_CALCS)
006C7B 7F6C7B B1 10 BB                    cmpa  TOEpct         ; Compare result with "TOEpct"                          (TOE_OFC_CALCS)
006C7E 7F6C7E 25 1E                       blo   TOE_CHK_TIME   ; If (A) is less than (M), branch to TOE_CHK_TIME: (result (TOE_OFC_CALCS)
                                                               ; < "TOEpct" so use this value for "TOEpct" and check if (TOE_OFC_CALCS)
                                                                                       ; acceleration is done)         (TOE_OFC_CALCS)
006C80 7F6C80 B6 10 F9                    ldaa  tmp5b          ; "tmp5b" -> A(("TpsDOTcor" * ColdMulpct)/100) + "ColdAddpct") (TOE_OFC_CALCS)
006C83 7F6C83 7A 10 BB                    staa  TOEpct         ; Copy result to "TOEpct"(result is higher than current (TOE_OFC_CALCS)
                                                               ; so update TOEpct with the higher value)               (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Calculate the Throttle Opening Enrichment adder for PW calculations.         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006C86 7F6C86 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006C8B 7F6C8B CD 08 00                    ldy   #veBins_E   ; Load index register Y with address of first configurable (TOE_OFC_CALCS)
                                                            ; constant on buffer RAM page 1 (veBins_E)                 (TOE_OFC_CALCS)
006C8E 7F6C8E EC EA 03 EC                 ldd   $03EC,Y     ; Load Accu D with value in buffer RAM page 1 (offset 1004)($03EC) (TOE_OFC_CALCS)
                                                            ; ("reqFuel" in Accu B)                                    (TOE_OFC_CALCS)
006C92 7F6C92 B6 10 BB                    ldaa  TOEpct      ; "TOEpct" -> Accu D (%)                                   (TOE_OFC_CALCS)
006C95 7F6C95 12                          mul               ;(A)x(B)->A:B (reqFuel" x "TOEpct")                        (TOE_OFC_CALCS)
006C96 7F6C96 CE 00 64                        ldx  #$0064       ; Decimal 100 -> Accu X                                (TOE_OFC_CALCS)
006C99 7F6C99 18 10                       idiv              ;(D)/(X)->X:rem->D (reqFuel" x "TOEpct")/10                (TOE_OFC_CALCS)
006C9B 7F6C9B 7E 10 BC                    stx  TOEpw        ; Result -> "TOEpw" TOE adder (mS x 10)                    (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check to see if Throttle Opening Enrichment is done.                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006C9E 7F6C9E                          TOE_CHK_TIME:                                                                   (TOE_OFC_CALCS)
006C9E 7F6C9E 1E 10 E1 40 07              brset  engine,OFCon,RESET_TOE ; If Overrun Fuel Cut bit of "Engine" bit field is set, (TOE_OFC_CALCS)
                                                                        ; branch to RESET_TOE:                         (TOE_OFC_CALCS)
006CA3 7F6CA3 B6 10 CF                     ldaa  TOEdurCnt    ; "TOEdurCnt" -> Accu A                                  (TOE_OFC_CALCS)
006CA6 7F6CA6 27 02                            beq   RESET_TOE    ; If "TOEdurCnt" = zero branch to RESET_TOE:(timer has timed out) (TOE_OFC_CALCS)
006CA8 7F6CA8 20 1F                            bra   TOE_LOOP     ; Branch to "TOE_LOOP:(Timer hasn't timed out yet)   (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - The throttle is no longer opening and the duration timer has timed out so clear (TOE_OFC_CALCS)
                                      ;    "TOEpct" and the "TOEon" bit of "engine" bit field.                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006CAA 7F6CAA                         RESET_TOE:                                                                       (TOE_OFC_CALCS)
006CAA 7F6CAA 1D 10 E1 20                 bclr  engine,TOEon      ; Clear "TOEon" bit of "engine" bit field            (TOE_OFC_CALCS)
006CAE 7F6CAE 1D 10 E2 08                 bclr  engine2,TOEduron  ; Clear "TOEduron" bit of "engine2" variable (TOE duration) (TOE_OFC_CALCS)
006CB2 7F6CB2 79 10 BB                    clr   TOEpct            ; Clear Throttle Opening Enrichment (%)              (TOE_OFC_CALCS)
006CB5 7F6CB5 79 10 B9                    clr   ColdAddpct        ; Clear Throttle Opening Enrichment cold adder (%)   (TOE_OFC_CALCS)
006CB8 7F6CB8 79 10 BA                    clr   ColdMulpct        ; Clear Throttle Opening Enrichment cold multiplier (%) (TOE_OFC_CALCS)
006CBB 7F6CBB 79 10 B8                    clr   TpsDOTcor         ; Clear Throttle Opening Enrichment table value(%)   (TOE_OFC_CALCS)
006CBE 7F6CBE 79 10 CF                    clr   TOEdurCnt         ; Clear Throttle Opening Enrichment duration counter (TOE_OFC_CALCS)
006CC1 7F6CC1 18 79 10 BC                 clrw  TOEpw             ; Clear Throttle Opening Enrichment adder (mS x 100) (TOE_OFC_CALCS)
006CC5 7F6CC5 18 79 10 BE                 clrw  PWlessTOE         ; Clear Injector pulse width before "TOEpw" and "Deadband" (mS x 10) (TOE_OFC_CALCS)
006CC9 7F6CC9                         TOE_LOOP:                                                                        (TOE_OFC_CALCS)
006CC9 7F6CC9 20 42                       job  OFC_LOOP       ; Jump or branch to OFC_LOOP:(Finished with TOE, not in OFC so (TOE_OFC_CALCS)
                                                                  ; fall through)                                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Overrun Fuel Cut mode 2/07/21 Note change in rti_BPEM488.s                   (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;                                                                                (TOE_OFC_CALCS)
                                      ; - Engine overrun occurs when the the vehicle is in motion, the throttle is closed and (TOE_OFC_CALCS)
                                      ;   the engine is turning faster than the driver wants it to be, either because of vehicle (TOE_OFC_CALCS)
                                      ;   inertia or by being on a negative grade. Under these conditions there will be a slight (TOE_OFC_CALCS)
                                      ;   increase in engine braking and some fuel can be saved if the fuel injectors are not (TOE_OFC_CALCS)
                                      ;   pulsed. OFC is only enabled manually by pulsing up on the dash mounted SPDT spring (TOE_OFC_CALCS)
                                      ;   return to centre toggle switch. In order to enter OFC mode several permissive (TOE_OFC_CALCS)
                                      ;   conditions must be met first. The throttle opening must be equal to or less than the (TOE_OFC_CALCS)
                                      ;   minimum permitted opening and the engine RPM must be equal to or more than the minimum (TOE_OFC_CALCS)
                                      ;   permitted RPM. OFC can be disabled manually by the driver at any time by pulsing (TOE_OFC_CALCS)
                                      ;   down on the dash mounted toggle switch. It will be disabled automatically if either (TOE_OFC_CALCS)
                                      ;   or both of the permissive conditions are no longer met                       (TOE_OFC_CALCS)
                                      ;                                                                                (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Check to see if we have permissives for Overrun Fuel Cut at steady state or closing (TOE_OFC_CALCS)
                                      ;   throttle.                                                                    (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006CCB 7F6CCB                         OFC_CHK:                                                                         (TOE_OFC_CALCS)
006CCB 7F6CCB 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006CD0 7F6CD0 CD 08 00                    ldy   #veBins_E     ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                            ; on buffer RAM page 1 (veBins_E)                          (TOE_OFC_CALCS)
006CD3 7F6CD3 EE EA 03 DA                 ldx   $03DA,Y     ; Load X with value in buffer RAM page 1 offset 986 (OFCtps) (TOE_OFC_CALCS)
                                                            ;(Overrun Fuel Cut min TPS%)                               (TOE_OFC_CALCS)
006CD7 7F6CD7 BE 10 7C                    cpx  TpsPctx10    ; Compare it with value in "TpsPctx10"                     (TOE_OFC_CALCS)
006CDA 7F6CDA 25 2D                       blo  OFC_CHK_DONE ; If (X)>(M), branch to OFC_CHK_DONE:                      (TOE_OFC_CALCS)
                                                            ;(TPS is above minimum so no fuel cut)                     (TOE_OFC_CALCS)
006CDC 7F6CDC 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (TOE_OFC_CALCS)
006CE1 7F6CE1 CD 08 00                    ldy   #veBins_E     ; Load index register Y with address of first configurable constant (TOE_OFC_CALCS)
                                                            ; on buffer RAM page 1 (veBins_E)                          (TOE_OFC_CALCS)
006CE4 7F6CE4 EE EA 03 DC                 ldx   $03DC,Y     ; Load X with value in buffer RAM page 1 offset 988 (OFCrpm) (TOE_OFC_CALCS)
                                                            ;(Overrun Fuel Cut min RPM)                                (TOE_OFC_CALCS)
006CE8 7F6CE8 BE 10 A0                    cpx  RPM          ; Compare it value in RPM                                  (TOE_OFC_CALCS)
006CEB 7F6CEB 22 1C                       bhi  OFC_CHK_DONE ; If (X)<(M), branch to OFC_CHK_DONE:                      (TOE_OFC_CALCS)
                                                            ;(RPM is below minimum so no fuel cut                      (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - We have permissives for Overrun Fuel Cut. Check to see if OFC is already on and being (TOE_OFC_CALCS)
                                      ;   being commanded off.                                                         (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006CED 7F6CED 1F 10 E1 40 07                  brclr  engine,OFCon,OFC_EN_CHK ; If "OFCon" bit of "engine" bit field is clear, branch (TOE_OFC_CALCS)
                                                                             ; to OFC_EN_CHK: (OFC is off, check to see if it is (TOE_OFC_CALCS)
                                                                                                         ; being commanded on (TOE_OFC_CALCS)
006CF2 7F6CF2 1F 10 DC 20 12              brclr PortAbits,OFCdis,OFC_CHK_DONE ; If "OFCdis" bit of "PortAbits" is clear (Low), (TOE_OFC_CALCS)
                                                                ; branch to OFC_CHK_DONE: (OFC is on and OFC disable switch is on, (TOE_OFC_CALCS)
                                                                                ; so disable fuel cut)                 (TOE_OFC_CALCS)
006CF7 7F6CF7 20 14                           bra  OFC_LOOP     ; branch to OFC_LOOP:(OFC is on, permissives are met and not being (TOE_OFC_CALCS)
                                                                ; commanded off, keep looping until permissives are no longer met (TOE_OFC_CALCS)
                                                                                ; or OFC has been commanded off)       (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - We have permissives for Overrun Fuel Cut and it is not being commanded off. Check to (TOE_OFC_CALCS)
                                      ;   see if OFC is off and being commanded on.                                    (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006CF9 7F6CF9                         OFC_EN_CHK:                                                                      (TOE_OFC_CALCS)
006CF9 7F6CF9 1E 10 E1 40 0F                  brset  engine,OFCon,OFC_LOOP   ; If "OFCon" bit of "engine" bit field is set, branch (TOE_OFC_CALCS)
                                                                             ; to OFC_LOOP: (OFC is already on so skip over) (TOE_OFC_CALCS)
006CFE 7F6CFE 1E 10 DC 10 0A              brset PortAbits,OFCen,OFC_LOOP ; "If OFCen" bit of "PortAbits" is set (High), branch to (TOE_OFC_CALCS)
                                                                             ; OFC_LOOP: (OFC enable switch is off so skip over) (TOE_OFC_CALCS)
006D03 7F6D03 1C 10 E1 40                     bset engine,OFCon              ; Set "OFCon" bit of "engine" bit field (This bit will be tested (TOE_OFC_CALCS)
                                                                             ; in the final pulse width calculations, if set the pulse width (TOE_OFC_CALCS)
                                                                                             ; will be set to zero     (TOE_OFC_CALCS)
006D07 7F6D07 20 04                           bra  OFC_LOOP                  ; branch to OFC_LOOP:(keep looping until permissives are no (TOE_OFC_CALCS)
                                                                             ; longer met or OFC has been commanded off) (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
                                      ; - Permissives have not or are no longer are being met or OFC has been commanded off. (TOE_OFC_CALCS)
                                      ;   Clear the flag.                                                              (TOE_OFC_CALCS)
                                      ;***************************************************************************************** (TOE_OFC_CALCS)
006D09 7F6D09                         OFC_CHK_DONE:                                                                    (TOE_OFC_CALCS)
006D09 7F6D09 1D 10 E1 40                     bclr engine,OFCon     ; Clear "OFCon" bit of "engine" bit field          (TOE_OFC_CALCS)
006D0D 7F6D0D                         OFC_LOOP:                                                                        (TOE_OFC_CALCS)
006D0D 7F6D0D MACRO                       RUN_PW_CALCS      ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate injector pulse width for a running engine "PW" (mS x 10)           (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ;barocor:      ds 2 ; Barometric Pressure Correction (% x 10) (104)              (RUN_PW_CALCS)
                                      ;matcor:       ds 2 ; Manifold Air Temperature Correction (% x 10)(108)          (RUN_PW_CALCS)
                                      ;Mapx10:       ds 2 ; Manifold Absolute Pressure (KPAx10)(update every revolution) (24) (RUN_PW_CALCS)
                                      ;Ftrmx10:      ds 2 ; Fuel Trim (% x 10)(update every mSec)(+-20%) (36)          (RUN_PW_CALCS)
                                      ;WUEandASEcor: ds 2 ; The sum of WUEcor and ASEcor (% x 10)                      (RUN_PW_CALCS)
                                      ;veCurr:       ds 2 ; Current value in VE table (% x 10) (72)                    (RUN_PW_CALCS)
                                      ;PWcalc1:      ds 2 ; PW calculations result 1                                   (RUN_PW_CALCS)
                                      ;PWcalc2:      ds 2 ; PW calculations result 2                                   (RUN_PW_CALCS)
                                      ;PWcalc3:      ds 2 ; PW calculations result 3                                   (RUN_PW_CALCS)
                                      ;PWcalc4:      ds 2 ; PW calculations result 4                                   (RUN_PW_CALCS)
                                      ;PWcalc5:      ds 2 ; PW calculations result 5                                   (RUN_PW_CALCS)
                                      ;reqFuel:      ds 2 ; Pulse width for 14.7 AFR @ 100% VE (mS x 10)               (RUN_PW_CALCS)
                                      ;PWlessTOE:    ds 2 ; Injector pulse width before "TOEpw" and "Deadband" (mS x 10) (RUN_PW_CALCS)
                                      ;TOEpw:        ds 2 ; Throttle Opening Enrichment adder (mS x 100)               (RUN_PW_CALCS)
                                      ;Deadband:     ds 2 ; injector deadband at current battery voltage mS*100        (RUN_PW_CALCS)
                                      ;FDpw:         ds 2 ; Fuel Delivery pulse width (PW - Deadband) (mS x 10)        (RUN_PW_CALCS)
                                      ;PW:           ds 2 ; Running engine injector pulsewidth (mS x 10)               (RUN_PW_CALCS)
                                      ;PWtk:         ds 2 ; Running engine injector pulsewidth (uS x 2.56)(102)        (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Method:                                                                      (RUN_PW_CALCS)
                                      ;                                                                                (RUN_PW_CALCS)
                                      ; ("barocor" * "matcor") / 1000 = "PWcalc1" (0.1% resolution)                    (RUN_PW_CALCS)
                                      ; ("Mapx10" * "Ftrmx10") / 1000 = "PWcalc2" (0.1% resolution)                    (RUN_PW_CALCS)
                                      ; ("PWcalc1" * "PWcalc2") / 1000 = "PWcalc3" (0.1% resolution)                   (RUN_PW_CALCS)
                                      ; ("WUEandASEcor" * "veCurr") / 1000 = "PWcalc4" (0.1% resolution)               (RUN_PW_CALCS)
                                      ; ("PWcalc3" * "PWcalc4") / 1000 = "PWcalc5" (0.1% resolution)                   (RUN_PW_CALCS)
                                      ; ("PWcalc5" * reqFuel") / 1000 = "PWlessTOE" (0.1mS resolution)                 (RUN_PW_CALCS)
                                      ; "PWlessTOE" + "TOEpw" = "FDpw"  (0.1mS resolution)                             (RUN_PW_CALCS)
                                      ; "FDpw" + "Deadband" = "PW"  (0.1mS resolution)                                 (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate total corrections before Throttle Opening Enrichment and deadband. (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
006D0D 7F6D0D 1E 10 E1 40 02              brset engine,OFCon,NoPWrunCalcs1 ; if "OFCon" bit of "engine" bit field is set branch (RUN_PW_CALCS)
                                                                           ; to NoPWrunCalcs1: (In overrun fuel cut mode so (RUN_PW_CALCS)
                                                                           ; fall through)                             (RUN_PW_CALCS)
006D12 7F6D12 20 03                       bra  PWrunCalcs    ; Branch to PWrunCalcs:                                   (RUN_PW_CALCS)
006D14 7F6D14                         NoPWrunCalcs1:                                                                   (RUN_PW_CALCS)
006D14 7F6D14 06 6D A5                    job  NoPWrunCalcs  ; Jump or branch to NoPWrunCalcs: (long branch)           (RUN_PW_CALCS)
006D17 7F6D17                         PWrunCalcs:                                                                      (RUN_PW_CALCS)
006D17 7F6D17 FC 10 AA                    ldd  barocor      ; "barocor" -> Accu D (% x 10)                             (RUN_PW_CALCS)
006D1A 7F6D1A FD 10 AC                    ldy  matcor       ; "matcor" -> Accu D (% x 10)                              (RUN_PW_CALCS)
006D1D 7F6D1D 13                          emul              ; (D)*(Y)->Y:D "barocor" * "matcor"                        (RUN_PW_CALCS)
006D1E 7F6D1E CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
006D21 7F6D21 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("barocor"*"matcor")/1000="PWcalc1" (RUN_PW_CALCS)
006D22 7F6D22 7D 10 4B                        sty  PWcalc1      ; Result -> "PWcalc1"                                  (RUN_PW_CALCS)
006D25 7F6D25 FC 10 78                    ldd  Mapx10       ; "Mapx10" -> Accu D (% x 10)                              (RUN_PW_CALCS)
006D28 7F6D28 FD 10 94                    ldy  Ftrmx10      ; "Ftrmx10" -> Accu D (% x 10)                             (RUN_PW_CALCS)
006D2B 7F6D2B 13                          emul              ; (D)*(Y)->Y:D "Mapx10" * "Ftrmx10"                        (RUN_PW_CALCS)
006D2C 7F6D2C CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
006D2F 7F6D2F 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("Mapx10"*"Ftrmx10")/1000="PWcalc2" (RUN_PW_CALCS)
006D30 7F6D30 7D 10 4D                        sty  PWcalc2      ; Result -> "PWcalc2"                                  (RUN_PW_CALCS)
006D33 7F6D33 FC 10 4B                    ldd  PWcalc1      ; "PWcalc1" -> Accu D (% x 10)                             (RUN_PW_CALCS)
006D36 7F6D36 FD 10 4D                    ldy  PWcalc2      ; "PWcalc2" -> Accu D (% x 10)                             (RUN_PW_CALCS)
006D39 7F6D39 13                          emul              ; (D)*(Y)->Y:D "PWcalc1" * "PWcalc2"                       (RUN_PW_CALCS)
006D3A 7F6D3A CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
006D3D 7F6D3D 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("PWcalc1"*"PWcalc2")/1000="PWcalc3" (RUN_PW_CALCS)
006D3E 7F6D3E 7D 10 4F                        sty  PWcalc3      ; Result -> "PWcalc3"                                  (RUN_PW_CALCS)
006D41 7F6D41 FC 10 B2                    ldd  WUEandASEcor ; "WUEandASEcor" -> Accu D (% x 10)                        (RUN_PW_CALCS)
006D44 7F6D44 FD 10 A8                    ldy  veCurr       ; "veCurr" -> Accu D (% x 10)                              (RUN_PW_CALCS)
006D47 7F6D47 13                          emul              ; (D)*(Y)->Y:D "WUEandASEcor" * "veCurr"                   (RUN_PW_CALCS)
006D48 7F6D48 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
006D4B 7F6D4B 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("WUEandASEcor"*"veCurr")/1000="PWcalc4" (RUN_PW_CALCS)
006D4C 7F6D4C 7D 10 51                        sty  PWcalc4      ; Result -> "PWcalc4"                                  (RUN_PW_CALCS)
006D4F 7F6D4F FC 10 4F                    ldd  PWcalc3      ; "PWcalc3" -> Accu D (% x 10)                             (RUN_PW_CALCS)
006D52 7F6D52 FD 10 51                    ldy  PWcalc4      ; "PWcalc4" -> Accu D (% x 10)                             (RUN_PW_CALCS)
006D55 7F6D55 13                          emul              ; (D)*(Y)->Y:D "PWcalc3" * "PWcalc4"                       (RUN_PW_CALCS)
006D56 7F6D56 CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
006D59 7F6D59 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("PWcalc3"*"PWcalc4")/1000="PWcalc5" (RUN_PW_CALCS)
006D5A 7F6D5A 7D 10 53                        sty  PWcalc5      ; Result -> "PWcalc5"(total corrections before Throttle Opening (RUN_PW_CALCS)
                                                                ; Enrichment and deadband)                             (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate injector pulse width before Throttle Opening Enrichment pulse width and (RUN_PW_CALCS)
                                      ;   Deadband.                                                                    (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
006D5D 7F6D5D FC 10 53                    ldd  PWcalc5      ; "PWcalc5" -> Accu D (% x 10)                             (RUN_PW_CALCS)
006D60 7F6D60 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (RUN_PW_CALCS)
006D65 7F6D65 CD 08 00                    ldy   #veBins_E   ; Load index register Y with address of first configurable (RUN_PW_CALCS)
                                                            ; constant on buffer RAM page 1 (veBins_E)                 (RUN_PW_CALCS)
006D68 7F6D68 EE EA 03 EC                 ldx   $03EC,Y     ; Load Accu X with value in buffer RAM page 1 (offset 1004)($03EC) (RUN_PW_CALCS)
                                                            ; ("reqFuel")                                              (RUN_PW_CALCS)
006D6C 7F6D6C B7 56                       tfr  X,Y          ; "reqFuel" -> Accu Y                                      (RUN_PW_CALCS)
006D6E 7F6D6E 13                          emul              ; (D)*(Y)->Y:D "PWcalc5" * "reqfuel"                       (RUN_PW_CALCS)
006D6F 7F6D6F CE 03 E8                        ldx  #$03E8       ; Decimal 1000 -> Accu X                               (RUN_PW_CALCS)
006D72 7F6D72 11                              ediv              ;(Y:D)/)X)->Y;Rem->D ("PWcalc5"*"reqFuel")/1000="PWlessTOE" (RUN_PW_CALCS)
006D73 7F6D73 7D 10 BE                        sty  PWlessTOE    ; Result -> "PWlessTOE" (mS x 10)                      (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Add the Throttle Opening Enricment pulse width and store as "FDpw"(fuel delivery (RUN_PW_CALCS)
                                      ;   pulse width)(mS x 10)                                                        (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
006D76 7F6D76 B7 64                       tfr  Y,D          ; "PWlessTOE" -> Accu D                                    (RUN_PW_CALCS)
006D78 7F6D78 F3 10 BC                        addd TOEpw        ; (A:B)+(M:M+1)->A:B ("PWlessTOE"+"TOEpw"="FDpw"       (RUN_PW_CALCS)
006D7B 7F6D7B 7C 10 C6                        std  FDpw         ; Result -> "FDpw" (fuel delivery pulsewidth (mS x 10) (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Add "deadband" and store the result as "PW"(final injector pulsewidth)(mS x 10) (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
006D7E 7F6D7E F3 10 C0                        addd Deadband    ; (A:B)+(M:M+1)->A:B ("FDpw"+"Deadband"="PW"            (RUN_PW_CALCS)
006D81 7F6D81 7C 10 C8                        std  PW          ; Result -> "PW" (final injector pulsewidth) (mS x 10)  (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Convert "PW" to timer ticks in 2.56uS resolution.                            (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
006D84 7F6D84 FC 10 C8                    ldd   PW         ; "PW" -> Accu D                                            (RUN_PW_CALCS)
006D87 7F6D87 CD 27 10                        ldy   #$2710     ; Load index register Y with decimal 10000 (for integer math) (RUN_PW_CALCS)
006D8A 7F6D8A 13                              emul             ;(D)x(Y)=Y:D "PW" * 10,000                              (RUN_PW_CALCS)
006D8B 7F6D8B CE 01 00                        ldx   #$100      ; Decimal 256 -> Accu X                                 (RUN_PW_CALCS)
006D8E 7F6D8E 11                          ediv             ;(Y:D)/(X)=Y;Rem->D "PW" * 10,000 / 256 = "PWtk"            (RUN_PW_CALCS)
006D8F 7F6D8F 7D 10 5B                    sty   PWtk       ; Copy result to "PWtk" (Running engine injector pulsewidth) (RUN_PW_CALCS)
                                                               ; (uS x 2.56)                                           (RUN_PW_CALCS)
006D92 7F6D92 7D 10 5F                    sty   InjOCadd2  ; Second injector output compare adder (2.56uS res)         (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Injector duty cycle percentage is the time the injector takes to inject the fuel (RUN_PW_CALCS)
                                      ;   divided by the time available x 100. The time available is the engine cycle which is (RUN_PW_CALCS)
                                      ;   two crankshaft revolutions. It is important to know what our duty cycle is at high (RUN_PW_CALCS)
                                      ;   engine speeds and loads. 80% is considered a safe maximum. The crank angle period is (RUN_PW_CALCS)
                                      ;   measured over 72 degrees of crank rotation. In run mode the timer is set to a 2.56uS (RUN_PW_CALCS)
                                      ;   time base and the pulse width timer value is in 2.56uS resolution. The engine cycle (RUN_PW_CALCS)
                                      ;   period in 2.56uS resolution can be calculated by multiplying the period by 10, for (RUN_PW_CALCS)
                                      ;   the two revolutions in the cycle. The duty cycle percentage is calculated by (RUN_PW_CALCS)
                                      ;   dividing "PWtk" by the cycle period and dividing by 100.                     (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
                                      ; - Calculate injector duty cycle                                                (RUN_PW_CALCS)
                                      ;***************************************************************************************** (RUN_PW_CALCS)
006D95 7F6D95 FC 10 5B                    ldd  PWtk           ; "PWtk"->Accu D                                         (RUN_PW_CALCS)
006D98 7F6D98 CD 00 0A                    ldy  #$000A         ; Decimal 10-> Accu Y (for integer math)                 (RUN_PW_CALCS)
006D9B 7F6D9B 13                              emul                ;(D)x(Y)=Y:D "PWtk"*10                               (RUN_PW_CALCS)
006D9C 7F6D9C FE 10 9C                    ldx  CASprd256      ; "CASprd256"-> Accu X (running period for 72 degrees rotation) (RUN_PW_CALCS)
006D9F 7F6D9F 11                          ediv                ;(Y:D)/(X)=Y;Rem->D ("PWtk"*10)/"CASprd256"              (RUN_PW_CALCS)
006DA0 7F6DA0 7D 10 E8                    sty  DutyCyclex10   ; Copy result to "DutyCyclex10" (Injector duty cycle x 10) (RUN_PW_CALCS)
006DA3 7F6DA3 20 24                       bra  PWrunCalcsDone ; Branch to PWrunCalcsDone:                              (RUN_PW_CALCS)
006DA5 7F6DA5                         NoPWrunCalcs:                                                                    (RUN_PW_CALCS)
006DA5 7F6DA5 18 79 10 BE                 clrw  PWlessTOE     ; Clear "PWlessTOE" Injector PW before "TOEpw"+"Deadband"(mS x 10) (RUN_PW_CALCS)
006DA9 7F6DA9 18 79 10 BC                 clrw  TOEpw         ; Clear "TOEpw" Throttle Opening Enrichment adder (mS x 100) (RUN_PW_CALCS)
006DAD 7F6DAD 18 79 10 C6                 clrw  FDpw          ; Clear "FDpw" Fuel Delivery pulse width (PW - Deadband)(mS x 10) (RUN_PW_CALCS)
006DB1 7F6DB1 18 79 10 C8                 clrw  PW            ; Clear "PW" Running engine injector pulsewidth (mS x 10) (RUN_PW_CALCS)
006DB5 7F6DB5 18 79 10 5B                 clrw  PWtk          ; Clear "PWtk" Running injector pulsewidth timer ticks(uS x 2.56) (RUN_PW_CALCS)
006DB9 7F6DB9 18 03 00 02 10 5D           movw  #$0002,InjOCadd1     ; First injector output compare adder (5.12uS res or 2.56uS res) (RUN_PW_CALCS)
006DBF 7F6DBF 18 03 00 02 10 5F           movw  #$0002,InjOCadd2     ; Second injector output compare adder (5.12uS res or 2.56uS res) (RUN_PW_CALCS)
006DC5 7F6DC5 18 79 10 E8                 clrw  DutyCyclex10  ; Clear "DutyCyclex10" Injector duty cycle in run mode (% x 10) (RUN_PW_CALCS)
006DC9 7F6DC9                         PWrunCalcsDone:                                                                  (RUN_PW_CALCS)
006DC9 7F6DC9 MACRO                       BARO_COR_LU       ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (BARO_COR_LU)
                                      ; - Look up current value in Barometric Correction Table (barocor)               (BARO_COR_LU)
                                      ;***************************************************************************************** (BARO_COR_LU)
006DC9 7F6DC9 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (BARO_COR_LU)
006DCE 7F6DCE 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (BARO_COR_LU)
                                                                  ; -> page where the desired curve resides            (BARO_COR_LU)
006DD4 7F6DD4 18 03 01 68 10 27           movw #$0168,CrvRowOfst  ; 360 -> Offset from the curve page to the curve row(barCorVals) (BARO_COR_LU)
                                                                      ; (actual offset is 720)                         (BARO_COR_LU)
006DDA 7F6DDA 18 03 01 71 10 29           movw #$0171,CrvColOfst  ; 369 -> Offset from the curve page to the curve column(barCorDelta) (BARO_COR_LU)
                                                                      ; (actual offset is 738)                         (BARO_COR_LU)
006DE0 7F6DE0 18 04 10 84 10 2B           movw Barox10,CrvCmpVal  ; Barometric Pressure (KPAx10) -> Curve comparison value (BARO_COR_LU)
006DE6 7F6DE6 18 0B 08 10 2D              movb #$08,CrvBinCnt     ; 8 -> number of bins in the curve row or column minus 1 (BARO_COR_LU)
006DEB 7F6DEB 16 6F 46                    jsr   CRV_LU_P   ; Jump to subroutine at CRV_LU_P:(located in interp_BEEM488.s module) (BARO_COR_LU)
006DEE 7F6DEE 7C 10 AA                    std   barocor    ; Copy result to Barometric correction (% x 10)             (BARO_COR_LU)
006DF1 7F6DF1 MACRO                       MAT_COR_LU        ; Macro in injcalcsBPEM.s
                                      ;***************************************************************************************** (MAT_COR_LU)
                                      ; - Look up current value in MAT Air Density Table (matcor)                      (MAT_COR_LU)
                                      ;***************************************************************************************** (MAT_COR_LU)
006DF1 7F6DF1 18 0B FF 00 17              movb  #(BUF_RAM_P1_START>>16),EPAGE  ; Move $FF into EPAGE                   (MAT_COR_LU)
006DF6 7F6DF6 18 03 08 00 10 25           movw #veBins_E,CrvPgPtr   ; Address of the first value in VE table(in RAM)(page pointer) (MAT_COR_LU)
                                                                  ;  ->page where the desired curve resides            (MAT_COR_LU)
006DFC 7F6DFC 18 03 01 9A 10 27           movw #$019A,CrvRowOfst  ; 410 -> Offset from the curve page to the curve row(matCorrTemps2) (MAT_COR_LU)
                                                                      ; (actual offset is 820)                         (MAT_COR_LU)
006E02 7F6E02 18 03 01 A3 10 29           movw #$01A3,CrvColOfst  ; 419 -> Offset from the curve page to the curve column(matCorrDelta2) (MAT_COR_LU)
                                                                      ; (actual offset is 838)                         (MAT_COR_LU)
006E08 7F6E08 18 04 10 70 10 2B           movw Matx10,CrvCmpVal   ; Manifold Air Temperature (Degrees F x 10) ->       (MAT_COR_LU)
                                                                  ; Curve comparison value                             (MAT_COR_LU)
006E0E 7F6E0E 18 0B 08 10 2D              movb #$08,CrvBinCnt     ; 8 -> number of bins in the curve row or column minus 1 (MAT_COR_LU)
006E13 7F6E13 16 70 0F                    jsr   CRV_LU_NP  ; Jump to subroutine at CRV_LU_NP:(located in interp_BEEM488.s module) (MAT_COR_LU)
006E16 7F6E16 7C 10 AC                    std   matcor     ; Copy result to Manifold Air Temperature Correction (% x 10) (MAT_COR_LU)
                                                            ; All of these Macro calls moved from the main loop in BPEM488.s
                                                            ; as a work around for random corrupted returns 5-4-21
006E19 7F6E19 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
006E1C 7F6E1C                         Notch_CT1_T8:
                                      ;*****************************************************************************************
                                      ; - If we are here the crankshaft is at 150 degrees before top dead centre on the
                                      ;   compression/power strokes for #7 cylinder. Start the hardware timer to delay the
                                      ;   coil dwell for spark #7, waste #4 if we are in run mode.
                                      ;*****************************************************************************************
006E1C 7F6E1C MACRO                       FIRE_IGN4                 ; macro in Tim_BPEM488.s
                                                              ; (Will trigger an interrupt after the delay time)(LED off) (FIRE_IGN4)
                                      ;***************************************************************************************** (FIRE_IGN4)
                                      ; - PT6 - IOC6 OC6 Ign4(4&7) Control                                             (FIRE_IGN4)
                                      ;***************************************************************************************** (FIRE_IGN4)
                                      ;***************************************************************************************** (FIRE_IGN4)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_IGN4)
                                      ;***************************************************************************************** (FIRE_IGN4)
006E1C 7F6E1C 4C 48 20                    bset ECT_TCTL1,Bit5 ; Set Ch6 output line to 1 on compare                    (FIRE_IGN4)
006E1F 7F6E1F 4C 48 10                    bset ECT_TCTL1,Bit4 ; Set Ch6 output line to 1 on compare                    (FIRE_IGN4)
006E22 7F6E22 DC 44                       ldd  ECT_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_IGN4)
006E24 7F6E24 F3 10 41                    addd IgnOCadd1      ; Add "IgnOCadd1" (Delay time from crank signal to energise coil) (FIRE_IGN4)
006E27 7F6E27 5C 5C                       std  ECT_TC6H       ; Copy result to Timer IC/OC register 2 (Start OC operation) (FIRE_IGN4)
006E29 7F6E29 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
006E2C 7F6E2C                         Notch_CT1_T9:
                                      ;*****************************************************************************************
                                      ; - If we are here the crankshaft is at 150 degrees before top dead centre on the
                                      ;   compression/power strokes for #2 cylinder. Start the hardware timer to delay the
                                      ;   coil dwell for spark #2, waste #3 if we are in run mode.
                                      ;*****************************************************************************************
006E2C 7F6E2C MACRO                       FIRE_IGN5                 ; macro in Tim_BPEM488.s
                                                              ; (Will trigger an interrupt after the delay time)(LED off) (FIRE_IGN5)
                                      ;***************************************************************************************** (FIRE_IGN5)
                                      ; - PT7 - IOC7 OC7 Ign5(3&2) Control                                             (FIRE_IGN5)
                                      ;***************************************************************************************** (FIRE_IGN5)
                                      ;***************************************************************************************** (FIRE_IGN5)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_IGN5)
                                      ;***************************************************************************************** (FIRE_IGN5)
006E2C 7F6E2C 4C 48 80                    bset ECT_TCTL1,Bit7 ; Set Ch7 output line to 1 on compare                    (FIRE_IGN5)
006E2F 7F6E2F 4C 48 40                    bset ECT_TCTL1,Bit6 ; Set Ch7 output line to 1 on compare                    (FIRE_IGN5)
006E32 7F6E32 DC 44                       ldd  ECT_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_IGN5)
006E34 7F6E34 F3 10 41                    addd IgnOCadd1      ; Add "IgnOCadd1" (Delay time from crank signal to energise coil) (FIRE_IGN5)
006E37 7F6E37 5C 5E                       std  ECT_TC7H       ; Copy result to Timer IC/OC register 2 (Start OC operation) (FIRE_IGN5)
006E39 7F6E39 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
006E3C 7F6E3C                         Notch_CT1_T10:
                                      ;*****************************************************************************************
                                      ; - If we are here the crankshaft is at 6 degrees before top dead centre on the
                                      ;   exhaust/intake strokes for #9 cylinder and 60 degrees before top dead centre on the
                                      ;   exhaust/intake strokes for #4 cylinder. #9 intake valve is just starting to open
                                      ;   and #4 intake valve is 54 degrees before it will start to open. Start the pulse
                                      ;   width for injectors 9&4.
                                      ;*****************************************************************************************
006E3C 7F6E3C 1E 10 E1 80 11              brset engine,FldClr,INJ2FldClr ; If "FldClr" bit of "engine" bit field is set branch
                                                                         ; to INJ2FldClr:
006E41 7F6E41 MACRO                       FIRE_INJ2                 ; Macro in Tim_BPEM488.s
                                                                  ; (Will trigger an interrupt after the delay time)(LED off) (FIRE_INJ2)
                                      ;***************************************************************************************** (FIRE_INJ2)
                                      ; - PP1 - TIM1 OC1(Inj2)(9&4) Control                                            (FIRE_INJ2)
                                      ;***************************************************************************************** (FIRE_INJ2)
                                      ;***************************************************************************************** (FIRE_INJ2)
                                      ; - Set the output compare value for desired delay from trigger time to energising time. (FIRE_INJ2)
                                      ;***************************************************************************************** (FIRE_INJ2)
006E41 7F6E41 1C 03 D9 04                 bset TIM_TCTL2,Bit2 ; Set Ch1 output line to 1 on compare                    (FIRE_INJ2)
006E45 7F6E45 1C 03 D9 08                 bset TIM_TCTL2,Bit3 ; Set Ch1 output line to 1 on compare                    (FIRE_INJ2)
006E49 7F6E49 FC 03 D4                    ldd  TIM_TCNTH      ; Contents of Timer Count Register-> Accu D              (FIRE_INJ2)
006E4C 7F6E4C F3 10 5D                    addd InjOCadd1      ; (A:B)+(M:M+1->A:B Add "InjOCadd1" (Delay from trigger to start (FIRE_INJ2)
                                                              ; of injection)                                          (FIRE_INJ2)
006E4F 7F6E4F 7C 03 E2                    std  TIM_TC1H       ; Copy result to Timer IC/OC register 1 (Start OC operation) (FIRE_INJ2)
006E52 7F6E52                         INJ2FldClr:
                                      ;***********************************************************************************************
                                      ; - Update Fuel Delivery Pulse Width Total so the results can be used by Tuner Studio and
                                      ;   Shadow Dash to calculate current fuel burn.
                                      ;***********************************************************************************************
006E52 7F6E52 FC 10 D0                    ldd  FDt            ; Fuel Delivery pulse width total(mS x 10)-> Accu D
006E55 7F6E55 F3 10 C6                    addd FDpw           ; (A:B)+(M:M+1->A:B Add  Fuel Delivery pulse width (mS x 10)
006E58 7F6E58 7C 10 D0                    std  FDt            ; Copy result to "FDT" (update "FDt")(mS x 10)
                                      ;***********************************************************************************************
                                      ; - Update the Fuel Delivery counter so that on roll over (65535mS)a pulsed signal can be sent to the
                                      ;   to the totalizer(open collector output)
                                      ;***********************************************************************************************
006E5B 7F6E5B FC 10 D0                    ldd  FDt             ; Fuel Delivery pulse width total(mS x 10)-> Accu D
006E5E 7F6E5E F3 10 61                        addd FDcnt           ; (A:B)+(M:M+1)->A:B (fuel delivery pulsewidth + fuel delivery counter)
006E61 7F6E61 25 05                       bcs  Totalizer2R     ; If the cary bit of CCR is set, branch to Totalizer2R: ("FDcnt"
                                                                   ;  rollover, pulse the totalizer)
006E63 7F6E63 7C 10 61                        std  FDcnt           ; Copy the result to "FDcnt" (update "FDcnt")
006E66 7F6E66 20 0B                       bra  TotalizerDone2R ; Branch to TotalizerDone2R:
006E68 7F6E68                         Totalizer2R:
006E68 7F6E68 7C 10 61                        std  FDcnt          ; Copy the result to "FDcnt" (update "FDcnt")
006E6B 7F6E6B 4C 01 08                    bset PORTB,AIOT     ; Set "AIOT" pin on Port B (PB6)(start totalizer pulse)
006E6E 7F6E6E 86 03                           ldaa #$03           ; Decimal 3->Accu A (3 mS)
006E70 7F6E70 7A 10 63                    staa AIOTcnt        ; Copy to "AIOTcnt" ( counter for totalizer pulse width,
                                                                  ; decremented every mS)
006E73 7F6E73                         TotalizerDone2R:
006E73 7F6E73 06 6E 76                    jmp   StateHandlersDone   ; Jump to StateHandlersDone:
006E76 7F6E76                         StateHandlersDone:
006E76 7F6E76 0B                          rti                  ; Return from interrupt
                                      ;**********************************************************************
006E77 7F6E77 -> $6E77                STATE_CODE_END          EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
006E77 7F6E77 -> $7F6E77              STATE_CODE_END_LIN      EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ;* - Tables -                                                                            *
                                      ;*****************************************************************************************
007B9F 7F7B9F                                                 ORG     STATE_TABS_START, STATE_TABS_START_LIN
007B9F 7F7B9F -> $7F7B9F              STATE_TABS_START_LIN    EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ; Lookup table for Dodge V10 Cam/Crank decoding
007B9F 7F7B9F                         StateLookup:
007B9F 7F7B9F 0B 0A 0C 46 0D 01 0E 02      db     $0B,$0A,$0C,$46,$0D,$01,$0E,$02,$0F,$03,$10,$04,$11,$05,$12,$06,
              0F 03 10 04 11 05 12 06 
007BAF 7F7BAF 13 07 14 08 15 09 16 17      db     $13,$07,$14,$08,$15,$09,$16,$17,$46,$7C,$46,$7C,$46,$7C,$46,$7C,
              46 7C 46 7C 46 7C 46 7C 
007BBF 7F7BBF 18 7C 19 7C 1B 1A 1C 1D      db     $18,$7C,$19,$7C,$1B,$1A,$1C,$1D,$1F,$1E,$21,$20,$46,$7D,$46,$22,
              1F 1E 21 20 46 7D 46 22 
007BCF 7F7BCF 46 7D 46 7D 46 23 46 7D      db     $46,$7D,$46,$7D,$46,$23,$46,$7D,$46,$7D,$46,$24,$46,$25,$46,$7D,
              46 7D 46 24 46 25 46 7D 
007BDF 7F7BDF 46 26 46 7D 46 27 46 28      db     $46,$26,$46,$7D,$46,$27,$46,$28,$46,$29,$46,$2A,$46,$2B,$46,$2C,
              46 29 46 2A 46 2B 46 2C 
007BEF 7F7BEF 46 2D 46 2E 46 2F 46 30      db     $46,$2D,$46,$2E,$46,$2F,$46,$30,$32,$31,$46,$33,$46,$34,$46,$35,
              32 31 46 33 46 34 46 35 
007BFF 7F7BFF 46 36 46 37 46 7F 46 38      db     $46,$36,$46,$37,$46,$7F,$46,$38,$46,$39,$46,$3A,$46,$3B,$3C,$7E,
              46 39 46 3A 46 3B 3C 7E 
007C0F 7F7C0F 3D 7E 3E 7E 3F 7E 40 7E      db     $3D,$7E,$3E,$7E,$3F,$7E,$40,$7E,$41,$46,$42,$46,$43,$46,$44,$46,
              41 46 42 46 43 46 44 46 
007C1F 7F7C1F 45 46 46 7D 46 7D 46 7D      db     $45,$46,$46,$7D,$46,$7D,$46,$7D,$46,$7D,$46,$7D,$46,$46,$46,$46,
              46 7D 46 7D 46 46 46 46 
007C2F 7F7C2F 46 46 46 46 46 46 46 46      db     $46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,
              46 46 46 46 46 46 46 46 
007C3F 7F7C3F 46 46 46 46 46 46 46 46      db     $46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,
              46 46 46 46 46 46 46 46 
007C4F 7F7C4F 46 46 46 46 46 46 46 46      db     $46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,
              46 46 46 46 46 46 46 46 
007C5F 7F7C5F 46 46 46 46 46 46 46 46      db     $46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,
              46 46 46 46 46 46 46 46 
007C6F 7F7C6F 46 69 46 6A 46 6B 46 6C      db     $46,$69,$46,$6A,$46,$6B,$46,$6C,$6D,$46,$6E,$46,$46,$7D,$46,$70,
              6D 46 6E 46 46 7D 46 70 
007C7F 7F7C7F 46 71 72 46 46 7F 46 7C      db     $46,$71,$72,$46,$46,$7F,$46,$7C,$73,$46,$46,$74,$46,$75,$46,$7E,
              73 46 46 74 46 75 46 7E 
007C8F 7F7C8F 46 77 46 78 46 79 46 7A      db     $46,$77,$46,$78,$46,$79,$46,$7A,$46,$68,$46,$6F,$46,$76,$46,$7B,
              46 68 46 6F 46 76 46 7B 
007C9F 7F7C9F -> $7C9F                STATE_TABS_END          EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
007C9F 7F7C9F -> $7F7C9F              STATE_TABS_END_LIN      EQU     @     ; @ Represents the current value of the linear
                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (interp_BPEM488.s)                                                          *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BPEM488 Engine Controller for the Dodge 488CID (8.0L) V10 engine  *
                                      ;*    by Robert Hiebert.                                                                 *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teaching    *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*    2D table interpolation Macro and 3D table interpolation subroutine                 *
                                      ;*    Author Dirk Heisswolf                                                              *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project                          *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map                                       *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project               *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map                                         *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features                     *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler              *
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications                  *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)                                     *
                                      ;*   gpio_BPEM488.s       - Initialization all ports                                     *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros (This module)           *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing                              *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths                       *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors                   *
                                      ;*****************************************************************************************
                                      ;* Version History:                                                                      *
                                      ;*    May5 25 2020                                                                       *
                                      ;*    - BPEM488 dedcated hardware version begins (work in progress)                      *
                                      ;*    - Update December 10 2020                                                          *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
007C9F 7F7C9F S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ;*****************************************************************************************
                                      ;* - Constants -                                                                         *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - 3DLUT table parameters for VE, ST and AFR 3D tables. Page is set in main loop when
                                      ;   calling a specific table
                                      ;*****************************************************************************************
007C9F 7F7C9F -> $0012                3DLUT_ROW_COUNT             EQU $12   ; Number of rows in table ($12=18)
007C9F 7F7C9F -> $0012                3DLUT_COL_COUNT             EQU $12   ; Number of columns in table ($12=18)
007C9F 7F7C9F -> $0288                3DLUT_ROW_BIN_OFFSET    EQU     2*(3DLUT_ROW_COUNT*3DLUT_COL_COUNT)
                                                                        ; Row bin offset from start of table ($288=648)
007C9F 7F7C9F -> $02AC                3DLUT_COL_BIN_OFFSET    EQU     3DLUT_ROW_BIN_OFFSET+(2*3DLUT_ROW_COUNT)
                                                                        ; Column bin offset from start of table ($2AC=684)
                                      ;*****************************************************************************************
                                      ;* - Variables -                                                                         *
                                      ;*****************************************************************************************
001025 0FD025                                     ORG     INTERP_VARS_START, INTERP_VARS_START_LIN
001025 0FD025 -> $FD025               INTERP_VARS_START_LIN   EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ; - 2D Lookup variables - (declared in this module)
                                      ;*****************************************************************************************
001025 0FD025                         CrvPgPtr:   ds 2 ; Pointer to the page where the desired curve resides
001027 0FD027                         CrvRowOfst: ds 2 ; Offset from the curve page to the curve row
001029 0FD029                         CrvColOfst: ds 2 ; Offset from the curve page to the curve column
00102B 0FD02B                         CrvCmpVal:  ds 2 ; Curve comparison value for interpolation
00102D 0FD02D                         CrvBinCnt:  ds 1 ; Number of bins in the curve row or column minus 1
00102E 0FD02E                         IndexNum:   ds 1 ; Position in the row or column of the curve comparison value
00102F 0FD02F                         CrvRowHi:   ds 2 ; Curve row high boundry value for interpolation
001031 0FD031                         CrvRowLo:   ds 2 ; Curve row low boundry value for interpolation
001033 0FD033                         CrvColHi:   ds 2 ; Curve column high boundry value for interpolation
001035 0FD035                         CrvColLo:   ds 2 ; Curve column low boundry value for interpolation
                                      ;*****************************************************************************************
001037 0FD037 -> $1037                INTERP_VARS_END         EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
001037 0FD037 -> $FD037               INTERP_VARS_END_LIN     EQU     @     ; @ Represents the current value of the linear
                                      ;*****************************************************************************************
                                      ;* - Code -                                                                              *
                                      ;*****************************************************************************************
006E77 7F6E77                                                 ORG     INTERP_CODE_START, INTERP_CODE_START_LIN
006E77 7F6E77 -> $7F6E77              INTERP_CODE_START_LIN   EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ; - Suboutines -
                                      ;*****************************************************************************************
                                      ; -Look-up value in 3D Table -
                                      ; =========================
                                      ; args:   D: row value
                                      ;         X: column value
                                      ;         Y: table pointer
                                      ; result: D: look-up value
                                      ; SSTACK:  bytes
                                      ;         X and Y are preserved
                                      ;*****************************************************************************************
006E77 7F6E77 -> $6E77                3D_LOOKUP:   EQU        *
                                      ;*****************************************************************************************
                                      ; - Save registers (row value in D, column value in X, table pointer
                                      ;   in Y)
                                      ;*****************************************************************************************
006E77 7F6E77 35                                      PSHY                                    ;save table pointer
006E78 7F6E78 34                                      PSHX                                    ;save column value
006E79 7F6E79 3B                                      PSHD                                    ;save row value
                                      ;*****************************************************************************************
                                                      ;    +--------+--------+
                                                      ;    |    row value    |  SP+ 0 ($3FF8)
                                                      ;    +--------+--------+
                                                      ;    |  column value   |  SP+ 2 ($3FFA)
                                                      ;    +--------+--------+
                                                      ;    |  table pointer  |  SP+ 4 ($3FFC)
                                                      ;    +--------+--------+
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Determine upper and lower column bin entry (column value in X,
                                      ;   table pointer in Y)
                                      ;*****************************************************************************************
006E7A 7F6E7A 19 EA 02 AC                             LEAY 3DLUT_COL_BIN_OFFSET,Y   ; Column bin pointer -> Y
                                                                            ;($2AC=684)
006E7E 7F6E7E C6 22                           LDAB #(2*(3DLUT_ROW_COUNT-1)) ; Lower column bin offset -> B
                                                                            ;($22=34)
006E80 7F6E80 18 0F                           TBA                                     ; Lower  offset -> A (start at $22=34)
006E82 7F6E82 AE EC                           CPX      A,Y            ; Compare column value against current bin
                                                                  ; value
006E84 7F6E84 2C 10                           BGE  3D_LOOKUP_2A   ; First iteration, if equal to or greater
                                                                  ; than current bin value, rail high, upper
                                                                  ; and lower bin offsets the same
006E86 7F6E86                         3D_LOOKUP_1:
006E86 7F6E86 18 0F                           TBA                                     ; Lower  offset -> A
006E88 7F6E88 AE EC                           CPX      A,Y            ; Compare column value against current bin
                                                                  ; value
006E8A 7F6E8A 2C 08                                   BGE      3D_LOOKUP_2    ; Branch if column value is greater than
                                                                  ; or equal to current bin value
                                                                  ;(match found)
006E8C 7F6E8C 53                                      DECB                ; Decrement bin offset low byte
006E8D 7F6E8D 04 31 F6                                DBNE B,3D_LOOKUP_1  ; Decrement bin offset Hi byte and loop
                                                                  ; back if not zero
006E90 7F6E90 18 0F                                   TBA                                     ; Column value too low, no match found,
                                                                  ; rail low, make lower and upper bin
                                                                  ; offsets the same)
006E92 7F6E92 20 02                           BRA   3D_LOOKUP_2A
                                      ;*****************************************************************************************
                                      ; - Increment lower offset to make upper offset
                                      ;*****************************************************************************************
006E94 7F6E94                         3D_LOOKUP_2:
006E94 7F6E94 42                              INCA                ; Increment lower offset Lo byte
006E95 7F6E95 42                              INCA                ; Increment lower offset Hi byte to make
                                                                  ; upper offset in "A"
                                      ;*****************************************************************************************
                                      ; - Push upper and lower column value (upper column bin offset in A,
                                      ;   lower column bin offset in B, column bin pointer in Y)
                                      ;*****************************************************************************************
006E96 7F6E96                         3D_LOOKUP_2A:
006E96 7F6E96 18 02 ED AE                     MOVW B,Y, 2,-SP     ; Push lower column value onto stack
006E9A 7F6E9A 18 02 EC AE                             MOVW A,Y, 2,-SP     ; Push upper column value onto stack
                                      ;*****************************************************************************************
                                                      ;    +--------+--------+
                                                      ;    | upper col value |  SP+ 0 ($3FF4)
                                                      ;    +--------+--------+
                                                      ;    | lower col value |  SP+ 2 ($3FF6)
                                                      ;    +--------+--------+
                                                      ;    |    row value    |  SP+ 4 ($3FF8)
                                                      ;    +--------+--------+
                                                      ;    |  column value   |  SP+ 6 ($3FFA)
                                                      ;    +--------+--------+
                                                      ;    |  table pointer  |  SP+ 8 ($3FFC)
                                                      ;    +--------+--------+
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Push upper and lower row pointer (upper colum bin offset in A,
                                      ;   lower column bin offset in B)
                                      ;*****************************************************************************************
006E9E 7F6E9E B7 05                                   TFR  A, X             ; Save upper colum bin offset in XL
006EA0 7F6EA0 86 12                                   LDAA #3DLUT_COL_COUNT ; Multiply lower column bin offset
                                                                    ; column count ($12=18)
006EA2 7F6EA2 12                                      MUL                   ; (A)x(B)->A:B
006EA3 7F6EA3 E3 88                                   ADDD 8,SP             ; Add table pointer
006EA5 7F6EA5 3B                                      PSHD                  ; Push lower row pointer onto the stack
006EA6 7F6EA6 B7 51                                   TFR      X,B              ; Restore upper colum bin offset
006EA8 7F6EA8 86 12                                   LDAA #3DLUT_COL_COUNT ; Multiply lower column bin offset
                                                                    ; Column count ($12=18)
006EAA 7F6EAA 12                                      MUL                   ; (A)x(B)->A:B (test 18*6=108)
006EAB 7F6EAB E3 8A                                   ADDD (8+2),SP         ; Add table pointer
006EAD 7F6EAD 3B                                      PSHD                  ; Push upper row pointer onto the stack
                                      ;*****************************************************************************************
                                                      ;    +--------+--------+
                                                      ;    |  upper row ptr  |  SP+ 0 ($3FF0)
                                                      ;    +--------+--------+
                                                      ;    |  lower row ptr  |  SP+ 2 ($3FF2)
                                                      ;    +--------+--------+
                                                      ;    | upper col value |  SP+ 4 ($3FF4)
                                                      ;    +--------+--------+
                                                      ;    | lower col value |  SP+ 6 ($3FF6)
                                                      ;    +--------+--------+
                                                      ;    |    row value    |  SP+ 8 ($3FF8)
                                                      ;    +--------+--------+
                                                      ;    |  column value   |  SP+10 ($3FFA)
                                                      ;    +--------+--------+
                                                      ;    |  table pointer  |  SP+12 ($3FFC)
                                                      ;    +--------+--------+
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Determine upper and lower row bin entry (column value in X,
                                      ;   table pointer in Y)
                                      ;*****************************************************************************************
006EAE 7F6EAE ED 8C                                   LDY      12,SP                    ; Table pointer -> Y
006EB0 7F6EB0 19 EA 02 88                             LEAY 3DLUT_ROW_BIN_OFFSET,Y   ; Row bin pointer -> Y($288=648)
006EB4 7F6EB4 C6 22                           LDAB #(2*(3DLUT_ROW_COUNT-1)) ; Lower row bin offset -> B
                                                                            ;($22=34)
006EB6 7F6EB6 EE 88                           LDX  8,SP                     ; Row value -> X
006EB8 7F6EB8 18 0F                           TBA                ; Lower offset -> A (start at $22=34)
006EBA 7F6EBA AE EC                           CPX     A,Y                ; Compare row value against current bin value
006EBC 7F6EBC 2C 10                           BGE 3D_LOOKUP_4A   ; First iteration, if equal to or greater
                                                                 ; than current bin value, rail high, upper
                                                                 ; and lower bin offsets the same
006EBE 7F6EBE                         3D_LOOKUP_3:
006EBE 7F6EBE 18 0F                           TBA                    ; Lower  offset -> A
006EC0 7F6EC0 AE EC                           CPX      A,Y           ; Compare column value against current bin
                                                                 ; value
006EC2 7F6EC2 2C 08                                   BGE     3D_LOOKUP_4    ; Branch if column value is greater than
                                                                 ; or equal to current bin value
                                                                 ;(match found)
006EC4 7F6EC4 53                                      DECB               ; Decrement bin offset low byte
006EC5 7F6EC5 04 31 F6                                DBNE B,3D_LOOKUP_3 ; Decrement bin offset Hi byte and loop
                                                                 ; back if not zero
006EC8 7F6EC8 18 0F                                   TBA                    ; Column value too low, no match found,
                                                                 ; rail low, make lower and upper bin
                                                                 ; offsets the same)
006ECA 7F6ECA 20 02                           bra   3D_LOOKUP_4A
                                      ;*****************************************************************************************
                                      ; - Increment lower offset to make upper offset
                                      ;*****************************************************************************************
006ECC 7F6ECC                         3D_LOOKUP_4:
006ECC 7F6ECC 42                              INCA                ; Increment lower offset Lo byte
006ECD 7F6ECD 42                              INCA                ; Increment lower offset Hi byte to make
                                                                  ; upper offset in "A"
                                      ;*****************************************************************************************
                                      ; - Push upper and lower row value (upper row bin offset in A,
                                      ;   lower row bin offset in B, row bin pointer in Y)
                                      ;*****************************************************************************************
006ECE 7F6ECE                         3D_LOOKUP_4A:
006ECE 7F6ECE 18 02 ED AE                     MOVW    B,Y, 2,-SP  ; Push lower row value onto stack
006ED2 7F6ED2 18 02 EC AE                             MOVW    A,Y, 2,-SP  ; Push upper row value onto stack
                                      ;*****************************************************************************************
                                                      ;    +--------+--------+
                                                      ;    | upper row value |  SP+ 0 ($3FFC)
                                                      ;    +--------+--------+
                                                      ;    | lower row value |  SP+ 2 ($3FEE)
                                                      ;    +--------+--------+
                                                      ;    |  upper row ptr  |  SP+ 4 ($3FF0)
                                                      ;    +--------+--------+
                                                      ;    |  lower row ptr  |  SP+ 6 ($3FF2)
                                                      ;    +--------+--------+
                                                      ;    | upper col value |  SP+ 8 ($3FF4)
                                                      ;    +--------+--------+
                                                      ;    | lower col value |  SP+10 ($3FF6)
                                                      ;    +--------+--------+
                                                      ;    |    row value    |  SP+12 ($3FF8)
                                                      ;    +--------+--------+
                                                      ;    |  column value   |  SP+14 ($3FFA)
                                                      ;    +--------+--------+
                                                      ;    |  table pointer  |  SP+16 ($3FFC)
                                                      ;    +--------+--------+
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Read Zhh, Zhl, Zlh, and Zll from look-up table
                                      ;  (upper row bin offset in A, lower row bin offset in B)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                                      ;
                                                      ;   lower                  upper
                                                      ;    row         row        row
                                                      ;   value       value      value
                                                      ;     .           .          .         lower
                                                      ;   ..0......................o.........column
                                                      ;     .Zll        .Zl        .Zlh      value
                                                      ;     .           .          .
                                                      ;     .           .          .
                                                      ;   ...................................column
                                                      ;     .           .Z         .         value
                                                      ;     .           .          .
                                                      ;     .           .          .         upper
                                                      ;   ..o......................o.........column
                                                      ;     .Zhl        .Zh        .Zhh      value
                                                      ;
                                      ;*****************************************************************************************
006ED6 7F6ED6 ED 84                                   LDY      4,SP       ; Upper row pointer -> Y
006ED8 7F6ED8 EE 86                                   LDX  6,SP       ; Lower row pointer -> X
006EDA 7F6EDA 18 02 E5 AE                             MOVW B,X, 2,-SP ; Push Zll
006EDE 7F6EDE 18 02 E4 AE                             MOVW A,X, 2,-SP ; Push Zlh
006EE2 7F6EE2 18 02 ED AE                             MOVW B,Y, 2,-SP ; Push Zhl
006EE6 7F6EE6 18 02 EC AE                             MOVW A,Y, 2,-SP ; Push Zhh
                                      ;*****************************************************************************************
                                                      ;    +--------+--------+
                                                      ;    |       Zhh       |  SP+ 0 ($3FE4)
                                                      ;    +--------+--------+
                                                      ;    |       Zhl       |  SP+ 2 ($3FE6)
                                                      ;    +--------+--------+
                                                      ;    |       Zlh       |  SP+ 4 ($3FE8)
                                                      ;    +--------+--------+
                                                      ;    |       Zll       |  SP+ 6 ($3FEA)
                                                      ;    +--------+--------+
                                                      ;    | upper row value |  SP+ 8 ($3FEC)
                                                      ;    +--------+--------+
                                                      ;    | lower row value |  SP+10 ($3FEE)
                                                      ;    +--------+--------+
                                                      ;    |  upper row ptr  |  SP+12 ($3FF0)
                                                      ;    +--------+--------+
                                                      ;    |  lower row ptr  |  SP+14 ($3FF2)
                                                      ;    +--------+--------+
                                                      ;    | upper col value |  SP+16 ($3FF4)
                                                      ;    +--------+--------+
                                                      ;    | lower col value |  SP+18 ($3FF6)
                                                      ;    +--------+--------+
                                                      ;    |    row value    |  SP+20 ($3FF8)
                                                      ;    +--------+--------+
                                                      ;    |  column value   |  SP+22 ($3FFA)
                                                      ;    +--------+--------+
                                                      ;    |  table pointer  |  SP+24 ($3FFC)
                                                      ;    +--------+--------+
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Determine Zl
                                      ;*****************************************************************************************
                                      ;                         V       V1      V2      Z1     Z2
006EEA 7F6EEA MACRO                                   2D_IPOL (20,SP), (10,SP), (8,SP), (6,SP), (4,SP)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (2D_IPOL)
                                      ; ==========================                                                     (2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (2D_IPOL)
                                      ; result: D: interpolated result                                                 (2D_IPOL)
                                      ; SSTACK: none                                                                   (2D_IPOL)
                                      ;         no registers are preserved                                             (2D_IPOL)
                                      ;                                                                                (2D_IPOL)
                                      ;    ^ V                                                                         (2D_IPOL)
                                      ;    |                                                                           (2D_IPOL)
                                      ;  Z2+....................*                                                      (2D_IPOL)
                                      ;    |                    :                                                      (2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (2D_IPOL)
                                      ;    |   :       :        :                                                      (2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (2D_IPOL)
                                      ;    |   V1      V        V2                                                     (2D_IPOL)
                                      ;                                                                                (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
006EEA 7F6EEA EC F0 14                                LDD       \1    ; load V                                         (2D_IPOL)
006EED 7F6EED A3 8A                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (2D_IPOL)
006EEF 7F6EEF B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
006EF1 7F6EF1 EC 84                                   LDD       \5    ; load Z2                                        (2D_IPOL)
006EF3 7F6EF3 A3 86                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
006EF5 7F6EF5 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (2D_IPOL)
006EF7 7F6EF7 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
006EF9 7F6EF9 EC 88                                   LDD       \3    ; load V2                                        (2D_IPOL)
006EFB 7F6EFB A3 8A                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (2D_IPOL)
006EFD 7F6EFD B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (2D_IPOL)
                                      ;*********************************************************************           (2D_IPOL)
006EFF 7F6EFF 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (2D_IPOL)
006F01 7F6F01 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
006F03 7F6F03 E3 86                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (2D_IPOL)
006F05 7F6F05 3B                                      PSHD     ; Push Zl onto stack
                                      ;*****************************************************************************************
                                                      ;    +--------+--------+
                                                      ;    |       Zl        |  SP+ 0 ($3FE2)
                                                      ;    +--------+--------+
                                                      ;    |       Zhh       |  SP+ 2 ($3FE4)
                                                      ;    +--------+--------+
                                                      ;    |       Zhl       |  SP+ 4 ($3FE6)
                                                      ;    +--------+--------+
                                                      ;    |       Zlh       |  SP+ 6 ($3FE8)
                                                      ;    +--------+--------+
                                                      ;    |       Zll       |  SP+ 8 ($3FEA)
                                                      ;    +--------+--------+
                                                      ;    | upper row value |  SP+10 ($3FEC)
                                                      ;    +--------+--------+
                                                      ;    | lower row value |  SP+12 ($3FEE)
                                                      ;    +--------+--------+
                                                      ;    |  upper row ptr  |  SP+14 ($3FF0)
                                                      ;    +--------+--------+
                                                      ;    |  lower row ptr  |  SP+16 ($3FF2)
                                                      ;    +--------+--------+
                                                      ;    | upper col value |  SP+18 ($3FF4)
                                                      ;    +--------+--------+
                                                      ;    | lower col value |  SP+20 ($3FF6)
                                                      ;    +--------+--------+
                                                      ;    |    row value    |  SP+22 ($3FF8)
                                                      ;    +--------+--------+
                                                      ;    |  column value   |  SP+24 ($3FFA)
                                                      ;    +--------+--------+
                                                      ;    |  table pointer  |  SP+26 ($3FFC)
                                                      ;    +--------+--------+
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Determine Zh
                                      ;*****************************************************************************************
                                      ;                         V       V1       V2      Z1     Z2
006F06 7F6F06 MACRO                                   2D_IPOL (22,SP), (12,SP), (10,SP), (4,SP), (2,SP)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (2D_IPOL)
                                      ; ==========================                                                     (2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (2D_IPOL)
                                      ; result: D: interpolated result                                                 (2D_IPOL)
                                      ; SSTACK: none                                                                   (2D_IPOL)
                                      ;         no registers are preserved                                             (2D_IPOL)
                                      ;                                                                                (2D_IPOL)
                                      ;    ^ V                                                                         (2D_IPOL)
                                      ;    |                                                                           (2D_IPOL)
                                      ;  Z2+....................*                                                      (2D_IPOL)
                                      ;    |                    :                                                      (2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (2D_IPOL)
                                      ;    |   :       :        :                                                      (2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (2D_IPOL)
                                      ;    |   V1      V        V2                                                     (2D_IPOL)
                                      ;                                                                                (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
006F06 7F6F06 EC F0 16                                LDD       \1    ; load V                                         (2D_IPOL)
006F09 7F6F09 A3 8C                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (2D_IPOL)
006F0B 7F6F0B B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
006F0D 7F6F0D EC 82                                   LDD       \5    ; load Z2                                        (2D_IPOL)
006F0F 7F6F0F A3 84                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
006F11 7F6F11 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (2D_IPOL)
006F13 7F6F13 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
006F15 7F6F15 EC 8A                                   LDD       \3    ; load V2                                        (2D_IPOL)
006F17 7F6F17 A3 8C                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (2D_IPOL)
006F19 7F6F19 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (2D_IPOL)
                                      ;*********************************************************************           (2D_IPOL)
006F1B 7F6F1B 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (2D_IPOL)
006F1D 7F6F1D B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
006F1F 7F6F1F E3 84                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (2D_IPOL)
006F21 7F6F21 3B                                      PSHD     ; Push Zh onto stack
                                      ;*****************************************************************************************
                                                      ;    +--------+--------+
                                                      ;    |       Zh        |  SP+ 0 ($3FE0)
                                                      ;    +--------+--------+
                                                      ;    |       Zl        |  SP+ 2 ($3FE2)
                                                      ;    +--------+--------+
                                                      ;    |       Zhh       |  SP+ 4 ($3FE4)
                                                      ;    +--------+--------+
                                                      ;    |       Zhl       |  SP+ 6 ($3FE6)
                                                      ;    +--------+--------+
                                                      ;    |       Zlh       |  SP+ 8 ($3FE8)
                                                      ;    +--------+--------+
                                                      ;    |       Zll       |  SP+10 ($3FEA)
                                                      ;    +--------+--------+
                                                      ;    | upper row value |  SP+12 ($3FEC)
                                                      ;    +--------+--------+
                                                      ;    | lower row value |  SP+14 ($3FEE)
                                                      ;    +--------+--------+
                                                      ;    |  upper row ptr  |  SP+16 ($3FF0)
                                                      ;    +--------+--------+
                                                      ;    |  lower row ptr  |  SP+18 ($3FF2)
                                                      ;    +--------+--------+
                                                      ;    | upper col value |  SP+20 ($3FF4)
                                                      ;    +--------+--------+
                                                      ;    | lower col value |  SP+22 ($3FF6)
                                                      ;    +--------+--------+
                                                      ;    |    row value    |  SP+24 ($3FF8)
                                                      ;    +--------+--------+
                                                      ;    |  column value   |  SP+26 ($3FFA)
                                                      ;    +--------+--------+
                                                      ;    |  table pointer  |  SP+28 ($3FFC)
                                                      ;    +--------+--------+
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Determine Z
                                      ;*****************************************************************************************
                                      ;                         V       V1        V2      Z1     Z2
006F22 7F6F22 MACRO                                   2D_IPOL (26,SP), (22,SP), (20,SP), (2,SP), (0,SP)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (2D_IPOL)
                                      ; ==========================                                                     (2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (2D_IPOL)
                                      ; result: D: interpolated result                                                 (2D_IPOL)
                                      ; SSTACK: none                                                                   (2D_IPOL)
                                      ;         no registers are preserved                                             (2D_IPOL)
                                      ;                                                                                (2D_IPOL)
                                      ;    ^ V                                                                         (2D_IPOL)
                                      ;    |                                                                           (2D_IPOL)
                                      ;  Z2+....................*                                                      (2D_IPOL)
                                      ;    |                    :                                                      (2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (2D_IPOL)
                                      ;    |   :       :        :                                                      (2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (2D_IPOL)
                                      ;    |   V1      V        V2                                                     (2D_IPOL)
                                      ;                                                                                (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
006F22 7F6F22 EC F0 1A                                LDD       \1    ; load V                                         (2D_IPOL)
006F25 7F6F25 A3 F0 16                                SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (2D_IPOL)
006F28 7F6F28 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
006F2A 7F6F2A EC 80                                   LDD       \5    ; load Z2                                        (2D_IPOL)
006F2C 7F6F2C A3 82                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
006F2E 7F6F2E 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (2D_IPOL)
006F30 7F6F30 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
006F32 7F6F32 EC F0 14                                LDD       \3    ; load V2                                        (2D_IPOL)
006F35 7F6F35 A3 F0 16                                SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (2D_IPOL)
006F38 7F6F38 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (2D_IPOL)
                                      ;*********************************************************************           (2D_IPOL)
006F3A 7F6F3A 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (2D_IPOL)
006F3C 7F6F3C B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (2D_IPOL)
                                      ;***************************************************************************************** (2D_IPOL)
006F3E 7F6F3E E3 82                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (2D_IPOL)
                                      ;*****************************************************************************************
                                      ; - Free stack space (result in D)
                                      ;*****************************************************************************************
006F40 7F6F40 1B F0 1A                                LEAS 26,SP   ; Stack pointer -> bottom of stack
                                      ;*****************************************************************************************
                                      ; - Restore registers (result in D)
                                      ;*****************************************************************************************
006F43 7F6F43 30                                      PULX   ; Pull index register X from stack
006F44 7F6F44 31                                      PULY   ; Pull index register Y from stack
                                      ;*****************************************************************************************
                                      ; - Done (result in D)
                                      ;*****************************************************************************************
006F45 7F6F45 3D                                      RTS   ; Return from subroutine
                                      ;*****************************************************************************************
                                      ; ------------------------------ Linear Interpolation - 2D -------------------------------
                                      ; Graph Plot
                                      ;    |
                                      ;  Z2+....................*
                                      ;    |                    :
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)
                                      ;    |           :        :        Z = Z1 + --------------
                                      ;  Z1+...*       :        :                    (V2-V1)
                                      ;    |   :       :        :
                                      ;   -+---+-------+--------+---
                                      ;    |   V1      V        V2
006F46 7F6F46 -> $6F46                CRV_LU_P:   EQU *
                                      ;*****************************************************************************************
                                      ; - This subroutine calculates the interpolated value of a 2D curve with an X axis that
                                      ;   starts with positive values and ends with positive values.
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - First, determine the position in the row of the comparison value for
                                      ;   interpolation (IndexNum). Position in the column will be the same as the position
                                      ;   in the row. Determine the row high and low boundary values.
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Set up the process to find the interpolated curve value by determining the values
                                      ;   of the first bins in the row and column. Clear the index number variable.
                                      ;*****************************************************************************************
006F46 7F6F46 MACRO                       CRV_SETUP       ; Macro this module
                                      ;***************************************************************************************** (CRV_SETUP)
                                      ; - Set up the process to find the interpolated curve value by determining the values (CRV_SETUP)
                                      ;   of the first bins in the row and column. Clear the index number variable.    (CRV_SETUP)
                                      ;***************************************************************************************** (CRV_SETUP)
006F46 7F6F46 FD 10 25                    ldy  CrvPgPtr     ; Pointer to the page where the desired curve resides -> Y (CRV_SETUP)
006F49 7F6F49 FC 10 27                    ldd  CrvRowOfst   ; Offset from the curve page to the curve row -> D         (CRV_SETUP)
006F4C 7F6F4C 19 EE                       leay D,Y          ; Curve row pointer -> Y                                   (CRV_SETUP)
006F4E 7F6F4E 18 05 EE 10 31              movw D,Y,CrvRowLo ; Copy to curve row low boundry value for interpolation    (CRV_SETUP)
006F53 7F6F53 18 05 EE 10 2F              movw D,Y,CrvRowHi ; Copy to curve row high boundry value for interpolation   (CRV_SETUP)
                                                            ; (start with low and high row bin values equal            (CRV_SETUP)
006F58 7F6F58 FD 10 25                    ldy  CrvPgPtr     ; Pointer to the page where the desired curve resides -> Y (CRV_SETUP)
006F5B 7F6F5B FC 10 29                    ldd  CrvColOfst   ; Offset from the curve page to the curve column -> D      (CRV_SETUP)
006F5E 7F6F5E 19 EE                       leay D,Y          ; Curve column pointer -> Y                                (CRV_SETUP)
006F60 7F6F60 18 05 EE 10 35              movw D,Y,CrvColLo ; Copy to curve row column boundry value for interpolation (CRV_SETUP)
006F65 7F6F65 18 05 EE 10 33              movw D,Y,CrvColHi ; Copy to curve column high boundry value for interpolation (CRV_SETUP)
                                                            ; (start with low and high column bin values equal         (CRV_SETUP)
006F6A 7F6F6A 79 10 2E                    clr   IndexNum    ; Position in the row or column of the curve comparison value (CRV_SETUP)
                                      ;*****************************************************************************************
                                      ; - Check to see if CrvCmpVal is =< CrvRowLo. if it is rail low with CrvColLo in Accu D
                                      ;*****************************************************************************************
006F6D 7F6F6D FE 10 2B                    ldx  CrvCmpVal    ; Curve compare value -> X
006F70 7F6F70 BE 10 31                    cpx  CrvRowLo     ; Compare curve compare value with curve low boundary
006F73 7F6F73 23 02                       bls  RailLowPos   ; If CrvCmpVal is the same or less than CrvRowLo branch to RailLowPos:
006F75 7F6F75 20 04                       bra  ReEntCrvPos  ; Branch to ReEntCrvPos:
006F77 7F6F77                         RailLowPos:
006F77 7F6F77 FC 10 35                    ldd  CrvColLo    ; Curve column low boundary value -> D
006F7A 7F6F7A 3D                          rts              ; Return from subroutine (Rail low, no interpolation required)
                                      ;*****************************************************************************************
                                      ; - Both CrvRowLo and CrvCmpVal are positive. CrvCmpVal is the greater than CrvRowLo.
                                      ;   Determine the value of CrvRowHi
                                      ;*****************************************************************************************
006F7B 7F6F7B                         ReEntCrvPos:
006F7B 7F6F7B 72 10 2E                    inc  IndexNum     ; Increment position in the row or column of the curve comparison
                                                            ; value
006F7E 7F6F7E 18 04 10 2F 10 31           movw CrvRowHi,CrvRowLo ; Curve row high boundry value -> curve row low boundry value
006F84 7F6F84 18 72 10 27                 incw CrvRowOfst   ; Increment Offset from the curve page to the curve row
006F88 7F6F88 FD 10 25                    ldy  CrvPgPtr     ; Pointer to the page where the desired curve resides -> Y
006F8B 7F6F8B FC 10 27                    ldd  CrvRowOfst   ; Incremented offset from the curve page to the curve row -> D
006F8E 7F6F8E 19 EE                       leay D,Y          ; Curve row pointer -> Y
006F90 7F6F90 18 05 EE 10 2F              movw D,Y,CrvRowHi ; Copy to curve row high boundry value for interpolation
                                                            ; (holds the contents of the incremented row bin)
                                      ;*****************************************************************************************
                                      ; - CrvRowLo, CrvCmpVal and CrvRowHi are all positive. CrvCmpVal is the greater than CrvRowLo.
                                      ;   Now see if CrvRowHi is greater than CrvCmpVal. If it is, we have the index number,
                                      ;   if it is not, loop back to increment to the next bin and check again.
                                      ;*****************************************************************************************
006F95 7F6F95 FE 10 2F                    ldx  CrvRowHi     ; Curve row high boundary -> X
006F98 7F6F98 BE 10 2B                    cpx  CrvCmpVal    ; Compare curve curve row high boundary with curve compare value
006F9B 7F6F9B 24 08                       bhs  GotNumPos    ; If contents of incremented row bin is greater than or equal to
                                                            ; curve compareson value then branch to GotNumPos:
006F9D 7F6F9D B6 10 2E                    ldaa IndexNum     ; Incremented position in the row or column of the curve comparison
                                                            ; value for interpolation -> A
006FA0 7F6FA0 B1 10 2D                    cmpa CrvBinCnt    ; Compare Incremented position in the row or column of the curve
                                                            ; comparison value for interpolation with number of bins in the curve
                                                            ; row or column minus 1
006FA3 7F6FA3 26 D6                       bne  ReEntCrvPos  ; If (A)-(M) if IndexNum does not = CrvBinCnt then branch to
                                                            ; ReEntCrvPos:
006FA5 7F6FA5                         GotNumPos:
                                      ;*****************************************************************************************
                                      ; - CrvRowLo, CrvCmpVal and CrvRowHi are all positive. CrvCmpVal is the greater than
                                      ;   CrvRowLo. CrvRowHi is greater than or equal to CrvCmpVal so we must have our index
                                      ;   number.
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Using the index number determine the column high and low boundary values
                                      ;*****************************************************************************************
006FA5 7F6FA5 MACRO                      COL_BOUNDARYS     ; Macro this module
                                                            ; for interpolation (start with zero)                      (COL_BOUNDARYS)
                                      ;***************************************************************************************** (COL_BOUNDARYS)
                                      ; - Using the index number determine the column high and low boundary values     (COL_BOUNDARYS)
                                      ;***************************************************************************************** (COL_BOUNDARYS)
006FA5 7F6FA5 FE 10 29                    ldx  CrvColOfst   ; Offset from the curve page to the curve column -> D      (COL_BOUNDARYS)
006FA8 7F6FA8 F6 10 2E                    ldab IndexNum     ; IndexNum -> B                                            (COL_BOUNDARYS)
006FAB 7F6FAB 1A E5                       abx               ;(B)+(X)->X Pointer to indexed column bin                  (COL_BOUNDARYS)
006FAD 7F6FAD 7E 10 29                    stx  CrvColOfst   ; Result to CrvColOfst (now points to indexed column bin)  (COL_BOUNDARYS)
006FB0 7F6FB0 FD 10 25                    ldy  CrvPgPtr     ; Pointer to the page where the desired curve resides -> Y (COL_BOUNDARYS)
006FB3 7F6FB3 FC 10 29                    ldd  CrvColOfst   ; Offset from the curve page to the curve column -> D      (COL_BOUNDARYS)
006FB6 7F6FB6 19 EE                       leay D,Y          ; Curve column pointer -> Y                                (COL_BOUNDARYS)
006FB8 7F6FB8 18 05 EE 10 33              movw D,Y,CrvColHi ; Copy to curve column high boundry value for interpolation (COL_BOUNDARYS)
006FBD 7F6FBD 18 73 10 29                 decw CrvColOfst   ; Decrement offset from the curve page to the curve column (COL_BOUNDARYS)
006FC1 7F6FC1 FD 10 25                    ldy  CrvPgPtr     ; Pointer to the page where the desired curve resides -> Y (COL_BOUNDARYS)
006FC4 7F6FC4 FC 10 29                    ldd  CrvColOfst   ; Offset from the curve page to the curve column -> D      (COL_BOUNDARYS)
006FC7 7F6FC7 19 EE                       leay D,Y          ; Curve column pointer -> Y                                (COL_BOUNDARYS)
006FC9 7F6FC9 18 05 EE 10 35              movw D,Y,CrvColLo ; Copy to curve column low boundry value for interpolation (COL_BOUNDARYS)
006FCE 7F6FCE FC 10 35                    ldd  CrvColLo     ; CrvColLo -> D                                            (COL_BOUNDARYS)
                                      ;*****************************************************************************************
                                      ; - Do the interpolation or rail high and exit subroutine
                                      ;*****************************************************************************************
006FD1 7F6FD1 MACRO                      CRV_INTERP       ; Macro this module
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ; - Do the interpolation or rail high and exit subroutine                        (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
006FD1 7F6FD1 FE 10 2B                    ldx  CrvCmpVal    ; Curve row comparison value -> X                          (CRV_INTERP)
006FD4 7F6FD4 BE 10 2F                    cpx  CrvRowHi     ; Compare row comparison value with curve row high boundry value (CRV_INTERP)
006FD7 7F6FD7 25 04                       blo  DoInterp     ; If Curve row comparison value is < curve row high boundry value (CRV_INTERP)
                                                            ; branch to DoInterp:                                      (CRV_INTERP)
006FD9 7F6FD9 FC 10 33                    ldd  CrvColHi     ; Curve column high boundry value -> D (result railed high) (CRV_INTERP)
006FDC 7F6FDC 3D                          rts               ; Return from subroutine (CrvCmpVal is equal to or higher than (CRV_INTERP)
                                                            ; CrvRowHi so no need to interpolate. Rail high with CrvColHi in D (CRV_INTERP)
006FDD 7F6FDD                         DoInterp:                                                                        (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ; - Save interpolation values to stack                                           (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
006FDD 7F6FDD FE 10 2B                    ldx  CrvCmpVal    ; Curve row comparison value -> X                          (CRV_INTERP)
006FE0 7F6FE0 34                          pshx              ; Save to stack                                            (CRV_INTERP)
006FE1 7F6FE1 FE 10 2F                    ldx  CrvRowHi     ; Curve row high boundry value -> X                        (CRV_INTERP)
006FE4 7F6FE4 34                          pshx              ; Save to stack                                            (CRV_INTERP)
006FE5 7F6FE5 FE 10 31                    ldx  CrvRowLo     ; Curve row low boundry value -> X                         (CRV_INTERP)
006FE8 7F6FE8 34                          pshx              ; Save to stack                                            (CRV_INTERP)
006FE9 7F6FE9 FE 10 33                    ldx  CrvColHi     ; Curve column high boundry value -> X                     (CRV_INTERP)
006FEC 7F6FEC 34                          pshx              ; Save to stack                                            (CRV_INTERP)
006FED 7F6FED FE 10 35                    ldx  CrvColLo     ; Curve column low boundry value -> X                      (CRV_INTERP)
006FF0 7F6FF0 34                          pshx              ; Save to stack                                            (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                          ;    | col lo boundary |  SP+ 0 ($3FF4)(Z1)                                  (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                          ;    | col hi boundary |  SP+ 2 ($3FF6)(Z2)                                  (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                          ;    | row lo boundary |  SP+ 4 ($3FF8)(V1)                                  (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                          ;    | row hi boundary |  SP+ 6 ($3FFA)(V2)                                  (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                          ;    |    CrvCmpVal    |  SP+ 8 ($3FFC)(V)                                   (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ; - Determine Z                                                                  (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ;                     V       V1      V2      Z1     Z2                          (CRV_INTERP)
006FF1 7F6FF1 MACRO                                   2D_IPOL (8,SP), (4,SP), (6,SP), (0,SP), (2,SP)                   (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CRV_INTERP/2D_IPOL)
                                      ; ==========================                                                     (CRV_INTERP/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CRV_INTERP/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CRV_INTERP/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CRV_INTERP/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CRV_INTERP/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CRV_INTERP/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CRV_INTERP/2D_IPOL)
                                      ; SSTACK: none                                                                   (CRV_INTERP/2D_IPOL)
                                      ;         no registers are preserved                                             (CRV_INTERP/2D_IPOL)
                                      ;                                                                                (CRV_INTERP/2D_IPOL)
                                      ;    ^ V                                                                         (CRV_INTERP/2D_IPOL)
                                      ;    |                                                                           (CRV_INTERP/2D_IPOL)
                                      ;  Z2+....................*                                                      (CRV_INTERP/2D_IPOL)
                                      ;    |                    :                                                      (CRV_INTERP/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CRV_INTERP/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CRV_INTERP/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CRV_INTERP/2D_IPOL)
                                      ;    |   :       :        :                                                      (CRV_INTERP/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CRV_INTERP/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CRV_INTERP/2D_IPOL)
                                      ;                                                                                (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
006FF1 7F6FF1 EC 88                                   LDD       \1    ; load V                                         (CRV_INTERP/2D_IPOL)
006FF3 7F6FF3 A3 84                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CRV_INTERP/2D_IPOL)
006FF5 7F6FF5 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
006FF7 7F6FF7 EC 82                                   LDD       \5    ; load Z2                                        (CRV_INTERP/2D_IPOL)
006FF9 7F6FF9 A3 80                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
006FFB 7F6FFB 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CRV_INTERP/2D_IPOL)
006FFD 7F6FFD B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
006FFF 7F6FFF EC 86                                   LDD       \3    ; load V2                                        (CRV_INTERP/2D_IPOL)
007001 7F7001 A3 84                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CRV_INTERP/2D_IPOL)
007003 7F7003 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CRV_INTERP/2D_IPOL)
                                      ;*********************************************************************           (CRV_INTERP/2D_IPOL)
007005 7F7005 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CRV_INTERP/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CRV_INTERP/2D_IPOL)
007007 7F7007 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
007009 7F7009 E3 80                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ; - Free stack space (result in D)                                               (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
00700B 7F700B 1B 88                       leas 8,SP   ; Stack pointer -> bottom of stack                               (CRV_INTERP)
00700D 7F700D 30                          pulx        ; Pull index register X from stack                               (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ; - Done (result in D)                                                           (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
00700E 7F700E 3D                         rts   ; Return from subroutine                                                (CRV_INTERP)
                                      ;*****************************************************************************************
00700F 7F700F -> $700F                CRV_LU_NP:   EQU        *
                                      ;*****************************************************************************************
                                      ; - This subroutine calculates the interpolated value of a 2D curve with an X axis that
                                      ;   starts with negative values and ends with positive values. The X axis MUST have
                                      ;   -0.2 (65534) and +0.2 (2) together some place in the row for the code to work.
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - First, determine the position in the row of the comparison value for
                                      ;   interpolation (IndexNum). Position in the column will be the same as the position
                                      ;   in the row. Determine the row high and low boundary values.
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Set up the process to find the interpolated curve value by determining the values
                                      ;   of the first bins in the row and column. Clear the index number variable.
                                      ;*****************************************************************************************
00700F 7F700F MACRO                       CRV_SETUP       ; Macro this module
                                      ;***************************************************************************************** (CRV_SETUP)
                                      ; - Set up the process to find the interpolated curve value by determining the values (CRV_SETUP)
                                      ;   of the first bins in the row and column. Clear the index number variable.    (CRV_SETUP)
                                      ;***************************************************************************************** (CRV_SETUP)
00700F 7F700F FD 10 25                    ldy  CrvPgPtr     ; Pointer to the page where the desired curve resides -> Y (CRV_SETUP)
007012 7F7012 FC 10 27                    ldd  CrvRowOfst   ; Offset from the curve page to the curve row -> D         (CRV_SETUP)
007015 7F7015 19 EE                       leay D,Y          ; Curve row pointer -> Y                                   (CRV_SETUP)
007017 7F7017 18 05 EE 10 31              movw D,Y,CrvRowLo ; Copy to curve row low boundry value for interpolation    (CRV_SETUP)
00701C 7F701C 18 05 EE 10 2F              movw D,Y,CrvRowHi ; Copy to curve row high boundry value for interpolation   (CRV_SETUP)
                                                            ; (start with low and high row bin values equal            (CRV_SETUP)
007021 7F7021 FD 10 25                    ldy  CrvPgPtr     ; Pointer to the page where the desired curve resides -> Y (CRV_SETUP)
007024 7F7024 FC 10 29                    ldd  CrvColOfst   ; Offset from the curve page to the curve column -> D      (CRV_SETUP)
007027 7F7027 19 EE                       leay D,Y          ; Curve column pointer -> Y                                (CRV_SETUP)
007029 7F7029 18 05 EE 10 35              movw D,Y,CrvColLo ; Copy to curve row column boundry value for interpolation (CRV_SETUP)
00702E 7F702E 18 05 EE 10 33              movw D,Y,CrvColHi ; Copy to curve column high boundry value for interpolation (CRV_SETUP)
                                                            ; (start with low and high column bin values equal         (CRV_SETUP)
007033 7F7033 79 10 2E                    clr   IndexNum    ; Position in the row or column of the curve comparison value (CRV_SETUP)
                                      ;*****************************************************************************************
                                      ; - CrvRowLo is negative. Now check CrvCmpVal for negative number.
                                      ;*****************************************************************************************
007036 7F7036 FE 10 2B                    ldx  CrvCmpVal    ; Curve comparison value -> X
007039 7F7039 18 84 80 00                 andx #$8000       ; Logical AND X with %1000 0000 0000 0000 (CCR N bit set of MSB of
                                                            ; result is set)
00703D 7F703D 2B 03                       bmi  CmpValNeg    ; If N bit of CCR is set, branch to CmpValNeg:
                                                            ;(CrvCmpVal is negative)
00703F 7F703F 06 70 E3                    job  CmpValPos    ; Jump or branch to CmpValPos: (CrvCmpVal is positive)
007042 7F7042                         CmpValNeg:
                                      ;*****************************************************************************************
                                      ; - Both CrvRowLo and CrvCmpVal are negative. Now see if CrvCmpVal is the same or less than
                                      ;   than CrvRowLo. If it is, rail low at the value of the first column bin. If it is not,
                                      ;   it must be greater than CrvRowLo, so loop back to do the next iteration.
                                      ;*****************************************************************************************
007042 7F7042 FE 10 2B                    ldx  CrvCmpVal    ; Curve compare value -> X
007045 7F7045 BE 10 31                    cpx  CrvRowLo     ; Compare curve compare value with curve low boundary
007048 7F7048 23 02                       bls  RailLowNeg   ; If CrvCmpVal is the same or less than CrvRowLo branch to RailLowNeg:
00704A 7F704A 20 04                       bra  ReEntCrvNeg1 ; Branch to ReEntCrvNeg1:
00704C 7F704C                         RailLowNeg:
00704C 7F704C FC 10 35                    ldd  CrvColLo    ; Curve column low boundary value -> D
00704F 7F704F 3D                          rts              ; Return from subroutine(Rail low with CrvColLo in Accur D,
                                                           ; no interpolation required)
                                      ;*****************************************************************************************
                                      ; - Both CrvRowLo and CrvCmpVal are negative. CrvCmpVal is the greater than CrvRowLo.
                                      ;   Determine the value of CrvRowHi
                                      ;*****************************************************************************************
007050 7F7050                         ReEntCrvNeg1:
007050 7F7050 72 10 2E                    inc  IndexNum     ; Increment position in the row or column of the curve comparison
                                                            ; value
007053 7F7053 18 04 10 2F 10 31           movw CrvRowHi,CrvRowLo ; Curve row high boundry value -> curve row low boundry value
007059 7F7059 18 72 10 27                 incw CrvRowOfst   ; Increment Offset from the curve page to the curve row
00705D 7F705D FD 10 25                    ldy  CrvPgPtr     ; Pointer to the page where the desired curve resides -> Y
007060 7F7060 FC 10 27                    ldd  CrvRowOfst   ; Incremented offset from the curve page to the curve row -> D
007063 7F7063 19 EE                       leay D,Y          ; Curve row pointer -> Y
007065 7F7065 18 05 EE 10 2F              movw D,Y,CrvRowHi ; Copy to curve row high boundry value for interpolation
                                                            ; (holds the contents of the incremented row bin)
00706A 7F706A                         RowHiNeg1:
                                      ;*****************************************************************************************
                                      ; - CrvRowLo, CrvRowHi and CrvCmpVal are all negative. CrvCmpVal is the greater than
                                      ;   CrvRowLo. Now see if CrvRowHi is greater than CrvCmpVal. If it is, we have the index
                                      ;   number, if it is not, loop back to increment to the next bin and check again.
                                      ;*****************************************************************************************
00706A 7F706A EE EE                       ldx  D,Y          ; Contents of incremented row bin -> X
00706C 7F706C BE 10 2B                    cpx  CrvCmpVal    ; Compare Contents of incremented row bin with curve comparison value
00706F 7F706F 24 08                       bhs  RowHiNeg2    ; If contents of incremented row bin is greater than or equal to
                                                            ; curve compareson value then branch to RowHiNeg2:
007071 7F7071 B6 10 2E                    ldaa IndexNum     ; Incremented position in the row or column of the curve comparison
                                                            ; value for interpolation -> A
007074 7F7074 B1 10 2D                    cmpa CrvBinCnt    ; Compare Incremented position in the row or column of the curve
                                                            ; comparison value for interpolation with number of bins in the curve
                                                            ; row or column minus 1
007077 7F7077 26 D7                       bne  ReEntCrvNeg1 ; If (A)-(M) if IndexNum does not = CrvBinCnt then branch to
                                                            ; ReEntCrvNeg1:
007079 7F7079                         RowHiNeg2:
                                      ;*****************************************************************************************
                                      ; - Using the index number determine the column high and low boundary values
                                      ;*****************************************************************************************
007079 7F7079 MACRO                      COL_BOUNDARYS     ; Macro this module
                                                            ; for interpolation (start with zero)                      (COL_BOUNDARYS)
                                      ;***************************************************************************************** (COL_BOUNDARYS)
                                      ; - Using the index number determine the column high and low boundary values     (COL_BOUNDARYS)
                                      ;***************************************************************************************** (COL_BOUNDARYS)
007079 7F7079 FE 10 29                    ldx  CrvColOfst   ; Offset from the curve page to the curve column -> D      (COL_BOUNDARYS)
00707C 7F707C F6 10 2E                    ldab IndexNum     ; IndexNum -> B                                            (COL_BOUNDARYS)
00707F 7F707F 1A E5                       abx               ;(B)+(X)->X Pointer to indexed column bin                  (COL_BOUNDARYS)
007081 7F7081 7E 10 29                    stx  CrvColOfst   ; Result to CrvColOfst (now points to indexed column bin)  (COL_BOUNDARYS)
007084 7F7084 FD 10 25                    ldy  CrvPgPtr     ; Pointer to the page where the desired curve resides -> Y (COL_BOUNDARYS)
007087 7F7087 FC 10 29                    ldd  CrvColOfst   ; Offset from the curve page to the curve column -> D      (COL_BOUNDARYS)
00708A 7F708A 19 EE                       leay D,Y          ; Curve column pointer -> Y                                (COL_BOUNDARYS)
00708C 7F708C 18 05 EE 10 33              movw D,Y,CrvColHi ; Copy to curve column high boundry value for interpolation (COL_BOUNDARYS)
007091 7F7091 18 73 10 29                 decw CrvColOfst   ; Decrement offset from the curve page to the curve column (COL_BOUNDARYS)
007095 7F7095 FD 10 25                    ldy  CrvPgPtr     ; Pointer to the page where the desired curve resides -> Y (COL_BOUNDARYS)
007098 7F7098 FC 10 29                    ldd  CrvColOfst   ; Offset from the curve page to the curve column -> D      (COL_BOUNDARYS)
00709B 7F709B 19 EE                       leay D,Y          ; Curve column pointer -> Y                                (COL_BOUNDARYS)
00709D 7F709D 18 05 EE 10 35              movw D,Y,CrvColLo ; Copy to curve column low boundry value for interpolation (COL_BOUNDARYS)
0070A2 7F70A2 FC 10 35                    ldd  CrvColLo     ; CrvColLo -> D                                            (COL_BOUNDARYS)
                                      ;*****************************************************************************************
                                      ; - Do the interpolation or rail high and exit subroutine
                                      ;*****************************************************************************************
0070A5 7F70A5 MACRO                      CRV_INTERP       ; Macro this module
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ; - Do the interpolation or rail high and exit subroutine                        (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
0070A5 7F70A5 FE 10 2B                    ldx  CrvCmpVal    ; Curve row comparison value -> X                          (CRV_INTERP)
0070A8 7F70A8 BE 10 2F                    cpx  CrvRowHi     ; Compare row comparison value with curve row high boundry value (CRV_INTERP)
0070AB 7F70AB 25 04                       blo  DoInterp     ; If Curve row comparison value is < curve row high boundry value (CRV_INTERP)
                                                            ; branch to DoInterp:                                      (CRV_INTERP)
0070AD 7F70AD FC 10 33                    ldd  CrvColHi     ; Curve column high boundry value -> D (result railed high) (CRV_INTERP)
0070B0 7F70B0 3D                          rts               ; Return from subroutine (CrvCmpVal is equal to or higher than (CRV_INTERP)
                                                            ; CrvRowHi so no need to interpolate. Rail high with CrvColHi in D (CRV_INTERP)
0070B1 7F70B1                         DoInterp:                                                                        (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ; - Save interpolation values to stack                                           (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
0070B1 7F70B1 FE 10 2B                    ldx  CrvCmpVal    ; Curve row comparison value -> X                          (CRV_INTERP)
0070B4 7F70B4 34                          pshx              ; Save to stack                                            (CRV_INTERP)
0070B5 7F70B5 FE 10 2F                    ldx  CrvRowHi     ; Curve row high boundry value -> X                        (CRV_INTERP)
0070B8 7F70B8 34                          pshx              ; Save to stack                                            (CRV_INTERP)
0070B9 7F70B9 FE 10 31                    ldx  CrvRowLo     ; Curve row low boundry value -> X                         (CRV_INTERP)
0070BC 7F70BC 34                          pshx              ; Save to stack                                            (CRV_INTERP)
0070BD 7F70BD FE 10 33                    ldx  CrvColHi     ; Curve column high boundry value -> X                     (CRV_INTERP)
0070C0 7F70C0 34                          pshx              ; Save to stack                                            (CRV_INTERP)
0070C1 7F70C1 FE 10 35                    ldx  CrvColLo     ; Curve column low boundry value -> X                      (CRV_INTERP)
0070C4 7F70C4 34                          pshx              ; Save to stack                                            (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                          ;    | col lo boundary |  SP+ 0 ($3FF4)(Z1)                                  (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                          ;    | col hi boundary |  SP+ 2 ($3FF6)(Z2)                                  (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                          ;    | row lo boundary |  SP+ 4 ($3FF8)(V1)                                  (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                          ;    | row hi boundary |  SP+ 6 ($3FFA)(V2)                                  (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                          ;    |    CrvCmpVal    |  SP+ 8 ($3FFC)(V)                                   (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ; - Determine Z                                                                  (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ;                     V       V1      V2      Z1     Z2                          (CRV_INTERP)
0070C5 7F70C5 MACRO                                   2D_IPOL (8,SP), (4,SP), (6,SP), (0,SP), (2,SP)                   (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CRV_INTERP/2D_IPOL)
                                      ; ==========================                                                     (CRV_INTERP/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CRV_INTERP/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CRV_INTERP/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CRV_INTERP/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CRV_INTERP/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CRV_INTERP/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CRV_INTERP/2D_IPOL)
                                      ; SSTACK: none                                                                   (CRV_INTERP/2D_IPOL)
                                      ;         no registers are preserved                                             (CRV_INTERP/2D_IPOL)
                                      ;                                                                                (CRV_INTERP/2D_IPOL)
                                      ;    ^ V                                                                         (CRV_INTERP/2D_IPOL)
                                      ;    |                                                                           (CRV_INTERP/2D_IPOL)
                                      ;  Z2+....................*                                                      (CRV_INTERP/2D_IPOL)
                                      ;    |                    :                                                      (CRV_INTERP/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CRV_INTERP/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CRV_INTERP/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CRV_INTERP/2D_IPOL)
                                      ;    |   :       :        :                                                      (CRV_INTERP/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CRV_INTERP/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CRV_INTERP/2D_IPOL)
                                      ;                                                                                (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
0070C5 7F70C5 EC 88                                   LDD       \1    ; load V                                         (CRV_INTERP/2D_IPOL)
0070C7 7F70C7 A3 84                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CRV_INTERP/2D_IPOL)
0070C9 7F70C9 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
0070CB 7F70CB EC 82                                   LDD       \5    ; load Z2                                        (CRV_INTERP/2D_IPOL)
0070CD 7F70CD A3 80                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
0070CF 7F70CF 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CRV_INTERP/2D_IPOL)
0070D1 7F70D1 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
0070D3 7F70D3 EC 86                                   LDD       \3    ; load V2                                        (CRV_INTERP/2D_IPOL)
0070D5 7F70D5 A3 84                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CRV_INTERP/2D_IPOL)
0070D7 7F70D7 B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CRV_INTERP/2D_IPOL)
                                      ;*********************************************************************           (CRV_INTERP/2D_IPOL)
0070D9 7F70D9 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CRV_INTERP/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CRV_INTERP/2D_IPOL)
0070DB 7F70DB B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
0070DD 7F70DD E3 80                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ; - Free stack space (result in D)                                               (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
0070DF 7F70DF 1B 88                       leas 8,SP   ; Stack pointer -> bottom of stack                               (CRV_INTERP)
0070E1 7F70E1 30                          pulx        ; Pull index register X from stack                               (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ; - Done (result in D)                                                           (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
0070E2 7F70E2 3D                         rts   ; Return from subroutine                                                (CRV_INTERP)
                                      ;**************************************************************************************
0070E3 7F70E3                         CmpValPos:
                                      ;*****************************************************************************************
                                      ; - CrvCmpVal is positive. Starting at the beginning of the row, loop through until the
                                      ;   first positive value is found.
                                      ;*****************************************************************************************
0070E3 7F70E3                         PosFind:
0070E3 7F70E3 72 10 2E                    inc  IndexNum     ; Increment position in the row or column of the curve comparison
                                                            ; value
0070E6 7F70E6 18 04 10 2F 10 31           movw CrvRowHi,CrvRowLo ; Curve row high boundry value -> curve row low boundry value
0070EC 7F70EC 18 72 10 27                 incw CrvRowOfst   ; Increment Offset from the curve page to the curve row
0070F0 7F70F0 FD 10 25                    ldy  CrvPgPtr     ; Pointer to the page where the desired curve resides -> Y
0070F3 7F70F3 FC 10 27                    ldd  CrvRowOfst   ; Incremented offset from the curve page to the curve row -> D
0070F6 7F70F6 19 EE                       leay D,Y          ; Curve row pointer -> Y
0070F8 7F70F8 18 05 EE 10 2F              movw D,Y,CrvRowHi ; Copy to curve row high boundry value for interpolation
                                                            ; (holds the contents of the incremented row bin)
0070FD 7F70FD FE 10 2F                    ldx  CrvRowHi     ; Curve row high boundry value -> X
007100 7F7100 18 84 80 00                 andx #$8000       ; Logical AND X with %1000 0000 0000 0000 (CCR N bit set of MSB of
                                                            ; result is set)
007104 7F7104 2B DD                       bmi  PosFind      ; If N bit of CCR is set, branch to PosFind: (CrvRowHi is negative
                                                            ; so loop back until the first positive value is found)
                                      ;*****************************************************************************************
                                      ; - CrvCmpVal is positive. We have found the first positive row value so all other row
                                      ;   values will be positive.
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Both CrvRowLo and CrvCmpVal are positive. CrvCmpVal is the greater than CrvRowLo.
                                      ;   Determine the value of CrvRowHi
                                      ;*****************************************************************************************
007106 7F7106                         ReEntCrvPos1:
007106 7F7106 72 10 2E                    inc  IndexNum     ; Increment position in the row or column of the curve comparison
                                                            ; value
007109 7F7109 18 04 10 2F 10 31           movw CrvRowHi,CrvRowLo ; Curve row high boundry value -> curve row low boundry value
00710F 7F710F 18 72 10 27                 incw CrvRowOfst   ; Increment Offset from the curve page to the curve row
007113 7F7113 FD 10 25                    ldy  CrvPgPtr     ; Pointer to the page where the desired curve resides -> Y
007116 7F7116 FC 10 27                    ldd  CrvRowOfst   ; Incremented offset from the curve page to the curve row -> D
007119 7F7119 19 EE                       leay D,Y          ; Curve row pointer -> Y
00711B 7F711B 18 05 EE 10 2F              movw D,Y,CrvRowHi ; Copy to curve row high boundry value for interpolation
                                                            ; (holds the contents of the incremented row bin)
                                      ;*****************************************************************************************
                                      ; - CrvRowLo, CrvCmpVal and CrvRowHi are all positive. CrvCmpVal is the greater than CrvRowLo.
                                      ;   Now see if CrvRowHi is greater than CrvCmpVal. If it is, we have the index number,
                                      ;   if it is not, loop back to increment to the next bin and check again.
                                      ;*****************************************************************************************
007120 7F7120 FE 10 2F                    ldx  CrvRowHi     ; Curve row high boundary -> X
007123 7F7123 BE 10 2B                    cpx  CrvCmpVal    ; Compare curve curve row high boundary with curve compare value
007126 7F7126 24 08                       bhs  GotNumPos1    ; If contents of incremented row bin is greater than or equal to
                                                            ; curve compareson value then branch to GotNumPos:
007128 7F7128 B6 10 2E                    ldaa IndexNum     ; Incremented position in the row or column of the curve comparison
                                                            ; value for interpolation -> A
00712B 7F712B B1 10 2D                    cmpa CrvBinCnt    ; Compare Incremented position in the row or column of the curve
                                                            ; comparison value for interpolation with number of bins in the curve
                                                            ; row or column minus 1
00712E 7F712E 26 D6                       bne  ReEntCrvPos1  ; If (A)-(M) if IndexNum does not = CrvBinCnt then branch to
                                                            ; ReEntCrvPos1:
007130 7F7130                         GotNumPos1:
                                      ;*****************************************************************************************
                                      ; - CrvRowLo, CrvCmpVal and CrvRowHi are all positive. CrvCmpVal is the greater than
                                      ;   CrvRowLo. CrvRowHi is greater than or equal to CrvCmpVal so we must have our index
                                      ;   number.
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Using the index number determine the column high and low boundary values
                                      ;*****************************************************************************************
007130 7F7130 MACRO                      COL_BOUNDARYS     ; Macro this module
                                                            ; for interpolation (start with zero)                      (COL_BOUNDARYS)
                                      ;***************************************************************************************** (COL_BOUNDARYS)
                                      ; - Using the index number determine the column high and low boundary values     (COL_BOUNDARYS)
                                      ;***************************************************************************************** (COL_BOUNDARYS)
007130 7F7130 FE 10 29                    ldx  CrvColOfst   ; Offset from the curve page to the curve column -> D      (COL_BOUNDARYS)
007133 7F7133 F6 10 2E                    ldab IndexNum     ; IndexNum -> B                                            (COL_BOUNDARYS)
007136 7F7136 1A E5                       abx               ;(B)+(X)->X Pointer to indexed column bin                  (COL_BOUNDARYS)
007138 7F7138 7E 10 29                    stx  CrvColOfst   ; Result to CrvColOfst (now points to indexed column bin)  (COL_BOUNDARYS)
00713B 7F713B FD 10 25                    ldy  CrvPgPtr     ; Pointer to the page where the desired curve resides -> Y (COL_BOUNDARYS)
00713E 7F713E FC 10 29                    ldd  CrvColOfst   ; Offset from the curve page to the curve column -> D      (COL_BOUNDARYS)
007141 7F7141 19 EE                       leay D,Y          ; Curve column pointer -> Y                                (COL_BOUNDARYS)
007143 7F7143 18 05 EE 10 33              movw D,Y,CrvColHi ; Copy to curve column high boundry value for interpolation (COL_BOUNDARYS)
007148 7F7148 18 73 10 29                 decw CrvColOfst   ; Decrement offset from the curve page to the curve column (COL_BOUNDARYS)
00714C 7F714C FD 10 25                    ldy  CrvPgPtr     ; Pointer to the page where the desired curve resides -> Y (COL_BOUNDARYS)
00714F 7F714F FC 10 29                    ldd  CrvColOfst   ; Offset from the curve page to the curve column -> D      (COL_BOUNDARYS)
007152 7F7152 19 EE                       leay D,Y          ; Curve column pointer -> Y                                (COL_BOUNDARYS)
007154 7F7154 18 05 EE 10 35              movw D,Y,CrvColLo ; Copy to curve column low boundry value for interpolation (COL_BOUNDARYS)
007159 7F7159 FC 10 35                    ldd  CrvColLo     ; CrvColLo -> D                                            (COL_BOUNDARYS)
                                      ;*****************************************************************************************
                                      ; - Do the interpolation or rail high and exit subroutine
                                      ;*****************************************************************************************
00715C 7F715C MACRO                      CRV_INTERP       ; Macro this module
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ; - Do the interpolation or rail high and exit subroutine                        (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
00715C 7F715C FE 10 2B                    ldx  CrvCmpVal    ; Curve row comparison value -> X                          (CRV_INTERP)
00715F 7F715F BE 10 2F                    cpx  CrvRowHi     ; Compare row comparison value with curve row high boundry value (CRV_INTERP)
007162 7F7162 25 04                       blo  DoInterp     ; If Curve row comparison value is < curve row high boundry value (CRV_INTERP)
                                                            ; branch to DoInterp:                                      (CRV_INTERP)
007164 7F7164 FC 10 33                    ldd  CrvColHi     ; Curve column high boundry value -> D (result railed high) (CRV_INTERP)
007167 7F7167 3D                          rts               ; Return from subroutine (CrvCmpVal is equal to or higher than (CRV_INTERP)
                                                            ; CrvRowHi so no need to interpolate. Rail high with CrvColHi in D (CRV_INTERP)
007168 7F7168                         DoInterp:                                                                        (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ; - Save interpolation values to stack                                           (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
007168 7F7168 FE 10 2B                    ldx  CrvCmpVal    ; Curve row comparison value -> X                          (CRV_INTERP)
00716B 7F716B 34                          pshx              ; Save to stack                                            (CRV_INTERP)
00716C 7F716C FE 10 2F                    ldx  CrvRowHi     ; Curve row high boundry value -> X                        (CRV_INTERP)
00716F 7F716F 34                          pshx              ; Save to stack                                            (CRV_INTERP)
007170 7F7170 FE 10 31                    ldx  CrvRowLo     ; Curve row low boundry value -> X                         (CRV_INTERP)
007173 7F7173 34                          pshx              ; Save to stack                                            (CRV_INTERP)
007174 7F7174 FE 10 33                    ldx  CrvColHi     ; Curve column high boundry value -> X                     (CRV_INTERP)
007177 7F7177 34                          pshx              ; Save to stack                                            (CRV_INTERP)
007178 7F7178 FE 10 35                    ldx  CrvColLo     ; Curve column low boundry value -> X                      (CRV_INTERP)
00717B 7F717B 34                          pshx              ; Save to stack                                            (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                          ;    | col lo boundary |  SP+ 0 ($3FF4)(Z1)                                  (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                          ;    | col hi boundary |  SP+ 2 ($3FF6)(Z2)                                  (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                          ;    | row lo boundary |  SP+ 4 ($3FF8)(V1)                                  (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                          ;    | row hi boundary |  SP+ 6 ($3FFA)(V2)                                  (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                          ;    |    CrvCmpVal    |  SP+ 8 ($3FFC)(V)                                   (CRV_INTERP)
                                          ;    +--------+--------+                                                     (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ; - Determine Z                                                                  (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ;                     V       V1      V2      Z1     Z2                          (CRV_INTERP)
00717C 7F717C MACRO                                   2D_IPOL (8,SP), (4,SP), (6,SP), (0,SP), (2,SP)                   (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ;#Perform a 2D interpolation                                                     (CRV_INTERP/2D_IPOL)
                                      ; ==========================                                                     (CRV_INTERP/2D_IPOL)
                                      ; args:   1: V  pointer (effective address)                                      (CRV_INTERP/2D_IPOL)
                                      ;         2: V1 pointer (effective address)                                      (CRV_INTERP/2D_IPOL)
                                      ;         3: V2 pointer (effective address)                                      (CRV_INTERP/2D_IPOL)
                                      ;         4: Z1 pointer (effective address)                                      (CRV_INTERP/2D_IPOL)
                                      ;         5: Z2 pointer (effective address)                                      (CRV_INTERP/2D_IPOL)
                                      ; result: D: interpolated result                                                 (CRV_INTERP/2D_IPOL)
                                      ; SSTACK: none                                                                   (CRV_INTERP/2D_IPOL)
                                      ;         no registers are preserved                                             (CRV_INTERP/2D_IPOL)
                                      ;                                                                                (CRV_INTERP/2D_IPOL)
                                      ;    ^ V                                                                         (CRV_INTERP/2D_IPOL)
                                      ;    |                                                                           (CRV_INTERP/2D_IPOL)
                                      ;  Z2+....................*                                                      (CRV_INTERP/2D_IPOL)
                                      ;    |                    :                                                      (CRV_INTERP/2D_IPOL)
                                      ;   Z+...........*        :                 (V-V1)*(Z2-Z1)                       (CRV_INTERP/2D_IPOL)
                                      ;    |           :        :        Z = Z1 + --------------                       (CRV_INTERP/2D_IPOL)
                                      ;  Z1+...*       :        :                    (V2-V1)                           (CRV_INTERP/2D_IPOL)
                                      ;    |   :       :        :                                                      (CRV_INTERP/2D_IPOL)
                                      ;   -+---+-------+--------+---> K                                                (CRV_INTERP/2D_IPOL)
                                      ;    |   V1      V        V2                                                     (CRV_INTERP/2D_IPOL)
                                      ;                                                                                (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ; - Calculate (V-V1)                                                             (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
00717C 7F717C EC 88                                   LDD       \1    ; load V                                         (CRV_INTERP/2D_IPOL)
00717E 7F717E A3 84                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CRV_INTERP/2D_IPOL)
007180 7F7180 B7 46                                   TFR       D,Y   ; (V-V1) -> index Y                              (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ; - Calculate (Z2-Z1)                                                            (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
007182 7F7182 EC 82                                   LDD       \5    ; load Z2                                        (CRV_INTERP/2D_IPOL)
007184 7F7184 A3 80                                   SUBD  \4    ; (A:B)-(M:M+1)->A:B Subtract Z1                     (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ; - Calculate (V-V1)*(Z2-Z1)                                                     (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
007186 7F7186 18 13                                   EMULS      ; (D)x(Y)->Y:D Multiply intermediate results -> Y:D   (CRV_INTERP/2D_IPOL)
007188 7F7188 B7 45                                   TFR       D,X  ; (V-V1)*(Z2-Z1) -> Y:X                           (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ; - Calculate (V2-V1)                                                            (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
00718A 7F718A EC 86                                   LDD       \3    ; load V2                                        (CRV_INTERP/2D_IPOL)
00718C 7F718C A3 84                                   SUBD  \2    ; (A:B)-(M:M+1)->A:B Subtract V1                     (CRV_INTERP/2D_IPOL)
00718E 7F718E B7 C5                                   EXG       D,X   ; (V2-V1) -> index X, (V-V1)*(Z2-Z1) -> Y:D      (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ;* - Calculate ((V-V1)*(Z2-Z1))/(V2-V1)                                          (CRV_INTERP/2D_IPOL)
                                      ;*********************************************************************           (CRV_INTERP/2D_IPOL)
007190 7F7190 18 14                                   EDIVS       ; (Y:D)/(X)->Y;Remainder->D                          (CRV_INTERP/2D_IPOL)
                                                          ; divide intermediate results -> index Y                     (CRV_INTERP/2D_IPOL)
007192 7F7192 B7 64                                   TFR       Y,D   ; (V-V1)*(Z2-Z1)/(V2-V1) -> D                    (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
                                      ; - Calculate Z1+(((Z1 +((V-V1))*(Z2-Z1))/(V2-V1))                               (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP/2D_IPOL)
007194 7F7194 E3 80                                   ADDD  \4        ; (A:B)+(M:M+1)->A:B Add Z1                      (CRV_INTERP/2D_IPOL)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ; - Free stack space (result in D)                                               (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
007196 7F7196 1B 88                       leas 8,SP   ; Stack pointer -> bottom of stack                               (CRV_INTERP)
007198 7F7198 30                          pulx        ; Pull index register X from stack                               (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
                                      ; - Done (result in D)                                                           (CRV_INTERP)
                                      ;***************************************************************************************** (CRV_INTERP)
007199 7F7199 3D                         rts   ; Return from subroutine                                                (CRV_INTERP)
                                      ;*****************************************************************************************
00719A 7F719A -> $719A                INTERP_CODE_END         EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
00719A 7F719A -> $7F719A              INTERP_CODE_END_LIN     EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ;* - Tables -                                                                            *
                                      ;*****************************************************************************************
007C9F 7F7C9F                                                 ORG     INTERP_TABS_START, INTERP_TABS_START_LIN
007C9F 7F7C9F -> $7F7C9F              INTERP_TABS_START_LIN   EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ; ------------------------------- No tables for this module ------------------------------
007C9F 7F7C9F -> $7C9F                INTERP_TABS_END         EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
007C9F 7F7C9F -> $7F7C9F              INTERP_TABS_END_LIN     EQU     @     ; @ Represents the current value of the linear
                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (igncalcs_BPEM488.s)                                                       *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BPEM488 Engine Controller for the Dodge 488CID (8.0L) V10 engine  *
                                      ;*    by Robert Hiebert.                                                                 *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teaching    *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*    This module contains code for for the ignition timing calculations                 *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project                          *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map                                       *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project               *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map                                         *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features                     *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler              *
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications                  *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)                                     *
                                      ;*   gpio_BPEM488.s       - Initialization all ports                                     *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros                         *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing (This module)                *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths                       *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors                   *
                                      ;*****************************************************************************************
                                      ;* Version History:                                                                      *
                                      ;*    May 13, 2020                                                                       *
                                      ;*    - BPEM488 dedicated hardware version begins (work in progress)                     *
                                      ;*    - Update December 10 2020                                                          *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
007C9F 7F7C9F S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ;*****************************************************************************************
                                      ;* - Variables -                                                                         *
                                      ;*****************************************************************************************
001037 0FD037                                     ORG     IGNCALCS_VARS_START, IGNCALCS_VARS_START_LIN
001037 0FD037 -> $FD037               IGNCALCS_VARS_START_LIN EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ; - RS232 variables variables used in this module (declared  in BPEM488.s)
                                      ;*****************************************************************************************
                                      ;Mapx10:         ds 2 ; Manifold Absolute Pressure (KPAx10)
                                      ;Itrmx10:        ds 2 ; Ignition Trim (degrees x 10)+-20 degrees)
                                      ;RPM:            ds 2 ; Crankshaft Revolutions Per Minute
                                      ;STcurr:         ds 2 ; Current value in ST table (Degrees x 10)
                                      ;DwellCor:       ds 2 ; Coil dwell voltage correction (%*10)
                                      ;DwellFin:       ds 2 ; ("Dwell" * "DwellCor") (mS*10)
                                      ;STandItrmx10:   ds 2 ; STcurr and Itmx10 (degrees*10)
                                      ;*****************************************************************************************
                                      ; - Non RS232 variables used in this module (declared in state_BPEM488.s
                                      ;*****************************************************************************************
                                      ;Degx10tk512:    ds 2 ;(Time for 1 degree of rotation in 5.12uS resolution x 10)
                                      ;Degx10tk256:    ds 2 ; (Time for 1 degree of rotation in 2.56uS resolution x 10)
                                      ;*****************************************************************************************
                                      ; - Non RS232 variables used in this module declared in this module
                                      ;*****************************************************************************************
001037 0FD037                         Spantk:         ds 2 ; Ignition Span time (5.12uS or 2.56uS res)
001039 0FD039                         DwellFintk:     ds 2 ; Time required for dwell after correction (5.12uS or 2.56uS res)
00103B 0FD03B                         STandItrmtk:    ds 2 ; STcurr and Itmx10 (5.12uS or 2.56uS res)
00103D 0FD03D                         Advancetk:      ds 2 ; Delay time for desired spark advance + dwell(5.12uS or 2.56uS res)
00103F 0FD03F                         Delaytk:        ds 2 ; Delay time from crank signal to energise coil(5.12uS or 2.56uS res)
001041 0FD041                         IgnOCadd1:      ds 2 ; First ignition output compare adder (5.12uS or 2.56uS res)
001043 0FD043                         IgnOCadd2:      ds 2 ; Second ignition output compare adder(5.12uS or 2.56uS res)
                                      ;******************************************************************************************
                                      ;*****************************************************************************************
                                      ; - These configurable constants are located in BPEM488.s in page 2 starting with the
                                      ;   ST table
                                      ;*****************************************************************************************
                                      ;Dwell_F       ; 1 byte for run mode dwell time (mSec*10)(offset = 748)($02EC)
                                      ;   db $28     ; 40 = 4.0mSec
                                      ;CrnkDwell_F   ; 1 byte for crank mode dwell time (mSec*10)(offset = 749)($02ED)
                                      ;   db $3C     ; 60 = 6.0 mSec
                                      ;CrnkAdv_F     ; 1 byte for crank mode ignition advance (Deg*10)(offset = 750)($02EE)
                                      ;   db $64     ; 100 = 10.0 degrees
                                      ;*****************************************************************************************
001045 0FD045 -> $1045                IGNCALCS_VARS_END               EQU     * ; * Represents the current value of the paged
                                                                    ; program counter
001045 0FD045 -> $FD045               IGNCALCS_VARS_END_LIN   EQU     @ ; @ Represents the current value of the linear
                                                           ; This is the first OC value loaded into the timer
                                      ;*****************************************************************************************
                                      ;* - Code -                                                                              *
                                      ;*****************************************************************************************
00719A 7F719A                                                 ORG     IGNCALCS_CODE_START, IGNCALCS_CODE_START_LIN
00719A 7F719A -> $7F719A              IGNCALCS_CODE_START_LIN EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ; ----------------------------- No code for this module ----------------------------------
00719A 7F719A -> $719A                IGNCALCS_CODE_END               EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
00719A 7F719A -> $7F719A              IGNCALCS_CODE_END_LIN   EQU     @     ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ;* - Tables -                                                                            *
                                      ;*****************************************************************************************
007C9F 7F7C9F                                                 ORG     IGNCALCS_TABS_START, IGNCALCS_TABS_START_LIN
007C9F 7F7C9F -> $7F7C9F              IGNCALCS_TABS_START_LIN EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ; ------------------------------- No tables for this module ------------------------------
007C9F 7F7C9F -> $7C9F                IGNCALCS_TABS_END               EQU     *     ; * Represents the current value of the paged
                                                                    ; program counter
007C9F 7F7C9F -> $7F7C9F              IGNCALCS_TABS_END_LIN   EQU     @     ; @ Represents the current value of the linear
                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (injcalcs_BPEM488.s)                                                       *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BPEM488 Engine Controller for the Dodge 488CID (8.0L) V10 engine  *
                                      ;*    by Robert Hiebert.                                                                 *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teaching    *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*    This module contains code for the fuel injection pulse width calculations          *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project                          *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map                                       *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project               *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map                                         *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features                     *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler              *
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications                  *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)                                     *
                                      ;*   gpio_BPEM488.s       - Initialization all ports                                     *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros                         *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing                              *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths (This module)         *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors                   *
                                      ;*****************************************************************************************
                                      ;* Version History:                                                                      *
                                      ;*    May 13, 2020                                                                       *
                                      ;*    - BPEM488 dedicated hardware version begins (work in progress)                     *
                                      ;*    - Update December 10 2020                                                          *
                                      ;*    - Update February 7 2021 Change OFC logic                                          *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
007C9F 7F7C9F S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ;*****************************************************************************************
                                      ;* - Variables -                                                                         *
                                      ;*****************************************************************************************
001045 0FD045                                     ORG     INJCALCS_VARS_START, INJCALCS_VARS_START_LIN
001045 0FD045 -> $FD045               INJCALCS_VARS_START_LIN EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ; - RS232 variables (declared in BPEM488.s)
                                      ;*****************************************************************************************
                                      ;cltAdc:       ds 2 ; RV15 10 bit ADC AN00 Engine Coolant Temperature ADC
                                      ;Mapx10:       ds 2 ; Manifold Absolute Pressure (KPAx10)
                                      ;TpsPctx10:    ds 2 ; Throttle Position Sensor % of travel(%x10)(update every 100mSec)
                                      ;RPM:          ds 2 ; Crankshaft Revolutions Per Minute
                                      ;reqFuel:      ds 2 ; Pulse width for 14.7 AFR @ 100% VE (mS x 10)
                                      ;ASEcnt:       ds 2 ; Counter for "ASErev"(offset=72)
                                      ;AFRcurr:      ds 2 ; Current value in AFR table (AFR x 100)(offset=74)
                                      ;VEcurr:       ds 2 ; Current value in VE table (% x 10)(offset=76)
                                      ;barocor:      ds 2 ; Barometric Pressure Correction (% x 10)(offset=78)
                                      ;matcor:       ds 2 ; Manifold Air Temperature Correction (% x 10)(offset=80)
                                      ;WUEcor:       ds 2 ; Warmup Enrichment Correction (% x 10)(offset=82)
                                      ;ASEcor:       ds 2 ; Afterstart Enrichmnet Correction (% x 10)(offset=84)
                                      ;WUEandASEcor: ds 2 ; the sum of WUEcor and ASEcor (% x 10)(offset=86)
                                      ;Crankcor:     ds 2 ; Cranking pulsewidth temperature correction (% x 10)(offset=88)
                                      ;TpsPctDOT:    ds 2 ; TPS difference over time (%/Sec)(update every 100mSec)(offset=90)
                                      ;TpsDOTcor:    ds 1 ; Throttle Opening Enrichment table value(%)(offset=92)
                                      ;ColdAddpct:   ds 1 ; Throttle Opening Enrichment cold adder (%)(offset=93)
                                      ;ColdMulpct:   ds 1 ; Throttle Opening Enrichment cold multiplier (%)(offset=94)
                                      ;TOEpct:       ds 1 ; Throttle Opening Enrichment (%)(offset=95)
                                      ;TOEpw:        ds 2 ; Throttle Opening Enrichment adder (mS x 100)(offset=96)
                                      ;PWlessTOE:    ds 2 ; Injector pulse width before "TOEpw" and "Deadband" (mS x 10)(offset=98)
                                      ;Deadband:     ds 2 ; injector deadband at current battery voltage mS*100(offset=100)
                                      ;PrimePW:      ds 2 ; Primer injector pulswidth (mS x 10)(offset=102)
                                      ;CrankPW:      ds 2 ; Cranking injector pulswidth (mS x 10)(offset=104)
                                      ;FDpw:         ds 2 ; Fuel Delivery pulse width (PW - Deadband) (mS x 10)(offset=106)
                                      ;PW:           ds 2 ; Running engine injector pulsewidth (mS x 10)(offset=108)
                                      ;FDsec:        ds 2 ; Fuel delivery pulse width total over 1 second (mS)(offset=112)
                                      ;OFCdelCnt:    ds 1 ; Overrun Fuel Cut delay counter(offset=114)(Not Used)
                                      ;TOEdurCnt:    ds 1 ; Throttle Opening Enrichment duration counter(offset=115)
                                      ;FDt:          ds 2 ; Fuel Delivery pulse width total(mS) (for FDsec calcs)(offset=116)
                                      ;CASprd512:    ds 2 ; Crankshaft Angle Sensor period (5.12uS time base(offset=62)
                                      ;CASprd256:    ds 2 ; Crankshaft Angle Sensor period (2.56uS time base(offset=64)
                                      ;DutyCyclex10: ds 2  ; Injector duty cycle in run mode (% x 10)(offset=142)
                                      ;engine:       ds 1  ; Engine status bit field
                                      ;engine2:      ds 1  ; Engine2 status bit field
                                      ;*****************************************************************************************
                                      ; - "engine" equates
                                      ;*****************************************************************************************
                                      ;OFCdelon     equ  $01 ; %00000001, bit 0, 0 = OFC timer not counting down(Grn),(not used)
                                                                              ; 1 = OFC timer counting down(Red)
                                      ;crank        equ  $02 ; %00000010, bit 1, 0 = engine not cranking(Grn),
                                                                              ; 1 = engine cranking(Red)
                                      ;run          equ  $04 ; %00000100, bit 2, 0 = engine not running(Red),
                                                                              ; 1 = engine running(Grn)
                                      ;ASEon        equ  $08 ; %00001000, bit 3, 0 = not in start/warmup(Grn),
                                                                              ; 1 = in start/warmup(Red)
                                      ;WUEon        equ  $10 ; %00010000, bit 4, 0 = not in warmup(Grn),
                                                                              ; 1 = in warmup(Red)
                                      ;TOEon        equ  $20 ; %00100000, bit 5, 0 = not in TOE mode(Grn),
                                                                              ; 1 = TOE mode(Red)
                                      ;OFCon        equ  $40 ; %01000000, bit 6, 0 = not in OFC mode(Grn),
                                                                              ; 1 = in OFC mode(Red)
                                      ;FldClr       equ $80  ; %10000000, bit 7, 0 = not in flood clear mode(Grn),
                                                                              ; 1 = Flood clear mode(Red)
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; "engine2" equates
                                      ;*****************************************************************************************
                                      ;base512        equ $01 ; %00000001, bit 0, 0 = 5.12uS time base off(White),
                                                                               ; 1 = 5.12uS time base on(Grn)
                                      ;base256        equ $02 ; %00000010, bit 1, 0 = 2.56uS time base off(White),
                                                                               ; 1 = 2.56uS time base on(Grn)
                                      ;AudAlrm        equ $04 ; %00000100, bit 2, 0 = Audible Alarm on(Grn),
                                                                               ; 1 = Audible Alarm off(Red)
                                      ;TOEduron       equ $08 ; %00001000, bit 3, 0 = TOE timer not counting down(Grn),
                                                                               ; 1 = TOE timer counting down(Red)
                                      ;eng2Bit4       equ $10 ; %00010000, bit 4, 0 = , 1 =
                                      ;eng2Bit5       equ $20 ; %00100000, bit 5, 0 = , 1 =
                                      ;eng2Bit6       equ $40 ; %01000000, bit 6, 0 = , 1 =
                                      ;eng2Bit7       equ $80 ; %10000000, bit 7, 0 = , 1 =
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - These configurable constants are located in BPEM488.s in page 1 starting with the
                                      ;   VE table
                                      ;*****************************************************************************************
                                      ;tpsThresh_F:       ; 2 bytes for Throttle Opening Enrichment threshold (TpsPctx10/100mS)(offset = 976)($03D0)
                                      ;    dw $01C2       ; 450 = 45% per Sec
                                      ;TOEtime_F:         ; 2 bytes for Throttle Opening Enrich time in 100mS increments(mSx10)(offset = 978)($03D2)
                                      ;    dw $0014       ; 20 = 2mS
                                      ;OFCtps_F:          ; 2 bytes for Overrun Fuel Cut min TpS%x10(offset = 986)($03DA)
                                      ;    dw $0014       ; 20 = 2%
                                      ;OFCrpm_F:          ; 2 bytes for Overrun Fuel Cut min RPM(offset = 988)($03DC)
                                      ;    dw $0384       ; 900
                                      ;OFCmap_F:          ; 2 bytes for Overrun Fuel Cut maximum manifold pressure permissive (KPAx10)(offset = 990)($03DE)(not used)
                                      ;    dw $00FA       ; 250 = 25.0KPA
                                      ;OFCdel_F:          ; 2 bytes for Overrun Fuel Cut delay time (Sec x 10)(offset = 992)($03E0)(not used)
                                      ;    dw $0032         ; 50 = 5.0Sec
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ; - Non RS232 variables (declared in this module)
                                      ;*****************************************************************************************
001045 0FD045                         TpsPctx10last: ds 2 ; Throttle Position Sensor percent last (%x10)(updated every 100Msec)
001047 0FD047                         DdBndZ1:       ds 2 ; Deadband interpolation Z1 value
001049 0FD049                         DdBndZ2:       ds 2 ; Deadband interpolation Z2 value
00104B 0FD04B                         PWcalc1:       ds 2 ; PW calculations result 1
00104D 0FD04D                         PWcalc2:       ds 2 ; PW calculations result 2
00104F 0FD04F                         PWcalc3:       ds 2 ; PW calculations result 3
001051 0FD051                         PWcalc4:       ds 2 ; PW calculations result 4
001053 0FD053                         PWcalc5:       ds 2 ; PW calculations result 5
001055 0FD055                         ASErev:        ds 2 ; Afterstart Enrichment Taper (revolutions)
001057 0FD057                         PrimePWtk:     ds 2 ; Primer injector pulswidth timer ticks(uS x 5.12)
001059 0FD059                         CrankPWtk:     ds 2 ; Cranking injector pulswidth timer ticks(uS x 5.12)
00105B 0FD05B                         PWtk:          ds 2 ; Running injector pulsewidth timer ticks(uS x 2.56)
00105D 0FD05D                         InjOCadd1:     ds 2 ; First injector output compare adder (5.12uS res or 2.56uS res)
00105F 0FD05F                         InjOCadd2:     ds 2 ; Second injector output compare adder (5.12uS res or 2.56uS res)
001061 0FD061                         FDcnt:         ds 2 ; Fuel delivery pulse width total(ms)(for totalizer pulse on rollover)
001063 0FD063                         AIOTcnt:       ds 1 ; Counter for AIOT totalizer pulse width
001064 0FD064 -> $1064                INJCALCS_VARS_END               EQU     * ; * Represents the current value of the paged
                                                                    ; program counter
001064 0FD064 -> $FD064               INJCALCS_VARS_END_LIN   EQU     @ ; @ Represents the current value of the linear
                                      ;*****************************************************************************************
                                      ;* - Code -                                                                              *
                                      ;*****************************************************************************************
00719A 7F719A                                                 ORG     INJCALCS_CODE_START, INJCALCS_CODE_START_LIN
00719A 7F719A -> $7F719A              INJCALCS_CODE_START_LIN EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ; ------------------------------- No code for this module ------------------------------
00719A 7F719A -> $719A                INJCALCS_CODE_END               EQU     * ; * Represents the current value of the paged
                                                                    ; program counter
00719A 7F719A -> $7F719A              INJCALCS_CODE_END_LIN   EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ;*****************************************************************************************
                                      ;* - Tables -                                                                            *
                                      ;*****************************************************************************************
007C9F 7F7C9F                                                 ORG     INJCALCS_TABS_START, INJCALCS_TABS_START_LIN
007C9F 7F7C9F -> $7F7C9F              INJCALCS_TABS_START_LIN EQU     @ ; @ Represents the current value of the linear
                                                                    ; program counter
                                      ; ------------------------------- No tables for this module ------------------------------
007C9F 7F7C9F -> $7C9F                INJCALCS_TABS_END               EQU     * ; * Represents the current value of the paged
                                                                    ; program counter
007C9F 7F7C9F -> $7F7C9F              INJCALCS_TABS_END_LIN   EQU     @ ; @ Represents the current value of the linear
                                      ;        1         2         3         4         5         6         7         8         9
                                      ;23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                      ;*****************************************************************************************
                                      ;* S12CBase - (DodgeTherm_BPEM488.s)                                                      *
                                      ;*****************************************************************************************
                                      ;*    Copyright 2010-2012 Dirk Heisswolf                                                 *
                                      ;*    This file is part of the S12CBase framework for Freescale's S12(X) MCU             *
                                      ;*    families.                                                                          *
                                      ;*                                                                                       *
                                      ;*    S12CBase is free software: you can redistribute it and/or modify                   *
                                      ;*    it under the terms of the GNU General Public License as published by               *
                                      ;*    the Free Software Foundation, either version 3 of the License, or                  *
                                      ;*    (at your option) any later version.                                                *
                                      ;*                                                                                       *
                                      ;*    S12CBase is distributed in the hope that it will be useful,                        *
                                      ;*    but WITHOUT ANY WARRANTY; without even the implied warranty of                     *
                                      ;*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                      *
                                      ;*    GNU General Public License for more details.                                       *
                                      ;*                                                                                       *
                                      ;*    You should have received a copy of the GNU General Public License                  *
                                      ;*    along with S12CBase. If not,see <http://www.gnu.org/licenses/>.                    *
                                      ;*****************************************************************************************
                                      ;*    Modified for the BPEM488 Engine Controller for the Dodge 488CID (8.0L) V10 engine  *
                                      ;*    by Robert Hiebert.                                                                 *
                                      ;*    Text Editor: Notepad++                                                             *
                                      ;*    Assembler: HSW12ASM by Dirk Heisswolf                                              *
                                      ;*    Processor: MC9S12XEP100 112 LQFP                                                   *
                                      ;*    Reference Manual: MC9S12XEP100RMV1 Rev. 1.25 02/2013                               *
                                      ;*    De-bugging and lin.s28 records loaded using Mini-BDM-Pod by Dirk Heisswolf         *
                                      ;*    running D-Bug12XZ 6.0.0b6                                                          *
                                      ;*    The code is heavily commented not only to help others, but mainly as a teaching    *
                                      ;*    aid for myself as an amatuer programmer with no formal training                    *
                                      ;*****************************************************************************************
                                      ;* Description:                                                                          *
                                      ;*    Lookup table for Dodge thermistors                                                 *
                                      ;*****************************************************************************************
                                      ;* Required Modules:                                                                     *
                                      ;*   BPEM488.s            - Application code for the BPEM488 project                     *
                                      ;*   base_BPEM488.s       - Base bundle for the BPEM488 project                          *
                                      ;*   regdefs_BPEM488.s    - S12XEP100 register map                                       *
                                      ;*   vectabs_BPEM488.s    - S12XEP100 vector table for the BEPM488 project               *
                                      ;*   mmap_BPEM488.s       - S12XEP100 memory map                                         *
                                      ;*   eeem_BPEM488.s       - EEPROM Emulation initialize, enable, disable Macros          *
                                      ;*   clock_BPEM488.s      - S12XEP100 PLL and clock related features                     *
                                      ;*   rti_BPEM488.s        - Real Time Interrupt time rate generator handler              *
                                      ;*   sci0_BPEM488.s       - SCI0 driver for Tuner Studio communications                  *
                                      ;*   adc0_BPEM488.s       - ADC0 driver (ADC inputs)                                     *
                                      ;*   gpio_BPEM488.s       - Initialization all ports                                     *
                                      ;*   ect_BPEM488.s        - Enhanced Capture Timer driver (triggers, ignition control)   *
                                      ;*   tim_BPEM488.s        - Timer module for Ignition and Injector control on Port P     *
                                      ;*   state_BPEM488.s      - State machine to determine crank position and cam phase      *
                                      ;*   interp_BPEM488.s     - Interpolation subroutines and macros                         *
                                      ;*   igncalcs_BPEM488.s   - Calculations for igntion timing                              *
                                      ;*   injcalcs_BPEM488.s   - Calculations for injector pulse widths                       *
                                      ;*   DodgeTherm_BPEM488.s - Lookup table for Dodge temperature sensors (This module)     *
                                      ;*****************************************************************************************
                                      ;* Version History:                                                                      *
                                      ;*    May 25 2020                                                                        *
                                      ;*    - BPEM488 dedicated hardware version begins (work in progress)                     *
                                      ;*    - Update December 10 2020                                                          *
                                      ;*****************************************************************************************
                                      ;*****************************************************************************************
                                      ;* - Configuration -                                                                     *
                                      ;*****************************************************************************************
007C9F 7F7C9F S12X CODE:                  CPU S12X   ; Switch to S12x opcode table
                                      ;*****************************************************************************************
                                      ;* - Variables -                                                                         *
                                      ;*****************************************************************************************
001064 0FD064                                    ORG     DODGETHERM_VARS_START, DODGETHERM_VARS_START_LIN
001064 0FD064 -> $FD064               DODGETHERM_VARS_START_LIN       EQU     @ ; @ Represents the current value of the linear
                                                                        ; program counter
                                      ; ----------------------------- No variables for this module ----------------------------
001064 0FD064 -> $1064                DODGETHERM_VARS_END             EQU     *     ; * Represents the current value of the paged
                                                                        ; program counter
001064 0FD064 -> $FD064               DODGETHERM_VARS_END_LIN EQU     @     ; @ Represents the current value of the linear
                                                                        ; program counter
                                      ;*****************************************************************************************
                                      ;* - Macros -                                                                            *
                                      ;*****************************************************************************************
                                      ; ------------------------------ No macros for this module -------------------------------
                                      ;*****************************************************************************************
                                      ;* - Code -                                                                              *
                                      ;*****************************************************************************************
00719A 7F719A                                                 ORG     DODGETHERM_CODE_START, DODGETHERM_CODE_START_LIN
00719A 7F719A -> $7F719A              DODGETHERM_CODE_START_LIN       EQU     @ ; @ Represents the current value of the linear
                                                                       ; program counter
                                      ; ------------------------------- No code for this module -------------------------------
00719A 7F719A -> $719A                DODGETHERM_CODE_END             EQU     *     ; * Represents the current value of the paged
                                                                        ; program counter
00719A 7F719A -> $7F719A              DODGETHERM_CODE_END_LIN EQU     @     ; @ Represents the current value of the linear
                                                                        ; program counter
                                      ;*****************************************************************************************
                                      ;* - Tables -                                                                            *
                                      ;*****************************************************************************************
007C9F 7F7C9F                                                 ORG     DODGETHERM_TABS_START, DODGETHERM_TABS_START_LIN
007C9F 7F7C9F -> $7F7C9F              DODGETHERM_TABS_START_LIN       EQU     @ ; @ Represents the current value of the linear
                                                                        ; program counter
                                      ; Dodge thermistor
                                      ; 5 volt, 10 bit ADC, Bias resistor = 6980R
                                      ; 0C, 32F    = 32660R
                                      ; 30C, 86F   = 8060R
                                      ; 90C, 194F  = 915R
007C9F 7F7C9F                         DodgeThermistor:
                                      ;        Hex        DgFx10  Deg F   Deg C  ADC          Vout    Ohms
007C9F 7F7C9F 06 40                           DW      $0640   ;       1600    160.00  71.11   0               0.000   Default to 160F (sensor failure)
007CA1 7F7CA1 1A 56                           DW      $1A56   ;       6742    674.22  356.79  1               0.005   6.987
007CA3 7F7CA3 16 36                           DW      $1636   ;       5686    568.58  298.10  2               0.010   13.998
007CA5 7F7CA5 14 1F                           DW      $141F   ;       5151    515.07  268.37  3               0.015   21.03
007CA7 7F7CA7 12 C5                           DW      $12C5   ;       4805    480.50  249.17  4               0.020   28.032
007CA9 7F7CA9 11 F5                           DW      $11F5   ;       4597    459.68  237.60  5               0.024   33.666
007CAB 7F7CAB 11 26                           DW      $1126   ;       4390    438.99  266.10  6               0.029   40.72
007CAD 7F7CAD 10 7F                           DW      $107F   ;       4223    422.26  216.81  7               0.034   47.789
007CAF 7F7CAF 0F F3                           DW      $0FF3   ;       4083    408.29  209.05  8               0.039   54.872
007CB1 7F7CB1 0F 7B                           DW      $0F7B   ;       3963    396.34  202.41  9               0.044   61.969
007CB3 7F7CB3 0F 13                           DW      $0F13   ;       3859    385.93  196.63  10              0.049   69.081
007CB5 7F7CB5 0E B7                           DW      $0EB7   ;       3767    376.73  191.52  11              0.054   76.207
007CB7 7F7CB7 0E 6A                           DW      $0E6A   ;       3690    368.50  186.95  12              0.059   83.348
007CB9 7F7CB9 0E 29                           DW      $0E29   ;       3625    362.50  183.61  13              0.063   89.07
007CBB 7F7CBB 0D E4                           DW      $0DE4   ;       3556    355.61  179.70  14              0.068   96.237
007CBD 7F7CBD 0D A5                           DW      $0DA5   ;       3493    349.31  176.78  15              0.073   103.418
007CBF 7F7CBF 0D 6B                           DW      $0D6B   ;       3435    343.49  173.05  16              0.078   110.614
007CC1 7F7CC1 0D 35                           DW      $0D35   ;       3381    338.11  170.06  17              0.083   117.824
007CC3 7F7CC3 0D 03                           DW      $0D03   ;       3331    333.09  167.27  18              0.088   125.049
007CC5 7F7CC5 0D 9C                           DW      $0D9C   ;       3484    348.41  164.67  19              0.093   132.289
007CC7 7F7CC7 0C A8                           DW      $0CA8   ;       3240    324.01  162.23  20              0.098   139.543
007CC9 7F7CC9 0C 7F                           DW      $0C7F   ;       3199    319.87  159.93  21              0.103   146.812
007CCB 7F7CCB 0C 5F                           DW      $0C5F   ;       3167    316.73  158.18  22              0.107   152.638
007CCD 7F7CCD 0C 3A                           DW      $0C3A   ;       3130    312.99  156.10  23              0.112   159.935
007CCF 7F7CCF 0C 16                           DW      $0C16   ;       3094    309.44  154.13  24              0.117   167.246
007CD1 7F7CD1 0B F5                           DW      $0BF5   ;       3061    306.06  152.26  25              0.122   174.572
007CD3 7F7CD3 0B D4                           DW      $0BD4   ;       3028    302.84  150.47  26              0.127   181.913
007CD5 7F7CD5 0B B6                           DW      $0BB6   ;       2998    299.77  148.76  27              0.132   189.269
007CD7 7F7CD7 0B 98                           DW      $0B98   ;       2968    296.83  147.13  28              0.137   196.640
007CD9 7F7CD9 0B 7C                           DW      $0B7C   ;       2940    294.02  145.57  29              0.142   204.026
007CDB 7F7CDB 0B 64                           DW      $0B64   ;       2916    291.85  144.36  30              0.146   209.946
007CDD 7F7CDD 0B 4C                           DW      $0B4C   ;       2892    289.23  142.90  31              0.151   217.360
007CDF 7F7CDF 0B 34                           DW      $0B34   ;       2868    286.76  141.54  32              0.156   224.789
007CE1 7F7CE1 0B 1B                           DW      $0B1B   ;       2843    284.28  140.17  33              0.161   232.234
007CE3 7F7CE3 0B 03                           DW      $0B03   ;       2819    281.94  138.86  34              0.166   239.694
007CE5 7F7CE5 0A ED                           DW      $0AED   ;       2797    279.68  137.6   35              0.171   247.169
007CE7 7F7CE7 0A D7                           DW      $0AD7   ;       2775    277.49  136.39  36              0.176   254.660
007CE9 7F7CE9 0A C2                           DW      $0AC2   ;       2754    275.38  135.21  37              0.181   262.166
007CEB 7F7CEB 0A AD                           DW      $0AAD   ;       2733    273.33  134.07  38              0.186   269.688
007CED 7F7CED 0A 9D                           DW      $0A9D   ;       2717    271.74  133.19  39              0.190   275.717
007CEF 7F7CEF 0A 8A                           DW      $0A8A   ;       2698    269.80  132.11  40              0.195   283.267
007CF1 7F7CF1 0A 77                           DW      $0A77   ;       2679    267.92  131.07  41              0.200   290.833
007CF3 7F7CF3 0A 65                           DW      $0A65   ;       2661    266.09  130.05  42              0.205   298.415
007CF5 7F7CF5 0A 53                           DW      $0A53   ;       2643    264.31  129.06  43              0.210   306.013
007CF7 7F7CF7 0A 42                           DW      $0A42   ;       2626    262.58  128.10  44              0.215   313.626
007CF9 7F7CF9 0A 31                           DW      $0A31   ;       2609    260.89  127.16  45              0.220   321.255
007CFB 7F7CFB 0A 21                           DW      $0A21   ;       2593    259.25  126.25  46              0.225   328.901
007CFD 7F7CFD 0A 14                           DW      $0A14   ;       2580    257.97  2125.54 47              0.229   335.028
007CFF 7F7CFF 0A 04                           DW      $0A04   ;       2564    256.40  124.67  48              0.234   342.702
007D01 7F7D01 09 F5                           DW      $09F5   ;       2549    254.87  123.82  49              0.239   350.393
007D03 7F7D03 09 E6                           DW      $09E6   ;       2534    253.37  122.99  50              0.244   358.099
007D05 7F7D05 09 D7                           DW      $09D7   ;       2519    251.91  122.17  51              0.249   365.822
007D07 7F7D07 09 C9                           DW      $09C9   ;       2505    250.48  121.38  52              0.254   373.561
007D09 7F7D09 09 BB                           DW      $09BB   ;       2491    249.09  120.60  53              0.259   381.316
007D0B 7F7D0B 09 AD                           DW      $09AD   ;       2477    247.72  119.85  54              0.264   289.088
007D0D 7F7D0D 09 A0                           DW      $09A0   ;       2464    246.39  119.10  55              0.269   396.876
007D0F 7F7D0F 09 95                           DW      $0995   ;       2453    245.34  118.52  56              0.273   403.118
007D11 7F7D11 09 89                           DW      $0989   ;       2441    244.05  117.80  57              0.278   410.936
007D13 7F7D13 09 7C                           DW      $097C   ;       2428    242.79  117.10  58              0.283   418.770
007D15 7F7D15 09 70                           DW      $0970   ;       2416    241.55  116.42  59              0.288   426.621
007D17 7F7D17 09 63                           DW      $0963   ;       2403    240.34  115.74  60              0.293   434.489
007D19 7F7D19 09 58                           DW      $0958   ;       2392    239.15  115.08  61              0.298   442.373
007D1B 7F7D1B 09 4C                           DW      $094C   ;       2380    237.98  114.43  62              0.303   450.278
007D1D 7F7D1D 09 40                           DW      $0940   ;       2368    236.83  113.80  63              0.308   458.193
007D1F 7F7D1F 09 35                           DW      $0935   ;       2357    235.71  113.17  64              0.313   466.128
007D21 7F7D21 09 2C                           DW      $092C   ;       2348    234.82  112.68  65              0.317   472.488
007D23 7F7D23 09 21                           DW      $0921   ;       2337    233.73  112.07  66              0.322   480.453
007D25 7F7D25 09 17                           DW      $0917   ;       2327    232.66  111.48  67              0.327   488.436
007D27 7F7D27 09 0C                           DW      $090C   ;       2316    231.60  110.89  68              0.332   496.435
007D29 7F7D29 09 02                           DW      $0902   ;       2306    230.57  110.36  69              0.337   504.452
007D2B 7F7D2B 08 F8                           DW      $08F8   ;       2296    229.55  109.75  70              0.342   512.486
007D2D 7F7D2D 08 EE                           DW      $08EE   ;       2286    228.55  109.19  71              0.347   520.537
007D2F 7F7D2F 08 E4                           DW      $08E4   ;       2276    227.56  108.64  72              0.352   528.606
007D31 7F7D31 08 DB                           DW      $08DB   ;       2267    226.78  108.21  73              0.356   535.073
007D33 7F7D33 08 D2                           DW      $08D2   ;       2258    225.82  107.68  74              0.361   543.173
007D35 7F7D35 08 C9                           DW      $08C9   ;       2249    224.88  107.15  75              0.366   551.290
007D37 7F7D37 08 C0                           DW      $08C0   ;       2240    223.95  106.64  76              0.371   559.425
007D39 7F7D39 08 B6                           DW      $08B6   ;       2230    223.03  106.13  77              0.376   567.578
007D3B 7F7D3B 08 AD                           DW      $08AD   ;       2221    222.13  105.63  78              0.381   575.748
007D3D 7F7D3D 08 A4                           DW      $08A4   ;       2212    221.24  105.13  79              0.386   583.936
007D3F 7F7D3F 08 9C                           DW      $089C   ;       2204    220.36  104.64  80              0.391   592.141
007D41 7F7D41 08 93                           DW      $0893   ;       2195    219.49  104.16  81              0.396   600.365
007D43 7F7D43 08 8C                           DW      $088C   ;       2188    218.81  103.78  82              0.400   606.957
007D45 7F7D45 08 84                           DW      $0884   ;       2180    217.97  103.31  83              0.405   615.212
007D47 7F7D47 08 7B                           DW      $087B   ;       2171    217.13  102.85  84              0.410   623.486
007D49 7F7D49 08 73                           DW      $0873   ;       2163    216.31  102.40  85              0.415   631.778
007D4B 7F7D4B 08 6B                           DW      $086B   ;       2155    215.50  101.95  86              0.420   640.087
007D4D 7F7D4D 08 63                           DW      $0863   ;       2147    214.70  101.50  87              0.425   648.415
007D4F 7F7D4F 08 5B                           DW      $085B   ;       2139    213.91  101.06  88              0.430   656.761
007D51 7F7D51 08 53                           DW      $0853   ;       2131    213.13  100.63  89              0.435   665.126
007D53 7F7D53 08 4D                           DW      $084D   ;       2125    212.51  100.29  90              0.439   671.831
007D55 7F7D55 08 46                           DW      $0846   ;       2118    211.75  99.86   91              0.444   680.228
007D57 7F7D57 08 3E                           DW      $083E   ;       2110    211.00  99.44   92              0.449   688.644
007D59 7F7D59 08 37                           DW      $0837   ;       2103    210.25  99.03   93              0.454   697.079
007D5B 7F7D5B 08 2F                           DW      $082F   ;       2095    209.52  98.62   94              0.459   705.532
007D5D 7F7D5D 08 28                           DW      $0828   ;       2088    208.79  98.22   95              0.464   714.004
007D5F 7F7D5F 08 20                           DW      $0820   ;       2080    208.07  97.82   96              0.469   722.494
007D61 7F7D61 08 1A                           DW      $081A   ;       2074    207.36  97.42   97              0.474   731.003
007D63 7F7D63 08 13                           DW      $0813   ;       2067    206.66  97.03   98              0.479   739.531
007D65 7F7D65 08 0D                           DW      $080D   ;       2061    206.10  96.72   99              0.483   746.367
007D67 7F7D67 08 06                           DW      $0806   ;       2054    205.41  96.34   100             0.488   754.929
007D69 7F7D69 07 FF                           DW      $07FF   ;       2047    204.73  95.96   101             0.493   763.510
007D6B 7F7D6B 07 F9                           DW      $07F9   ;       2041    204.06  95.59   102             0.498   772.110
007D6D 7F7D6D 07 F2                           DW      $07F2   ;       2034    203.39  95.22   103             0.503   780.729
007D6F 7F7D6F 07 EB                           DW      $07EB   ;       2027    202.73  94.85   104             0.508   789.386
007D71 7F7D71 07 E5                           DW      $07E5   ;       2021    202.08  94.49   105             0.513   798.025
007D73 7F7D73 07 DE                           DW      $07DE   ;       2014    201.43  94.13   106             0.518   806.702
007D75 7F7D75 07 D9                           DW      $07D9   ;       2009    200.92  93.85   107             0.522   813.658
007D77 7F7D77 07 D3                           DW      $07D3   ;       2003    200.29  93.49   108             0.527   822.370
007D79 7F7D79 07 CD                           DW      $07CD   ;       1997    199.66  93.15   109             0.532   831.101
007D7B 7F7D7B 07 C6                           DW      $07C6   ;       1990    199.04  92.80   110             0.537   839.852
007D7D 7F7D7D 07 C0                           DW      $07C0   ;       1984    198.43  92.46   111             0.542   848.623
007D7F 7F7D7F 07 BA                           DW      $07BA   ;       1978    197.82  92.12   112             0.547   857.413
007D81 7F7D81 07 B4                           DW      $07B4   ;       1972    197.21  91.79   113             0.552   866.223
007D83 7F7D83 07 AE                           DW      $07AE   ;       1966    196.62  91.45   114             0.557   875.053
007D85 7F7D85 07 A8                           DW      $07A8   ;       1960    196.03  91.13   115             0.562   883.903
007D87 7F7D87 07 A4                           DW      $07A4   ;       1956    195.56  90.86   116             0.566   890.997
007D89 7F7D89 07 9E                           DW      $079E   ;       1950    194.97  90.54   117             0.571   899.883
007D8B 7F7D8B 07 98                           DW      $0798   ;       1944    194.40  90.22   118             0.576   908.788
007D8D 7F7D8D 07 92                           DW      $0792   ;       1938    193.83  89.90   119             0.581   917.714
007D8F 7F7D8F 07 8D                           DW      $078D   ;       1933    193.26  89.59   120             0.586   926.661
007D91 7F7D91 07 87                           DW      $0787   ;       1927    192.70  89.28   121             0.591   935.627
007D93 7F7D93 07 81                           DW      $0781   ;       1921    192.14  88.97   122             0.596   944.614
007D95 7F7D95 07 7C                           DW      $077C   ;       1916    191.59  88.66   123             0.601   953.621
007D97 7F7D97 07 77                           DW      $0777   ;       1911    191.05  88.36   124             0.605   962.649
007D99 7F7D99 07 72                           DW      $0772   ;       1906    190.61  88.12   125             0.610   969.886
007D9B 7F7D9B 07 6D                           DW      $076D   ;       1901    190.08  87.82   126             0.615   978.951
007D9D 7F7D9D 07 67                           DW      $0767   ;       1895    189.54  87.52   127             0.620   988.037
007D9F 7F7D9F 07 62                           DW      $0762   ;       1890    189.01  87.23   128             0.625   997.143
007DA1 7F7DA1 07 5D                           DW      $075D   ;       1885    188.49  86.94   129             0.630   1006.27
007DA3 7F7DA3 07 58                           DW      $0758   ;       1880    187.97  86.65   130             0.635   1015.418
007DA5 7F7DA5 07 53                           DW      $0753   ;       1875    187.45  86.36   131             0.640   1024.587
007DA7 7F7DA7 07 4D                           DW      $074D   ;       1869    186.94  86.08   132             0.645   1033.777
007DA9 7F7DA9 07 49                           DW      $0749   ;       1865    186.53  85.85   133             0.649   1041.145
007DAB 7F7DAB 07 44                           DW      $0744   ;       1860    186.03  85.57   134             0.654   1050.373
007DAD 7F7DAD 07 3F                           DW      $073F   ;       1855    185.53  85.29   135             0.659   1059.622
007DAF 7F7DAF 07 3A                           DW      $073A   ;       1850    185.03  85.02   136             0.664   1068.893
007DB1 7F7DB1 07 35                           DW      $0735   ;       1845    184.54  84.75   137             0.669   1078.185
007DB3 7F7DB3 07 31                           DW      $0731   ;       1841    184.05  84.47   138             0.674   1087.499
007DB5 7F7DB5 07 2C                           DW      $072C   ;       1836    183.57  84.20   139             0.679   1096.834
007DB7 7F7DB7 07 27                           DW      $0727   ;       1831    183.09  83.94   140             0.684   1106.191
007DB9 7F7DB9 07 23                           DW      $0723   ;       1827    182.70  83.72   141             0.688   1113.692
007DBB 7F7DBB 07 1E                           DW      $071E   ;       1822    182.23  83.46   142             0.693   1123.088
007DBD 7F7DBD 07 1A                           DW      $071A   ;       1818    181.76  83.20   143             0.698   1132.506
007DBF 7F7DBF 07 15                           DW      $0715   ;       1813    181.29  82.94   144             0.703   1141.946
007DC1 7F7DC1 07 10                           DW      $0710   ;       1808    180.82  82.68   145             0.708   1151.407
007DC3 7F7DC3 07 0C                           DW      $070C   ;       1804    180.36  82.42   146             0.713   1160.891
007DC5 7F7DC5 07 07                           DW      $0707   ;       1799    179.90  82.17   147             0.718   1170.397
007DC7 7F7DC7 07 03                           DW      $0703   ;       1795    179.45  81.92   148             0.723   1179.925
007DC9 7F7DC9 06 FE                           DW      $06FE   ;       1790    179.00  81.67   149             0.728   1189.476
007DCB 7F7DCB 06 FA                           DW      $06FA   ;       1786    178.64  81.47   150             0.732   1197.132
007DCD 7F7DCD 06 F6                           DW      $06F6   ;       1782    178.19  81.22   151             0.737   1206.723
007DCF 7F7DCF 06 F2                           DW      $06F2   ;       1778    177.75  80.97   152             0.742   1216.336
007DD1 7F7DD1 06 ED                           DW      $06ED   ;       1773    177.31  80.73   153             0.747   1225.972
007DD3 7F7DD3 06 E9                           DW      $06E9   ;       1769    176.87  80.49   154             0.752   1235.631
007DD5 7F7DD5 06 E4                           DW      $06E4   ;       1764    176.44  80.24   155             0.757   1245.312
007DD7 7F7DD7 06 E0                           DW      $06E0   ;       1760    176.01  80.00   156             0.762   1255.017
007DD9 7F7DD9 06 DC                           DW      $06DC   ;       1756    175.58  79.77   157             0.767   1264.744
007DDB 7F7DDB 06 D8                           DW      $06D8   ;       1752    175.24  79.58   158             0.771   1272.542
007DDD 7F7DDD 06 D4                           DW      $06D4   ;       1748    174.82  79.34   159             0.776   1282.311
007DDF 7F7DDF 06 D0                           DW      $06D0   ;       1744    174.40  79.11   160             0.781   1292.102
007DE1 7F7DE1 06 CC                           DW      $06CC   ;       1740    173.98  78.88   161             0.786   1301.917
007DE3 7F7DE3 06 C8                           DW      $06C8   ;       1736    173.56  78.65   162             0.791   1311.756
007DE5 7F7DE5 06 C4                           DW      $06C4   ;       1732    173.15  78.42   163             0.796   1321.618
007DE7 7F7DE7 06 BF                           DW      $06BF   ;       1727    172.74  78.19   164             0.801   1331.503
007DE9 7F7DE9 06 BB                           DW      $06BB   ;       1723    172.33  77.96   165             0.806   1341.412
007DEB 7F7DEB 06 B7                           DW      $06B7   ;       1719    171.93  77.73   166             0.811   1351.344
007DED 7F7DED 06 B4                           DW      $06B4   ;       1716    171.61  77.56   167             0.815   1359.307
007DEF 7F7DEF 06 B0                           DW      $06B0   ;       1712    171.20  77.34   168             0.820   1369.282
007DF1 7F7DF1 06 AC                           DW      $06AC   ;       1708    170.81  77.11   169             0.825   1379.281
007DF3 7F7DF3 06 A8                           DW      $06A8   ;       1704    170.41  76.89   170             0.830   1389.305
007DF5 7F7DF5 06 A4                           DW      $06A4   ;       1700    170.02  76.68   171             0.835   1399.352
007DF7 7F7DF7 06 A0                           DW      $06A0   ;       1696    169.63  76.46   172             0.840   1409.423
007DF9 7F7DF9 06 9C                           DW      $069C   ;       1692    169.24  76.24   173             0.845   1419.519
007DFB 7F7DFB 06 99                           DW      $0699   ;       1689    168.85  76.03   174             0.850   1429.639
007DFD 7F7DFD 06 95                           DW      $0695   ;       1685    168.54  75.86   175             0.854   1437.752
007DFF 7F7DFF 06 92                           DW      $0692   ;       1682    168.16  75.65   176             0.859   1447.916
007E01 7F7E01 06 8E                           DW      $068E   ;       1678    167.78  75.43   177             0.864   1458.104
007E03 7F7E03 06 8A                           DW      $068A   ;       1674    167.40  75.22   178             0.869   1468.318
007E05 7F7E05 06 86                           DW      $0686   ;       1670    167.03  75.05   179             0.874   1478.556
007E07 7F7E07 06 83                           DW      $0683   ;       1667    166.65  74.81   180             0.879   1488.818
007E09 7F7E09 06 7F                           DW      $067F   ;       1663    166.28  74.60   181             0.884   1499.106
007E0B 7F7E0B 06 7D                           DW      $067D   ;       1661    166.09  74.49   182             0.889   1504.419
007E0D 7F7E0D 06 77                           DW      $0677   ;       1655    165.54  74.19   183             0.894   1519.756
007E0F 7F7E0F 06 75                           DW      $0675   ;       1653    165.25  74.03   184             0.898   1528.045
007E11 7F7E11 06 71                           DW      $0671   ;       1649    164.89  73.83   185             0.903   1538.428
007E13 7F7E13 06 6D                           DW      $066D   ;       1645    164.52  73.63   186             0.908   1548.837
007E15 7F7E15 06 6A                           DW      $066A   ;       1642    164.16  73.42   187             0.913   1559.271
007E17 7F7E17 06 66                           DW      $0666   ;       1638    163.81  73.23   188             0.918   1569.731
007E19 7F7E19 06 63                           DW      $0663   ;       1635    163.45  73.03   189             0.923   1580.216
007E1B 7F7E1B 06 5F                           DW      $065F   ;       1631    163.09  72.98   190             0.928   1590.727
007E1D 7F7E1D 06 5B                           DW      $065B   ;       1627    162.74  72.63   191             0.933   1601.264
007E1F 7F7E1F 06 58                           DW      $0658   ;       1624    162.39  72.44   192             0.938   1611.827
007E21 7F7E21 06 55                           DW      $0655   ;       1621    162.11  72.28   193             0.942   1620.296
007E23 7F7E23 06 52                           DW      $0652   ;       1618    161.76  72.09   194             0.947   1630.906
007E25 7F7E25 06 4E                           DW      $064E   ;       1614    161.42  71.90   195             0.952   1641.542
007E27 7F7E27 06 4B                           DW      $064B   ;       1611    161.07  71.71   196             0.957   1652.204
007E29 7F7E29 06 47                           DW      $0647   ;       1607    160.73  71.52   197             0.962   1662.893
007E2B 7F7E2B 06 44                           DW      $0644   ;       1604    160.39  71.33   198             0.967   1673.608
007E2D 7F7E2D 06 41                           DW      $0641   ;       1601    160.16  71.14   199             0.972   1684.350
007E2F 7F7E2F 06 3D                           DW      $063D   ;       1597    159.71  70.95   200             0.977   1695.118
007E31 7F7E31 06 3A                           DW      $063A   ;       1594    159.44  70.80   201             0.981   1703.752
007E33 7F7E33 06 37                           DW      $0637   ;       1591    159.11  70.62   202             0.986   1714.569
007E35 7F7E35 06 34                           DW      $0634   ;       1588    158.78  70.43   203             0.991   1725.413
007E37 7F7E37 06 30                           DW      $0630   ;       1584    158.44  70.25   204             0.996   1736.284
007E39 7F7E39 06 2D                           DW      $062D   ;       1581    158.11  70.06   205             1.001   1747.182
007E3B 7F7E3B 06 2A                           DW      $062A   ;       1578    157.79  69.88   206             1.006   1758.107
007E3D 7F7E3D 06 27                           DW      $0627   ;       1575    157.46  69.70   207             1.011   1769.06
007E3F 7F7E3F 06 23                           DW      $0623   ;       1571    157.13  69.52   208             1.016   1780.04
007E41 7F7E41 06 20                           DW      $0620   ;       1568    156.81  69.34   209             1.021   1791.048
007E43 7F7E43 06 1E                           DW      $061E   ;       1566    156.55  69.20   210             1.025   1799.874
007E45 7F7E45 06 1A                           DW      $061A   ;       1562    156.23  69.02   211             1.030   1810.932
007E47 7F7E47 06 17                           DW      $0617   ;       1559    155.91  68.84   212             1.035   1822.018
007E49 7F7E49 06 14                           DW      $0614   ;       1556    155.59  68.66   213             1.040   1833.131
007E4B 7F7E4B 06 11                           DW      $0611   ;       1553    155.28  68.49   214             1.045   1844.273
007E4D 7F7E4D 06 0E                           DW      $060E   ;       1550    154.96  68.31   215             1.050   1855.443
007E4F 7F7E4F 06 0B                           DW      $060B   ;       1547    154.65  68.14   216             1.055   1866.641
007E51 7F7E51 06 07                           DW      $0607   ;       1543    154.33  67.96   217             1.060   1877.868
007E53 7F7E53 06 05                           DW      $0605   ;       1541    154.08  67.82   218             1.064   1886.870
007E55 7F7E55 06 02                           DW      $0602   ;       1538    153.77  67.65   219             1.069   1898.148
007E57 7F7E57 05 FF                           DW      $05FF   ;       1535    153.46  67.48   220             1.074   1909.455
007E59 7F7E59 05 FC                           DW      $05FC   ;       1532    153.16  67.31   221             1.079   1920.791
007E5B 7F7E5B 05 F9                           DW      $05F9   ;       1529    152.85  67.14   222             1.084   1932.155
007E5D 7F7E5D 05 F6                           DW      $05F6   ;       1526    152.55  66.97   223             1.089   1943.549
007E5F 7F7E5F 05 F2                           DW      $05F2   ;       1522    152.24  66.80   224             1.094   1954.972
007E61 7F7E61 05 EF                           DW      $05EF   ;       1519    151.94  66.63   225             1.099   1966.424
007E63 7F7E63 05 EC                           DW      $05EC   ;       1516    151.64  66.47   226             1.104   1977.906
007E65 7F7E65 05 EA                           DW      $05EA   ;       1514    151.40  66.33   227             1.108   1987.112
007E67 7F7E67 05 E7                           DW      $05E7   ;       1511    151.10  66.17   228             1.113   1998.647
007E69 7F7E69 05 E4                           DW      $05E4   ;       1508    150.80  66.00   229             1.118   2010.211
007E6B 7F7E6B 05 E1                           DW      $05E1   ;       1505    150.51  65.84   230             1.123   2021.806
007E6D 7F7E6D 05 DE                           DW      $05DE   ;       1502    150.21  65.67   231             1.128   2033.430
007E6F 7F7E6F 05 DB                           DW      $05DB   ;       1499    149.92  65.51   232             1.133   2045.084
007E71 7F7E71 05 D8                           DW      $05D8   ;       1496    149.62  65.35   233             1.138   2056.769
007E73 7F7E73 05 D5                           DW      $05D5   ;       1493    149.33  65.18   234             1.143   2068.483
007E75 7F7E75 05 D3                           DW      $05D3   ;       1491    149.10  65.05   235             1.147   2077.877
007E77 7F7E77 05 D0                           DW      $05D0   ;       1488    148.81  64.89   236             1.152   2089.647
007E79 7F7E79 05 CD                           DW      $05CD   ;       1485    148.52  64.73   237             1.157   2101.447
007E7B 7F7E7B 05 CA                           DW      $05CA   ;       1482    148.23  64.57   238             1.162   2113.278
007E7D 7F7E7D 05 C8                           DW      $05C8   ;       1480    147.95  64.41   239             1.167   2125.140
007E7F 7F7E7F 05 C5                           DW      $05C5   ;       1477    147.66  64.26   240             1.172   2137.032
007E81 7F7E81 05 C2                           DW      $05C2   ;       1474    147.38  64.10   241             1.177   2148.956
007E83 7F7E83 05 BF                           DW      $05BF   ;       1471    147.09  63.94   242             1.182   2160.911
007E85 7F7E85 05 BC                           DW      $05BC   ;       1468    146.81  63.78   243             1.187   2172.898
007E87 7F7E87 05 BA                           DW      $05BA   ;       1466    146.59  63.66   244             1.191   2182.510
007E89 7F7E89 05 B7                           DW      $05B7   ;       1463    146.31  63.50   245             1.196   2194.553
007E8B 7F7E8B 05 B4                           DW      $05B4   ;       1460    146.03  63.35   246             1.201   2206.628
007E8D 7F7E8D 05 B2                           DW      $05B2   ;       1458    145.75  63.19   247             1.206   2218.735
007E8F 7F7E8F 05 AF                           DW      $05AF   ;       1455    145.47  63.04   248             1.211   2230.874
007E91 7F7E91 05 AC                           DW      $05AC   ;       1452    145.20  62.89   249             1.216   2243.044
007E93 7F7E93 05 A9                           DW      $05A9   ;       1449    144.92  62.73   250             1.221   2255.247
007E95 7F7E95 05 A7                           DW      $05A7   ;       1447    144.65  62.58   251             1.226   2267.483
007E97 7F7E97 05 A2                           DW      $05A2   ;       1442    144.23  62.46   252             1.230   2277.294
007E99 7F7E99 05 A2                           DW      $05A2   ;       1442    144.16  62.31   253             1.235   2289.588
007E9B 7F7E9B 05 9F                           DW      $059F   ;       1439    143.88  62.16   254             1.240   2301.915
007E9D 7F7E9D 05 9C                           DW      $059C   ;       1436    143.61  62.00   255             1.245   2314.274
007E9F 7F7E9F 05 99                           DW      $0599   ;       1433    143.34  61.86   256             1.250   2326.667
007EA1 7F7EA1 05 97                           DW      $0597   ;       1431    143.08  61.71   257             1.255   2339.092
007EA3 7F7EA3 05 94                           DW      $0594   ;       1428    142.81  61.56   258             1.260   2351.551
007EA5 7F7EA5 05 91                           DW      $0591   ;       1425    142.54  61.41   259             1.265   2364.043
007EA7 7F7EA7 05 8F                           DW      $058F   ;       1423    142.28  61.26   260             1.270   2376.568
007EA9 7F7EA9 05 8D                           DW      $058D   ;       1421    142.06  61.15   261             1.274   2386.613
007EAB 7F7EAB 05 8A                           DW      $058A   ;       1418    141.80  61.00   262             1.279   2399.199
007EAD 7F7EAD 05 87                           DW      $0587   ;       1415    141.54  60.85   263             1.284   2411.819
007EAF 7F7EAF 05 85                           DW      $0585   ;       1413    141.27  60.71   264             1.289   2424.473
007EB1 7F7EB1 05 82                           DW      $0582   ;       1410    141.01  60.56   265             1.294   2437.161
007EB3 7F7EB3 05 80                           DW      $0580   ;       1408    140.75  60.42   266             1.299   2449.884
007EB5 7F7EB5 05 7D                           DW      $057D   ;       1405    140.49  60.27   267             1.304   2462.641
007EB7 7F7EB7 05 7A                           DW      $057A   ;       1402    140.23  60.13   268             1.309   2475.432
007EB9 7F7EB9 05 78                           DW      $0578   ;       1400    140.03  60.01   269             1.313   2485.690
007EBB 7F7EBB 05 76                           DW      $0576   ;       1398    139.77  59.87   270             1.318   2498.544
007EBD 7F7EBD 05 73                           DW      $0573   ;       1395    139.51  59.73   271             1.323   2511.433
007EBF 7F7EBF 05 71                           DW      $0571   ;       1393    139.26  59.59   272             1.328   2524.357
007EC1 7F7EC1 05 6E                           DW      $056E   ;       1390    139.00  59.44   273             1.333   2537.317
007EC3 7F7EC3 05 6C                           DW      $056C   ;       1388    138.75  59.30   274             1.338   2550.311
007EC5 7F7EC5 05 69                           DW      $0569   ;       1385    138.49  59.16   275             1.343   2563.342
007EC7 7F7EC7 05 66                           DW      $0566   ;       1382    138.24  59.02   276             1.348   2576.407
007EC9 7F7EC9 05 64                           DW      $0564   ;       1380    137.99  58.88   277             1.353   2589.509
007ECB 7F7ECB 05 62                           DW      $0562   ;       1378    137.79  58.77   278             1.357   2600.016
007ECD 7F7ECD 05 5F                           DW      $055F   ;       1375    137.54  58.63   279             1.362   2613.183
007ECF 7F7ECF 05 5D                           DW      $055D   ;       1373    137.29  58.49   280             1.367   2626.386
007ED1 7F7ED1 05 5A                           DW      $055A   ;       1370    137.04  58.35   281             1.372   2639.625
007ED3 7F7ED3 05 58                           DW      $0558   ;       1368    136.79  58.22   282             1.377   2652.901
007ED5 7F7ED5 05 55                           DW      $0555   ;       1365    136.54  58.08   283             1.382   2666.213
007ED7 7F7ED7 05 53                           DW      $0553   ;       1363    136.29  57.94   284             1.387   2679.563
007ED9 7F7ED9 05 51                           DW      $0551   ;       1361    136.05  57.80   285             1.392   2692.949
007EDB 7F7EDB 05 4F                           DW      $054F   ;       1359    135.85  57.70   286             1.396   2703.685
007EDD 7F7EDD 05 4C                           DW      $054C   ;       1356    135.61  57.56   287             1.401   2717.138
007EDF 7F7EDF 05 4A                           DW      $054A   ;       1354    135.38  57.42   288             1.406   2730.629
007EE1 7F7EE1 05 47                           DW      $0547   ;       1351    135.12  57.29   289             1.411   2744.157
007EE3 7F7EE3 05 45                           DW      $0545   ;       1349    134.88  57.15   290             1.416   2757.723
007EE5 7F7EE5 05 42                           DW      $0542   ;       1346    134.64  57.02   291             1.421   2771.327
007EE7 7F7EE7 05 40                           DW      $0540   ;       1344    134.39  56.89   292             1.426   2784.969
007EE9 7F7EE9 05 3E                           DW      $053E   ;       1342    134.15  56.75   293             1.431   2798.649
007EEB 7F7EEB 05 3B                           DW      $053B   ;       1339    133.91  56.62   294             1.436   2812.368
007EED 7F7EED 05 39                           DW      $0539   ;       1337    133.72  56.51   295             1.440   2823.371
007EEF 7F7EEF 05 37                           DW      $0537   ;       1335    133.48  56.38   296             1.445   2837.159
007EF1 7F7EF1 05 35                           DW      $0535   ;       1333    133.25  56.25   297             1.450   2850.986
007EF3 7F7EF3 05 32                           DW      $0532   ;       1330    133.01  56.12   298             1.455   2864.852
007EF5 7F7EF5 05 30                           DW      $0530   ;       1328    132.77  55.98   299             1.460   2878.757
007EF7 7F7EF7 05 2D                           DW      $052D   ;       1325    132.54  55.85   300             1.465   2892.702
007EF9 7F7EF9 05 2B                           DW      $052B   ;       1323    132.30  55.72   301             1.470   2906.686
007EFB 7F7EFB 05 29                           DW      $0529   ;       1321    132.07  55.59   302             1.475   2920.709
007EFD 7F7EFD 05 27                           DW      $0527   ;       1319    131.88  55.49   303             1.479   2931.957
007EFF 7F7EFF 05 24                           DW      $0524   ;       1316    131.64  55.36   304             1.484   2946.052
007F01 7F7F01 05 22                           DW      $0522   ;       1314    131.41  55.23   305             1.489   2960.188
007F03 7F7F03 05 20                           DW      $0520   ;       1312    131.88  55.10   306             1.494   2974.364
007F05 7F7F05 05 1E                           DW      $051E   ;       1310    130.95  54.97   307             1.499   2988.580
007F07 7F7F07 05 1B                           DW      $051B   ;       1307    130.72  54.84   308             1.504   3002.838
007F09 7F7F09 05 19                           DW      $0519   ;       1305    130.49  54.71   309             1.509   3017.135
007F0B 7F7F0B 05 17                           DW      $0517   ;       1303    130.25  54.59   310             1.514   3031.474
007F0D 7F7F0D 05 14                           DW      $0514   ;       1300    130.03  54.46   311             1.519   3045.855
007F0F 7F7F0F 05 12                           DW      $0512   ;       1298    129.84  54.36   312             1.523   3057.389
007F11 7F7F11 05 10                           DW      $0510   ;       1296    129.61  54.23   313             1.528   3071.843
007F13 7F7F13 05 0E                           DW      $050E   ;       1294    129.39  54.10   314             1.533   3086.340
007F15 7F7F15 05 0C                           DW      $050C   ;       1292    129.16  53.98   315             1.538   3100.878
007F17 7F7F17 05 09                           DW      $0509   ;       1289    128.93  53.85   316             1.543   3115.458
007F19 7F7F19 05 07                           DW      $0507   ;       1287    128.71  53.73   317             1.548   3130.081
007F1B 7F7F1B 05 05                           DW      $0505   ;       1285    128.48  53.60   318             1.553   3144.746
007F1D 7F7F1D 05 03                           DW      $0503   ;       1283    128.26  53.48   319             1.558   3159.454
007F1F 7F7F1F 05 00                           DW      $0500   ;       1280    128.03  53.35   320             1.563   3174.204
007F21 7F7F21 04 FF                           DW      $04FF   ;       1279    127.85  53.25   321             1.567   3186.036
007F23 7F7F23 04 FC                           DW      $04FC   ;       1276    127.63  53.13   322             1.572   3200.863
007F25 7F7F25 04 FA                           DW      $04FA   ;       1274    127.41  53.00   323             1.577   3215.735
007F27 7F7F27 04 F8                           DW      $04F8   ;       1272    127.18  52.88   324             1.582   3230.650
007F29 7F7F29 04 F6                           DW      $04F6   ;       1270    126.96  52.76   325             1.587   3245.608
007F2B 7F7F2B 04 F3                           DW      $04F3   ;       1267    126.74  52.63   326             1.592   3260.610
007F2D 7F7F2D 04 F1                           DW      $04F1   ;       1265    126.52  52.51   327             1.597   3275.657
007F2F 7F7F2F 04 EF                           DW      $04EF   ;       1263    126.30  52.39   328             1.602   3290.747
007F31 7F7F31 04 ED                           DW      $04ED   ;       1261    126.12  52.29   329             1.606   3302.852
007F33 7F7F33 04 EB                           DW      $04EB   ;       1259    125.90  52.17   330             1.611   3318.023
007F35 7F7F35 04 E9                           DW      $04E9   ;       1257    125.68  52.05   331             1.616   3333.239
007F37 7F7F37 04 E7                           DW      $04E7   ;       1255    125.47  51.93   332             1.621   3348.500
007F39 7F7F39 04 E5                           DW      $04E5   ;       1253    125.25  51.80   333             1.626   3363.806
007F3B 7F7F3B 04 E2                           DW      $04E2   ;       1250    125.03  51.68   334             1.631   3379.157
007F3D 7F7F3D 04 E0                           DW      $04E0   ;       1248    124.81  51.56   335             1.636   3394.554
007F3F 7F7F3F 04 DE                           DW      $04DE   ;       1246    124.60  51.44   336             1.641   3409.997
007F41 7F7F41 04 DC                           DW      $04DC   ;       1244    124.38  51.32   337             1.646   3425.486
007F43 7F7F43 04 DA                           DW      $04DA   ;       1242    124.21  51.23   338             1.650   3437.910
007F45 7F7F45 04 D8                           DW      $04D8   ;       1240    123.99  51.11   339             1.655   3453.483
007F47 7F7F47 04 D6                           DW      $04D6   ;       1238    123.78  50.99   340             1.660   3469.102
007F49 7F7F49 04 D4                           DW      $04D4   ;       1236    123.56  50.87   341             1.665   3484.768
007F4B 7F7F4B 04 D2                           DW      $04D2   ;       1234    123.35  50.75   342             1.670   3500.480
007F4D 7F7F4D 04 CF                           DW      $04CF   ;       1231    123.14  50.63   343             1.675   3516.241
007F4F 7F7F4F 04 CD                           DW      $04CD   ;       1229    122.92  50.51   344             1.680   3532.048
007F51 7F7F51 04 CB                           DW      $04CB   ;       1227    122.71  50.40   345             1.685   3547.903
007F53 7F7F53 04 C9                           DW      $04C9   ;       1225    122.54  50.30   346             1.689   3560.622
007F55 7F7F55 04 C7                           DW      $04C7   ;       1223    122.33  50.18   347             1.694   3576.564
007F57 7F7F57 04 C5                           DW      $04C5   ;       1221    122.12  50.07   348             1.699   3592.554
007F59 7F7F59 04 C3                           DW      $04C3   ;       1219    121.91  49.95   349             1.704   3608.592
007F5B 7F7F5B 04 C1                           DW      $04C1   ;       1217    121.70  49.83   350             1.709   3624.679
007F5D 7F7F5D 04 BF                           DW      $04BF   ;       1215    121.49  49.72   351             1.714   3640.816
007F5F 7F7F5F 04 BD                           DW      $04BD   ;       1213    121.28  4960    352             1.719   3657.001
007F61 7F7F61 04 BB                           DW      $04BB   ;       1211    121.07  49.48   353             1.724   3673.236
007F63 7F7F63 04 B9                           DW      $04B9   ;       1209    120.86  49.37   354             1.729   3689.520
007F65 7F7F65 04 B7                           DW      $04B7   ;       1207    120.70  49.28   355             1.733   3702.583
007F67 7F7F67 04 B5                           DW      $04B5   ;       1205    120.49  49.16   356             1.738   3718.958
007F69 7F7F69 04 B3                           DW      $04B3   ;       1203    120.28  49.04   357             1.743   3735.382
007F6B 7F7F6B 04 B1                           DW      $04B1   ;       1201    120.07  48.93   358             1.748   3751.857
007F6D 7F7F6D 04 AF                           DW      $04AF   ;       1199    119.87  48.82   359             1.753   3768.383
007F6F 7F7F6F 04 AD                           DW      $04AD   ;       1197    119.66  48.70   360             1.758   3784.960
007F71 7F7F71 04 AB                           DW      $04AB   ;       1195    119.46  48.59   361             1.763   3801.588
007F73 7F7F73 04 A9                           DW      $04A9   ;       1193    119.25  48.47   362             1.768   3818.267
007F75 7F7F75 04 A7                           DW      $04A7   ;       1191    119.09  48.38   363             1.772   3831.648
007F77 7F7F77 04 A5                           DW      $04A5   ;       1189    118.88  48.27   364             1.777   3848.421
007F79 7F7F79 04 A3                           DW      $04A3   ;       1187    118.68  48.15   365             1.782   3865.245
007F7B 7F7F7B 04 A1                           DW      $04A1   ;       1185    118.47  48.04   366             1.787   3882.123
007F7D 7F7F7D 04 9F                           DW      $049F   ;       1183    118.27  47.93   367             1.792   3899.052
007F7F 7F7F7F 04 9D                           DW      $049D   ;       1181    118.07  47.81   368             1.797   3916.035
007F81 7F7F81 04 9B                           DW      $049B   ;       1179    117.86  47.70   369             1.802   3933.071
007F83 7F7F83 04 99                           DW      $0499   ;       1177    117.66  47.59   370             1.807   3950.160
007F85 7F7F85 04 97                           DW      $0497   ;       1175    117.46  47.48   371             1.812   3967.302
007F87 7F7F87 04 95                           DW      $0495   ;       1173    117.30  47.39   372             1.816   3981.055
007F89 7F7F89 04 93                           DW      $0493   ;       1171    117.10  47.28   373             1.821   3998.295
007F8B 7F7F8B 04 91                           DW      $0491   ;       1169    116.90  47.16   374             1.826   4015.589
007F8D 7F7F8D 04 8F                           DW      $048F   ;       1167    116.69  47.05   375             1.831   4032.938
007F8F 7F7F8F 04 8D                           DW      $048D   ;       1165    116.49  46.94   376             1.836   4050.341
007F91 7F7F91 04 8B                           DW      $048B   ;       1163    116.29  46.83   377             1.841   4067.800
007F93 7F7F93 04 89                           DW      $0489   ;       1161    116.10  46.72   378             1.846   4085.314
007F95 7F7F95 04 87                           DW      $0487   ;       1159    115.90  46.61   379             1.851   4102.883
007F97 7F7F97 04 85                           DW      $0485   ;       1157    115.74  46.52   380             1.855   4116.979
007F99 7F7F99 04 83                           DW      $0483   ;       1155    115.54  46.41   381             1.860   4134.65
007F9B 7F7F9B 04 81                           DW      $0481   ;       1153    115.34  46.30   382             1.865   4152.376
007F9D 7F7F9D 04 7F                           DW      $047F   ;       1151    115.14  46.19   383             1.870   4170.160
007F9F 7F7F9F 04 7D                           DW      $047D   ;       1149    114.94  46.08   384             1.875   4188.000
007FA1 7F7FA1 04 7C                           DW      $047C   ;       1148    114.75  45.97   385             1.880   4205.897
007FA3 7F7FA3 04 7A                           DW      $047A   ;       1146    114.55  45.86   386             1.885   4223.852
007FA5 7F7FA5 04 78                           DW      $0478   ;       1144    114.35  45.75   387             1.890   4241.865
007FA7 7F7FA7 04 76                           DW      $0476   ;       1142    114.16  45.64   388             1.895   4259.936
007FA9 7F7FA9 04 74                           DW      $0474   ;       1140    114.00  45.56   389             1.899   4274.434
007FAB 7F7FAB 04 72                           DW      $0472   ;       1138    113.80  45.45   390             1.904   4292.610
007FAD 7F7FAD 04 70                           DW      $0470   ;       1136    113.61  45.34   391             1.909   4310.844
007FAF 7F7FAF 04 6E                           DW      $046E   ;       1134    113.41  45.23   392             1.914   4329.138
007FB1 7F7FB1 04 6C                           DW      $046C   ;       1132    113.22  45.12   393             1.919   4347.491
007FB3 7F7FB3 04 6A                           DW      $046A   ;       1130    113.02  45.01   394             1.924   4365.904
007FB5 7F7FB5 04 68                           DW      $0468   ;       1128    112.83  44.91   395             1.929   4384.376
007FB7 7F7FB7 04 66                           DW      $0466   ;       1126    112.64  44.80   396             1.934   4402.909
007FB9 7F7FB9 04 65                           DW      $0465   ;       1125    112.48  44.71   397             1.938   4417.779
007FBB 7F7FBB 04 63                           DW      $0463   ;       1123    112.29  44.60   398             1.943   4436.421
007FBD 7F7FBD 04 61                           DW      $0461   ;       1121    112.10  44.50   399             1.948   4455.125
007FBF 7F7FBF 04 5F                           DW      $045F   ;       1119    111.90  44.39   400             1.953   4473.889
007FC1 7F7FC1 04 5D                           DW      $045D   ;       1117    111.71  44.28   401             1.958   4492.715
007FC3 7F7FC3 04 5B                           DW      $045B   ;       1115    111.52  44.18   402             1.963   4511.604
007FC5 7F7FC5 04 59                           DW      $0459   ;       1113    111.33  44.07   403             1.968   4530.554
007FC7 7F7FC7 04 57                           DW      $0457   ;       1111    111.13  43.96   404             1.973   4549.567
007FC9 7F7FC9 04 55                           DW      $0455   ;       1109    110.94  43.86   405             1.978   4568.643
007FCB 7F7FCB 04 54                           DW      $0454   ;       1108    110.79  43.77   406             1.982   4583.950
007FCD 7F7FCD 04 52                           DW      $0452   ;       1106    110.60  43.67   407             1.987   4603.140
007FCF 7F7FCF 04 50                           DW      $0450   ;       1104    110.41  43.56   408             1.992   4622.394
007FD1 7F7FD1 04 4E                           DW      $044E   ;       1102    110.22  43.45   409             1.997   4641.712
007FD3 7F7FD3 04 4C                           DW      $044C   ;       1100    110.03  43.35   410             2.002   4661.094
007FD5 7F7FD5 04 4A                           DW      $044A   ;       1098    109.84  43.24   411             2.007   4680.541
007FD7 7F7FD7 04 49                           DW      $0449   ;       1097    109.65  43.14   412             2.012   4700.054
007FD9 7F7FD9 04 47                           DW      $0447   ;       1095    109.46  43.03   413             2.017   4719.631
007FDB 7F7FDB 04 45                           DW      $0445   ;       1093    109.31  42.95   414             2.021   4735.341
007FDD 7F7FDD 04 43                           DW      $0443   ;       1091    109.12  42.84   415             2.026   4755.037
007FDF 7F7FDF 04 41                           DW      $0441   ;       1089    108.93  42.74   416             2.031   4774.800
007FE1 7F7FE1 04 3F                           DW      $043F   ;       1087    108.74  42.64   417             2.036   4794.629
007FE3 7F7FE3 04 3E                           DW      $043E   ;       1086    108.56  42.53   418             2.041   4814.525
007FE5 7F7FE5 04 3C                           DW      $043C   ;       1084    108.37  42.43   419             2.046   4834.489
007FE7 7F7FE7 04 3A                           DW      $043A   ;       1082    108.18  42.32   420             2.051   4854.520
007FE9 7F7FE9 04 38                           DW      $0438   ;       1080    107.99  42.22   421             2.056   4874.620
007FEB 7F7FEB 04 36                           DW      $0436   ;       1078    107.81  42.11   422             2.061   4894.787
007FED 7F7FED 04 17                           DW      $0417   ;       1077    107.66  42.03   423             2.065   4910.971
007FEF 7F7FEF 04 33                           DW      $0433   ;       1075    107.47  41.93   424             2.070   4931.263
007FF1 7F7FF1 04 31                           DW      $0431   ;       1073    107.28  41.82   425             2.075   4951.624
007FF3 7F7FF3 04 2F                           DW      $042F   ;       1071    107.10  41.72   426             2.080   4972.055
007FF5 7F7FF5 04 2D                           DW      $042D   ;       1069    106.91  41.62   427             2.085   4992.556
007FF7 7F7FF7 04 2B                           DW      $042B   ;       1067    106.73  41.51   428             2.090   5013.127
007FF9 7F7FF9 04 29                           DW      $0429   ;       1065    106.54  41.41   429             2.095   5033.769
007FFB 7F7FFB 04 28                           DW      $0428   ;       1064    106.36  41.31   430             2.100   5054.483
007FFD 7F7FFD 04 26                           DW      $0426   ;       1062    106.21  41.23   431             2.104   5071.105
007FFF 7F7FFF 04 24                           DW      $0424   ;       1060    106.02  41.12   432             2.109   5091.947
008001 7F8001 04 22                           DW      $0422   ;       1058    105.84  41.02   433             2.114   5112.862
008003 7F8003 04 21                           DW      $0421   ;       1057    105.66  40.92   434             2.119   5133.849
008005 7F8005 04 1F                           DW      $041F   ;       1055    105.47  40.82   435             2.124   5154.910
008007 7F8007 04 1D                           DW      $041D   ;       1053    105.29  40.72   436             2.129   5176.043
008009 7F8009 04 1B                           DW      $041B   ;       1051    105.10  40.61   437             2.134   5197.251
00800B 7F800B 04 19                           DW      $0419   ;       1049    104.92  40.51   438             2.139   5218.532
00800D 7F800D 04 17                           DW      $0417   ;       1047    104.74  40.41   439             2.144   5239.888
00800F 7F800F 04 16                           DW      $0416   ;       1046    104.59  40.33   440             2.148   5257.027
008011 7F8011 04 14                           DW      $0414   ;       1044    104.41  40.23   441             2.153   5278.518
008013 7F8013 04 12                           DW      $0412   ;       1042    104.23  40.13   442             2.158   5300.084
008015 7F8015 04 10                           DW      $0410   ;       1040    104.04  40.02   443             2.163   5321.727
008017 7F8017 04 0F                           DW      $040F   ;       1039    103.86  39.92   444             2.168   5343.446
008019 7F8019 04 0D                           DW      $040D   ;       1037    103.68  39.82   445             2.173   5365.242
00801B 7F801B 04 0B                           DW      $040B   ;       1035    103.50  39.72   446             2.178   5387.116
00801D 7F801D 04 09                           DW      $0409   ;       1033    103.32  39.62   447             2.183   5409.066
00801F 7F801F 04 07                           DW      $0407   ;       1031    103.14  39.52   448             2.188   5431.095
008021 7F8021 04 06                           DW      $0406   ;       1030    102.99  39.44   449             2.192   5448.775
008023 7F8023 04 04                           DW      $0404   ;       1028    102.81  39.34   450             2.197   5470.945
008025 7F8025 04 02                           DW      $0402   ;       1026    102.63  39.24   451             2.202   5493.195
008027 7F8027 04 01                           DW      $0401   ;       1025    102.45  39.14   452             2.207   5515.525
008029 7F8029 03 FF                           DW      $03FF   ;       1023    102.27  39.04   453             2.212   5537.934
00802B 7F802B 03 FD                           DW      $03FD   ;       1021    102.09  38.94   454             2.217   5560.424
00802D 7F802D 03 FB                           DW      $03FB   ;       1019    101.91  38.84   455             2.222   5582.995
00802F 7F802F 03 F9                           DW      $03F9   ;       1017    101.73  38.74   456             2.227   5605.647
008031 7F8031 03 F8                           DW      $03F8   ;       1016    101.58  38.66   457             2.231   5623.828
008033 7F8033 03 F6                           DW      $03F6   ;       1014    101.40  38.56   458             2.236   5646.628
008035 7F8035 03 F4                           DW      $03F4   ;       1012    101.22  38.46   459             2.241   5669.511
008037 7F8037 03 F3                           DW      $03F3   ;       1011    101.05  38.36   460             2.246   5692.476
008039 7F8039 03 F1                           DW      $03F1   ;       1009    100.87  38.26   461             2.251   5715.526
00803B 7F803B 03 EF                           DW      $03EF   ;       1007    100.69  38.16   462             2.256   5738.659
00803D 7F803D 03 ED                           DW      $03ED   ;       1005    100.51  38.06   463             2.261   5761.887
00803F 7F803F 03 EB                           DW      $03EB   ;       1003    100.33  37.96   464             2.266   5785.179
008041 7F8041 03 EA                           DW      $03EA   ;       1002    100.15  37.86   465             2.271   5808.567
008043 7F8043 03 E8                           DW      $03E8   ;       1000    100.01  37.78   466             2.275   5827.339
008045 7F8045 03 E6                           DW      $03E6   ;       998         99.83       37.68   467             2.280   5850.882
008047 7F8047 03 E5                           DW      $03E5   ;       997     99.65   37.59   468             2.285   5874.512
008049 7F8049 03 E3                           DW      $03E3   ;       995     99.48   37.49   469             2.290   5898.229
00804B 7F804B 03 E1                           DW      $03E1   ;       993     99.30   37.39   470             2.295   5922.033
00804D 7F804D 03 DF                           DW      $03DF   ;       991     99.12   37.29   471             2.300   5945.926
00804F 7F804F 03 DD                           DW      $03DD   ;       989     98.94   37.19   472             2.305   5969.907
008051 7F8051 03 DC                           DW      $03DC   ;       988     98.77   37.09   473             2.310   5993.978
008053 7F8053 03 DA                           DW      $03DA   ;       986     98.63   37.01   474             2.314   6013.299
008055 7F8055 03 D9                           DW      $03D9   ;       985     98.45   36.92   475             2.319   6037.531
008057 7F8057 03 D7                           DW      $03D7   ;       983     98.27   36.82   476             2.324   6061.854
008059 7F8059 03 D5                           DW      $03D5   ;       981     98.10   36.72   477             2.329   6086.267
00805B 7F805B 03 D3                           DW      $03D3   ;       979     97.92   36.62   478             2.334   6110.773
00805D 7F805D 03 D1                           DW      $03D1   ;       977     97.74   36.52   479             2.339   6135.370
00805F 7F805F 03 D0                           DW      $03D0   ;       976     97.57   36.43   480             2.344   6160.060
008061 7F8061 03 CE                           DW      $03CE   ;       974     97.39   36.33   481             2.349   6184.843
008063 7F8063 03 CC                           DW      $03CC   ;       972     97.21   36.23   482             2.354   6209.720
008065 7F8065 03 CA                           DW      $03CA   ;       970     97.07   36.15   483             2.358   6229.690
008067 7F8067 03 C9                           DW      $03C9   ;       969     96.90   36.05   484             2.363   6254.736
008069 7F8069 03 C7                           DW      $03C7   ;       967     96.72   35.96   485             2.368   6279.878
00806B 7F806B 03 C6                           DW      $03C6   ;       966     95.86   35.86   486             2.373   6305.116
00806D 7F806D 03 C4                           DW      $03C4   ;       964     96.37   35.76   487             2.378   6330.450
00806F 7F806F 03 C2                           DW      $03C2   ;       962     96.20   35.67   488             2.383   6355.881
008071 7F8071 03 C0                           DW      $03C0   ;       960     96.02   35.57   489             2.388   6381.409
008073 7F8073 03 BF                           DW      $03BF   ;       959     95.85   35.47   490             2.393   6407.035
008075 7F8075 03 BD                           DW      $03BD   ;       957     95.39   35.39   491             2.397   6427.607
008077 7F8077 03 BB                           DW      $03BB   ;       955     95.53   35.30   492             2.402   6453.410
008079 7F8079 03 BA                           DW      $03BA   ;       954     95.36   35.20   493             2.407   6479.314
00807B 7F807B 03 B8                           DW      $03B8   ;       952     95.19   35.10   494             2.412   6505.317
00807D 7F807D 03 B6                           DW      $03B6   ;       950     95.01   35.00   495             2.417   6531.421
00807F 7F807F 03 B4                           DW      $03B4   ;       948     94.84   34.91   496             2.422   6557.626
008081 7F8081 03 B3                           DW      $03B3   ;       947     94.66   34.81   497             2.427   6583.933
008083 7F8083 03 B1                           DW      $03B1   ;       945     94.49   34.72   498             2.432   6610.343
008085 7F8085 03 AF                           DW      $03AF   ;       943     94.32   34.62   499             2.437   6636.855
008087 7F8087 03 AE                           DW      $03AE   ;       942     94.18   34.54   500             2.441   6658.140
008089 7F8089 03 AC                           DW      $03AC   ;       940     94.00   34.45   501             2.446   6684.839
00808B 7F808B 03 AA                           DW      $03AA   ;       938     93.83   34.35   502             2.451   6711.644
00808D 7F808D 03 A9                           DW      $03A9   ;       937     93.66   34.25   503             2.456   6738.553
00808F 7F808F 03 A7                           DW      $03A7   ;       935     93.48   34.16   504             2.461   6765.569
008091 7F8091 03 A5                           DW      $03A5   ;       933     93.31   34.06   505             2.466   6792.691
008093 7F8093 03 A3                           DW      $03A3   ;       931     93.14   33.97   506             2.471   6819.921
008095 7F8095 03 A2                           DW      $03A2   ;       930     92.97   33.87   507             2.476   6847.258
008097 7F8097 03 A0                           DW      $03A0   ;       928     92.83   33.79   508             2.480   6869.206
008099 7F8099 03 9F                           DW      $039F   ;       927     92.65   33.70   509             2.485   6896.740
00809B 7F809B 03 9D                           DW      $039D   ;       925     92.48   33.60   510             2.490   6924.382
00809D 7F809D 03 9B                           DW      $039B   ;       923     92.31   33.51   511             2.495   6952.136
00809F 7F809F 03 99                           DW      $0399   ;       921     92.14   33.41   512             2.500   6980.000
0080A1 7F80A1 03 98                           DW      $0398   ;       920     91.96   33.31   513             2.505   7007.976
0080A3 7F80A3 03 96                           DW      $0396   ;       918     91.79   33.22   514             2.510   7036.064
0080A5 7F80A5 03 94                           DW      $0394   ;       916     91.62   33.12   515             2.515   7064.266
0080A7 7F80A7 03 93                           DW      $0393   ;       915     91.45   33.03   516             2.520   7092.581
0080A9 7F80A9 03 91                           DW      $0391   ;       913     91.31   32.95   517             2.524   7115.315
0080AB 7F80AB 03 8F                           DW      $038F   ;       911     91.14   32.85   518             2.529   7143.837
0080AD 7F80AD 03 8E                           DW      $038E   ;       910     90.97   32.76   519             2.534   7172.474
0080AF 7F80AF 03 8C                           DW      $038C   ;       908     90.80   32.66   520             2.539   7201.227
0080B1 7F80B1 03 8A                           DW      $038A   ;       906     90.62   32.57   521             2.544   7230.098
0080B3 7F80B3 03 89                           DW      $0389   ;       905     90.45   32.47   522             2.549   7259.086
0080B5 7F80B5 03 87                           DW      $0387   ;       903     90.28   32.38   523             2.554   7288.193
0080B7 7F80B7 03 85                           DW      $0385   ;       901     90.11   32.28   524             2.559   7317.419
0080B9 7F80B9 03 84                           DW      $0384   ;       900     89.97   32.21   525             2.563   7340.886
0080BB 7F80BB 03 82                           DW      $0382   ;       898     89.80   32.11   526             2.568   7370.329
0080BD 7F80BD 03 80                           DW      $0380   ;       896     89.63   32.02   527             2.573   7399.893
0080BF 7F80BF 03 7F                           DW      $037F   ;       895     89.46   31.92   528             2.578   7429.579
0080C1 7F80C1 03 7D                           DW      $037D   ;       893     89.29   31.83   529             2.583   7459.388
0080C3 7F80C3 03 7B                           DW      $037B   ;       891     89.12   31.73   530             2.588   7489.320
0080C5 7F80C5 03 7A                           DW      $037A   ;       890     88.95   31.64   531             2.593   7519.377
0080C7 7F80C7 03 78                           DW      $0378   ;       888     88.78   31.54   532             2.598   7549.559
0080C9 7F80C9 03 76                           DW      $0376   ;       886     88.61   31.45   533             2.603   7579.866
0080CB 7F80CB 03 75                           DW      $0375   ;       885     88.47   31.37   534             2.607   7604.204
0080CD 7F80CD 03 73                           DW      $0373   ;       883     88.30   31.28   535             2.612   7634.740
0080CF 7F80CF 03 71                           DW      $0371   ;       881     88.13   31.18   536             2.617   7665.405
0080D1 7F80D1 03 70                           DW      $0370   ;       880     87.96   31.09   537             2.622   7696.198
0080D3 7F80D3 03 6E                           DW      $036E   ;       878     87.79   30.99   538             2.627   7727.122
0080D5 7F80D5 03 6C                           DW      $036C   ;       876     87.62   30.90   539             2.632   7758.176
0080D7 7F80D7 03 6B                           DW      $036B   ;       875     87.45   30.80   540             2.637   7789.361
0080D9 7F80D9 03 69                           DW      $0369   ;       873     87.28   30.71   541             2.642   7820.679
0080DB 7F80DB 03 67                           DW      $0367   ;       871     87.14   30.63   542             2.646   7845.828
0080DD 7F80DD 03 66                           DW      $0366   ;       870     86.97   30.54   543             2.651   7877.386
0080DF 7F80DF 03 64                           DW      $0364   ;       868     86.80   30.44   544             2.656   7909.078
0080E1 7F80E1 03 62                           DW      $0362   ;       866     86.63   30.35   545             2.661   7940.906
0080E3 7F80E3 03 61                           DW      $0361   ;       865     86.46   30.26   546             2.666   7972.871
0080E5 7F80E5 03 5F                           DW      $035F   ;       863     86.29   30.16   547             2.671   8004.972
0080E7 7F80E7 03 5D                           DW      $035D   ;       861     86.12   30.07   548             2.676   8037.212
0080E9 7F80E9 03 5C                           DW      $035C   ;       860     85.95   29.97   549             2.681   8069.590
0080EB 7F80EB 03 5A                           DW      $035A   ;       858     85.78   29.88   550             2.686   8102.109
0080ED 7F80ED 03 58                           DW      $0358   ;       856     85.64   29.80   551             2.690   8128.225
0080EF 7F80EF 03 57                           DW      $0357   ;       855     85.47   29.71   552             2.695   8160.998
0080F1 7F80F1 03 55                           DW      $0355   ;       853     85.30   29.61   553             2.700   8193.913
0080F3 7F80F3 03 53                           DW      $0353   ;       851     85.14   29.52   554             2.705   8226.972
0080F5 7F80F5 03 52                           DW      $0352   ;       850     84.97   29.43   555             2.710   8260.175
0080F7 7F80F7 03 50                           DW      $0350   ;       848     84.80   29.33   556             2.715   8293.523
0080F9 7F80F9 03 4E                           DW      $034E   ;       846     84.63   29.24   557             2.720   8327.018
0080FB 7F80FB 03 4D                           DW      $034D   ;       845     84.46   29.14   558             2.725   8360.659
0080FD 7F80FD 03 4B                           DW      $034B   ;       843     84.32   29.07   559             2.729   8387.679
0080FF 7F80FF 03 4A                           DW      $034A   ;       842     84.15   28.97   560             2.734   8421.589
008101 7F8101 03 48                           DW      $0348   ;       840     83.98   28.88   561             2.739   8455.648
008103 7F8103 03 46                           DW      $0346   ;       838     83.81   28.78   562             2.744   8489.858
008105 7F8105 03 44                           DW      $0344   ;       836     83.64   28.69   563             2.749   8524.220
008107 7F8107 03 43                           DW      $0343   ;       835     83.47   28.60   564             2.754   8558.736
008109 7F8109 03 41                           DW      $0341   ;       833     83.30   28.50   565             2.759   8593.405
00810B 7F810B 03 3F                           DW      $033F   ;       831     83.14   28.41   566             2.764   8628.229
00810D 7F810D 03 3E                           DW      $033E   ;       830     82.97   28.31   567             2.769   8663.209
00810F 7F810F 03 3C                           DW      $033C   ;       828     82.83   28.24   568             2.773   8691.307
008111 7F8111 03 3B                           DW      $033B   ;       827     82.66   28.15   569             2.778   8726.571
008113 7F8113 03 39                           DW      $0339   ;       825     82.49   28.05   570             2.783   8761.994
008115 7F8115 03 37                           DW      $0337   ;       823     82.32   27.96   571             2.788   8797.577
008117 7F8117 03 36                           DW      $0336   ;       822     82.15   27.86   572             2.793   8833.321
008119 7F8119 03 34                           DW      $0334   ;       820     81.98   27.77   573             2.798   8869.228
00811B 7F811B 03 32                           DW      $0332   ;       818     81.82   27.68   574             2.803   8905.298
00811D 7F811D 03 31                           DW      $0331   ;       817     81.65   27.58   575             2.808   8941.533
00811F 7F811F 03 2F                           DW      $032F   ;       815     81.48   27.49   576             2.813   8977.933
008121 7F8121 03 2D                           DW      $032D   ;       813     81.34   27.41   577             2.817   9007.174
008123 7F8123 03 2C                           DW      $032C   ;       812     81.17   27.32   578             2.822   9043.875
008125 7F8125 03 2A                           DW      $032A   ;       810     81.00   27.22   579             2.827   9080.746
008127 7F8127 03 28                           DW      $0328   ;       808     80.83   27.13   580             2.832   9117.786
008129 7F8129 03 27                           DW      $0327   ;       807     80.67   27.04   581             2.837   9154.998
00812B 7F812B 03 25                           DW      $0325   ;       805     80.50   26.94   582             2.842   9192.382
00812D 7F812D 03 23                           DW      $0323   ;       803     80.30   26.85   583             2.847   9229.940
00812F 7F812F 03 22                           DW      $0322   ;       802     80.16   26.75   584             2.852   9267.672
008131 7F8131 03 20                           DW      $0320   ;       800     80.02   26.68   585             2.856   9297.985
008133 7F8133 03 1F                           DW      $031F   ;       799     79.85   26.59   586             2.861   9336.036
008135 7F8135 03 1D                           DW      $031D   ;       797     79.68   26.49   587             2.866   9374.264
008137 7F8137 03 1B                           DW      $031B   ;       795     79.52   26.40   588             2.871   9412.673
008139 7F8139 03 19                           DW      $0319   ;       793     79.35   26.30   589             2.876   9451.262
00813B 7F813B 03 18                           DW      $0318   ;       792     79.18   26.21   590             2.881   9490.033
00813D 7F813D 03 16                           DW      $0316   ;       790     79.00   26.12   591             2.886   9528.988
00813F 7F813F 03 14                           DW      $0314   ;       788     78.84   26.02   592             2.891   9568.127
008141 7F8141 03 13                           DW      $0313   ;       787     78.67   25.93   593             2.896   9607.452
008143 7F8143 03 11                           DW      $0311   ;       785     78.53   25.85   594             2.900   9639.048
008145 7F8145 03 10                           DW      $0310   ;       784     78.36   25.76   595             2.905   9678.711
008147 7F8147 03 0E                           DW      $030E   ;       782     78.19   25.66   596             2.910   9718.565
008149 7F8149 03 0C                           DW      $030C   ;       780     78.03   25.57   597             2.915   9758.609
00814B 7F814B 03 0B                           DW      $030B   ;       779     77.86   25.48   598             2.920   9798.846
00814D 7F814D 03 09                           DW      $0309   ;       777     77.69   25.38   599             2.925   9839.277
00814F 7F814F 03 07                           DW      $0307   ;       775     77.52   25.29   600             2.930   9879.903
008151 7F8151 03 06                           DW      $0306   ;       774     77.35   25.19   601             2.935   9920.726
008153 7F8153 03 04                           DW      $0304   ;       772     77.21   25.12   602             2.939   9953.527
008155 7F8155 03 02                           DW      $0302   ;       770     77.04   25.02   603             2.944   9994.708
008157 7F8157 03 01                           DW      $0301   ;       769     76.87   24.93   604             2.949   10036.090
008159 7F8159 02 FF                           DW      $02FF   ;       767     76.70   24.84   605             2.954   10077.674
00815B 7F815B 02 FD                           DW      $02FD   ;       765     76.53   24.74   606             2.959   10119.461
00815D 7F815D 02 FC                           DW      $02FC   ;       764     76.36   24.65   607             2.964   10161.454
00815F 7F815F 02 FA                           DW      $02FA   ;       762     76.20   24.55   608             2.969   10203.635
008161 7F8161 02 F8                           DW      $02F8   ;       760     76.03   24.46   609             2.974   10246.061
008163 7F8163 02 F7                           DW      $02F7   ;       759     75.86   24.36   610             2.979   10288.679
008165 7F8165 02 F5                           DW      $02F5   ;       757     75.72   24.29   611             2.983   10322.925
008167 7F8167 02 F4                           DW      $02F4   ;       756     75.55   24.19   612             2.988   10365.924
008169 7F8169 02 F2                           DW      $02F2   ;       754     75.38   24.10   613             2.993   10409.138
00816B 7F816B 02 F0                           DW      $02F0   ;       752     75.21   24.00   614             2.998   10452.567
00816D 7F816D 02 EE                           DW      $02EE   ;       750     75.04   23.91   615             3.003   10496.214
00816F 7F816F 02 ED                           DW      $02ED   ;       749     74.87   23.82   616             3.008   10540.080
008171 7F8171 02 EB                           DW      $02EB   ;       747     74.70   23.72   617             3.013   10584.167
008173 7F8173 02 E9                           DW      $02E9   ;       745     74.53   23.63   618             3.018   10628.476
008175 7F8175 02 E8                           DW      $02E8   ;       744     74.39   23.55   619             3.022   10664.085
008177 7F8177 02 E6                           DW      $02E6   ;       742     74.22   23.46   620             3.027   10708.799
008179 7F8179 02 E4                           DW      $02E4   ;       740     74.05   23.36   621             3.032   10753.740
00817B 7F817B 02 E3                           DW      $02E3   ;       739     73.88   23.27   622             3.037   10798.910
00817D 7F817D 02 E1                           DW      $02E1   ;       737     73.71   23.17   623             3.042   10844.311
00817F 7F817F 02 DF                           DW      $02DF   ;       735     73.54   23.08   624             3.047   10889.944
008181 7F8181 02 DE                           DW      $02DE   ;       734     73.37   22.98   625             3.052   10935.811
008183 7F8183 02 DC                           DW      $02DC   ;       732     73.20   22.89   626             3.057   10981.915
008185 7F8185 02 DA                           DW      $02DA   ;       730     73.03   22.80   627             3.062   11028.256
008187 7F8187 02 D9                           DW      $02D9   ;       729     72.90   22.72   628             3.066   11065.502
008189 7F8189 02 D7                           DW      $02D7   ;       727     72.72   22.62   629             3.071   11112.276
00818B 7F818B 02 D6                           DW      $02D6   ;       726     72.55   22.53   630             3.076   11159.293
00818D 7F818D 02 D4                           DW      $02D4   ;       724     72.38   22.43   631             3.081   11206.555
00818F 7F818F 02 D2                           DW      $02D2   ;       722     72.21   22.34   632             3.086   11254.065
008191 7F8191 02 D0                           DW      $02D0   ;       720     72.04   22.24   633             3.091   11301.823
008193 7F8193 02 CF                           DW      $02CF   ;       719     71.87   22.15   634             3.096   11349.832
008195 7F8195 02 CD                           DW      $02CD   ;       717     71.70   22.05   635             3.101   11398.094
008197 7F8197 02 CC                           DW      $02CC   ;       716     71.56   21.98   636             3.105   11436.887
008199 7F8199 02 CA                           DW      $02CA   ;       714     71.39   21.88   637             3.110   11485.608
00819B 7F819B 02 C8                           DW      $02C8   ;       712     71.22   21.79   638             3.115   11534.589
00819D 7F819D 02 C7                           DW      $02C7   ;       711     71.05   21.69   639             3.120   11583.830
00819F 7F819F 02 C5                           DW      $02C5   ;       709     70.88   21.60   640             3.125   11633.333
0081A1 7F81A1 02 C3                           DW      $02C3   ;       707     70.70   21.50   641             3.130   11683.102
0081A3 7F81A3 02 C1                           DW      $02C1   ;       705     70.53   21.41   642             3.135   11733.137
0081A5 7F81A5 02 C0                           DW      $02C0   ;       704     70.36   21.31   643             3.140   11783.441
0081A7 7F81A7 02 BE                           DW      $02BE   ;       702     70.19   21.22   644             3.145   11834.016
0081A9 7F81A9 02 BD                           DW      $02BD   ;       701     70.05   21.14   645             3.149   11874.673
0081AB 7F81AB 02 BB                           DW      $02BB   ;       699     69.88   21.04   646             3.154   11925.742
0081AD 7F81AD 02 B9                           DW      $02B9   ;       697     69.71   20.95   647             3.159   11977.089
0081AF 7F81AF 02 B7                           DW      $02B7   ;       695     69.53   20.85   648             3.164   12028.715
0081B1 7F81B1 02 B6                           DW      $02B6   ;       694     69.36   20.76   649             3.169   12080.623
0081B3 7F81B3 02 B4                           DW      $02B4   ;       692     69.19   20.66   650             3.174   12132.815
0081B5 7F81B5 02 B2                           DW      $02B2   ;       690     69.02   20.57   651             3.179   12185.294
0081B7 7F81B7 02 B0                           DW      $02B0   ;       688     68.84   20.47   652             3.184   12238.062
0081B9 7F81B9 02 AF                           DW      $02AF   ;       687     68.71   20.39   653             3.188   12280.486
0081BB 7F81BB 02 AD                           DW      $02AD   ;       685     68.53   20.30   654             3.193   12333.780
0081BD 7F81BD 02 AC                           DW      $02AC   ;       684     68.36   20.20   655             3.198   12387.370
0081BF 7F81BF 02 AA                           DW      $02AA   ;       682     68.19   20.10   656             3.203   12441.258
0081C1 7F81C1 02 A8                           DW      $02A8   ;       680     68.01   20.00   657             3.208   12495.446
0081C3 7F81C3 02 A6                           DW      $02A6   ;       678     67.84   19.91   658             3.213   12549.938
0081C5 7F81C5 02 A5                           DW      $02A5   ;       677     67.67   19.81   659             3.218   12604.736
0081C7 7F81C7 02 A3                           DW      $02A3   ;       675     67.49   19.72   660             3.223   12659.842
0081C9 7F81C9 02 A1                           DW      $02A1   ;       673     67.32   19.62   661             3.228   12715.260
0081CB 7F81CB 02 A0                           DW      $02A0   ;       672     67.18   19.54   662             3.232   12759.819
0081CD 7F81CD 02 9E                           DW      $029E   ;       670     67.01   19.45   663             3.237   12815.803
0081CF 7F81CF 02 9C                           DW      $029C   ;       668     66.83   19.35   664             3.242   12872.105
0081D1 7F81D1 02 9B                           DW      $029B   ;       667     66.66   19.26   665             3.247   12928.728
0081D3 7F81D3 02 99                           DW      $0299   ;       665     66.49   19.16   666             3.252   12985.675
0081D5 7F81D5 02 97                           DW      $0297   ;       663     66.31   19.06   667             3.257   13042.949
0081D7 7F81D7 02 95                           DW      $0295   ;       661     66.14   18.96   668             3.262   13100.552
0081D9 7F81D9 02 94                           DW      $0294   ;       660     65.96   18.87   669             3.267   13158.488
0081DB 7F81DB 02 92                           DW      $0292   ;       658     65.82   18.79   670             3.271   13205.078
0081DD 7F81DD 02 91                           DW      $0291   ;       657     65.65   18.69   671             3.276   13263.619
0081DF 7F81DF 02 8F                           DW      $028F   ;       655     65.47   18.60   672             3.281   13322.501
0081E1 7F81E1 02 8D                           DW      $028D   ;       653     65.30   18.50   673             3.286   13381.727
0081E3 7F81E3 02 8B                           DW      $028B   ;       651     65.12   18.40   674             3.291   13441.299
0081E5 7F81E5 02 8A                           DW      $028A   ;       650     64.95   18.30   675             3.296   13501.221
0081E7 7F81E7 02 88                           DW      $0288   ;       648     64.77   18.21   676             3.301   13561.495
0081E9 7F81E9 02 86                           DW      $0286   ;       646     64.59   18.11   677             3.306   13622.125
0081EB 7F81EB 02 84                           DW      $0284   ;       644     64.42   18.01   678             3.311   13683.114
0081ED 7F81ED 02 83                           DW      $0283   ;       643     64.28   17.93   679             3.315   13732.166
0081EF 7F81EF 02 81                           DW      $0281   ;       641     64.10   17.83   680             3.320   13793.81
0081F1 7F81F1 02 7F                           DW      $027F   ;       639     63.93   17.74   681             3.325   13855.821
0081F3 7F81F3 02 7E                           DW      $027E   ;       638     63.75   17.64   682             3.330   13981.204
0081F5 7F81F5 02 7C                           DW      $027C   ;       636     63.57   17.54   683             3.335   13980.961
0081F7 7F81F7 02 7A                           DW      $027A   ;       634     63.40   17.44   684             3.340   14044.096
0081F9 7F81F9 02 78                           DW      $0278   ;       632     63.22   17.34   685             3.345   14107.613
0081FB 7F81FB 02 76                           DW      $0276   ;       630     63.04   17.24   686             3.350   14171.515
0081FD 7F81FD 02 75                           DW      $0275   ;       629     62.90   17.17   687             3.354   14222.916
0081FF 7F81FF 02 73                           DW      $0273   ;       627     62.72   17.07   688             3.359   14287.520
008201 7F8201 02 71                           DW      $0271   ;       625     62.54   16.97   689             3.364   14352.518
008203 7F8203 02 70                           DW      $0270   ;       624     62.37   16.87   690             3.369   14417.915
008205 7F8205 02 6E                           DW      $026E   ;       622     62.19   16.77   691             3.374   14483.715
008207 7F8207 02 6C                           DW      $026C   ;       620     62.01   16.67   692             3.379   14549.920
008209 7F8209 02 6A                           DW      $026A   ;       618     61.83   16.57   693             3.384   14616.535
00820B 7F820B 02 69                           DW      $0269   ;       617     61.65   16.47   694             3.389   14683.563
00820D 7F820D 02 67                           DW      $0267   ;       615     61.47   16.37   695             3.394   14751.009
00820F 7F820F 02 65                           DW      $0265   ;       613     61.33   16.30   696             3.398   14805.268
008211 7F8211 02 64                           DW      $0264   ;       612     61.15   16.20   697             3.403   14873.475
008213 7F8213 02 62                           DW      $0262   ;       610     60.97   16.10   698             3.408   14942.111
008215 7F8215 02 60                           DW      $0260   ;       608     60.79   16.00   699             3.413   15011.178
008217 7F8217 02 5E                           DW      $025E   ;       606     60.61   15.90   700             3.418   15080.683
008219 7F8219 02 5C                           DW      $025C   ;       604     60.43   15.80   701             3.423   15150.628
00821B 7F821B 02 5B                           DW      $025B   ;       603     60.25   15.70   702             3.428   15221.018
00821D 7F821D 02 59                           DW      $0259   ;       601     60.07   15.60   703             3.433   15291.857
00821F 7F821F 02 57                           DW      $0257   ;       599     59.89   15.50   704             3.438   15363.150
008221 7F8221 02 56                           DW      $0256   ;       598     59.75   15.41   705             3.442   15420.513
008223 7F8223 02 54                           DW      $0254   ;       596     59.57   15.32   706             3.447   15492.634
008225 7F8225 02 52                           DW      $0252   ;       594     59.39   15.22   707             3.452   15565.220
008227 7F8227 02 50                           DW      $0250   ;       592     59.21   15.11   708             3.457   15638.276
008229 7F8229 02 4E                           DW      $024E   ;       590     59.02   15.01   709             3.462   15711.808
00822B 7F822B 02 4C                           DW      $024C   ;       588     58.84   14.91   710             3.467   15785.819
00822D 7F822D 02 4B                           DW      $024B   ;       587     58.66   14.81   711             3.472   15860.314
00822F 7F822F 02 49                           DW      $0249   ;       585     58.48   14.71   712             3.477   15935.299
008231 7F8231 02 47                           DW      $0247   ;       583     58.33   14.63   713             3.481   15995.642
008233 7F8233 02 46                           DW      $0246   ;       582     58.15   14.53   714             3.486   16071.519
008235 7F8235 02 44                           DW      $0244   ;       580     57.97   14.43   715             3.491   16147.899
008237 7F8237 02 42                           DW      $0242   ;       578     57.78   14.32   716             3.496   16224.787
008239 7F8239 02 40                           DW      $0240   ;       576     57.60   14.22   717             3.501   16302.188
00823B 7F823B 02 3E                           DW      $023E   ;       574     57.42   14.12   718             3.506   16380.107
00823D 7F823D 02 3C                           DW      $023C   ;       572     57.23   14.02   719             3.511   16458.549
00823F 7F823F 02 3B                           DW      $023B   ;       571     57.05   13.92   720             3.516   16537.520
008241 7F8241 02 39                           DW      $0239   ;       569     56.87   13.81   721             3.521   16617.025
008243 7F8243 02 37                           DW      $0237   ;       567     56.72   13.73   722             3.525   16681.017
008245 7F8245 02 35                           DW      $0235   ;       565     56.53   13.63   723             3.530   16761.497
008247 7F8247 02 34                           DW      $0234   ;       564     56.35   13.53   724             3.535   16842.526
008249 7F8249 02 32                           DW      $0232   ;       562     56.16   13.42   725             3.540   16924.110
00824B 7F824B 02 30                           DW      $0230   ;       560     55.98   13.32   726             3.545   17006.254
00824D 7F824D 02 2E                           DW      $022E   ;       558     55.79   13.22   727             3.550   17088.966
00824F 7F824F 02 2C                           DW      $022C   ;       556     55.61   13.11   728             3.555   17172.249
008251 7F8251 02 2A                           DW      $022A   ;       554     55.42   13.01   729             3.560   17256.111
008253 7F8253 02 29                           DW      $0229   ;       553     55.27   12.93   730             3.564   17323.621
008255 7F8255 02 27                           DW      $0227   ;       551     55.08   12.82   731             3.569   17408.539
008257 7F8257 02 25                           DW      $0225   ;       549     54.90   12.72   732             3.574   17494.053
008259 7F8259 02 23                           DW      $0223   ;       547     54.71   12.62   733             3.579   17580.169
00825B 7F825B 02 21                           DW      $0221   ;       545     54.52   12.51   734             3.584   17666.893
00825D 7F825D 02 1F                           DW      $021F   ;       543     54.34   12.41   735             3.589   17754.231
00825F 7F825F 02 1E                           DW      $021E   ;       542     54.15   12.30   736             3.594   17842.191
008261 7F8261 02 1C                           DW      $021C   ;       540     53.96   12.20   737             3.599   17930.778
008263 7F8263 02 1A                           DW      $021A   ;       538     53.77   12.09   738             3.604   18020.000
008265 7F8265 02 18                           DW      $0218   ;       536     53.62   12.01   739             3.608   18091.839
008267 7F8267 02 16                           DW      $0216   ;       534     53.43   11.91   740             3.613   18182.221
008269 7F8269 02 14                           DW      $0214   ;       532     53.24   11.80   741             3.618   18273.256
00826B 7F826B 02 13                           DW      $0213   ;       531     53.05   11.69   742             3.623   18364.953
00826D 7F826D 02 11                           DW      $0211   ;       529     52.86   11.59   743             3.628   18457.318
00826F 7F826F 02 0F                           DW      $020F   ;       527     52.67   11.48   744             3.633   18550.358
008271 7F8271 02 0D                           DW      $020D   ;       525     52.48   11.38   745             3.638   18644.082
008273 7F8273 02 0B                           DW      $020B   ;       523     52.29   11.27   746             3.643   18738.497
008275 7F8275 02 09                           DW      $0209   ;       521     52.14   11.19   747             3.647   18814.531
008277 7F8277 02 07                           DW      $0207   ;       519     51.94   11.08   748             3.652   18910.208
008279 7F8279 02 06                           DW      $0206   ;       518     51.75   10.97   749             3.657   19006.597
00827B 7F827B 02 04                           DW      $0204   ;       516     51.56   10.87   750             3.662   19103.707
00827D 7F827D 02 02                           DW      $0202   ;       514     51.37   10.76   751             3.667   19201.545
00827F 7F827F 02 00                           DW      $0200   ;       512     51.17   10.65   752             3.672   19300.120
008281 7F8281 01 FE                           DW      $01FE   ;       510     50.98   10.54   753             3.677   19399.441
008283 7F8283 01 FC                           DW      $01FC   ;       508     50.79   10.44   754             3.682   19449.514
008285 7F8285 01 FA                           DW      $01FA   ;       506     50.59   10.33   755             3.687   19600.350
008287 7F8287 01 F8                           DW      $01F8   ;       504     50.44   10.24   756             3.691   19681.574
008289 7F8289 01 F6                           DW      $01F6   ;       502     50.24   10.14   757             3.696   19783.804
00828B 7F828B 01 F5                           DW      $01F5   ;       501     50.05   10.03   758             3.701   19886.821
00828D 7F828D 01 F3                           DW      $01F3   ;       499     49.85   9.92    759             3.706   19990.634
00828F 7F828F 01 F1                           DW      $01F1   ;       497     49.66   9.81    760             3.711   20095.252
008291 7F8291 01 EF                           DW      $01EF   ;       495     49.46   9.70    761             3.716   20200.685
008293 7F8293 01 ED                           DW      $01ED   ;       493     49.27   9.59    762             3.721   20306.943
008295 7F8295 01 EB                           DW      $01EB   ;       491     49.07   9.48    763             3.726   20414.035
008297 7F8297 01 E9                           DW      $01E9   ;       489     48.91   9.39    764             3.730   20500.315
008299 7F8299 01 E7                           DW      $01E7   ;       487     48.71   9.29    765             3.735   20608.933
00829B 7F829B 01 E5                           DW      $01E5   ;       485     48.52   9.18    766             3.740   20718.413
00829D 7F829D 01 E3                           DW      $01E3   ;       483     48.32   9.07    767             3.745   20828.765
00829F 7F829F 01 E1                           DW      $01E1   ;       481     48.12   8.95    768             3.750   20940.000
0082A1 7F82A1 01 DF                           DW      $01DF   ;       479     47.92   8.84    769             3.755   21052.129
0082A3 7F82A3 01 DD                           DW      $01DD   ;       477     47.72   8.73    770             3.760   21165.161
0082A5 7F82A5 01 DB                           DW      $01DB   ;       475     47.52   8.62    771             3.765   21279.109
0082A7 7F82A7 01 D9                           DW      $01D9   ;       473     47.32   8.51    772             3.770   21393.984
0082A9 7F82A9 01 D7                           DW      $01D7   ;       471     47.16   8.42    773             3.774   21486.558
0082AB 7F82AB 01 D6                           DW      $01D6   ;       470     46.96   8.31    774             3.779   21603.129
0082AD 7F82AD 01 D4                           DW      $01D4   ;       468     46.76   8.20    775             3.784   21720.658
0082AF 7F82AF 01 D2                           DW      $01D2   ;       466     46.56   8.08    776             3.789   21839.158
0082B1 7F82B1 01 D0                           DW      $01D0   ;       464     46.35   7.97    777             3.794   21958.640
0082B3 7F82B3 01 CE                           DW      $01CE   ;       462     46.15   7.86    778             3.799   22079.117
0082B5 7F82B5 01 CC                           DW      $01CC   ;       460     45.95   7.75    779             3.804   22200.602
0082B7 7F82B7 01 C9                           DW      $01C9   ;       457     45.74   7.64    780             3.809   22323.107
0082B9 7F82B9 01 C8                           DW      $01C8   ;       456     45.58   7.54    781             3.813   22421.853
0082BB 7F82BB 01 C6                           DW      $01C6   ;       454     45.38   7.43    782             3.818   22546.227
0082BD 7F82BD 01 C4                           DW      $01C4   ;       452     45.17   7.32    783             3.823   22671.657
0082BF 7F82BF 01 C2                           DW      $01C2   ;       450     44.97   7.20    784             3.828   22798.157
0082C1 7F82C1 01 C0                           DW      $01C0   ;       448     44.76   7.09    785             3.833   22925.741
0082C3 7F82C3 01 BE                           DW      $01BE   ;       446     44.55   6.97    786             3.838   23054.423
0082C5 7F82C5 01 BC                           DW      $01BC   ;       444     44.35   6.86    787             3.843   23184.218
0082C7 7F82C7 01 BA                           DW      $01BA   ;       442     44.14   6.74    788             3.848   23315.139
0082C9 7F82C9 01 B7                           DW      $01B7   ;       439     43.93   6.63    789             3.853   23447.201
0082CB 7F82CB 01 B6                           DW      $01B6   ;       438     43.77   6.54    790             3.857   13553.683
0082CD 7F82CD 01 B4                           DW      $01B4   ;       436     43.56   6.42    791             3.862   23687.838
0082CF 7F82CF 01 B2                           DW      $01B2   ;       434     43.35   6.30    792             3.867   23823.177
0082D1 7F82D1 01 AF                           DW      $01AF   ;       431     43.14   6.19    793             3.872   23959.716
0082D3 7F82D3 01 AD                           DW      $01AD   ;       429     42.93   6.07    794             3.877   24097.471
0082D5 7F82D5 01 AB                           DW      $01AB   ;       427     42.72   5.95    795             3.882   24236.458
0082D7 7F82D7 01 A9                           DW      $01A9   ;       425     42.51   5.84    796             3.887   24376.694
0082D9 7F82D9 01 A7                           DW      $01A7   ;       423     42.30   5.72    797             3.892   24518.195
0082DB 7F82DB 01 A5                           DW      $01A5   ;       421     42.13   5.63    798             3.896   24632.319
0082DD 7F82DD 01 A3                           DW      $01A3   ;       419     41.91   5.51    799             3.901   24776.142
0082DF 7F82DF 01 A1                           DW      $01A1   ;       417     41.70   5.39    800             3.906   24921.280
0082E1 7F82E1 01 9F                           DW      $019F   ;       415     41.49   5.27    801             3.911   25067.750
0082E3 7F82E3 01 9D                           DW      $019D   ;       413     41.27   5.15    802             3.916   25215.572
0082E5 7F82E5 01 9B                           DW      $019B   ;       411     41.06   5.03    803             3.921   25364.764
0082E7 7F82E7 01 98                           DW      $0198   ;       408     40.84   4.91    804             3.926   25515.345
0082E9 7F82E9 01 96                           DW      $0196   ;       406     40.63   4.79    805             3.931   25667.334
0082EB 7F82EB 01 94                           DW      $0194   ;       404     40.41   4.67    806             3.936   25820.752
0082ED 7F82ED 01 92                           DW      $0192   ;       402     40.24   4.58    807             3.940   25944.528
0082EF 7F82EF 01 90                           DW      $0190   ;       400     40.02   4.46    808             3.945   26100.569
0082F1 7F82F1 01 8E                           DW      $018E   ;       398     39.80   4.33    809             3.950   26258.095
0082F3 7F82F3 01 8C                           DW      $018C   ;       396     39.58   4.21    810             3.955   26417.129
0082F5 7F82F5 01 8A                           DW      $018A   ;       394     39.36   4.09    811             3.960   26577.692
0082F7 7F82F7 01 87                           DW      $0187   ;       391     39.14   3.97    812             3.965   26739.807
0082F9 7F82F9 01 85                           DW      $0185   ;       389     38.92   3.85    813             3.970   26903.495
0082FB 7F82FB 01 83                           DW      $0183   ;       387     38.70   3.72    814             3.975   27068.780
0082FD 7F82FD 01 81                           DW      $0181   ;       385     38.52   3.62    815             3.979   27202.174
0082FF 7F82FF 01 7F                           DW      $017F   ;       383     38.30   3.50    816             3.984   27370.394
008301 7F8301 01 7D                           DW      $017D   ;       381     38.08   3.37    817             3.989   27540.277
008303 7F8303 01 7B                           DW      $017B   ;       379     37.85   3.25    818             3.994   27711.849
008305 7F8305 01 78                           DW      $0178   ;       376     37.63   3.00    820             4.004   28060.161
008307 7F8307 01 74                           DW      $0174   ;       372     37.18   2.88    821             4.009   28236.953
008309 7F8309 01 72                           DW      $0172   ;       370     36.95   2.75    822             4.014   28415.538
00830B 7F830B 01 6F                           DW      $016F   ;       367     36.72   2.62    823             4.019   28595.943
00830D 7F830D 01 6D                           DW      $016D   ;       365     36.54   2.52    824             4.023   28741.597
00830F 7F830F 01 6B                           DW      $016B   ;       363     36.32   2.40    825             4.028   28925.350
008311 7F8311 01 69                           DW      $0169   ;       361     36.09   2.27    826             4.033   29111.003
008313 7F8313 01 67                           DW      $0167   ;       359     35.86   2.14    827             4.038   29298.586
008315 7F8315 01 64                           DW      $0164   ;       356     35.63   2.01    828             4.043   29488.130
008317 7F8317 01 62                           DW      $0162   ;       354     35.40   1.89    829             4.048   29679.644
008319 7F8319 01 60                           DW      $0160   ;       352     35.16   1.76    830             4.053   29873.221
00831B 7F831B 01 5D                           DW      $015D   ;       349     34.93   1.63    831             4.058   30068.832
00831D 7F831D 01 5B                           DW      $015B   ;       347     34.70   1.50    832             4.063   30266.531
00831F 7F831F 01 59                           DW      $0159   ;       345     34.51   1.40    833             4.067   30426.217
008321 7F8321 01 57                           DW      $0157   ;       343     34.28   1.26    834             4.072   30627.759
008323 7F8323 01 54                           DW      $0154   ;       340     34.04   1.13    835             4.077   30831.484
008325 7F8325 01 52                           DW      $0152   ;       338     33.80   1.00    836             4.082   31037.429
008327 7F8327 01 50                           DW      $0150   ;       336     33.57   0.87    837             4.087   31245.630
008329 7F8329 01 4D                           DW      $014D   ;       333     33.33   0.74    838             4.092   31456.123
00832B 7F832B 01 4B                           DW      $014B   ;       331     33.09   0.61    839             4.097   31668.948
00832D 7F832D 01 49                           DW      $0149   ;       329     32.85   0.47    840             4.102   31884.143
00832F 7F832F 01 47                           DW      $0147   ;       327     32.66   0.37    841             4.106   32058.031
008331 7F8331 01 44                           DW      $0144   ;       324     32.42   0.23    842             4.111   32277.593
008333 7F8333 01 42                           DW      $0142   ;       322     32.17   0.10    843             4.116   32499.638
008335 7F8335 01 3F                           DW      $013F   ;       319     31.93   -0.04   844             4.121   32724.209
008337 7F8337 01 3D                           DW      $013D   ;       317     31.69   -0.17   845             4.126   32951.350
008339 7F8339 01 3A                           DW      $013A   ;       314     31.44   -0.31   846             4.131   33181.105
00833B 7F833B 01 38                           DW      $0138   ;       312     31.20   -0.45   847             4.136   33413.519
00833D 7F833D 01 36                           DW      $0136   ;       310     30.95   -0.58   848             4.141   33648.638
00833F 7F833F 01 33                           DW      $0133   ;       307     30.70   -0.72   849             4.146   33886.511
008341 7F8341 01 31                           DW      $0131   ;       305     30.50   -0.83   850             4.150   34078.824
008343 7F8343 01 2F                           DW      $012F   ;       303     30.25   -0.97   851             4.155   34321.775
008345 7F8345 01 2C                           DW      $012C   ;       300     30.00   -1.11   852             4.160   34567.619
008347 7F8347 01 2A                           DW      $012A   ;       298     29.75   -1.25   853             4.165   34816.407
008349 7F8349 01 27                           DW      $0127   ;       295     29.50   -1.39   854             4.170   35068.193
00834B 7F834B 01 25                           DW      $0125   ;       293     29.25   -1.53   855             4.175   35323.030
00834D 7F834D 01 22                           DW      $0122   ;       290     28.99   -1.67   856             4.180   35580.976
00834F 7F834F 01 1F                           DW      $011F   ;       287     28.74   -1.81   857             4.185   35842.086
008351 7F8351 01 1D                           DW      $011D   ;       285     28.53   -1.93   858             4.189   36053.292
008353 7F8353 01 1B                           DW      $011B   ;       283     28.28   -2.07   859             4.194   36320.248
008355 7F8355 01 18                           DW      $0118   ;       280     28.02   -2.21   860             4.199   36590.537
008357 7F8357 01 16                           DW      $0116   ;       278     27.76   -2.36   861             4.204   36864.221
008359 7F8359 01 13                           DW      $0113   ;       275     27.50   -2.50   862             4.209   37141.365
00835B 7F835B 01 10                           DW      $0110   ;       272     27.24   -2.65   863             4.214   37422.036
00835D 7F835D 01 0E                           DW      $010E   ;       270     26.98   -2.79   864             4.219   37706.300
00835F 7F835F 01 0B                           DW      $010B   ;       267     26.71   -2.94   865             4.224   37994.227
008361 7F8361 01 09                           DW      $0109   ;       265     26.45   -3.08   866             4.229   38285.888
008363 7F8363 01 06                           DW      $0106   ;       262     26.23   -3.20   867             4.233   38521.956
008365 7F8365 01 04                           DW      $0104   ;       260     25.97   -3.35   868             4.238   38820.525
008367 7F8367 01 01                           DW      $0101   ;       257     25.70   -3.50   869             4.243   39123.038
008369 7F8369 00 FE                           DW      $00FE   ;       254     25.43   -3.65   870             4.248   39429.574
00836B 7F836B 00 FC                           DW      $00FC   ;       252     25.16   -3.80   871             4.253   39740.214
00836D 7F836D 00 F9                           DW      $00F9   ;       249     24.89   -3.95   872             4.258   40055.040
00836F 7F836F 00 F6                           DW      $00F6   ;       246     24.62   -4.10   873             4.263   40374.138
008371 7F8371 00 F3                           DW      $00F3   ;       243     24.34   -4.25   874             4.268   40697.596
008373 7F8373 00 F1                           DW      $00F1   ;       241     24.12   -4.38   875             4.272   40959.560
008375 7F8375 00 EE                           DW      $00EE   ;       238     23.84   -4.53   876             4.277   41291.093
008377 7F8377 00 EC                           DW      $00EC   ;       236     23.57   -4.69   877             4.282   41627.242
008379 7F8379 00 E9                           DW      $00E9   ;       233     23.29   -4.84   878             4.287   41968.107
00837B 7F837B 00 E6                           DW      $00E6   ;       230     23.01   -5.00   879             4.292   42313.785
00837D 7F837D 00 E3                           DW      $00E3   ;       227     22.72   -5.15   880             4.297   42664.381
00837F 7F837F 00 E0                           DW      $00E0   ;       224     22.44   -5.31   881             4.302   43020.000
008381 7F8381 00 DE                           DW      $00DE   ;       222     22.16   -5.47   882             4.307   43380.750
008383 7F8383 00 DB                           DW      $00DB   ;       219     21.87   -5.63   883             4.312   43746.744
008385 7F8385 00 D8                           DW      $00D8   ;       216     21.64   -5.76   884             4.316   44043.392
008387 7F8387 00 D6                           DW      $00D6   ;       214     21.35   -5.92   885             4.321   44419.116
008389 7F8389 00 D3                           DW      $00D3   ;       211     21.06   -6.08   886             4.326   44800.415
00838B 7F838B 00 D0                           DW      $00D0   ;       208     20.77   -6.24   887             4.331   45187.414
00838D 7F838D 00 CD                           DW      $00CD   ;       205     20.48   -6.40   888             4.336   45580.241
00838F 7F838F 00 CA                           DW      $00CA   ;       202     20.18   -6.57   889             4.341   45979.029
008391 7F8391 00 C7                           DW      $00C7   ;       199     19.88   -6.73   890             4.346   46383.914
008393 7F8393 00 C4                           DW      $00C4   ;       196     19.59   -6.90   891             4.351   46795.039
008395 7F8395 00 C2                           DW      $00C2   ;       194     19.35   -7.03   892             4.355   47128.527
008397 7F8397 00 BE                           DW      $00BE   ;       190     19.04   -7.20   893             4.360   47551.250
008399 7F8399 00 BB                           DW      $00BB   ;       187     18.74   -7.37   894             4.365   47980.630
00839B 7F839B 00 B8                           DW      $00B8   ;       184     18.44   -7.53   895             4.370   48416.825
00839D 7F839D 00 B5                           DW      $00B5   ;       181     18.13   -7.71   896             4.375   48860.000
00839F 7F839F 00 B2                           DW      $00B2   ;       178     17.82   -7.87   897             4.380   49310.323
0083A1 7F83A1 00 AF                           DW      $00AF   ;       175     17.51   -8.05   898             4.385   49767.967
0083A3 7F83A3 00 AC                           DW      $00AC   ;       172     17.20   -8.22   899             4.390   50233.115
0083A5 7F83A5 00 A9                           DW      $00A9   ;       169     16.89   -8.40   900             4.395   50705.950
0083A7 7F83A7 00 A6                           DW      $00A6   ;       166     16.64   -8.54   901             4.399   51089.884
0083A9 7F83A9 00 A3                           DW      $00A3   ;       163     16.32   -8.71   902             4.404   51577.047
0083AB 7F83AB 00 A0                           DW      $00A0   ;       160     16.00   -8.89   903             4.409   52072.453
0083AD 7F83AD 00 9D                           DW      $009D   ;       157     15.68   -9.07   904             4.414   52576.314
0083AF 7F83AF 00 9A                           DW      $009A   ;       154     15.35   -9.25   905             4.419   53088.847
0083B1 7F83B1 00 96                           DW      $0096   ;       150     15.03   -9.43   906             4.424   53610.278
0083B3 7F83B3 00 93                           DW      $0093   ;       147     14.70   -9.61   907             4.429   54140.841
0083B5 7F83B5 00 90                           DW      $0090   ;       144     14.37   -9.79   908             4.434   54680.777
0083B7 7F83B7 00 8D                           DW      $008D   ;       141     14.11   -9.94   909             4.438   55119.644
0083B9 7F83B9 00 8A                           DW      $008A   ;       138     13.76   -10.12  910             4.443   55677.092
0083BB 7F83BB 00 86                           DW      $0086   ;       134     13.44   -10.31  911             4.448   56244.638
0083BD 7F83BD 00 83                           DW      $0083   ;       131     13.10   -10.50  912             4.453   56822.559
0083BF 7F83BF 00 80                           DW      $0080   ;       128     12.76   -10.69  913             4.458   57411.144
0083C1 7F83C1 00 7C                           DW      $007C   ;       124     12.42   -10.88  914             4.463   58010.689
0083C3 7F83C3 00 79                           DW      $0079   ;       121     12.08   -11.07  915             4.468   58621.504
0083C5 7F83C5 00 75                           DW      $0075   ;       117     11.73   -11.26  916             4.473   59243.909
0083C7 7F83C7 00 72                           DW      $0072   ;       114     11.38   -11.46  917             4.478   59878.238
0083C9 7F83C9 00 6F                           DW      $006F   ;       111     11.10   -11.61  918             4.482   60394.517
0083CB 7F83CB 00 6B                           DW      $006B   ;       107     10.74   -11.81  919             4.487   61051.189
0083CD 7F83CD 00 68                           DW      $0068   ;       104     10.39   -12.00  920             4.492   61720.787
0083CF 7F83CF 00 64                           DW      $0064   ;       100     10.03   -12.21  921             4.497   62403.698
0083D1 7F83D1 00 61                           DW      $0061   ;       97              9.66    -12.41  922             4.502   63100.321
0083D3 7F83D3 00 5D                           DW      $005D   ;       93      9.30    -12.61  923             4.507   63811.075
0083D5 7F83D5 00 59                           DW      $0059   ;       89              8.93    -12.82  924             4.512   64536.393
0083D7 7F83D7 00 56                           DW      $0056   ;       86      8.56    -13.02  925             4.517   65276.729
0083D9 7F83D9 00 53                           DW      $0053   ;       83              8.26    -13.19  926             4.521   65880.125
0083DB 7F83DB 00 4F                           DW      $004F   ;       79              7.86    -13.40  927             4.526   66648.692
0083DD 7F83DD 00 4B                           DW      $004B   ;       75              7.51    -13.61  928             4.531   67433.646
0083DF 7F83DF 00 47                           DW      $0047   ;       71      7.12    -13.82  929             4.536   68235.577
0083E1 7F83E1 00 43                           DW      $0043   ;       67              6.74    -14.03  930             4.541   69054.858
0083E3 7F83E3 00 40                           DW      $0040   ;       64              6.35    -14.25  931             4.546   69892.247
0083E5 7F83E5 00 3C                           DW      $003C   ;       60              5.96    -14.47  932             4.551   70748.285
0083E7 7F83E7 00 38                           DW      $0038   ;       56              5.56    -14.69  933             4.556   71623.604
0083E9 7F83E9 00 34                           DW      $0034   ;       52              5.16    -14.91  934             4.561   72518.861
0083EB 7F83EB 00 30                           DW      $0030   ;       48          4.84        -15.09  935             4.565   73249.885
0083ED 7F83ED 00 2C                           DW      $002C   ;       44              4.44    -15.31  936             4.570   74182.791
0083EF 7F83EF 00 28                           DW      $0028   ;   40          4.03    -15.54  937             4.575   75137.647
0083F1 7F83F1 00 24                           DW      $0024   ;       36      3.61    -15.77  938             4.580   76115.238
0083F3 7F83F3 00 20                           DW      $0020   ;       32              3.20    -16.00  939             4.585   77116.386
0083F5 7F83F5 00 1C                           DW      $001C   ;       28              2.78    -16.23  940             4.590   78141.951
0083F7 7F83F7 00 18                           DW      $0018   ;       24              2.35    -16.47  941             4.595   79192.840
0083F9 7F83F9 00 13                           DW      $0013   ;       19          1.92        -16.71  942             4.600   80270.000
0083FB 7F83FB 00 10                           DW      $0010   ;       16      1.58    -16.90  943             4.604   81151.313
0083FD 7F83FD 00 0B                           DW      $000B   ;       11      1.14    -17.14  944             4.609   82278.312
0083FF 7F83FF 00 07                           DW      $0007   ;       7       0.70    -17.39  945             4.614   83434.508
008401 7F8401 00 03                           DW      $0003   ;       3       0.25    -17.64  946             4.619   84621.050
008403 7F8403 FF FE                           DW      $FFFE   ;       -2      -0.20   -17.89  947             4.624   85839.149
008405 7F8405 FF F9                           DW      $FFF9   ;       -7      -0.65   -18.14  948             4.629   87090.081
008407 7F8407 FF F5                           DW      $FFF5   ;       -11     -1.11   -18.39  949             4.634   88375.191
008409 7F8409 FF F0                           DW      $FFF0   ;       -16     -1.58   -18.65  950             4.639   89695.900
00840B 7F840B FF EC                           DW      $FFEC   ;       -20     -2.05   -18.91  951             4.644   91053.708
00840D 7F840D FF E8                           DW      $FFE8   ;       -24     -2.43   -19.13  952             4.648   92167.727
00840F 7F840F FF E3                           DW      $FFE3   ;       -29     -2.91   -19.39  953             4.653   93956.369
008411 7F8411 FF DE                           DW      $FFDE   ;       -34     -3.39   -19.66  954             4.658   95066.784
008413 7F8413 FF D9                           DW      $FFD9   ;       -39     -3.88   -19.93  955             4.663   96580.837
008415 7F8415 FF D4                           DW      $FFD4   ;       -44     -4.38   -20.21  956             4.668   98140.482
008417 7F8417 FF CF                           DW      $FFCF   ;       -49     -4.88   -20.49  957             4.673   99747.829
008419 7F8419 FF CA                           DW      $FFCA   ;       -54     -5.39   -20.77  958             4.678   101405.093
00841B 7F841B FF C5                           DW      $FFC5   ;       -59     -5.91   -21.06  959             4.683   103114.637
00841D 7F841D FF C0                           DW      $FFC0   ;       -64     -6.43   -21.35  960             4.688   104878.974
00841F 7F841F FF BB                           DW      $FFBB   ;       -69     -6.85   -21.58  961             4.692   106331.688
008421 7F8421 FF B6                           DW      $FFB6   ;       -74     -7.39   -21.88  962             4.697   108201.518
008423 7F8423 FF B1                           DW      $FFB1   ;       -79     -7.93   -22.18  963             4.702   110134.094
008425 7F8425 FF AB                           DW      $FFAB   ;       -85     -8.48   -22.49  964             4.707   112132.628
008427 7F8427 FF A6                           DW      $FFA6   ;       -90     -9.04   -22.80  965             4.712   114200.556
008429 7F8429 FF A0                           DW      $FFA0   ;       -96     -9.60   -23.11  966             4.717   116341.555
00842B 7F842B FF 9A                           DW      $FF9A   ;       -102    -10.18  -23.43  967             4.722   118559.568
00842D 7F842D FF 94                           DW      $FF94   ;       -108    -10.76  -23.75  968             4.727   120858.828
00842F 7F842F FF 90                           DW      $FF90   ;       -112    -11.23  -24.02  969             4.731   122759.777
008431 7F8431 FF 8A                           DW      $FF8A   ;       -118    -11.83  -24.35  970             4.736   125216.970
008433 7F8433 FF 84                           DW      $FF84   ;       -124    -12.44  -24.69  971             4.741   127769.035
008435 7F8435 FF 7D                           DW      $FF7D   ;       -131    -13.05  -25.03  972             4.746   130421.575
008437 7F8437 FF 77                           DW      $FF77   ;       -137    -13.68  -25.38  973             4.751   133180.643
008439 7F8439 FF 71                           DW      $FF71   ;       -143    -14.32  -25.73  974             4.756   136052.787
00843B 7F843B FF 6A                           DW      $FF6A   ;       -150    -14.97  -26.09  975             4.761   139045.105
00843D 7F843D FF 64                           DW      $FF64   ;       -156    -15.63  -26.46  976             4.766   142165.299
00843F 7F843F FF 5D                           DW      $FF5D   ;       -163    -16.30  -26.84  977             4.771   145421.747
008441 7F8441 FF 56                           DW      $FF56   ;       -170    -16.85  -27.14  978             4.775   148131.111
008443 7F8443 FF 50                           DW      $FF50   ;       -176    -17.55  -27.53  979             4.780   151656.364
008445 7F8445 FF 49                           DW      $FF49   ;       -183    -18.25  -27.92  980             4.785   155345.581
008447 7F8447 FF 42                           DW      $FF42   ;       -190    -18.98  -28.32  981             4.790   159210.476
008449 7F8449 FF 3B                           DW      $FF3B   ;       -197    -19.71  -28.73  982             4.795   163263.902
00844B 7F844B FF 37                           DW      $FF37   ;       -201    -20.47  -29.15  983             4.800   167520.000
00844D 7F844D FF 2C                           DW      $FF2C   ;       -212    -21.24  -29.58  984             4.805   171994.359
00844F 7F844F FF 24                           DW      $FF24   ;       -220    -22.02  -30.01  985             4.810   176704.211
008451 7F8451 FF 1D                           DW      $FF1D   ;       -227    -22.66  -30.37  986             4.814   180654.409
008453 7F8453 FF 15                           DW      $FF15   ;       -235    -23.48  -30.82  987             4.819   185837.680
008455 7F8455 FF 0D                           DW      $FF0D   ;       -243    -24.32  -31.29  988             4.824   191315.455
008457 7F8457 FF 04                           DW      $FF04   ;       -252    -25.18  -31.77  989             4.829   197113.567
008459 7F8459 FE FB                           DW      $FEFB   ;       -261    -26.06  -32.25  990             4.834   203260.964
00845B 7F845B FE F2                           DW      $FEF2   ;       -270    -26.96  -32.76  991             4.839   209790.186
00845D 7F845D FE E8                           DW      $FEE8   ;       -280    -27.89  -33.27  992             4.844   216737.949
00845F 7F845F FE E4                           DW      $FEE4   ;       -284    -28.84  -33.80  993             4.849   224145.828
008461 7F8461 FE D6                           DW      $FED6   ;       -298    -29.82  -34.34  994             4.854   232061.096
008463 7F8463 FE CE                           DW      $FECE   ;       -306    -30.63  -34.79  995             4.858   238794.648
008465 7F8465 FE C3                           DW      $FEC3   ;       -317    -31.66  -35.37  996             4.863   247764.526
008467 7F8467 FE B9                           DW      $FEB9   ;       -327    -32.73  -35.96  997             4.868   257413.939
008469 7F8469 FE AE                           DW      $FEAE   ;       -338    -33.83  -36.57  998             4.873   267823.150
00846B 7F846B FE A2                           DW      $FEA2   ;       -350    -34.97  -37.21  999             4.878   279085.574
00846D 7F846D FE 96                           DW      $FE96   ;       -362    -36.16  -37.86  1000    4.883   291310.598
00846F 7F846F FE 8A                           DW      $FE8A   ;       -374    -37.38  -38.55  1001    4.888   304627.143
008471 7F8471 FE 7D                           DW      $FE7D   ;       -387    -38.66  -39.26  1002    4.893   319188.224
008473 7F8473 FE 73                           DW      $FE73   ;       -397    -39.72  -39.84  1003    4.897   331854.951
008475 7F8475 FE 65                           DW      $FE65   ;       -411    -41.09  -40.61  1004    4.902   349142.449
008477 7F8477 FE 57                           DW      $FE57   ;       -425    -42.53  -41.41  1005    4.907   368288.817
008479 7F8479 FE 48                           DW      $FE48   ;       -440    -44.04  -42.24  1006    4.912   389610.909
00847B 7F847B FE 38                           DW      $FE38   ;       -456    -45.62  -43.12  1007    4.917   413501.928
00847D 7F847D FE 27                           DW      $FE27   ;       -473    -47.29  -44.05  1008    4.922   440455.897
00847F 7F847F FE 15                           DW      $FE15   ;       -491    -49.06  -45.03  1009    4.927   471102.192
008481 7F8481 FE 03                           DW      $FE03   ;       -509    -50.94  -46.08  1010    4.932   506255.294
008483 7F8483 FD EE                           DW      $FDEE   ;       -530    -52.94  -47.19  1011    4.937   546988.254
008485 7F8485 FD DD                           DW      $FDDD   ;       -547    -54.65  -48.14  1012    4.941   584545.424
008487 7F8487 FD C6                           DW      $FDC6   ;       -570    -56.95  -49.41  1013    4.946   639316.296
008489 7F8489 FD AE                           DW      $FDAE   ;       -594    -59.41  -50.79  1014    4.951   705264.898
00848B 7F848B FD 93                           DW      $FD93   ;       -621    -62.13  -52.29  1015    4.956   786201.818
00848D 7F848D FD 75                           DW      $FD75   ;       -651    -65.14  -53.96  1016    4.961   887891.795
00848F 7F848F FD 53                           DW      $FD53   ;       -685    -68.51  -55.84  1017    4.966   1019490.588
008491 7F8491 FD 2C                           DW      $FD2C   ;       -724    -72.36  -57.98  1018    4.971   1196468.276
008493 7F8493 FC FF                           DW      $FCFF   ;       -769    -76.86  -60.48  1019    4.976   1447186.667
008495 7F8495 FC D5                           DW      $FCD5   ;       -811    -81.11  -62.84  1020    4.980   1738020.000
008497 7F8497 FC 93                           DW      $FC93   ;       -877    -87.67  -66.48  1021    4.985   2319686.667
008499 7F8499 FC 3A                           DW      $FC3A   ;       -966    -96.61  -71.45  1022    4.990   3483020.000
00849B 7F849B 3E 80                           DW      $3E80   ;       1600    160.00  71.11   1023    4.995   Default to 160F (sensor failure)
00849D 7F849D -> $849D                DODGETHERM_TABS_END             EQU     *     ; * Represents the current value of the paged
                                                                        ; program counter
00849D 7F849D -> $7F849D              DODGETHERM_TABS_END_LIN EQU     @     ; @ Represents the current value of the linear
